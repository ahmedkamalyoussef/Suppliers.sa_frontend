"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@maptiler";
exports.ids = ["vendor-chunks/@maptiler"];
exports.modules = {

/***/ "(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@maptiler/client/dist/maptiler-client.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientConfig: () => (/* binding */ ClientConfig),\n/* harmony export */   ISOLanguage: () => (/* binding */ ISOLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   MapStyle: () => (/* binding */ MapStyle),\n/* harmony export */   MapStyleVariant: () => (/* binding */ MapStyleVariant),\n/* harmony export */   NonISOLanguage: () => (/* binding */ NonISOLanguage),\n/* harmony export */   ReferenceMapStyle: () => (/* binding */ ReferenceMapStyle),\n/* harmony export */   ServiceError: () => (/* binding */ ServiceError),\n/* harmony export */   areSameLanguages: () => (/* binding */ areSameLanguages),\n/* harmony export */   bufferToPixelDataBrowser: () => (/* binding */ bufferToPixelDataBrowser),\n/* harmony export */   canParsePixelData: () => (/* binding */ canParsePixelData),\n/* harmony export */   circumferenceAtLatitude: () => (/* binding */ circumferenceAtLatitude),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   coordinates: () => (/* binding */ coordinates),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   elevation: () => (/* binding */ elevation),\n/* harmony export */   expandMapStyle: () => (/* binding */ expandMapStyle),\n/* harmony export */   geocoding: () => (/* binding */ geocoding),\n/* harmony export */   geolocation: () => (/* binding */ geolocation),\n/* harmony export */   getAutoLanguage: () => (/* binding */ getAutoLanguage),\n/* harmony export */   getBufferToPixelDataParser: () => (/* binding */ getBufferToPixelDataParser),\n/* harmony export */   getLanguageInfoFromCode: () => (/* binding */ getLanguageInfoFromCode),\n/* harmony export */   getLanguageInfoFromFlag: () => (/* binding */ getLanguageInfoFromFlag),\n/* harmony export */   getLanguageInfoFromKey: () => (/* binding */ getLanguageInfoFromKey),\n/* harmony export */   getTileCache: () => (/* binding */ getTileCache),\n/* harmony export */   isLanguageInfo: () => (/* binding */ isLanguageInfo),\n/* harmony export */   mapStylePresetList: () => (/* binding */ mapStylePresetList),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   misc: () => (/* binding */ misc),\n/* harmony export */   staticMaps: () => (/* binding */ staticMaps),\n/* harmony export */   styleToStyle: () => (/* binding */ styleToStyle),\n/* harmony export */   toLanguageInfo: () => (/* binding */ toLanguageInfo)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\n\n\nfunction tryGettingFetch() {\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n  return null;\n}\nclass ClientConfig {\n  constructor() {\n    /**\n     * MapTiler Cloud API key\n     */\n    this._apiKey = \"\";\n    /**\n     * The fetch function. To be set if in Node < 18, otherwise\n     * will be automatically resolved.\n     */\n    this._fetch = tryGettingFetch();\n    /**\n     * Number of tiles to keep in cache\n     */\n    this.tileCacheSize = 200;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    this._fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return this._fetch;\n  }\n}\nconst config = new ClientConfig();\n\nconst NonISOLanguage = {\n  /**\n   * Language mode to display the labels in the end user's device language.\n   */\n  AUTO: {\n    code: null,\n    flag: \"auto\",\n    name: \"Auto\",\n    latin: false,\n    isMode: true,\n    geocoding: true\n  },\n  /**\n   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback. This is not to be confused with the \"Classical Latin\" language, which is available under the tag `.CLASSICAL_LATIN`.\n   */\n  LATIN: {\n    code: \"latin\",\n    flag: \"name:latin\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback.\n   */\n  NON_LATIN: {\n    code: \"nonlatin\",\n    flag: \"name:nonlatin\",\n    name: \"Non Latin\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.\n   */\n  LOCAL: {\n    code: null,\n    flag: \"name\",\n    name: \"Local\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  }\n};\nconst ISOLanguage = {\n  /**\n   * Albanian language\n   */\n  ALBANIAN: {\n    code: \"sq\",\n    flag: \"name:sq\",\n    name: \"Albanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Amharic language\n   */\n  AMHARIC: {\n    code: \"am\",\n    flag: \"name:am\",\n    name: \"Amharic\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Arabic language (right-to-left script)\n   */\n  ARABIC: {\n    code: \"ar\",\n    flag: \"name:ar\",\n    name: \"Arabic\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Armenian language\n   */\n  ARMENIAN: {\n    code: \"hy\",\n    flag: \"name:hy\",\n    name: \"Armenian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Azerbaijani language\n   */\n  AZERBAIJANI: {\n    code: \"az\",\n    flag: \"name:az\",\n    name: \"Azerbaijani\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Basque language\n   */\n  BASQUE: {\n    code: \"eu\",\n    flag: \"name:eu\",\n    name: \"Basque\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Belarusian langauge\n   */\n  BELARUSIAN: {\n    code: \"be\",\n    flag: \"name:be\",\n    name: \"Belarusian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bengali language\n   */\n  BENGALI: {\n    code: \"bn\",\n    flag: \"name:bn\",\n    name: \"Bengali\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bosnian language\n   */\n  BOSNIAN: {\n    code: \"bs\",\n    flag: \"name:bs\",\n    name: \"Bosnian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Breton language\n   */\n  BRETON: {\n    code: \"br\",\n    flag: \"name:br\",\n    name: \"Breton\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bulgarian language\n   */\n  BULGARIAN: {\n    code: \"bg\",\n    flag: \"bg\",\n    name: \"Bulgarian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Catalan language\n   */\n  CATALAN: {\n    code: \"ca\",\n    flag: \"name:ca\",\n    name: \"Catalan\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Chinese language\n   */\n  CHINESE: {\n    code: \"zh\",\n    flag: \"name:zh\",\n    name: \"Chinese\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Traditional Chinese language\n   */\n  TRADITIONAL_CHINESE: {\n    code: \"zh-Hant\",\n    flag: \"name:zh-Hant\",\n    name: \"Chinese (traditional)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Simplified Chinese language\n   */\n  SIMPLIFIED_CHINESE: {\n    code: \"zh-Hans\",\n    flag: \"name:zh-Hans\",\n    name: \"Chinese (simplified)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Corsican language\n   */\n  CORSICAN: {\n    code: \"co\",\n    flag: \"name:co\",\n    name: \"Corsican\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Croatian language\n   */\n  CROATIAN: {\n    code: \"hr\",\n    flag: \"name:hr\",\n    name: \"Croatian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Czech language\n   */\n  CZECH: {\n    code: \"cs\",\n    flag: \"name:cs\",\n    name: \"Czech\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Danish language\n   */\n  DANISH: {\n    code: \"da\",\n    flag: \"name:da\",\n    name: \"Danish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Dutch language\n   */\n  DUTCH: {\n    code: \"nl\",\n    flag: \"name:nl\",\n    name: \"Dutch\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * German language\n   */\n  GERMAN: {\n    code: \"de\",\n    flag: \"name:de\",\n    name: \"German\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Greek language\n   */\n  GREEK: {\n    code: \"el\",\n    flag: \"name:el\",\n    name: \"Greek\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * English language\n   */\n  ENGLISH: {\n    code: \"en\",\n    flag: \"name:en\",\n    name: \"English\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Esperanto language\n   */\n  ESPERANTO: {\n    code: \"eo\",\n    flag: \"name:eo\",\n    name: \"Esperanto\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Estonian language\n   */\n  ESTONIAN: {\n    code: \"et\",\n    flag: \"name:et\",\n    name: \"Estonian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Finnish language\n   */\n  FINNISH: {\n    code: \"fi\",\n    flag: \"name:fi\",\n    name: \"Finnish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * French language\n   */\n  FRENCH: {\n    code: \"fr\",\n    flag: \"name:fr\",\n    name: \"French\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Frisian language\n   */\n  FRISIAN: {\n    code: \"fy\",\n    flag: \"name:fy\",\n    name: \"Frisian (West)\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Georgian language\n   */\n  GEORGIAN: {\n    code: \"ka\",\n    flag: \"name:ka\",\n    name: \"Georgian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hebrew language (right-to-left non-latin script)\n   */\n  HEBREW: {\n    code: \"he\",\n    flag: \"name:he\",\n    name: \"Hebrew\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hindi language\n   */\n  HINDI: {\n    code: \"hi\",\n    flag: \"name:hi\",\n    name: \"Hindi\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hungarian language\n   */\n  HUNGARIAN: {\n    code: \"hu\",\n    flag: \"name:hu\",\n    name: \"Hungarian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Icelandic language\n   */\n  ICELANDIC: {\n    code: \"is\",\n    flag: \"name:is\",\n    name: \"Icelandic\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Indonesian language\n   */\n  INDONESIAN: {\n    code: \"id\",\n    flag: \"name:id\",\n    name: \"Indonesian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Irish language\n   */\n  IRISH: {\n    code: \"ga\",\n    flag: \"name:ga\",\n    name: \"Irish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Italian language\n   */\n  ITALIAN: {\n    code: \"it\",\n    flag: \"name:it\",\n    name: \"Italian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Japanese language\n   */\n  JAPANESE: {\n    code: \"ja\",\n    flag: \"name:ja\",\n    name: \"Japanese\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Japanese language in Hiragana form\n   */\n  JAPANESE_HIRAGANA: {\n    code: \"ja-Hira\",\n    flag: \"name:ja-Hira\",\n    name: \"Japanese Hiragana form\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanese language (latin script)\n   */\n  JAPANESE_2018: {\n    code: \"ja-Latn\",\n    flag: \"name:ja-Latn\",\n    name: \"Japanese (Latin 2018)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanese language in Kana form (non-latin script)\n   */\n  JAPANESE_KANA: {\n    code: \"ja_kana\",\n    flag: \"name:ja_kana\",\n    name: \"Japanese (Kana)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanse language, romanized (latin script)\n   */\n  JAPANESE_LATIN: {\n    code: \"ja_rm\",\n    flag: \"name:ja_rm\",\n    name: \"Japanese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Kannada language\n   */\n  KANNADA: {\n    code: \"kn\",\n    flag: \"name:kn\",\n    name: \"Kannada\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Kazakh language\n   */\n  KAZAKH: {\n    code: \"kk\",\n    flag: \"name:kk\",\n    name: \"Kazakh\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Korean language\n   */\n  KOREAN: {\n    code: \"ko\",\n    flag: \"name:ko\",\n    name: \"Korean\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Korean language (latin script)\n   */\n  KOREAN_LATIN: {\n    code: \"ko-Latn\",\n    flag: \"name:ko-Latn\",\n    name: \"Korean (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Kurdish language\n   */\n  KURDISH: {\n    code: \"ku\",\n    flag: \"name:ku\",\n    name: \"Kurdish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Classical Latin language\n   */\n  CLASSICAL_LATIN: {\n    code: \"la\",\n    flag: \"name:la\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Latvian language\n   */\n  LATVIAN: {\n    code: \"lv\",\n    flag: \"name:lv\",\n    name: \"Latvian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Lithuanian language\n   */\n  LITHUANIAN: {\n    code: \"lt\",\n    flag: \"name:lt\",\n    name: \"Lithuanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Luxembourgish language\n   */\n  LUXEMBOURGISH: {\n    code: \"lb\",\n    flag: \"name:lb\",\n    name: \"Luxembourgish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Macedonian language\n   */\n  MACEDONIAN: {\n    code: \"mk\",\n    flag: \"name:mk\",\n    name: \"Macedonian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Malayalm language\n   */\n  MALAYALAM: {\n    code: \"ml\",\n    flag: \"name:ml\",\n    name: \"Malayalam\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Maltese language\n   */\n  MALTESE: {\n    code: \"mt\",\n    flag: \"name:mt\",\n    name: \"Maltese\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Norwegian language\n   */\n  NORWEGIAN: {\n    code: \"no\",\n    flag: \"name:no\",\n    name: \"Norwegian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Occitan language\n   */\n  OCCITAN: {\n    code: \"oc\",\n    flag: \"name:oc\",\n    name: \"Occitan\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Persian language\n   */\n  PERSIAN: {\n    code: \"fa\",\n    flag: \"name:fa\",\n    name: \"Persian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Polish language\n   */\n  POLISH: {\n    code: \"pl\",\n    flag: \"name:pl\",\n    name: \"Polish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Portuguese language\n   */\n  PORTUGUESE: {\n    code: \"pt\",\n    flag: \"name:pt\",\n    name: \"Portuguese\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Punjabi language\n   */\n  PUNJABI: {\n    code: \"pa\",\n    flag: \"name:pa\",\n    name: \"Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Western Punjabi language\n   */\n  WESTERN_PUNJABI: {\n    code: \"pnb\",\n    flag: \"name:pnb\",\n    name: \"Western Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Romanian language\n   */\n  ROMANIAN: {\n    code: \"ro\",\n    flag: \"name:ro\",\n    name: \"Romanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Romansh language\n   */\n  ROMANSH: {\n    code: \"rm\",\n    flag: \"name:rm\",\n    name: \"Romansh\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Russian language\n   */\n  RUSSIAN: {\n    code: \"ru\",\n    flag: \"name:ru\",\n    name: \"Russian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Serbian language (cyrillic script)\n   */\n  SERBIAN_CYRILLIC: {\n    code: \"sr\",\n    flag: \"name:sr\",\n    name: \"Serbian (Cyrillic script)\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Serbian language (latin script)\n   */\n  SERBIAN_LATIN: {\n    code: \"sr-Latn\",\n    flag: \"name:sr-Latn\",\n    name: \"Serbian (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Scottish Gaelic language\n   */\n  SCOTTISH_GAELIC: {\n    code: \"gd\",\n    flag: \"name:gd\",\n    name: \"Scottish Gaelic\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Slovak language\n   */\n  SLOVAK: {\n    code: \"sk\",\n    flag: \"name:sk\",\n    name: \"Slovak\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Slovene language\n   */\n  SLOVENE: {\n    code: \"sl\",\n    flag: \"name:sl\",\n    name: \"Slovene\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Spanish language\n   */\n  SPANISH: {\n    code: \"es\",\n    flag: \"name:es\",\n    name: \"Spanish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Swedish language\n   */\n  SWEDISH: {\n    code: \"sv\",\n    flag: \"name:sv\",\n    name: \"Swedish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Tamil language\n   */\n  TAMIL: {\n    code: \"ta\",\n    flag: \"name:ta\",\n    name: \"Tamil\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Telugu language\n   */\n  TELUGU: {\n    code: \"te\",\n    flag: \"name:te\",\n    name: \"Telugu\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Thai language\n   */\n  THAI: {\n    code: \"th\",\n    flag: \"name:th\",\n    name: \"Thai\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Turkish language\n   */\n  TURKISH: {\n    code: \"tr\",\n    flag: \"name:tr\",\n    name: \"Turkish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Ukrainian language\n   */\n  UKRAINIAN: {\n    code: \"uk\",\n    flag: \"name:uk\",\n    name: \"Ukrainian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Vietnamese language (latin script)\n   */\n  VIETNAMESE: {\n    code: \"vi\",\n    flag: \"name:vi\",\n    name: \"Vietnamese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Welsh language\n   */\n  WELSH: {\n    code: \"cy\",\n    flag: \"name:cy\",\n    name: \"Welsh\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  }\n};\nconst Language = {\n  ...NonISOLanguage,\n  ...ISOLanguage\n};\nfunction getLanguageInfoFromKey(languageKey, languageDictionary = Language) {\n  if (languageKey in languageDictionary) {\n    return languageKey[languageKey];\n  }\n  return null;\n}\nfunction getLanguageInfoFromCode(languageCode, languageDictionary = Language) {\n  for (const lang of Object.values(languageDictionary)) {\n    if (lang.code === languageCode) {\n      return lang;\n    }\n  }\n  return null;\n}\nfunction getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {\n  for (const lang of Object.values(languageDictionary)) {\n    if (lang.flag === languageFlag) {\n      return lang;\n    }\n  }\n  return null;\n}\nfunction getAutoLanguage() {\n  if (typeof navigator === \"undefined\") {\n    const code = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n    const langInfo = getLanguageInfoFromCode(code);\n    return langInfo ?? Language.ENGLISH;\n  }\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).map((code) => getLanguageInfoFromCode(code)).filter((li) => li);\n  return canditatelangs[0] ?? Language.ENGLISH;\n}\nfunction isLanguageInfo(obj) {\n  return obj !== null && typeof obj === \"object\" && \"code\" in obj && \"flag\" in obj && \"name\" in obj && \"latin\" in obj && \"isMode\" in obj && \"geocoding\" in obj && (typeof obj.code === \"string\" || obj.code === null) && typeof obj.flag === \"string\" && typeof obj.name === \"string\" && typeof obj.latin === \"boolean\" && typeof obj.isMode === \"boolean\" && typeof obj.geocoding === \"boolean\";\n}\nfunction toLanguageInfo(lang, languageDictionary = Language) {\n  if (isLanguageInfo(lang)) {\n    return getLanguageInfoFromFlag(lang.flag, languageDictionary);\n  }\n  if (typeof lang !== \"string\") {\n    return null;\n  }\n  return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;\n}\nfunction areSameLanguages(langA, langB, languageDictionary = Language) {\n  const langAObj = toLanguageInfo(langA, languageDictionary);\n  const langBObj = toLanguageInfo(langB, languageDictionary);\n  return langAObj && langBObj && langAObj.flag === langBObj.flag;\n}\n\nasync function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\"\n    );\n  }\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\n      \"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\"\n    );\n  }\n  return config.fetch(resource, options);\n}\n\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\"\n};\nObject.freeze(defaults);\n\nclass ServiceError extends Error {\n  constructor(res, customMessage = \"\") {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`\n    );\n    this.res = res;\n  }\n}\n\nconst customMessages$4 = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction addLanguageGeocodingOptions(searchParams, options) {\n  const { language } = options;\n  if (language === void 0) {\n    return;\n  }\n  const languageCodes = (Array.isArray(language) ? language : [language]).map((elem) => toValidGeocodingLanguageCode(elem)).filter((elem) => elem);\n  const languages = Array.from(new Set(languageCodes)).join(\",\");\n  searchParams.set(\"language\", languages);\n}\nfunction toValidGeocodingLanguageCode(lang) {\n  const langInfo = lang === Language.AUTO.flag ? getAutoLanguage() : typeof lang === \"string\" ? getLanguageInfoFromCode(lang) : isLanguageInfo(lang) ? lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag) : null;\n  return langInfo?.geocoding ? langInfo.code : null;\n}\nfunction addCommonForwardAndReverseGeocodingOptions(searchParams, options) {\n  const { apiKey, limit, types, excludeTypes } = options;\n  searchParams.set(\"key\", apiKey ?? config.apiKey);\n  if (limit !== void 0) {\n    searchParams.set(\"limit\", String(limit));\n  }\n  if (types !== void 0) {\n    searchParams.set(\"types\", types.join(\",\"));\n  }\n  if (excludeTypes !== void 0) {\n    searchParams.set(\"excludeTypes\", String(excludeTypes));\n  }\n  addLanguageGeocodingOptions(searchParams, options);\n}\nfunction addForwardGeocodingOptions(searchParams, options) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n  const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;\n  if (bbox !== void 0) {\n    searchParams.set(\"bbox\", bbox.join(\",\"));\n  }\n  if (proximity !== void 0) {\n    searchParams.set(\n      \"proximity\",\n      proximity === \"ip\" ? proximity : proximity.join(\",\")\n    );\n  }\n  if (country !== void 0) {\n    searchParams.set(\"country\", country.join(\",\"));\n  }\n  if (fuzzyMatch !== void 0) {\n    searchParams.set(\"fuzzyMatch\", fuzzyMatch ? \"true\" : \"false\");\n  }\n  if (autocomplete !== void 0) {\n    searchParams.set(\"autocomplete\", autocomplete ? \"true\" : \"false\");\n  }\n}\nasync function forward(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL\n  );\n  addForwardGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  return await res.json();\n}\nasync function reverse(position, options = {}) {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n  const endpoint = new URL(\n    `geocoding/${position[0]},${position[1]}.json`,\n    defaults.maptilerApiURL\n  );\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  return await res.json();\n}\nasync function byId(id, options = {}) {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  return await res.json();\n}\nasync function batch$1(queries, options = {}) {\n  if (!queries.length) {\n    return [];\n  }\n  const joinedQuery = queries.map((query) => encodeURIComponent(query)).join(\";\");\n  const endpoint = new URL(\n    `geocoding/${joinedQuery}.json`,\n    defaults.maptilerApiURL\n  );\n  addForwardGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return queries.length === 1 ? [obj] : obj;\n}\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch: batch$1\n};\n\nconst customMessages$3 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function info(options = {}) {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"elevation\" in options) {\n    endpoint.searchParams.set(\n      \"elevation\",\n      options.elevation ? \"true\" : \"false\"\n    );\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$3 ? customMessages$3[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst geolocation = {\n  info\n};\n\nconst customMessages$2 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function search(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString()\n    );\n  }\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$2 ? customMessages$2[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function transform(positions, options = {}) {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map((coord) => `${coord[0]},${coord[1]}`).join(\";\");\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations) ? options.operations : [options.operations]).join(\"|\")\n    );\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$2 ? customMessages$2[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst coordinates = {\n  search,\n  transform\n};\n\nconst customMessages$1 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function get(dataId, options = {}) {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$1 ? customMessages$1[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst data = {\n  get\n};\n\nfunction expandMapStyle(style) {\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n  return expandedStyle;\n}\nclass MapStyleVariant {\n  constructor(name, variantType, id, referenceStyle, description, imageURL, deprecated = false, deprecationMessage) {\n    this.name = name;\n    this.variantType = variantType;\n    this.id = id;\n    this.referenceStyle = referenceStyle;\n    this.description = description;\n    this.imageURL = imageURL;\n    this.deprecated = deprecated;\n    this.deprecationMessage = deprecationMessage;\n  }\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  getFullName() {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType() {\n    return this.variantType;\n  }\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Get the human-friendly description\n   */\n  getDescription() {\n    return this.description;\n  }\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle() {\n    return this.referenceStyle;\n  }\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    const variant = this.referenceStyle.getVariant(variantType);\n    this.warnIfDeprecated(variant);\n    return variant;\n  }\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants() {\n    return this.referenceStyle.getVariants().filter((v) => v !== this).map((v) => {\n      this.warnIfDeprecated(v);\n      return v;\n    });\n  }\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL() {\n    return this.imageURL;\n  }\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL() {\n    return expandMapStyle(this.getId());\n  }\n  warnIfDeprecated(variant = this) {\n    if (!variant.deprecated) return variant;\n    if (variant.deprecationMessage) {\n      console.warn(variant.deprecationMessage);\n    } else {\n      const name = variant.getFullName();\n      console.warn(\n        `Style \"${name}\" is deprecated and will be removed in a future version.`\n      );\n    }\n    return variant;\n  }\n}\nclass ReferenceMapStyle {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Variants that belong to this reference style, key being the reference type\n     */\n    this.variants = {};\n    /**\n     * Variants that belong to this reference style, ordered by relevance\n     */\n    this.orderedVariants = [];\n  }\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return variantType in this.variants;\n  }\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];\n  }\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants() {\n    return Object.values(this.variants);\n  }\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant() {\n    return this.orderedVariants[0].warnIfDeprecated();\n  }\n}\nconst mapStylePresetList = [\n  {\n    referenceStyleID: \"STREETS_V2\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v2\",\n        name: \"Default v2\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"streets-v2\" is deprecated, use \"streets-v4\" instead`\n      },\n      {\n        id: \"streets-v2-dark\",\n        name: \"Dark v2\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"streets-v2-dark\" is deprecated, use \"streets-v4-dark\" instead`\n      },\n      {\n        id: \"streets-v2-light\",\n        name: \"Light v2\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"streets-v2-light\" is deprecated, use \"streets-v4-light\" instead`\n      },\n      {\n        id: \"streets-v2-night\",\n        name: \"Night v2\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"streets-v2-night\" is deprecated, use \"streets-v4-night\" instead`\n      },\n      {\n        id: \"streets-v2-pastel\",\n        name: \"Pastel v2\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"streets-v2-pastel\" is deprecated, use \"streets-v4-pastel\" instead`\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"STREETS_V4\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v4\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v4-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v4-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BASE_V4\",\n    name: \"Base\",\n    description: \"\",\n    variants: [\n      {\n        id: \"base-v4\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"base-v4-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"base-v4-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"base-v4-ai\",\n        name: \"Base AI\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OUTDOOR\",\n    name: \"Outdoor\",\n    description: \"\",\n    variants: [\n      {\n        id: \"outdoor-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"outdoor-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"WINTER\",\n    name: \"Winter\",\n    description: \"\",\n    variants: [\n      {\n        id: \"winter-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"winter-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"SATELLITE\",\n    name: \"Satellite\",\n    description: \"\",\n    variants: [\n      {\n        id: \"satellite\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"HYBRID\",\n    name: \"Hybrid\",\n    description: \"\",\n    variants: [\n      {\n        id: \"hybrid\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BASIC_V2\",\n    name: \"Basic\",\n    description: \"\",\n    variants: [\n      {\n        id: \"basic-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"basic-v2\" is deprecated, use \"basic-v4\" instead`\n      },\n      {\n        id: \"basic-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"basic-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BRIGHT\",\n    name: \"Bright\",\n    description: \"\",\n    variants: [\n      {\n        id: \"bright-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OPENSTREETMAP\",\n    name: \"OpenStreetMap\",\n    description: \"\",\n    variants: [\n      {\n        id: \"openstreetmap\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"TOPO\",\n    name: \"Topo\",\n    description: \"\",\n    variants: [\n      {\n        id: \"topo-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-shiny\",\n        name: \"Shiny\",\n        deprecated: true,\n        variantType: \"SHINY\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-topographique\",\n        name: \"Topographique\",\n        variantType: \"TOPOGRAPHIQUE\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"VOYAGER\",\n    name: \"Voyager\",\n    description: \"\",\n    variants: [\n      {\n        id: \"voyager-v2\",\n        name: \"Default\",\n        deprecated: true,\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-darkmatter\",\n        name: \"Darkmatter\",\n        deprecated: true,\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-positron\",\n        name: \"Positron\",\n        deprecated: true,\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-vintage\",\n        name: \"Vintage\",\n        deprecated: true,\n        variantType: \"VINTAGE\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"TONER\",\n    name: \"Toner\",\n    description: \"\",\n    variants: [\n      {\n        id: \"toner-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-background\",\n        name: \"Background\",\n        variantType: \"BACKGROUND\",\n        deprecated: true,\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-lite\",\n        name: \"Lite\",\n        variantType: \"LITE\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-lines\",\n        name: \"Lines\",\n        variantType: \"LINES\",\n        deprecated: true,\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"DATAVIZ\",\n    name: \"Dataviz\",\n    description: \"\",\n    variants: [\n      {\n        id: \"dataviz\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"dataviz-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"dataviz-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BACKDROP\",\n    name: \"Backdrop\",\n    description: \"\",\n    variants: [\n      {\n        id: \"backdrop\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"backdrop-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"backdrop-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OCEAN\",\n    name: \"Ocean\",\n    description: \"\",\n    variants: [\n      {\n        id: \"ocean\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"AQUARELLE\",\n    name: \"Aquarelle\",\n    description: \"Watercolor map for creative use\",\n    variants: [\n      {\n        id: \"aquarelle\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"aquarelle-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"aquarelle-vivid\",\n        name: \"Vivid\",\n        variantType: \"VIVID\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"LANDSCAPE_V2\",\n    name: \"Landscape\",\n    description: \"Terrain map for data overlays and visualisations\",\n    variants: [\n      {\n        id: \"landscape\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"landscape\" is deprecated, use \"landscape-v4\" instead`\n      },\n      {\n        id: \"landscape-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"landscape-dark\" is deprecated, use \"landscape-v4-dark\" instead`\n      },\n      {\n        id: \"landscape-vivid\",\n        name: \"Vivid\",\n        variantType: \"VIVID\",\n        description: \"\",\n        imageURL: \"\",\n        deprecated: true,\n        deprecationMessage: `\"landscape-vivid\" is deprecated, use \"landscape-v4-vivid\" instead`\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"LANDSCAPE_V4\",\n    name: \"Landscape\",\n    description: \"Terrain map for data overlays and visualisations\",\n    variants: [\n      {\n        id: \"landscape-v4\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"landscape-v4-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"landscape-v4-vivid\",\n        name: \"Vivid\",\n        variantType: \"VIVID\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  }\n];\nconst defaultReferenceStyleMap = {\n  STREETS: \"STREETS_V2\",\n  BASIC: \"BASIC_V2\",\n  LANDSCAPE: \"LANDSCAPE_V2\"\n};\nfunction applyVersionToDefaultReferenceStyle(defaultKey, referenceKey) {\n  if (mapStylePresetList.find((style) => style.referenceStyleID === defaultKey)) {\n    console.warn(\n      `Default reference style ${defaultKey} already exists, it will be overwritten...`\n    );\n  }\n  const versionedMapStyle = mapStylePresetList.find(\n    (style) => style.referenceStyleID === referenceKey\n  );\n  if (!versionedMapStyle) {\n    throw new Error(\n      `Versioned map style not found for reference style: ${referenceKey}`\n    );\n  }\n  const defaultStyle = {\n    ...versionedMapStyle,\n    referenceStyleID: defaultKey\n  };\n  mapStylePresetList.push(defaultStyle);\n}\nObject.entries(defaultReferenceStyleMap).forEach(\n  ([defaultKey, referenceKey]) => {\n    applyVersionToDefaultReferenceStyle(defaultKey, referenceKey);\n  }\n);\nfunction makeReferenceStyleProxy(referenceStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop)) {\n        return target.getVariant(prop);\n      }\n      if (prop.toString().toUpperCase() === prop) {\n        return referenceStyle.getDefaultVariant();\n      }\n      const style = Reflect.get(target, prop, receiver);\n      return style;\n    }\n  });\n}\nfunction buildMapStyles() {\n  const mapStyle = {};\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n    const refStyle = makeReferenceStyleProxy(\n      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)\n    );\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(\n        variantInfo.name,\n        // name\n        variantInfo.variantType,\n        // variantType\n        variantInfo.id,\n        // id\n        refStyle,\n        // referenceStyle\n        variantInfo.description,\n        variantInfo.imageURL,\n        // imageURL\n        variantInfo.deprecated\n        // deprecated\n      );\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle;\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\nconst MapStyle = buildMapStyles();\n\nfunction extractLineStrings(geoJson) {\n  const lineStrings = [];\n  function extractFromGeometry(geometry) {\n    if (geometry.type === \"LineString\" || geometry.type === \"MultiLineString\") {\n      lineStrings.push(geometry);\n    }\n  }\n  function extractFromFeature(feature) {\n    if (feature.geometry) {\n      extractFromGeometry(feature.geometry);\n    }\n  }\n  function extractFromFeatureCollection(collection) {\n    for (const feature of collection.features) {\n      if (feature.type === \"Feature\") {\n        extractFromFeature(feature);\n      } else if (feature.type === \"FeatureCollection\") {\n        extractFromFeatureCollection(feature);\n      }\n    }\n  }\n  if (geoJson.type === \"Feature\") {\n    extractFromFeature(geoJson);\n  } else if (geoJson.type === \"FeatureCollection\") {\n    extractFromFeatureCollection(geoJson);\n  } else {\n    extractFromGeometry(geoJson);\n  }\n  return lineStrings;\n}\nfunction getSqSegDist(p, p1, p2) {\n  let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  let maxSqDist = sqTolerance, index;\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance) {\n  if (points.length <= 2) {\n    return points;\n  }\n  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\nconst misc = {\n  extractLineStrings,\n  simplify\n};\n\nfunction staticMapMarkerToString(marker, includeColor = true) {\n  let str = `${marker[0]},${marker[1]}`;\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n  return str;\n}\nfunction simplifyAndStringify(path, maxNbChar = 3e3) {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 5e-6;\n  const toleranceStep = 1e-5;\n  while (str.length > maxNbChar) {\n    const simplerPath = misc.simplify(path, tolerance);\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n  return str;\n}\nfunction centered(center, zoom, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction bounded(boundingBox, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction automatic(options = {}) {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\"\n    );\n  }\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic\n};\n\nconst EARTH_RADIUS = 63710088e-1;\nconst EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;\nfunction longitudeToMercatorX(lng) {\n  return (180 + lng) / 360;\n}\nfunction latitudeToMercatorY(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nfunction wgs84ToMercator(position) {\n  const wrappedPos = wrapWgs84(position);\n  return [\n    longitudeToMercatorX(wrappedPos[0]),\n    latitudeToMercatorY(wrappedPos[1])\n  ];\n}\nfunction mercatorXToLongitude(x) {\n  return x * 360 - 180;\n}\nfunction mercatorYToLatitude(y) {\n  const y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nfunction mercatorToWgs84(position) {\n  return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];\n}\nfunction haversineDistanceWgs84(from, to) {\n  const rad = Math.PI / 180;\n  const lat1 = from[1] * rad;\n  const lat2 = to[1] * rad;\n  const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to[0] - from[0]) * rad);\n  const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));\n  return maxMeters;\n}\nfunction haversineCumulatedDistanceWgs84(positions) {\n  const cumulatedDistance = Array(positions.length);\n  cumulatedDistance[0] = 0;\n  const l = cumulatedDistance.length;\n  for (let i = 1; i < l; i++) {\n    cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];\n  }\n  return cumulatedDistance;\n}\nfunction wrapWgs84(position) {\n  const lng = position[0];\n  const lat = position[1];\n  const d = 360;\n  const w = ((lng + 180) % d + d) % d - 180;\n  const wrapLong = w === -180 ? 180 : w;\n  return [wrapLong, lat];\n}\nfunction circumferenceAtLatitude(latitude) {\n  return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);\n}\nfunction mercatorToTileIndex(position, zoom, strict = true) {\n  const numberOfTilePerAxis = 2 ** zoom;\n  const fIndex = [\n    position[0] * numberOfTilePerAxis,\n    position[1] * numberOfTilePerAxis\n  ];\n  return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;\n}\nfunction wgs84ToTileIndex(position, zoom, strict = true) {\n  const merc = wgs84ToMercator(position);\n  return mercatorToTileIndex(merc, zoom, strict);\n}\nfunction toRadians(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction toDegrees(radians) {\n  return radians * 180 / Math.PI;\n}\nfunction haversineIntermediateWgs84(pos1, pos2, ratio) {\n  const d = haversineDistanceWgs84(pos1, pos2);\n  const \\u03BB1 = toRadians(pos1[0]);\n  const \\u03C61 = toRadians(pos1[1]);\n  const \\u03BB2 = toRadians(pos2[0]);\n  const \\u03C62 = toRadians(pos2[1]);\n  const \\u03B4 = d / EARTH_RADIUS;\n  const a = Math.sin((1 - ratio) * \\u03B4) / Math.sin(\\u03B4);\n  const b = Math.sin(ratio * \\u03B4) / Math.sin(\\u03B4);\n  const x = a * Math.cos(\\u03C61) * Math.cos(\\u03BB1) + b * Math.cos(\\u03C62) * Math.cos(\\u03BB2);\n  const y = a * Math.cos(\\u03C61) * Math.sin(\\u03BB1) + b * Math.cos(\\u03C62) * Math.sin(\\u03BB2);\n  const z = a * Math.sin(\\u03C61) + b * Math.sin(\\u03C62);\n  const \\u03C63 = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const \\u03BB3 = Math.atan2(y, x);\n  return [toDegrees(\\u03BB3), toDegrees(\\u03C63)];\n}\nconst math = {\n  EARTH_RADIUS,\n  EARTH_CIRCUMFERENCE,\n  longitudeToMercatorX,\n  latitudeToMercatorY,\n  wgs84ToMercator,\n  mercatorXToLongitude,\n  mercatorYToLatitude,\n  mercatorToWgs84,\n  haversineDistanceWgs84,\n  wrapWgs84,\n  circumferenceAtLatitude,\n  mercatorToTileIndex,\n  wgs84ToTileIndex,\n  toRadians,\n  toDegrees,\n  haversineIntermediateWgs84,\n  haversineCumulatedDistanceWgs84\n};\n\nlet tileCache = null;\nfunction getTileCache() {\n  if (!tileCache) {\n    tileCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ maxSize: config.tileCacheSize });\n  }\n  return tileCache;\n}\nasync function bufferToPixelDataBrowser(buff) {\n  const blob = new Blob([buff]);\n  const imageBitmap = await createImageBitmap(blob);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = imageBitmap.width;\n  canvas.height = imageBitmap.height;\n  ctx.drawImage(imageBitmap, 0, 0);\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  return {\n    pixels: imageData.data,\n    width: canvas.width,\n    height: canvas.height,\n    components: imageData.data.length / (canvas.width * canvas.height)\n  };\n}\nfunction getBufferToPixelDataParser() {\n  if (config.bufferToPixelData) {\n    return config.bufferToPixelData;\n  }\n  if (typeof window !== \"undefined\") {\n    return bufferToPixelDataBrowser;\n  }\n  throw new Error(\n    \"An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`\"\n  );\n}\nfunction canParsePixelData() {\n  return !!config.bufferToPixelData || typeof window !== \"undefined\";\n}\n\nconst TERRAIN_TILESET = \"terrain-rgb-v2\";\nconst API_BATCH_SIZE = 50;\nconst API_WARN_SIZE = 1e3;\nlet terrainTileJson = null;\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function computeOnServer(positions, apiKey) {\n  if (positions.length > API_WARN_SIZE) {\n    console.warn(\n      \"Computing elevation for complex geometries is discouraged - simplify the geometry before proceeding\"\n    );\n  }\n  const parts = Math.ceil(positions.length / API_BATCH_SIZE);\n  const respPromises = Array.from({ length: parts }, () => null).map(\n    (_, part) => {\n      const startPos = part * API_BATCH_SIZE;\n      const batch2 = positions.slice(startPos, startPos + API_BATCH_SIZE);\n      const batchEncoded = batch2.map((pos) => pos.join(\",\")).join(\";\");\n      const endpoint = new URL(\n        `elevation/${batchEncoded}.json`,\n        defaults.maptilerApiURL\n      );\n      endpoint.searchParams.set(\"key\", apiKey);\n      return callFetch(endpoint.toString());\n    }\n  );\n  const resps = await Promise.allSettled(respPromises);\n  const jsons = await Promise.all(\n    resps.map(async (resp) => {\n      if (resp.status === \"rejected\") {\n        throw new Error(\n          `Some segments could not be fetched, error: ${resp.reason}`\n        );\n      }\n      if (!resp.value.ok) {\n        throw new Error(\n          `Some segments could not be fetched, response: ${resp.value.status} ${await resp.value.text()}, url: ${resp.value.url}`\n        );\n      }\n      return resp.value.json();\n    })\n  );\n  return jsons.flat();\n}\nasync function computeOnClient(positions, apiKey, zoom) {\n  if (!terrainTileJson) {\n    const endpoint = new URL(\n      `tiles/${TERRAIN_TILESET}/tiles.json`,\n      defaults.maptilerApiURL\n    );\n    endpoint.searchParams.set(\"key\", apiKey);\n    const urlWithParams = endpoint.toString();\n    const res = await callFetch(urlWithParams);\n    if (res.ok) {\n      terrainTileJson = await res.json();\n    } else {\n      throw new ServiceError(res, customMessages[res.status] ?? \"\");\n    }\n  }\n  const tileParser = getBufferToPixelDataParser();\n  const tileURLSchema = terrainTileJson.tiles[0];\n  const cache = getTileCache();\n  const maxZoom = terrainTileJson.maxzoom;\n  let usedZoom = ~~(zoom ?? maxZoom);\n  if (usedZoom > maxZoom || usedZoom < 0) {\n    usedZoom = maxZoom;\n  }\n  const tileIndicesFloats = positions.map(\n    (position) => math.wgs84ToTileIndex(position, usedZoom, false)\n  );\n  const tileIndicesInteger = tileIndicesFloats.map((index) => [\n    ~~index[0],\n    ~~index[1]\n  ]);\n  const tileIDs = tileIndicesInteger.map(\n    (index) => `terrain_${usedZoom.toString()}_${index[0].toString()}_${index[1].toString()}`\n  );\n  const uniqueTilesToFetch = Array.from(\n    new Set(tileIDs.filter((tileID) => !cache.has(tileID)))\n  ).map((tileID) => tileID.split(\"_\").slice(1));\n  const tileURLs = uniqueTilesToFetch.map(\n    (zxy) => tileURLSchema.replace(\"{x}\", zxy[1].toString()).replace(\"{y}\", zxy[2].toString()).replace(\"{z}\", zxy[0].toString())\n  );\n  const promisesFetchTiles = tileURLs.map((url) => callFetch(url));\n  const resTiles = await Promise.allSettled(promisesFetchTiles);\n  const fulfilledRes = resTiles.map(\n    (el) => el.status === \"fulfilled\" ? el.value : null\n  ).filter((res) => res);\n  const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);\n  if (fulfilledRes.length !== promisesFetchTiles.length) {\n    throw new Error(\"Some tiles could not be fetched.\");\n  }\n  if (fulfilledRButNotOkRes.length) {\n    throw new ServiceError(\n      fulfilledRButNotOkRes[0],\n      customMessages[fulfilledRButNotOkRes[0].status] ?? \"\"\n    );\n  }\n  const tileArrayBuffers = await Promise.all(\n    fulfilledRes.map((res) => res.arrayBuffer())\n  );\n  if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) {\n    throw new Error(\"Some tiles are not available.\");\n  }\n  const tilePixelDatas = await Promise.all(\n    tileArrayBuffers.map((buff) => tileParser(buff))\n  );\n  tilePixelDatas.forEach((tilePixelData, i) => {\n    const zxy = uniqueTilesToFetch[i];\n    const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;\n    cache.set(tileID, tilePixelData);\n  });\n  const elevatedPositions = positions.map((position, i) => {\n    const tileID = tileIDs[i];\n    const tileIndexFloat = tileIndicesFloats[i];\n    const tilePixelData = cache.get(tileID);\n    const pixelX = Math.min(\n      Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)),\n      tilePixelData.width - 1\n    );\n    const pixelY = Math.min(\n      Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)),\n      tilePixelData.height - 1\n    );\n    const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n    const R = tilePixelData.pixels[pixelDataIndex];\n    const G = tilePixelData.pixels[pixelDataIndex + 1];\n    const B = tilePixelData.pixels[pixelDataIndex + 2];\n    const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;\n    return [position[0], position[1], ~~(elevation2 * 1e3) / 1e3];\n  });\n  return elevatedPositions;\n}\nasync function at(position, options = {}) {\n  const elevatedPositions = await batch([position], options);\n  return elevatedPositions[0];\n}\nasync function batch(positions, options = {}) {\n  if (positions.length === 0) return [];\n  const apiKey = options.apiKey ?? config.apiKey;\n  const elevatedPositions = options.computeOn === \"client\" ? await computeOnClient(positions, apiKey, options.zoom) : await computeOnServer(positions, apiKey);\n  if (options.smoothingKernelSize) {\n    const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;\n    const elevations = elevatedPositions.map((pos) => pos[2]);\n    const kernelSpan = ~~(kernelSize / 2);\n    for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {\n      let sum = 0;\n      for (let j = 0; j < kernelSize; j += 1) {\n        const elev = elevations[i - kernelSpan + j];\n        sum += elev;\n      }\n      sum /= kernelSize;\n      elevatedPositions[i][2] = sum;\n    }\n  }\n  return elevatedPositions;\n}\nasync function fromLineString(ls, options = {}) {\n  if (ls.type !== \"LineString\") {\n    throw new Error(\"The provided object is not a GeoJSON LineString\");\n  }\n  options.computeOn ?? (options.computeOn = canParsePixelData() ? \"client\" : \"server\");\n  const clone = structuredClone(ls);\n  const elevatedPositions = await batch(clone.coordinates, options);\n  clone.coordinates = elevatedPositions;\n  return clone;\n}\nasync function fromMultiLineString(ls, options = {}) {\n  if (ls.type !== \"MultiLineString\") {\n    throw new Error(\"The provided object is not a GeoJSON MultiLineString\");\n  }\n  options.computeOn ?? (options.computeOn = canParsePixelData() ? \"client\" : \"server\");\n  const clone = structuredClone(ls);\n  const multiLengths = clone.coordinates.map((poss) => poss.length);\n  const flattenPositions = clone.coordinates.flat();\n  const flattenPositionsElevated = await batch(flattenPositions, options);\n  const result = [];\n  let index = 0;\n  for (const length of multiLengths) {\n    result.push(flattenPositionsElevated.slice(index, index + length));\n    index += length;\n  }\n  clone.coordinates = result;\n  return clone;\n}\nconst elevation = {\n  at,\n  batch,\n  fromLineString,\n  fromMultiLineString\n};\n\n\n//# sourceMappingURL=maptiler-client.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2NsaWVudC9kaXN0L21hcHRpbGVyLWNsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0oscURBQXFELFNBQVM7QUFDOUQsSUFBSTtBQUNKLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0IsRUFBRSxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVEsR0FBRywrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUJBQW1CLEVBQUUsd0JBQXdCLFNBQVMsZUFBZTtBQUNoSTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRSxnQ0FBZ0MsRUFBRSxnQ0FBZ0MsRUFBRTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzFGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7QUFDckU7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ2dCO0FBQ2hnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cHBsaWVyLWRpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9AbWFwdGlsZXIvY2xpZW50L2Rpc3QvbWFwdGlsZXItY2xpZW50Lm1qcz8xOTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBRdWlja0xSVSBmcm9tICdxdWljay1scnUnO1xuXG5mdW5jdGlvbiB0cnlHZXR0aW5nRmV0Y2goKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmZXRjaC5iaW5kKHNlbGYpO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5mZXRjaCkge1xuICAgIHJldHVybiBnbG9iYWwuZmV0Y2g7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBDbGllbnRDb25maWcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBNYXBUaWxlciBDbG91ZCBBUEkga2V5XG4gICAgICovXG4gICAgdGhpcy5fYXBpS2V5ID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmV0Y2ggZnVuY3Rpb24uIFRvIGJlIHNldCBpZiBpbiBOb2RlIDwgMTgsIG90aGVyd2lzZVxuICAgICAqIHdpbGwgYmUgYXV0b21hdGljYWxseSByZXNvbHZlZC5cbiAgICAgKi9cbiAgICB0aGlzLl9mZXRjaCA9IHRyeUdldHRpbmdGZXRjaCgpO1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiB0aWxlcyB0byBrZWVwIGluIGNhY2hlXG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGVTaXplID0gMjAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIE1hcFRpbGVyIENsb3VkIEFQSSBrZXlcbiAgICovXG4gIHNldCBhcGlLZXkoaykge1xuICAgIHRoaXMuX2FwaUtleSA9IGs7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJIGtleVxuICAgKi9cbiAgZ2V0IGFwaUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXBpS2V5O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB0aGUgY3VzdG9tIGZldGNoIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhlIGRlZmF1bHQgb25lXG4gICAqL1xuICBzZXQgZmV0Y2goZikge1xuICAgIHRoaXMuX2ZldGNoID0gZjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmZXRjaCBmdWNudGlvblxuICAgKi9cbiAgZ2V0IGZldGNoKCkge1xuICAgIHJldHVybiB0aGlzLl9mZXRjaDtcbiAgfVxufVxuY29uc3QgY29uZmlnID0gbmV3IENsaWVudENvbmZpZygpO1xuXG5jb25zdCBOb25JU09MYW5ndWFnZSA9IHtcbiAgLyoqXG4gICAqIExhbmd1YWdlIG1vZGUgdG8gZGlzcGxheSB0aGUgbGFiZWxzIGluIHRoZSBlbmQgdXNlcidzIGRldmljZSBsYW5ndWFnZS5cbiAgICovXG4gIEFVVE86IHtcbiAgICBjb2RlOiBudWxsLFxuICAgIGZsYWc6IFwiYXV0b1wiLFxuICAgIG5hbWU6IFwiQXV0b1wiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IHRydWUsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgT1NNIGxhbmd1YWdlIHVzaW5nIGxhdGluIHNjcmlwdC4gTWFwVGlsZXIgZGlzY291cmFnZXMgaXRzIHVzZSBhcyBhIHByaW1hcnkgbGFuZ3VhZ2Ugc2V0dGluZyBkdWUgdG8gdGhlIGxhY2sgb2YgYWN0dWFsIGxpbmd1aXN0aWMgc3BlY2lmaWNpdHksXG4gICAqIHRob3VnaCBpdCBjYW4gYmUgYW4gaGFuZHkgZmFsbGJhY2suIFRoaXMgaXMgbm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIFwiQ2xhc3NpY2FsIExhdGluXCIgbGFuZ3VhZ2UsIHdoaWNoIGlzIGF2YWlsYWJsZSB1bmRlciB0aGUgdGFnIGAuQ0xBU1NJQ0FMX0xBVElOYC5cbiAgICovXG4gIExBVElOOiB7XG4gICAgY29kZTogXCJsYXRpblwiLFxuICAgIGZsYWc6IFwibmFtZTpsYXRpblwiLFxuICAgIG5hbWU6IFwiTGF0aW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBPU00gbGFuZ3VhZ2UgdXNpbmcgbm9uLWxhdGluIHNjcmlwdC4gTWFwVGlsZXIgZGlzY291cmFnZXMgaXRzIHVzZSBhcyBhIHByaW1hcnkgbGFuZ3VhZ2Ugc2V0dGluZyBkdWUgdG8gdGhlIGxhY2sgb2YgYWN0dWFsIGxpbmd1aXN0aWMgc3BlY2lmaWNpdHksXG4gICAqIHRob3VnaCBpdCBjYW4gYmUgYW4gaGFuZHkgZmFsbGJhY2suXG4gICAqL1xuICBOT05fTEFUSU46IHtcbiAgICBjb2RlOiBcIm5vbmxhdGluXCIsXG4gICAgZmxhZzogXCJuYW1lOm5vbmxhdGluXCIsXG4gICAgbmFtZTogXCJOb24gTGF0aW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBVc2luZyB0aGUgbG9jYWwgbGFuZ3VhZ2UgZ2VuZXJhbHkgKGJ1dCBub3QgYWx3YXlzKSBtZWFucyB0aGF0IGV2ZXJ5IGxhYmVscyBvZiBhIGdpdmVuIHJlZ2lvbiB3aWxsIHVzZSB0aGUgZG9taW5hbnQgbG9jYWwgbGFuZ3VhZ2UuXG4gICAqL1xuICBMT0NBTDoge1xuICAgIGNvZGU6IG51bGwsXG4gICAgZmxhZzogXCJuYW1lXCIsXG4gICAgbmFtZTogXCJMb2NhbFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9XG59O1xuY29uc3QgSVNPTGFuZ3VhZ2UgPSB7XG4gIC8qKlxuICAgKiBBbGJhbmlhbiBsYW5ndWFnZVxuICAgKi9cbiAgQUxCQU5JQU46IHtcbiAgICBjb2RlOiBcInNxXCIsXG4gICAgZmxhZzogXCJuYW1lOnNxXCIsXG4gICAgbmFtZTogXCJBbGJhbmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBBbWhhcmljIGxhbmd1YWdlXG4gICAqL1xuICBBTUhBUklDOiB7XG4gICAgY29kZTogXCJhbVwiLFxuICAgIGZsYWc6IFwibmFtZTphbVwiLFxuICAgIG5hbWU6IFwiQW1oYXJpY1wiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQXJhYmljIGxhbmd1YWdlIChyaWdodC10by1sZWZ0IHNjcmlwdClcbiAgICovXG4gIEFSQUJJQzoge1xuICAgIGNvZGU6IFwiYXJcIixcbiAgICBmbGFnOiBcIm5hbWU6YXJcIixcbiAgICBuYW1lOiBcIkFyYWJpY1wiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQXJtZW5pYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEFSTUVOSUFOOiB7XG4gICAgY29kZTogXCJoeVwiLFxuICAgIGZsYWc6IFwibmFtZTpoeVwiLFxuICAgIG5hbWU6IFwiQXJtZW5pYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEF6ZXJiYWlqYW5pIGxhbmd1YWdlXG4gICAqL1xuICBBWkVSQkFJSkFOSToge1xuICAgIGNvZGU6IFwiYXpcIixcbiAgICBmbGFnOiBcIm5hbWU6YXpcIixcbiAgICBuYW1lOiBcIkF6ZXJiYWlqYW5pXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEJhc3F1ZSBsYW5ndWFnZVxuICAgKi9cbiAgQkFTUVVFOiB7XG4gICAgY29kZTogXCJldVwiLFxuICAgIGZsYWc6IFwibmFtZTpldVwiLFxuICAgIG5hbWU6IFwiQmFzcXVlXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEJlbGFydXNpYW4gbGFuZ2F1Z2VcbiAgICovXG4gIEJFTEFSVVNJQU46IHtcbiAgICBjb2RlOiBcImJlXCIsXG4gICAgZmxhZzogXCJuYW1lOmJlXCIsXG4gICAgbmFtZTogXCJCZWxhcnVzaWFuXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBCZW5nYWxpIGxhbmd1YWdlXG4gICAqL1xuICBCRU5HQUxJOiB7XG4gICAgY29kZTogXCJiblwiLFxuICAgIGZsYWc6IFwibmFtZTpiblwiLFxuICAgIG5hbWU6IFwiQmVuZ2FsaVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBCb3NuaWFuIGxhbmd1YWdlXG4gICAqL1xuICBCT1NOSUFOOiB7XG4gICAgY29kZTogXCJic1wiLFxuICAgIGZsYWc6IFwibmFtZTpic1wiLFxuICAgIG5hbWU6IFwiQm9zbmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBCcmV0b24gbGFuZ3VhZ2VcbiAgICovXG4gIEJSRVRPTjoge1xuICAgIGNvZGU6IFwiYnJcIixcbiAgICBmbGFnOiBcIm5hbWU6YnJcIixcbiAgICBuYW1lOiBcIkJyZXRvblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBCdWxnYXJpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEJVTEdBUklBTjoge1xuICAgIGNvZGU6IFwiYmdcIixcbiAgICBmbGFnOiBcImJnXCIsXG4gICAgbmFtZTogXCJCdWxnYXJpYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIENhdGFsYW4gbGFuZ3VhZ2VcbiAgICovXG4gIENBVEFMQU46IHtcbiAgICBjb2RlOiBcImNhXCIsXG4gICAgZmxhZzogXCJuYW1lOmNhXCIsXG4gICAgbmFtZTogXCJDYXRhbGFuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIENoaW5lc2UgbGFuZ3VhZ2VcbiAgICovXG4gIENISU5FU0U6IHtcbiAgICBjb2RlOiBcInpoXCIsXG4gICAgZmxhZzogXCJuYW1lOnpoXCIsXG4gICAgbmFtZTogXCJDaGluZXNlXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBUcmFkaXRpb25hbCBDaGluZXNlIGxhbmd1YWdlXG4gICAqL1xuICBUUkFESVRJT05BTF9DSElORVNFOiB7XG4gICAgY29kZTogXCJ6aC1IYW50XCIsXG4gICAgZmxhZzogXCJuYW1lOnpoLUhhbnRcIixcbiAgICBuYW1lOiBcIkNoaW5lc2UgKHRyYWRpdGlvbmFsKVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIFNpbXBsaWZpZWQgQ2hpbmVzZSBsYW5ndWFnZVxuICAgKi9cbiAgU0lNUExJRklFRF9DSElORVNFOiB7XG4gICAgY29kZTogXCJ6aC1IYW5zXCIsXG4gICAgZmxhZzogXCJuYW1lOnpoLUhhbnNcIixcbiAgICBuYW1lOiBcIkNoaW5lc2UgKHNpbXBsaWZpZWQpXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogQ29yc2ljYW4gbGFuZ3VhZ2VcbiAgICovXG4gIENPUlNJQ0FOOiB7XG4gICAgY29kZTogXCJjb1wiLFxuICAgIGZsYWc6IFwibmFtZTpjb1wiLFxuICAgIG5hbWU6IFwiQ29yc2ljYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQ3JvYXRpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIENST0FUSUFOOiB7XG4gICAgY29kZTogXCJoclwiLFxuICAgIGZsYWc6IFwibmFtZTpoclwiLFxuICAgIG5hbWU6IFwiQ3JvYXRpYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQ3plY2ggbGFuZ3VhZ2VcbiAgICovXG4gIENaRUNIOiB7XG4gICAgY29kZTogXCJjc1wiLFxuICAgIGZsYWc6IFwibmFtZTpjc1wiLFxuICAgIG5hbWU6IFwiQ3plY2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogRGFuaXNoIGxhbmd1YWdlXG4gICAqL1xuICBEQU5JU0g6IHtcbiAgICBjb2RlOiBcImRhXCIsXG4gICAgZmxhZzogXCJuYW1lOmRhXCIsXG4gICAgbmFtZTogXCJEYW5pc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogRHV0Y2ggbGFuZ3VhZ2VcbiAgICovXG4gIERVVENIOiB7XG4gICAgY29kZTogXCJubFwiLFxuICAgIGZsYWc6IFwibmFtZTpubFwiLFxuICAgIG5hbWU6IFwiRHV0Y2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogR2VybWFuIGxhbmd1YWdlXG4gICAqL1xuICBHRVJNQU46IHtcbiAgICBjb2RlOiBcImRlXCIsXG4gICAgZmxhZzogXCJuYW1lOmRlXCIsXG4gICAgbmFtZTogXCJHZXJtYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogR3JlZWsgbGFuZ3VhZ2VcbiAgICovXG4gIEdSRUVLOiB7XG4gICAgY29kZTogXCJlbFwiLFxuICAgIGZsYWc6IFwibmFtZTplbFwiLFxuICAgIG5hbWU6IFwiR3JlZWtcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEVuZ2xpc2ggbGFuZ3VhZ2VcbiAgICovXG4gIEVOR0xJU0g6IHtcbiAgICBjb2RlOiBcImVuXCIsXG4gICAgZmxhZzogXCJuYW1lOmVuXCIsXG4gICAgbmFtZTogXCJFbmdsaXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEVzcGVyYW50byBsYW5ndWFnZVxuICAgKi9cbiAgRVNQRVJBTlRPOiB7XG4gICAgY29kZTogXCJlb1wiLFxuICAgIGZsYWc6IFwibmFtZTplb1wiLFxuICAgIG5hbWU6IFwiRXNwZXJhbnRvXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEVzdG9uaWFuIGxhbmd1YWdlXG4gICAqL1xuICBFU1RPTklBTjoge1xuICAgIGNvZGU6IFwiZXRcIixcbiAgICBmbGFnOiBcIm5hbWU6ZXRcIixcbiAgICBuYW1lOiBcIkVzdG9uaWFuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEZpbm5pc2ggbGFuZ3VhZ2VcbiAgICovXG4gIEZJTk5JU0g6IHtcbiAgICBjb2RlOiBcImZpXCIsXG4gICAgZmxhZzogXCJuYW1lOmZpXCIsXG4gICAgbmFtZTogXCJGaW5uaXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEZyZW5jaCBsYW5ndWFnZVxuICAgKi9cbiAgRlJFTkNIOiB7XG4gICAgY29kZTogXCJmclwiLFxuICAgIGZsYWc6IFwibmFtZTpmclwiLFxuICAgIG5hbWU6IFwiRnJlbmNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEZyaXNpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEZSSVNJQU46IHtcbiAgICBjb2RlOiBcImZ5XCIsXG4gICAgZmxhZzogXCJuYW1lOmZ5XCIsXG4gICAgbmFtZTogXCJGcmlzaWFuIChXZXN0KVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBHZW9yZ2lhbiBsYW5ndWFnZVxuICAgKi9cbiAgR0VPUkdJQU46IHtcbiAgICBjb2RlOiBcImthXCIsXG4gICAgZmxhZzogXCJuYW1lOmthXCIsXG4gICAgbmFtZTogXCJHZW9yZ2lhblwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSGVicmV3IGxhbmd1YWdlIChyaWdodC10by1sZWZ0IG5vbi1sYXRpbiBzY3JpcHQpXG4gICAqL1xuICBIRUJSRVc6IHtcbiAgICBjb2RlOiBcImhlXCIsXG4gICAgZmxhZzogXCJuYW1lOmhlXCIsXG4gICAgbmFtZTogXCJIZWJyZXdcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEhpbmRpIGxhbmd1YWdlXG4gICAqL1xuICBISU5ESToge1xuICAgIGNvZGU6IFwiaGlcIixcbiAgICBmbGFnOiBcIm5hbWU6aGlcIixcbiAgICBuYW1lOiBcIkhpbmRpXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBIdW5nYXJpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEhVTkdBUklBTjoge1xuICAgIGNvZGU6IFwiaHVcIixcbiAgICBmbGFnOiBcIm5hbWU6aHVcIixcbiAgICBuYW1lOiBcIkh1bmdhcmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBJY2VsYW5kaWMgbGFuZ3VhZ2VcbiAgICovXG4gIElDRUxBTkRJQzoge1xuICAgIGNvZGU6IFwiaXNcIixcbiAgICBmbGFnOiBcIm5hbWU6aXNcIixcbiAgICBuYW1lOiBcIkljZWxhbmRpY1wiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBJbmRvbmVzaWFuIGxhbmd1YWdlXG4gICAqL1xuICBJTkRPTkVTSUFOOiB7XG4gICAgY29kZTogXCJpZFwiLFxuICAgIGZsYWc6IFwibmFtZTppZFwiLFxuICAgIG5hbWU6IFwiSW5kb25lc2lhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBJcmlzaCBsYW5ndWFnZVxuICAgKi9cbiAgSVJJU0g6IHtcbiAgICBjb2RlOiBcImdhXCIsXG4gICAgZmxhZzogXCJuYW1lOmdhXCIsXG4gICAgbmFtZTogXCJJcmlzaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBJdGFsaWFuIGxhbmd1YWdlXG4gICAqL1xuICBJVEFMSUFOOiB7XG4gICAgY29kZTogXCJpdFwiLFxuICAgIGZsYWc6IFwibmFtZTppdFwiLFxuICAgIG5hbWU6IFwiSXRhbGlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBKYXBhbmVzZSBsYW5ndWFnZVxuICAgKi9cbiAgSkFQQU5FU0U6IHtcbiAgICBjb2RlOiBcImphXCIsXG4gICAgZmxhZzogXCJuYW1lOmphXCIsXG4gICAgbmFtZTogXCJKYXBhbmVzZVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSmFwYW5lc2UgbGFuZ3VhZ2UgaW4gSGlyYWdhbmEgZm9ybVxuICAgKi9cbiAgSkFQQU5FU0VfSElSQUdBTkE6IHtcbiAgICBjb2RlOiBcImphLUhpcmFcIixcbiAgICBmbGFnOiBcIm5hbWU6amEtSGlyYVwiLFxuICAgIG5hbWU6IFwiSmFwYW5lc2UgSGlyYWdhbmEgZm9ybVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIEphcGFuZXNlIGxhbmd1YWdlIChsYXRpbiBzY3JpcHQpXG4gICAqL1xuICBKQVBBTkVTRV8yMDE4OiB7XG4gICAgY29kZTogXCJqYS1MYXRuXCIsXG4gICAgZmxhZzogXCJuYW1lOmphLUxhdG5cIixcbiAgICBuYW1lOiBcIkphcGFuZXNlIChMYXRpbiAyMDE4KVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogSmFwYW5lc2UgbGFuZ3VhZ2UgaW4gS2FuYSBmb3JtIChub24tbGF0aW4gc2NyaXB0KVxuICAgKi9cbiAgSkFQQU5FU0VfS0FOQToge1xuICAgIGNvZGU6IFwiamFfa2FuYVwiLFxuICAgIGZsYWc6IFwibmFtZTpqYV9rYW5hXCIsXG4gICAgbmFtZTogXCJKYXBhbmVzZSAoS2FuYSlcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBKYXBhbnNlIGxhbmd1YWdlLCByb21hbml6ZWQgKGxhdGluIHNjcmlwdClcbiAgICovXG4gIEpBUEFORVNFX0xBVElOOiB7XG4gICAgY29kZTogXCJqYV9ybVwiLFxuICAgIGZsYWc6IFwibmFtZTpqYV9ybVwiLFxuICAgIG5hbWU6IFwiSmFwYW5lc2UgKExhdGluIHNjcmlwdClcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIEthbm5hZGEgbGFuZ3VhZ2VcbiAgICovXG4gIEtBTk5BREE6IHtcbiAgICBjb2RlOiBcImtuXCIsXG4gICAgZmxhZzogXCJuYW1lOmtuXCIsXG4gICAgbmFtZTogXCJLYW5uYWRhXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEthemFraCBsYW5ndWFnZVxuICAgKi9cbiAgS0FaQUtIOiB7XG4gICAgY29kZTogXCJra1wiLFxuICAgIGZsYWc6IFwibmFtZTpra1wiLFxuICAgIG5hbWU6IFwiS2F6YWtoXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBLb3JlYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEtPUkVBTjoge1xuICAgIGNvZGU6IFwia29cIixcbiAgICBmbGFnOiBcIm5hbWU6a29cIixcbiAgICBuYW1lOiBcIktvcmVhblwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogS29yZWFuIGxhbmd1YWdlIChsYXRpbiBzY3JpcHQpXG4gICAqL1xuICBLT1JFQU5fTEFUSU46IHtcbiAgICBjb2RlOiBcImtvLUxhdG5cIixcbiAgICBmbGFnOiBcIm5hbWU6a28tTGF0blwiLFxuICAgIG5hbWU6IFwiS29yZWFuIChMYXRpbiBzY3JpcHQpXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBLdXJkaXNoIGxhbmd1YWdlXG4gICAqL1xuICBLVVJESVNIOiB7XG4gICAgY29kZTogXCJrdVwiLFxuICAgIGZsYWc6IFwibmFtZTprdVwiLFxuICAgIG5hbWU6IFwiS3VyZGlzaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBDbGFzc2ljYWwgTGF0aW4gbGFuZ3VhZ2VcbiAgICovXG4gIENMQVNTSUNBTF9MQVRJTjoge1xuICAgIGNvZGU6IFwibGFcIixcbiAgICBmbGFnOiBcIm5hbWU6bGFcIixcbiAgICBuYW1lOiBcIkxhdGluXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIExhdHZpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIExBVFZJQU46IHtcbiAgICBjb2RlOiBcImx2XCIsXG4gICAgZmxhZzogXCJuYW1lOmx2XCIsXG4gICAgbmFtZTogXCJMYXR2aWFuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIExpdGh1YW5pYW4gbGFuZ3VhZ2VcbiAgICovXG4gIExJVEhVQU5JQU46IHtcbiAgICBjb2RlOiBcImx0XCIsXG4gICAgZmxhZzogXCJuYW1lOmx0XCIsXG4gICAgbmFtZTogXCJMaXRodWFuaWFuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEx1eGVtYm91cmdpc2ggbGFuZ3VhZ2VcbiAgICovXG4gIExVWEVNQk9VUkdJU0g6IHtcbiAgICBjb2RlOiBcImxiXCIsXG4gICAgZmxhZzogXCJuYW1lOmxiXCIsXG4gICAgbmFtZTogXCJMdXhlbWJvdXJnaXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIE1hY2Vkb25pYW4gbGFuZ3VhZ2VcbiAgICovXG4gIE1BQ0VET05JQU46IHtcbiAgICBjb2RlOiBcIm1rXCIsXG4gICAgZmxhZzogXCJuYW1lOm1rXCIsXG4gICAgbmFtZTogXCJNYWNlZG9uaWFuXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBNYWxheWFsbSBsYW5ndWFnZVxuICAgKi9cbiAgTUFMQVlBTEFNOiB7XG4gICAgY29kZTogXCJtbFwiLFxuICAgIGZsYWc6IFwibmFtZTptbFwiLFxuICAgIG5hbWU6IFwiTWFsYXlhbGFtXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBNYWx0ZXNlIGxhbmd1YWdlXG4gICAqL1xuICBNQUxURVNFOiB7XG4gICAgY29kZTogXCJtdFwiLFxuICAgIGZsYWc6IFwibmFtZTptdFwiLFxuICAgIG5hbWU6IFwiTWFsdGVzZVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBOb3J3ZWdpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIE5PUldFR0lBTjoge1xuICAgIGNvZGU6IFwibm9cIixcbiAgICBmbGFnOiBcIm5hbWU6bm9cIixcbiAgICBuYW1lOiBcIk5vcndlZ2lhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBPY2NpdGFuIGxhbmd1YWdlXG4gICAqL1xuICBPQ0NJVEFOOiB7XG4gICAgY29kZTogXCJvY1wiLFxuICAgIGZsYWc6IFwibmFtZTpvY1wiLFxuICAgIG5hbWU6IFwiT2NjaXRhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBQZXJzaWFuIGxhbmd1YWdlXG4gICAqL1xuICBQRVJTSUFOOiB7XG4gICAgY29kZTogXCJmYVwiLFxuICAgIGZsYWc6IFwibmFtZTpmYVwiLFxuICAgIG5hbWU6IFwiUGVyc2lhblwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogUG9saXNoIGxhbmd1YWdlXG4gICAqL1xuICBQT0xJU0g6IHtcbiAgICBjb2RlOiBcInBsXCIsXG4gICAgZmxhZzogXCJuYW1lOnBsXCIsXG4gICAgbmFtZTogXCJQb2xpc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogUG9ydHVndWVzZSBsYW5ndWFnZVxuICAgKi9cbiAgUE9SVFVHVUVTRToge1xuICAgIGNvZGU6IFwicHRcIixcbiAgICBmbGFnOiBcIm5hbWU6cHRcIixcbiAgICBuYW1lOiBcIlBvcnR1Z3Vlc2VcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogUHVuamFiaSBsYW5ndWFnZVxuICAgKi9cbiAgUFVOSkFCSToge1xuICAgIGNvZGU6IFwicGFcIixcbiAgICBmbGFnOiBcIm5hbWU6cGFcIixcbiAgICBuYW1lOiBcIlB1bmphYmlcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFdlc3Rlcm4gUHVuamFiaSBsYW5ndWFnZVxuICAgKi9cbiAgV0VTVEVSTl9QVU5KQUJJOiB7XG4gICAgY29kZTogXCJwbmJcIixcbiAgICBmbGFnOiBcIm5hbWU6cG5iXCIsXG4gICAgbmFtZTogXCJXZXN0ZXJuIFB1bmphYmlcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBSb21hbmlhbiBsYW5ndWFnZVxuICAgKi9cbiAgUk9NQU5JQU46IHtcbiAgICBjb2RlOiBcInJvXCIsXG4gICAgZmxhZzogXCJuYW1lOnJvXCIsXG4gICAgbmFtZTogXCJSb21hbmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBSb21hbnNoIGxhbmd1YWdlXG4gICAqL1xuICBST01BTlNIOiB7XG4gICAgY29kZTogXCJybVwiLFxuICAgIGZsYWc6IFwibmFtZTpybVwiLFxuICAgIG5hbWU6IFwiUm9tYW5zaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBSdXNzaWFuIGxhbmd1YWdlXG4gICAqL1xuICBSVVNTSUFOOiB7XG4gICAgY29kZTogXCJydVwiLFxuICAgIGZsYWc6IFwibmFtZTpydVwiLFxuICAgIG5hbWU6IFwiUnVzc2lhblwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogU2VyYmlhbiBsYW5ndWFnZSAoY3lyaWxsaWMgc2NyaXB0KVxuICAgKi9cbiAgU0VSQklBTl9DWVJJTExJQzoge1xuICAgIGNvZGU6IFwic3JcIixcbiAgICBmbGFnOiBcIm5hbWU6c3JcIixcbiAgICBuYW1lOiBcIlNlcmJpYW4gKEN5cmlsbGljIHNjcmlwdClcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFNlcmJpYW4gbGFuZ3VhZ2UgKGxhdGluIHNjcmlwdClcbiAgICovXG4gIFNFUkJJQU5fTEFUSU46IHtcbiAgICBjb2RlOiBcInNyLUxhdG5cIixcbiAgICBmbGFnOiBcIm5hbWU6c3ItTGF0blwiLFxuICAgIG5hbWU6IFwiU2VyYmlhbiAoTGF0aW4gc2NyaXB0KVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogU2NvdHRpc2ggR2FlbGljIGxhbmd1YWdlXG4gICAqL1xuICBTQ09UVElTSF9HQUVMSUM6IHtcbiAgICBjb2RlOiBcImdkXCIsXG4gICAgZmxhZzogXCJuYW1lOmdkXCIsXG4gICAgbmFtZTogXCJTY290dGlzaCBHYWVsaWNcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogU2xvdmFrIGxhbmd1YWdlXG4gICAqL1xuICBTTE9WQUs6IHtcbiAgICBjb2RlOiBcInNrXCIsXG4gICAgZmxhZzogXCJuYW1lOnNrXCIsXG4gICAgbmFtZTogXCJTbG92YWtcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogU2xvdmVuZSBsYW5ndWFnZVxuICAgKi9cbiAgU0xPVkVORToge1xuICAgIGNvZGU6IFwic2xcIixcbiAgICBmbGFnOiBcIm5hbWU6c2xcIixcbiAgICBuYW1lOiBcIlNsb3ZlbmVcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogU3BhbmlzaCBsYW5ndWFnZVxuICAgKi9cbiAgU1BBTklTSDoge1xuICAgIGNvZGU6IFwiZXNcIixcbiAgICBmbGFnOiBcIm5hbWU6ZXNcIixcbiAgICBuYW1lOiBcIlNwYW5pc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogU3dlZGlzaCBsYW5ndWFnZVxuICAgKi9cbiAgU1dFRElTSDoge1xuICAgIGNvZGU6IFwic3ZcIixcbiAgICBmbGFnOiBcIm5hbWU6c3ZcIixcbiAgICBuYW1lOiBcIlN3ZWRpc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVGFtaWwgbGFuZ3VhZ2VcbiAgICovXG4gIFRBTUlMOiB7XG4gICAgY29kZTogXCJ0YVwiLFxuICAgIGZsYWc6IFwibmFtZTp0YVwiLFxuICAgIG5hbWU6IFwiVGFtaWxcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFRlbHVndSBsYW5ndWFnZVxuICAgKi9cbiAgVEVMVUdVOiB7XG4gICAgY29kZTogXCJ0ZVwiLFxuICAgIGZsYWc6IFwibmFtZTp0ZVwiLFxuICAgIG5hbWU6IFwiVGVsdWd1XCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBUaGFpIGxhbmd1YWdlXG4gICAqL1xuICBUSEFJOiB7XG4gICAgY29kZTogXCJ0aFwiLFxuICAgIGZsYWc6IFwibmFtZTp0aFwiLFxuICAgIG5hbWU6IFwiVGhhaVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVHVya2lzaCBsYW5ndWFnZVxuICAgKi9cbiAgVFVSS0lTSDoge1xuICAgIGNvZGU6IFwidHJcIixcbiAgICBmbGFnOiBcIm5hbWU6dHJcIixcbiAgICBuYW1lOiBcIlR1cmtpc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVWtyYWluaWFuIGxhbmd1YWdlXG4gICAqL1xuICBVS1JBSU5JQU46IHtcbiAgICBjb2RlOiBcInVrXCIsXG4gICAgZmxhZzogXCJuYW1lOnVrXCIsXG4gICAgbmFtZTogXCJVa3JhaW5pYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFZpZXRuYW1lc2UgbGFuZ3VhZ2UgKGxhdGluIHNjcmlwdClcbiAgICovXG4gIFZJRVROQU1FU0U6IHtcbiAgICBjb2RlOiBcInZpXCIsXG4gICAgZmxhZzogXCJuYW1lOnZpXCIsXG4gICAgbmFtZTogXCJWaWV0bmFtZXNlIChMYXRpbiBzY3JpcHQpXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFdlbHNoIGxhbmd1YWdlXG4gICAqL1xuICBXRUxTSDoge1xuICAgIGNvZGU6IFwiY3lcIixcbiAgICBmbGFnOiBcIm5hbWU6Y3lcIixcbiAgICBuYW1lOiBcIldlbHNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfVxufTtcbmNvbnN0IExhbmd1YWdlID0ge1xuICAuLi5Ob25JU09MYW5ndWFnZSxcbiAgLi4uSVNPTGFuZ3VhZ2Vcbn07XG5mdW5jdGlvbiBnZXRMYW5ndWFnZUluZm9Gcm9tS2V5KGxhbmd1YWdlS2V5LCBsYW5ndWFnZURpY3Rpb25hcnkgPSBMYW5ndWFnZSkge1xuICBpZiAobGFuZ3VhZ2VLZXkgaW4gbGFuZ3VhZ2VEaWN0aW9uYXJ5KSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlS2V5W2xhbmd1YWdlS2V5XTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExhbmd1YWdlSW5mb0Zyb21Db2RlKGxhbmd1YWdlQ29kZSwgbGFuZ3VhZ2VEaWN0aW9uYXJ5ID0gTGFuZ3VhZ2UpIHtcbiAgZm9yIChjb25zdCBsYW5nIG9mIE9iamVjdC52YWx1ZXMobGFuZ3VhZ2VEaWN0aW9uYXJ5KSkge1xuICAgIGlmIChsYW5nLmNvZGUgPT09IGxhbmd1YWdlQ29kZSkge1xuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VJbmZvRnJvbUZsYWcobGFuZ3VhZ2VGbGFnLCBsYW5ndWFnZURpY3Rpb25hcnkgPSBMYW5ndWFnZSkge1xuICBmb3IgKGNvbnN0IGxhbmcgb2YgT2JqZWN0LnZhbHVlcyhsYW5ndWFnZURpY3Rpb25hcnkpKSB7XG4gICAgaWYgKGxhbmcuZmxhZyA9PT0gbGFuZ3VhZ2VGbGFnKSB7XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRBdXRvTGFuZ3VhZ2UoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgY29kZSA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUuc3BsaXQoXCItXCIpWzBdO1xuICAgIGNvbnN0IGxhbmdJbmZvID0gZ2V0TGFuZ3VhZ2VJbmZvRnJvbUNvZGUoY29kZSk7XG4gICAgcmV0dXJuIGxhbmdJbmZvID8/IExhbmd1YWdlLkVOR0xJU0g7XG4gIH1cbiAgY29uc3QgY2FuZGl0YXRlbGFuZ3MgPSBBcnJheS5mcm9tKFxuICAgIG5ldyBTZXQobmF2aWdhdG9yLmxhbmd1YWdlcy5tYXAoKGwpID0+IGwuc3BsaXQoXCItXCIpWzBdKSlcbiAgKS5tYXAoKGNvZGUpID0+IGdldExhbmd1YWdlSW5mb0Zyb21Db2RlKGNvZGUpKS5maWx0ZXIoKGxpKSA9PiBsaSk7XG4gIHJldHVybiBjYW5kaXRhdGVsYW5nc1swXSA/PyBMYW5ndWFnZS5FTkdMSVNIO1xufVxuZnVuY3Rpb24gaXNMYW5ndWFnZUluZm8ob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBcImNvZGVcIiBpbiBvYmogJiYgXCJmbGFnXCIgaW4gb2JqICYmIFwibmFtZVwiIGluIG9iaiAmJiBcImxhdGluXCIgaW4gb2JqICYmIFwiaXNNb2RlXCIgaW4gb2JqICYmIFwiZ2VvY29kaW5nXCIgaW4gb2JqICYmICh0eXBlb2Ygb2JqLmNvZGUgPT09IFwic3RyaW5nXCIgfHwgb2JqLmNvZGUgPT09IG51bGwpICYmIHR5cGVvZiBvYmouZmxhZyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqLm5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iai5sYXRpbiA9PT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIG9iai5pc01vZGUgPT09IFwiYm9vbGVhblwiICYmIHR5cGVvZiBvYmouZ2VvY29kaW5nID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHRvTGFuZ3VhZ2VJbmZvKGxhbmcsIGxhbmd1YWdlRGljdGlvbmFyeSA9IExhbmd1YWdlKSB7XG4gIGlmIChpc0xhbmd1YWdlSW5mbyhsYW5nKSkge1xuICAgIHJldHVybiBnZXRMYW5ndWFnZUluZm9Gcm9tRmxhZyhsYW5nLmZsYWcsIGxhbmd1YWdlRGljdGlvbmFyeSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsYW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGdldExhbmd1YWdlSW5mb0Zyb21LZXkobGFuZywgbGFuZ3VhZ2VEaWN0aW9uYXJ5KSB8fCBnZXRMYW5ndWFnZUluZm9Gcm9tQ29kZShsYW5nLCBsYW5ndWFnZURpY3Rpb25hcnkpIHx8IGdldExhbmd1YWdlSW5mb0Zyb21GbGFnKGxhbmcsIGxhbmd1YWdlRGljdGlvbmFyeSkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGFyZVNhbWVMYW5ndWFnZXMobGFuZ0EsIGxhbmdCLCBsYW5ndWFnZURpY3Rpb25hcnkgPSBMYW5ndWFnZSkge1xuICBjb25zdCBsYW5nQU9iaiA9IHRvTGFuZ3VhZ2VJbmZvKGxhbmdBLCBsYW5ndWFnZURpY3Rpb25hcnkpO1xuICBjb25zdCBsYW5nQk9iaiA9IHRvTGFuZ3VhZ2VJbmZvKGxhbmdCLCBsYW5ndWFnZURpY3Rpb25hcnkpO1xuICByZXR1cm4gbGFuZ0FPYmogJiYgbGFuZ0JPYmogJiYgbGFuZ0FPYmouZmxhZyA9PT0gbGFuZ0JPYmouZmxhZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbEZldGNoKHJlc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKGNvbmZpZy5mZXRjaCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIGZldGNoIGZ1bmN0aW9uIHdhcyBub3QgZm91bmQuIElmIG9uIE5vZGVKUyA8IDE4IHBsZWFzZSBzcGVjaWZ5IHRoZSBmZXRjaCBmdW5jdGlvbiB3aXRoIGNvbmZpZy5mZXRjaFwiXG4gICAgKTtcbiAgfVxuICBpZiAobmV3IFVSTChyZXNvdXJjZSkuc2VhcmNoUGFyYW1zLmdldChcImtleVwiKS50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBNYXBUaWxlciBDbG91ZCBBUEkga2V5IGlzIG1pc3NpbmcuIFNldCBpdCBpbiBgY29uZmlnLmFwaUtleWAgb3IgZ2V0IG9uZSBmb3IgZnJlZSBhdCBodHRwczovL21hcHRpbGVyLmNvbVwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmZldGNoKHJlc291cmNlLCBvcHRpb25zKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIG1hcHRpbGVyQXBpVVJMOiBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9cIixcbiAgbWFwU3R5bGU6IFwic3RyZWV0cy12MlwiXG59O1xuT2JqZWN0LmZyZWV6ZShkZWZhdWx0cyk7XG5cbmNsYXNzIFNlcnZpY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzLCBjdXN0b21NZXNzYWdlID0gXCJcIikge1xuICAgIHN1cGVyKFxuICAgICAgYENhbGwgdG8gZW5wb2ludCAke3Jlcy51cmx9IGZhaWxlZCB3aXRoIHRoZSBzdGF0dXMgY29kZSAke3Jlcy5zdGF0dXN9LiAke2N1c3RvbU1lc3NhZ2V9YFxuICAgICk7XG4gICAgdGhpcy5yZXMgPSByZXM7XG4gIH1cbn1cblxuY29uc3QgY3VzdG9tTWVzc2FnZXMkNCA9IHtcbiAgNDAwOiBcIlF1ZXJ5IHRvbyBsb25nIC8gSW52YWxpZCBwYXJhbWV0ZXJzXCIsXG4gIDQwMzogXCJLZXkgaXMgbWlzc2luZywgaW52YWxpZCBvciByZXN0cmljdGVkXCJcbn07XG5mdW5jdGlvbiBhZGRMYW5ndWFnZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgbGFuZ3VhZ2UgfSA9IG9wdGlvbnM7XG4gIGlmIChsYW5ndWFnZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxhbmd1YWdlQ29kZXMgPSAoQXJyYXkuaXNBcnJheShsYW5ndWFnZSkgPyBsYW5ndWFnZSA6IFtsYW5ndWFnZV0pLm1hcCgoZWxlbSkgPT4gdG9WYWxpZEdlb2NvZGluZ0xhbmd1YWdlQ29kZShlbGVtKSkuZmlsdGVyKChlbGVtKSA9PiBlbGVtKTtcbiAgY29uc3QgbGFuZ3VhZ2VzID0gQXJyYXkuZnJvbShuZXcgU2V0KGxhbmd1YWdlQ29kZXMpKS5qb2luKFwiLFwiKTtcbiAgc2VhcmNoUGFyYW1zLnNldChcImxhbmd1YWdlXCIsIGxhbmd1YWdlcyk7XG59XG5mdW5jdGlvbiB0b1ZhbGlkR2VvY29kaW5nTGFuZ3VhZ2VDb2RlKGxhbmcpIHtcbiAgY29uc3QgbGFuZ0luZm8gPSBsYW5nID09PSBMYW5ndWFnZS5BVVRPLmZsYWcgPyBnZXRBdXRvTGFuZ3VhZ2UoKSA6IHR5cGVvZiBsYW5nID09PSBcInN0cmluZ1wiID8gZ2V0TGFuZ3VhZ2VJbmZvRnJvbUNvZGUobGFuZykgOiBpc0xhbmd1YWdlSW5mbyhsYW5nKSA/IGxhbmcuZmxhZyA9PT0gTGFuZ3VhZ2UuQVVUTy5mbGFnID8gZ2V0QXV0b0xhbmd1YWdlKCkgOiBnZXRMYW5ndWFnZUluZm9Gcm9tRmxhZyhsYW5nLmZsYWcpIDogbnVsbDtcbiAgcmV0dXJuIGxhbmdJbmZvPy5nZW9jb2RpbmcgPyBsYW5nSW5mby5jb2RlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGFkZENvbW1vbkZvcndhcmRBbmRSZXZlcnNlR2VvY29kaW5nT3B0aW9ucyhzZWFyY2hQYXJhbXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhcGlLZXksIGxpbWl0LCB0eXBlcywgZXhjbHVkZVR5cGVzIH0gPSBvcHRpb25zO1xuICBzZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIGFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgaWYgKGxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gIH1cbiAgaWYgKHR5cGVzICE9PSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwidHlwZXNcIiwgdHlwZXMuam9pbihcIixcIikpO1xuICB9XG4gIGlmIChleGNsdWRlVHlwZXMgIT09IHZvaWQgMCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJleGNsdWRlVHlwZXNcIiwgU3RyaW5nKGV4Y2x1ZGVUeXBlcykpO1xuICB9XG4gIGFkZExhbmd1YWdlR2VvY29kaW5nT3B0aW9ucyhzZWFyY2hQYXJhbXMsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYWRkRm9yd2FyZEdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKSB7XG4gIGFkZENvbW1vbkZvcndhcmRBbmRSZXZlcnNlR2VvY29kaW5nT3B0aW9ucyhzZWFyY2hQYXJhbXMsIG9wdGlvbnMpO1xuICBjb25zdCB7IGJib3gsIHByb3hpbWl0eSwgY291bnRyeSwgZnV6enlNYXRjaCwgYXV0b2NvbXBsZXRlIH0gPSBvcHRpb25zO1xuICBpZiAoYmJveCAhPT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImJib3hcIiwgYmJveC5qb2luKFwiLFwiKSk7XG4gIH1cbiAgaWYgKHByb3hpbWl0eSAhPT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcbiAgICAgIFwicHJveGltaXR5XCIsXG4gICAgICBwcm94aW1pdHkgPT09IFwiaXBcIiA/IHByb3hpbWl0eSA6IHByb3hpbWl0eS5qb2luKFwiLFwiKVxuICAgICk7XG4gIH1cbiAgaWYgKGNvdW50cnkgIT09IHZvaWQgMCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJjb3VudHJ5XCIsIGNvdW50cnkuam9pbihcIixcIikpO1xuICB9XG4gIGlmIChmdXp6eU1hdGNoICE9PSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZnV6enlNYXRjaFwiLCBmdXp6eU1hdGNoID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuICB9XG4gIGlmIChhdXRvY29tcGxldGUgIT09IHZvaWQgMCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJhdXRvY29tcGxldGVcIiwgYXV0b2NvbXBsZXRlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmb3J3YXJkKHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gXCJzdHJpbmdcIiB8fCBxdWVyeS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHF1ZXJ5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgZ2VvY29kaW5nLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX0uanNvbmAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgYWRkRm9yd2FyZEdlb2NvZGluZ09wdGlvbnMoZW5kcG9pbnQuc2VhcmNoUGFyYW1zLCBvcHRpb25zKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKGVuZHBvaW50LnRvU3RyaW5nKCkpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IocmVzLCBjdXN0b21NZXNzYWdlcyQ0W3Jlcy5zdGF0dXNdID8/IFwiXCIpO1xuICB9XG4gIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmV2ZXJzZShwb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwb3NpdGlvbikgfHwgcG9zaXRpb24ubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwb3NpdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mIGZvcm0gW2xuZywgbGF0XS5cIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBnZW9jb2RpbmcvJHtwb3NpdGlvblswXX0sJHtwb3NpdGlvblsxXX0uanNvbmAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgYWRkQ29tbW9uRm9yd2FyZEFuZFJldmVyc2VHZW9jb2RpbmdPcHRpb25zKGVuZHBvaW50LnNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxGZXRjaChlbmRwb2ludC50b1N0cmluZygpKTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKHJlcywgY3VzdG9tTWVzc2FnZXMkNFtyZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ5SWQoaWQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoYGdlb2NvZGluZy8ke2lkfS5qc29uYCwgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkwpO1xuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICBhZGRMYW5ndWFnZUdlb2NvZGluZ09wdGlvbnMoZW5kcG9pbnQuc2VhcmNoUGFyYW1zLCBvcHRpb25zKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKGVuZHBvaW50LnRvU3RyaW5nKCkpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IocmVzLCBjdXN0b21NZXNzYWdlcyQ0W3Jlcy5zdGF0dXNdID8/IFwiXCIpO1xuICB9XG4gIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gYmF0Y2gkMShxdWVyaWVzLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFxdWVyaWVzLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBqb2luZWRRdWVyeSA9IHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KSkuam9pbihcIjtcIik7XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgZ2VvY29kaW5nLyR7am9pbmVkUXVlcnl9Lmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGFkZEZvcndhcmRHZW9jb2RpbmdPcHRpb25zKGVuZHBvaW50LnNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxGZXRjaChlbmRwb2ludC50b1N0cmluZygpKTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKHJlcywgY3VzdG9tTWVzc2FnZXMkNFtyZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gcXVlcmllcy5sZW5ndGggPT09IDEgPyBbb2JqXSA6IG9iajtcbn1cbmNvbnN0IGdlb2NvZGluZyA9IHtcbiAgZm9yd2FyZCxcbiAgcmV2ZXJzZSxcbiAgYnlJZCxcbiAgYmF0Y2g6IGJhdGNoJDFcbn07XG5cbmNvbnN0IGN1c3RvbU1lc3NhZ2VzJDMgPSB7XG4gIDQwMzogXCJLZXkgaXMgbWlzc2luZywgaW52YWxpZCBvciByZXN0cmljdGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBpbmZvKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoYGdlb2xvY2F0aW9uL2lwLmpzb25gLCBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTCk7XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGlmIChcImVsZXZhdGlvblwiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgXCJlbGV2YXRpb25cIixcbiAgICAgIG9wdGlvbnMuZWxldmF0aW9uID8gXCJ0cnVlXCIgOiBcImZhbHNlXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMyA/IGN1c3RvbU1lc3NhZ2VzJDNbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgZ2VvbG9jYXRpb24gPSB7XG4gIGluZm9cbn07XG5cbmNvbnN0IGN1c3RvbU1lc3NhZ2VzJDIgPSB7XG4gIDQwMzogXCJLZXkgaXMgbWlzc2luZywgaW52YWxpZCBvciByZXN0cmljdGVkXCJcbn07XG5hc3luYyBmdW5jdGlvbiBzZWFyY2gocXVlcnksIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIHF1ZXJ5ICE9PSBcInN0cmluZ1wiIHx8IHF1ZXJ5LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcXVlcnkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBjb29yZGluYXRlcy9zZWFyY2gvJHtxdWVyeX0uanNvbmAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgaWYgKFwibGltaXRcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwidHJhbnNmb3JtYXRpb25zXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICBcInRyYW5zZm9ybWF0aW9uc1wiLFxuICAgICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbnMudG9TdHJpbmcoKVxuICAgICk7XG4gIH1cbiAgaWYgKFwiZXhwb3J0c1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwiZXhwb3J0c1wiLCBvcHRpb25zLmV4cG9ydHMudG9TdHJpbmcoKSk7XG4gIH1cbiAgY29uc3QgdXJsV2l0aFBhcmFtcyA9IGVuZHBvaW50LnRvU3RyaW5nKCk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxGZXRjaCh1cmxXaXRoUGFyYW1zKTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKFxuICAgICAgcmVzLFxuICAgICAgcmVzLnN0YXR1cyBpbiBjdXN0b21NZXNzYWdlcyQyID8gY3VzdG9tTWVzc2FnZXMkMltyZXMuc3RhdHVzXSA6IFwiXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IG9iaiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIHJldHVybiBvYmo7XG59XG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9zaXRpb25zLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY29vcmRpbmF0ZXNTdHIgPSAoQXJyYXkuaXNBcnJheShwb3NpdGlvbnNbMF0pID8gcG9zaXRpb25zIDogW3Bvc2l0aW9uc10pLm1hcCgoY29vcmQpID0+IGAke2Nvb3JkWzBdfSwke2Nvb3JkWzFdfWApLmpvaW4oXCI7XCIpO1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYGNvb3JkaW5hdGVzL3RyYW5zZm9ybS8ke2Nvb3JkaW5hdGVzU3RyfS5qc29uYCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICBpZiAoXCJzb3VyY2VDcnNcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInNfc3JzXCIsIG9wdGlvbnMuc291cmNlQ3JzLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcInRhcmdldENyc1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwidF9zcnNcIiwgb3B0aW9ucy50YXJnZXRDcnMudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwib3BlcmF0aW9uc1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgXCJvcHNcIixcbiAgICAgIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3BlcmF0aW9ucykgPyBvcHRpb25zLm9wZXJhdGlvbnMgOiBbb3B0aW9ucy5vcGVyYXRpb25zXSkuam9pbihcInxcIilcbiAgICApO1xuICB9XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMiA/IGN1c3RvbU1lc3NhZ2VzJDJbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgY29vcmRpbmF0ZXMgPSB7XG4gIHNlYXJjaCxcbiAgdHJhbnNmb3JtXG59O1xuXG5jb25zdCBjdXN0b21NZXNzYWdlcyQxID0ge1xuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0KGRhdGFJZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZGF0YUlkICE9PSBcInN0cmluZ1wiIHx8IGRhdGFJZC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgSUQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBkYXRhLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFJZCl9L2ZlYXR1cmVzLmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMSA/IGN1c3RvbU1lc3NhZ2VzJDFbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgZGF0YSA9IHtcbiAgZ2V0XG59O1xuXG5mdW5jdGlvbiBleHBhbmRNYXBTdHlsZShzdHlsZSkge1xuICBjb25zdCBtYXB0aWxlckRvbWFpblJlZ2V4ID0gL15tYXB0aWxlcjpcXC9cXC8oLiopLztcbiAgbGV0IG1hdGNoO1xuICBjb25zdCB0cmltbWVkID0gc3R5bGUudHJpbSgpO1xuICBsZXQgZXhwYW5kZWRTdHlsZTtcbiAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgdHJpbW1lZC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICBleHBhbmRlZFN0eWxlID0gdHJpbW1lZDtcbiAgfSBlbHNlIGlmICgobWF0Y2ggPSBtYXB0aWxlckRvbWFpblJlZ2V4LmV4ZWModHJpbW1lZCkpICE9PSBudWxsKSB7XG4gICAgZXhwYW5kZWRTdHlsZSA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vbWFwcy8ke21hdGNoWzFdfS9zdHlsZS5qc29uYDtcbiAgfSBlbHNlIHtcbiAgICBleHBhbmRlZFN0eWxlID0gYGh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9tYXBzLyR7dHJpbW1lZH0vc3R5bGUuanNvbmA7XG4gIH1cbiAgcmV0dXJuIGV4cGFuZGVkU3R5bGU7XG59XG5jbGFzcyBNYXBTdHlsZVZhcmlhbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YXJpYW50VHlwZSwgaWQsIHJlZmVyZW5jZVN0eWxlLCBkZXNjcmlwdGlvbiwgaW1hZ2VVUkwsIGRlcHJlY2F0ZWQgPSBmYWxzZSwgZGVwcmVjYXRpb25NZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZhcmlhbnRUeXBlID0gdmFyaWFudFR5cGU7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucmVmZXJlbmNlU3R5bGUgPSByZWZlcmVuY2VTdHlsZTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgdGhpcy5pbWFnZVVSTCA9IGltYWdlVVJMO1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG4gICAgdGhpcy5kZXByZWNhdGlvbk1lc3NhZ2UgPSBkZXByZWNhdGlvbk1lc3NhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4tZnJpZW5kbHkgbmFtZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnJlZmVyZW5jZVN0eWxlLmdldE5hbWUoKX0gJHt0aGlzLm5hbWV9YDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YXJpYW50IHR5cGUgKGVnLiBcIkRFRkFVTFRcIiwgXCJEQVJLXCIsIFwiUEFTVEVMXCIsIGV0Yy4pXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhbnRUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIENsb3VkIGlkXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbi1mcmllbmRseSBkZXNjcmlwdGlvblxuICAgKi9cbiAgZ2V0RGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVmZXJlbmNlIHN0eWxlIHRoaXMgdmFyaWFudCBiZWxvbmdzIHRvXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRSZWZlcmVuY2VTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VTdHlsZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YXJpYW50IG9mIGEgZ2l2ZW4gdHlwZSBleGlzdHMgZm9yIF90aGlzXyB2YXJpYW50c1xuICAgKiAoZWcuIGlmIHRoaXMgaXMgYSBcIkRBUktcIiwgdGhlbiB3ZSBjYW4gY2hlY2sgaWYgdGhlcmUgaXMgYSBcIkxJR0hUXCIgdmFyaWFudCBvZiBpdClcbiAgICogQHBhcmFtIHZhcmlhbnRUeXBlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBoYXNWYXJpYW50KHZhcmlhbnRUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlU3R5bGUuaGFzVmFyaWFudCh2YXJpYW50VHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSB2YXJpYW50IG9mIGEgZ2l2ZW4gdHlwZS4gSWYgbm90IGZvdW5kLCB3aWxsIHJldHVybiB0aGUgXCJERUZBVUxUXCIgdmFyaWFudC5cbiAgICogKGVnLiBfdGhpc18gXCJEQVJLXCIgdmFyaWFudCBkb2VzIG5vdCBoYXZlIGFueSBcIlBBU1RFTFwiIHZhcmlhbnQsIHRoZW4gdGhlIFwiREVGQVVMVFwiIGlzIHJldHVybmVkKVxuICAgKiBAcGFyYW0gdmFyaWFudFR5cGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFZhcmlhbnQodmFyaWFudFR5cGUpIHtcbiAgICBjb25zdCB2YXJpYW50ID0gdGhpcy5yZWZlcmVuY2VTdHlsZS5nZXRWYXJpYW50KHZhcmlhbnRUeXBlKTtcbiAgICB0aGlzLndhcm5JZkRlcHJlY2F0ZWQodmFyaWFudCk7XG4gICAgcmV0dXJuIHZhcmlhbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgdGhlIHZhcmlhbnRzIGZvciBfdGhpc18gdmFyaWFudHMsIGV4Y2VwdCBfdGhpc18gY3VycmVudCBvbmVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFZhcmlhbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZVN0eWxlLmdldFZhcmlhbnRzKCkuZmlsdGVyKCh2KSA9PiB2ICE9PSB0aGlzKS5tYXAoKHYpID0+IHtcbiAgICAgIHRoaXMud2FybklmRGVwcmVjYXRlZCh2KTtcbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIFVSTCB0aGF0IHJlcHJlc2VudCBfdGhpc18gdmFyaWFudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0SW1hZ2VVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VVUkw7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgYXMgdXNhYmxlIGJ5IE1hcExpYnJlLCBhIHN0cmluZyAoVVJMKSBvciBhIHBsYWluIHN0eWxlIGRlc2NyaXB0aW9uIChTdHlsZVNwZWNpZmljYXRpb24pXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRFeHBhbmRlZFN0eWxlVVJMKCkge1xuICAgIHJldHVybiBleHBhbmRNYXBTdHlsZSh0aGlzLmdldElkKCkpO1xuICB9XG4gIHdhcm5JZkRlcHJlY2F0ZWQodmFyaWFudCA9IHRoaXMpIHtcbiAgICBpZiAoIXZhcmlhbnQuZGVwcmVjYXRlZCkgcmV0dXJuIHZhcmlhbnQ7XG4gICAgaWYgKHZhcmlhbnQuZGVwcmVjYXRpb25NZXNzYWdlKSB7XG4gICAgICBjb25zb2xlLndhcm4odmFyaWFudC5kZXByZWNhdGlvbk1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuYW1lID0gdmFyaWFudC5nZXRGdWxsTmFtZSgpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgU3R5bGUgXCIke25hbWV9XCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhbnQ7XG4gIH1cbn1cbmNsYXNzIFJlZmVyZW5jZU1hcFN0eWxlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgaWQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICAvKipcbiAgICAgKiBWYXJpYW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIHJlZmVyZW5jZSBzdHlsZSwga2V5IGJlaW5nIHRoZSByZWZlcmVuY2UgdHlwZVxuICAgICAqL1xuICAgIHRoaXMudmFyaWFudHMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBWYXJpYW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIHJlZmVyZW5jZSBzdHlsZSwgb3JkZXJlZCBieSByZWxldmFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm9yZGVyZWRWYXJpYW50cyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuLWZyaWVuZGx5IG5hbWUgb2YgdGhpcyByZWZlcmVuY2Ugc3R5bGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBpZCBvZiBfdGhpc18gcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgdmFyaWFudCB0byBfdGhpc18gcmVmZXJlbmNlIHN0eWxlXG4gICAqIEBwYXJhbSB2XG4gICAqL1xuICBhZGRWYXJpYW50KHYpIHtcbiAgICB0aGlzLnZhcmlhbnRzW3YuZ2V0VHlwZSgpXSA9IHY7XG4gICAgdGhpcy5vcmRlcmVkVmFyaWFudHMucHVzaCh2KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBnaXZlbiB2YXJpYW50IHR5cGUgZXhpc3RzIGZvciB0aGlzIHJlZmVyZW5jZSBzdHlsZVxuICAgKiBAcGFyYW0gdmFyaWFudFR5cGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1ZhcmlhbnQodmFyaWFudFR5cGUpIHtcbiAgICByZXR1cm4gdmFyaWFudFR5cGUgaW4gdGhpcy52YXJpYW50cztcbiAgfVxuICAvKipcbiAgICogR2V0IGEgZ2l2ZW4gdmFyaWFudC4gSWYgdGhlIGdpdmVuIHR5cGUgb2YgdmFyaWFudCBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyByZWZlcmVuY2Ugc3R5bGUsXG4gICAqIHRoZW4gdGhlIG1vc3QgcmVsZXZhbnQgZGVmYXVsdCB2YXJpYW50IGlzIHJldHVybmVkIGluc3RlYWRcbiAgICogQHBhcmFtIHZhcmlhbnRUeXBlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRWYXJpYW50KHZhcmlhbnRUeXBlKSB7XG4gICAgcmV0dXJuIHZhcmlhbnRUeXBlIGluIHRoaXMudmFyaWFudHMgPyB0aGlzLnZhcmlhbnRzW3ZhcmlhbnRUeXBlXSA6IHRoaXMub3JkZXJlZFZhcmlhbnRzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgdmFyaWFudHMgZm9yIHRoaXMgcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRWYXJpYW50cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnZhcmlhbnRzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkZWZ1YWx0IHZhcmlhbnQgZm9yIHRoaXMgcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXREZWZhdWx0VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmRlcmVkVmFyaWFudHNbMF0ud2FybklmRGVwcmVjYXRlZCgpO1xuICB9XG59XG5jb25zdCBtYXBTdHlsZVByZXNldExpc3QgPSBbXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlNUUkVFVFNfVjJcIixcbiAgICBuYW1lOiBcIlN0cmVldHNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJzdHJlZXRzLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdCB2MlwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRpb25NZXNzYWdlOiBgXCJzdHJlZXRzLXYyXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwic3RyZWV0cy12NFwiIGluc3RlYWRgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJzdHJlZXRzLXYyLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrIHYyXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICBkZXByZWNhdGlvbk1lc3NhZ2U6IGBcInN0cmVldHMtdjItZGFya1wiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcInN0cmVldHMtdjQtZGFya1wiIGluc3RlYWRgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJzdHJlZXRzLXYyLWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHQgdjJcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICBkZXByZWNhdGlvbk1lc3NhZ2U6IGBcInN0cmVldHMtdjItbGlnaHRcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCJzdHJlZXRzLXY0LWxpZ2h0XCIgaW5zdGVhZGBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInN0cmVldHMtdjItbmlnaHRcIixcbiAgICAgICAgbmFtZTogXCJOaWdodCB2MlwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJOSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0aW9uTWVzc2FnZTogYFwic3RyZWV0cy12Mi1uaWdodFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcInN0cmVldHMtdjQtbmlnaHRcIiBpbnN0ZWFkYFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1wYXN0ZWxcIixcbiAgICAgICAgbmFtZTogXCJQYXN0ZWwgdjJcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiUEFTVEVMXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRpb25NZXNzYWdlOiBgXCJzdHJlZXRzLXYyLXBhc3RlbFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcInN0cmVldHMtdjQtcGFzdGVsXCIgaW5zdGVhZGBcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlNUUkVFVFNfVjRcIixcbiAgICBuYW1lOiBcIlN0cmVldHNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJzdHJlZXRzLXY0XCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12NC1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12NC1wYXN0ZWxcIixcbiAgICAgICAgbmFtZTogXCJQYXN0ZWxcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiUEFTVEVMXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiQkFTRV9WNFwiLFxuICAgIG5hbWU6IFwiQmFzZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhc2UtdjRcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJiYXNlLXY0LWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJiYXNlLXY0LWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJiYXNlLXY0LWFpXCIsXG4gICAgICAgIG5hbWU6IFwiQmFzZSBBSVwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJOSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIk9VVERPT1JcIixcbiAgICBuYW1lOiBcIk91dGRvb3JcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJvdXRkb29yLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwib3V0ZG9vci12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiV0lOVEVSXCIsXG4gICAgbmFtZTogXCJXaW50ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJ3aW50ZXItdjJcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ3aW50ZXItdjItZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlNBVEVMTElURVwiLFxuICAgIG5hbWU6IFwiU2F0ZWxsaXRlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic2F0ZWxsaXRlXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiSFlCUklEXCIsXG4gICAgbmFtZTogXCJIeWJyaWRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJoeWJyaWRcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJCQVNJQ19WMlwiLFxuICAgIG5hbWU6IFwiQmFzaWNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJiYXNpYy12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0aW9uTWVzc2FnZTogYFwiYmFzaWMtdjJcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCJiYXNpYy12NFwiIGluc3RlYWRgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJiYXNpYy12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYmFzaWMtdjItbGlnaHRcIixcbiAgICAgICAgbmFtZTogXCJMaWdodFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJMSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIkJSSUdIVFwiLFxuICAgIG5hbWU6IFwiQnJpZ2h0XCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYnJpZ2h0LXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYnJpZ2h0LXYyLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJicmlnaHQtdjItbGlnaHRcIixcbiAgICAgICAgbmFtZTogXCJMaWdodFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJMSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJyaWdodC12Mi1wYXN0ZWxcIixcbiAgICAgICAgbmFtZTogXCJQYXN0ZWxcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiUEFTVEVMXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiT1BFTlNUUkVFVE1BUFwiLFxuICAgIG5hbWU6IFwiT3BlblN0cmVldE1hcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcIm9wZW5zdHJlZXRtYXBcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJUT1BPXCIsXG4gICAgbmFtZTogXCJUb3BvXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidG9wby12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvcG8tdjItZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvcG8tdjItc2hpbnlcIixcbiAgICAgICAgbmFtZTogXCJTaGlueVwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJTSElOWVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvcG8tdjItcGFzdGVsXCIsXG4gICAgICAgIG5hbWU6IFwiUGFzdGVsXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlBBU1RFTFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvcG8tdjItdG9wb2dyYXBoaXF1ZVwiLFxuICAgICAgICBuYW1lOiBcIlRvcG9ncmFwaGlxdWVcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiVE9QT0dSQVBISVFVRVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlZPWUFHRVJcIixcbiAgICBuYW1lOiBcIlZveWFnZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJ2b3lhZ2VyLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidm95YWdlci12Mi1kYXJrbWF0dGVyXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya21hdHRlclwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidm95YWdlci12Mi1wb3NpdHJvblwiLFxuICAgICAgICBuYW1lOiBcIlBvc2l0cm9uXCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWUsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidm95YWdlci12Mi12aW50YWdlXCIsXG4gICAgICAgIG5hbWU6IFwiVmludGFnZVwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJWSU5UQUdFXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiVE9ORVJcIixcbiAgICBuYW1lOiBcIlRvbmVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidG9uZXItdjJcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b25lci12Mi1iYWNrZ3JvdW5kXCIsXG4gICAgICAgIG5hbWU6IFwiQmFja2dyb3VuZFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJCQUNLR1JPVU5EXCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidG9uZXItdjItbGl0ZVwiLFxuICAgICAgICBuYW1lOiBcIkxpdGVcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElURVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvbmVyLXYyLWxpbmVzXCIsXG4gICAgICAgIG5hbWU6IFwiTGluZXNcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElORVNcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJEQVRBVklaXCIsXG4gICAgbmFtZTogXCJEYXRhdml6XCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiZGF0YXZpelwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImRhdGF2aXotZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImRhdGF2aXotbGlnaHRcIixcbiAgICAgICAgbmFtZTogXCJMaWdodFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJMSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIkJBQ0tEUk9QXCIsXG4gICAgbmFtZTogXCJCYWNrZHJvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhY2tkcm9wXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYmFja2Ryb3AtZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhY2tkcm9wLWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJPQ0VBTlwiLFxuICAgIG5hbWU6IFwiT2NlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJvY2VhblwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIkFRVUFSRUxMRVwiLFxuICAgIG5hbWU6IFwiQXF1YXJlbGxlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiV2F0ZXJjb2xvciBtYXAgZm9yIGNyZWF0aXZlIHVzZVwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImFxdWFyZWxsZVwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImFxdWFyZWxsZS1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYXF1YXJlbGxlLXZpdmlkXCIsXG4gICAgICAgIG5hbWU6IFwiVml2aWRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiVklWSURcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJMQU5EU0NBUEVfVjJcIixcbiAgICBuYW1lOiBcIkxhbmRzY2FwZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRlcnJhaW4gbWFwIGZvciBkYXRhIG92ZXJsYXlzIGFuZCB2aXN1YWxpc2F0aW9uc1wiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImxhbmRzY2FwZVwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0aW9uTWVzc2FnZTogYFwibGFuZHNjYXBlXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwibGFuZHNjYXBlLXY0XCIgaW5zdGVhZGBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImxhbmRzY2FwZS1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRpb25NZXNzYWdlOiBgXCJsYW5kc2NhcGUtZGFya1wiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcImxhbmRzY2FwZS12NC1kYXJrXCIgaW5zdGVhZGBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImxhbmRzY2FwZS12aXZpZFwiLFxuICAgICAgICBuYW1lOiBcIlZpdmlkXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlZJVklEXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRpb25NZXNzYWdlOiBgXCJsYW5kc2NhcGUtdml2aWRcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCJsYW5kc2NhcGUtdjQtdml2aWRcIiBpbnN0ZWFkYFxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiTEFORFNDQVBFX1Y0XCIsXG4gICAgbmFtZTogXCJMYW5kc2NhcGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUZXJyYWluIG1hcCBmb3IgZGF0YSBvdmVybGF5cyBhbmQgdmlzdWFsaXNhdGlvbnNcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJsYW5kc2NhcGUtdjRcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJsYW5kc2NhcGUtdjQtZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImxhbmRzY2FwZS12NC12aXZpZFwiLFxuICAgICAgICBuYW1lOiBcIlZpdmlkXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlZJVklEXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfVxuXTtcbmNvbnN0IGRlZmF1bHRSZWZlcmVuY2VTdHlsZU1hcCA9IHtcbiAgU1RSRUVUUzogXCJTVFJFRVRTX1YyXCIsXG4gIEJBU0lDOiBcIkJBU0lDX1YyXCIsXG4gIExBTkRTQ0FQRTogXCJMQU5EU0NBUEVfVjJcIlxufTtcbmZ1bmN0aW9uIGFwcGx5VmVyc2lvblRvRGVmYXVsdFJlZmVyZW5jZVN0eWxlKGRlZmF1bHRLZXksIHJlZmVyZW5jZUtleSkge1xuICBpZiAobWFwU3R5bGVQcmVzZXRMaXN0LmZpbmQoKHN0eWxlKSA9PiBzdHlsZS5yZWZlcmVuY2VTdHlsZUlEID09PSBkZWZhdWx0S2V5KSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBEZWZhdWx0IHJlZmVyZW5jZSBzdHlsZSAke2RlZmF1bHRLZXl9IGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLi4uYFxuICAgICk7XG4gIH1cbiAgY29uc3QgdmVyc2lvbmVkTWFwU3R5bGUgPSBtYXBTdHlsZVByZXNldExpc3QuZmluZChcbiAgICAoc3R5bGUpID0+IHN0eWxlLnJlZmVyZW5jZVN0eWxlSUQgPT09IHJlZmVyZW5jZUtleVxuICApO1xuICBpZiAoIXZlcnNpb25lZE1hcFN0eWxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFZlcnNpb25lZCBtYXAgc3R5bGUgbm90IGZvdW5kIGZvciByZWZlcmVuY2Ugc3R5bGU6ICR7cmVmZXJlbmNlS2V5fWBcbiAgICApO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHtcbiAgICAuLi52ZXJzaW9uZWRNYXBTdHlsZSxcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBkZWZhdWx0S2V5XG4gIH07XG4gIG1hcFN0eWxlUHJlc2V0TGlzdC5wdXNoKGRlZmF1bHRTdHlsZSk7XG59XG5PYmplY3QuZW50cmllcyhkZWZhdWx0UmVmZXJlbmNlU3R5bGVNYXApLmZvckVhY2goXG4gIChbZGVmYXVsdEtleSwgcmVmZXJlbmNlS2V5XSkgPT4ge1xuICAgIGFwcGx5VmVyc2lvblRvRGVmYXVsdFJlZmVyZW5jZVN0eWxlKGRlZmF1bHRLZXksIHJlZmVyZW5jZUtleSk7XG4gIH1cbik7XG5mdW5jdGlvbiBtYWtlUmVmZXJlbmNlU3R5bGVQcm94eShyZWZlcmVuY2VTdHlsZSkge1xuICByZXR1cm4gbmV3IFByb3h5KHJlZmVyZW5jZVN0eWxlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzVmFyaWFudChwcm9wKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhcmlhbnQocHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgPT09IHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZVN0eWxlLmdldERlZmF1bHRWYXJpYW50KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBidWlsZE1hcFN0eWxlcygpIHtcbiAgY29uc3QgbWFwU3R5bGUgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBTdHlsZVByZXNldExpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCByZWZTdHlsZUluZm8gPSBtYXBTdHlsZVByZXNldExpc3RbaV07XG4gICAgY29uc3QgcmVmU3R5bGUgPSBtYWtlUmVmZXJlbmNlU3R5bGVQcm94eShcbiAgICAgIG5ldyBSZWZlcmVuY2VNYXBTdHlsZShyZWZTdHlsZUluZm8ubmFtZSwgcmVmU3R5bGVJbmZvLnJlZmVyZW5jZVN0eWxlSUQpXG4gICAgKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZlN0eWxlSW5mby52YXJpYW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgY29uc3QgdmFyaWFudEluZm8gPSByZWZTdHlsZUluZm8udmFyaWFudHNbal07XG4gICAgICBjb25zdCB2YXJpYW50ID0gbmV3IE1hcFN0eWxlVmFyaWFudChcbiAgICAgICAgdmFyaWFudEluZm8ubmFtZSxcbiAgICAgICAgLy8gbmFtZVxuICAgICAgICB2YXJpYW50SW5mby52YXJpYW50VHlwZSxcbiAgICAgICAgLy8gdmFyaWFudFR5cGVcbiAgICAgICAgdmFyaWFudEluZm8uaWQsXG4gICAgICAgIC8vIGlkXG4gICAgICAgIHJlZlN0eWxlLFxuICAgICAgICAvLyByZWZlcmVuY2VTdHlsZVxuICAgICAgICB2YXJpYW50SW5mby5kZXNjcmlwdGlvbixcbiAgICAgICAgdmFyaWFudEluZm8uaW1hZ2VVUkwsXG4gICAgICAgIC8vIGltYWdlVVJMXG4gICAgICAgIHZhcmlhbnRJbmZvLmRlcHJlY2F0ZWRcbiAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgKTtcbiAgICAgIHJlZlN0eWxlLmFkZFZhcmlhbnQodmFyaWFudCk7XG4gICAgfVxuICAgIG1hcFN0eWxlW3JlZlN0eWxlSW5mby5yZWZlcmVuY2VTdHlsZUlEXSA9IHJlZlN0eWxlO1xuICB9XG4gIHJldHVybiBtYXBTdHlsZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVG9TdHlsZShzdHlsZSkge1xuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuIE1hcFN0eWxlW21hcFN0eWxlUHJlc2V0TGlzdFswXS5yZWZlcmVuY2VTdHlsZUlEXS5nZXREZWZhdWx0VmFyaWFudCgpLmdldElkKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIiB8fCBzdHlsZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHJldHVybiBzdHlsZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBNYXBTdHlsZVZhcmlhbnQpIHtcbiAgICByZXR1cm4gc3R5bGUuZ2V0SWQoKTtcbiAgfVxuICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VNYXBTdHlsZSkge1xuICAgIHJldHVybiBzdHlsZS5nZXREZWZhdWx0VmFyaWFudCgpLmdldElkKCk7XG4gIH1cbn1cbmNvbnN0IE1hcFN0eWxlID0gYnVpbGRNYXBTdHlsZXMoKTtcblxuZnVuY3Rpb24gZXh0cmFjdExpbmVTdHJpbmdzKGdlb0pzb24pIHtcbiAgY29uc3QgbGluZVN0cmluZ3MgPSBbXTtcbiAgZnVuY3Rpb24gZXh0cmFjdEZyb21HZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIiB8fCBnZW9tZXRyeS50eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSB7XG4gICAgICBsaW5lU3RyaW5ncy5wdXNoKGdlb21ldHJ5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdEZyb21GZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeSkge1xuICAgICAgZXh0cmFjdEZyb21HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0cmFjdEZyb21GZWF0dXJlQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIGNvbGxlY3Rpb24uZmVhdHVyZXMpIHtcbiAgICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IFwiRmVhdHVyZVwiKSB7XG4gICAgICAgIGV4dHJhY3RGcm9tRmVhdHVyZShmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZS50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIpIHtcbiAgICAgICAgZXh0cmFjdEZyb21GZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGdlb0pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICBleHRyYWN0RnJvbUZlYXR1cmUoZ2VvSnNvbik7XG4gIH0gZWxzZSBpZiAoZ2VvSnNvbi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIpIHtcbiAgICBleHRyYWN0RnJvbUZlYXR1cmVDb2xsZWN0aW9uKGdlb0pzb24pO1xuICB9IGVsc2Uge1xuICAgIGV4dHJhY3RGcm9tR2VvbWV0cnkoZ2VvSnNvbik7XG4gIH1cbiAgcmV0dXJuIGxpbmVTdHJpbmdzO1xufVxuZnVuY3Rpb24gZ2V0U3FTZWdEaXN0KHAsIHAxLCBwMikge1xuICBsZXQgeCA9IHAxWzBdLCB5ID0gcDFbMV0sIGR4ID0gcDJbMF0gLSB4LCBkeSA9IHAyWzFdIC0geTtcbiAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG4gICAgY29uc3QgdCA9ICgocFswXSAtIHgpICogZHggKyAocFsxXSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIHggPSBwMlswXTtcbiAgICAgIHkgPSBwMlsxXTtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4ICs9IGR4ICogdDtcbiAgICAgIHkgKz0gZHkgKiB0O1xuICAgIH1cbiAgfVxuICBkeCA9IHBbMF0gLSB4O1xuICBkeSA9IHBbMV0gLSB5O1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICBsZXQgbWF4U3FEaXN0ID0gc3FUb2xlcmFuY2UsIGluZGV4O1xuICBmb3IgKGxldCBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgY29uc3Qgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcbiAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICBpbmRleCA9IGk7XG4gICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgfVxuICB9XG4gIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgIGlmIChpbmRleCAtIGZpcnN0ID4gMSkge1xuICAgICAgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBmaXJzdCwgaW5kZXgsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG4gICAgc2ltcGxpZmllZC5wdXNoKHBvaW50c1tpbmRleF0pO1xuICAgIGlmIChsYXN0IC0gaW5kZXggPiAxKSB7XG4gICAgICBzaW1wbGlmeURQU3RlcChwb2ludHMsIGluZGV4LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcbiAgY29uc3QgbGFzdCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICBjb25zdCBzaW1wbGlmaWVkID0gW3BvaW50c1swXV07XG4gIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2xhc3RdKTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBjb25zdCBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAhPT0gdm9pZCAwID8gdG9sZXJhbmNlICogdG9sZXJhbmNlIDogMTtcbiAgY29uc3Qgc2ltcGxlUG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHNpbXBsZVBvaW50cztcbn1cbmNvbnN0IG1pc2MgPSB7XG4gIGV4dHJhY3RMaW5lU3RyaW5ncyxcbiAgc2ltcGxpZnlcbn07XG5cbmZ1bmN0aW9uIHN0YXRpY01hcE1hcmtlclRvU3RyaW5nKG1hcmtlciwgaW5jbHVkZUNvbG9yID0gdHJ1ZSkge1xuICBsZXQgc3RyID0gYCR7bWFya2VyWzBdfSwke21hcmtlclsxXX1gO1xuICBpZiAobWFya2VyLmxlbmd0aCA9PT0gMyAmJiBpbmNsdWRlQ29sb3IpIHtcbiAgICBzdHIgKz0gYCwke21hcmtlclsyXX1gO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzaW1wbGlmeUFuZFN0cmluZ2lmeShwYXRoLCBtYXhOYkNoYXIgPSAzZTMpIHtcbiAgbGV0IHN0ciA9IHBhdGgubWFwKChwb2ludCkgPT4gcG9pbnQuam9pbihcIixcIikpLmpvaW4oXCJ8XCIpO1xuICBsZXQgdG9sZXJhbmNlID0gNWUtNjtcbiAgY29uc3QgdG9sZXJhbmNlU3RlcCA9IDFlLTU7XG4gIHdoaWxlIChzdHIubGVuZ3RoID4gbWF4TmJDaGFyKSB7XG4gICAgY29uc3Qgc2ltcGxlclBhdGggPSBtaXNjLnNpbXBsaWZ5KHBhdGgsIHRvbGVyYW5jZSk7XG4gICAgc3RyID0gc2ltcGxlclBhdGgubWFwKChwb2ludCkgPT4gYCR7cG9pbnRbMF19LCR7cG9pbnRbMV19YCkuam9pbihcInxcIik7XG4gICAgdG9sZXJhbmNlICs9IHRvbGVyYW5jZVN0ZXA7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNlbnRlcmVkKGNlbnRlciwgem9vbSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVUb1N0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuaGlEUEkgPyBcIkAyeFwiIDogXCJcIjtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgPz8gXCJwbmdcIjtcbiAgbGV0IHdpZHRoID0gfn4ob3B0aW9ucy53aWR0aCA/PyAxMDI0KTtcbiAgbGV0IGhlaWdodCA9IH5+KG9wdGlvbnMuaGVpZ2h0ID8/IDEwMjQpO1xuICBpZiAob3B0aW9ucy5oaURQSSkge1xuICAgIHdpZHRoID0gfn4od2lkdGggLyAyKTtcbiAgICBoZWlnaHQgPSB+fihoZWlnaHQgLyAyKTtcbiAgfVxuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYG1hcHMvJHtlbmNvZGVVUklDb21wb25lbnQoc3R5bGUpfS9zdGF0aWMvJHtjZW50ZXJbMF19LCR7Y2VudGVyWzFdfSwke3pvb219LyR7d2lkdGh9eCR7aGVpZ2h0fSR7c2NhbGV9LiR7Zm9ybWF0fWAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgaWYgKFwiYXR0cmlidXRpb25cIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImF0dHJpYnV0aW9uXCIsIG9wdGlvbnMuYXR0cmlidXRpb24udG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwibWFya2Vyc1wiIGluIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFya2VyU3RyID0gXCJcIjtcbiAgICBjb25zdCBoYXNJY29uID0gXCJtYXJrZXJJY29uXCIgaW4gb3B0aW9ucztcbiAgICBpZiAoaGFzSWNvbikge1xuICAgICAgbWFya2VyU3RyICs9IGBpY29uOiR7b3B0aW9ucy5tYXJrZXJJY29ufXxgO1xuICAgIH1cbiAgICBpZiAoaGFzSWNvbiAmJiBcIm1hcmtlckFuY2hvclwiIGluIG9wdGlvbnMpIHtcbiAgICAgIG1hcmtlclN0ciArPSBgYW5jaG9yOiR7b3B0aW9ucy5tYXJrZXJBbmNob3J9fGA7XG4gICAgfVxuICAgIGlmIChoYXNJY29uICYmIG9wdGlvbnMuaGlEUEkpIHtcbiAgICAgIG1hcmtlclN0ciArPSBgc2NhbGU6MnxgO1xuICAgIH1cbiAgICBjb25zdCBtYXJrZXJMaXN0ID0gQXJyYXkuaXNBcnJheShvcHRpb25zLm1hcmtlcnNbMF0pID8gb3B0aW9ucy5tYXJrZXJzIDogW29wdGlvbnMubWFya2Vyc107XG4gICAgbWFya2VyU3RyICs9IG1hcmtlckxpc3QubWFwKChtKSA9PiBzdGF0aWNNYXBNYXJrZXJUb1N0cmluZyhtLCAhaGFzSWNvbikpLmpvaW4oXCJ8XCIpO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJtYXJrZXJzXCIsIG1hcmtlclN0cik7XG4gIH1cbiAgaWYgKFwicGF0aFwiIGluIG9wdGlvbnMpIHtcbiAgICBsZXQgcGF0aFN0ciA9IFwiXCI7XG4gICAgcGF0aFN0ciArPSBgZmlsbDoke29wdGlvbnMucGF0aEZpbGxDb2xvciA/PyBcIm5vbmVcIn18YDtcbiAgICBpZiAoXCJwYXRoU3Ryb2tlQ29sb3JcIiBpbiBvcHRpb25zKSB7XG4gICAgICBwYXRoU3RyICs9IGBzdHJva2U6JHtvcHRpb25zLnBhdGhTdHJva2VDb2xvcn18YDtcbiAgICB9XG4gICAgaWYgKFwicGF0aFdpZHRoXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgcGF0aFdpZHRoID0gb3B0aW9ucy5wYXRoV2lkdGggLyAob3B0aW9ucy5oaURQSSA/IDIgOiAxKTtcbiAgICAgIHBhdGhTdHIgKz0gYHdpZHRoOiR7cGF0aFdpZHRoLnRvU3RyaW5nKCl9fGA7XG4gICAgfVxuICAgIHBhdGhTdHIgKz0gc2ltcGxpZnlBbmRTdHJpbmdpZnkob3B0aW9ucy5wYXRoKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwicGF0aFwiLCBwYXRoU3RyKTtcbiAgfVxuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICByZXR1cm4gZW5kcG9pbnQudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGJvdW5kZWQoYm91bmRpbmdCb3gsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzdHlsZSA9IHN0eWxlVG9TdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLmhpRFBJID8gXCJAMnhcIiA6IFwiXCI7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ID8/IFwicG5nXCI7XG4gIGxldCB3aWR0aCA9IH5+KG9wdGlvbnMud2lkdGggPz8gMTAyNCk7XG4gIGxldCBoZWlnaHQgPSB+fihvcHRpb25zLmhlaWdodCA/PyAxMDI0KTtcbiAgaWYgKG9wdGlvbnMuaGlEUEkpIHtcbiAgICB3aWR0aCA9IH5+KHdpZHRoIC8gMik7XG4gICAgaGVpZ2h0ID0gfn4oaGVpZ2h0IC8gMik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBtYXBzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHN0eWxlKX0vc3RhdGljLyR7Ym91bmRpbmdCb3hbMF19LCR7Ym91bmRpbmdCb3hbMV19LCR7Ym91bmRpbmdCb3hbMl19LCR7Ym91bmRpbmdCb3hbM119LyR7d2lkdGh9eCR7aGVpZ2h0fSR7c2NhbGV9LiR7Zm9ybWF0fWAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgaWYgKFwiYXR0cmlidXRpb25cIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImF0dHJpYnV0aW9uXCIsIG9wdGlvbnMuYXR0cmlidXRpb24udG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwicGFkZGluZ1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwicGFkZGluZ1wiLCBvcHRpb25zLnBhZGRpbmcudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwibWFya2Vyc1wiIGluIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFya2VyU3RyID0gXCJcIjtcbiAgICBjb25zdCBoYXNJY29uID0gXCJtYXJrZXJJY29uXCIgaW4gb3B0aW9ucztcbiAgICBpZiAoaGFzSWNvbikge1xuICAgICAgbWFya2VyU3RyICs9IGBpY29uOiR7b3B0aW9ucy5tYXJrZXJJY29ufXxgO1xuICAgIH1cbiAgICBpZiAoaGFzSWNvbiAmJiBcIm1hcmtlckFuY2hvclwiIGluIG9wdGlvbnMpIHtcbiAgICAgIG1hcmtlclN0ciArPSBgYW5jaG9yOiR7b3B0aW9ucy5tYXJrZXJBbmNob3J9fGA7XG4gICAgfVxuICAgIGlmIChoYXNJY29uICYmIG9wdGlvbnMuaGlEUEkpIHtcbiAgICAgIG1hcmtlclN0ciArPSBgc2NhbGU6MnxgO1xuICAgIH1cbiAgICBjb25zdCBtYXJrZXJMaXN0ID0gQXJyYXkuaXNBcnJheShvcHRpb25zLm1hcmtlcnNbMF0pID8gb3B0aW9ucy5tYXJrZXJzIDogW29wdGlvbnMubWFya2Vyc107XG4gICAgbWFya2VyU3RyICs9IG1hcmtlckxpc3QubWFwKChtKSA9PiBzdGF0aWNNYXBNYXJrZXJUb1N0cmluZyhtLCAhaGFzSWNvbikpLmpvaW4oXCJ8XCIpO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJtYXJrZXJzXCIsIG1hcmtlclN0cik7XG4gIH1cbiAgaWYgKFwicGF0aFwiIGluIG9wdGlvbnMpIHtcbiAgICBsZXQgcGF0aFN0ciA9IFwiXCI7XG4gICAgcGF0aFN0ciArPSBgZmlsbDoke29wdGlvbnMucGF0aEZpbGxDb2xvciA/PyBcIm5vbmVcIn18YDtcbiAgICBpZiAoXCJwYXRoU3Ryb2tlQ29sb3JcIiBpbiBvcHRpb25zKSB7XG4gICAgICBwYXRoU3RyICs9IGBzdHJva2U6JHtvcHRpb25zLnBhdGhTdHJva2VDb2xvcn18YDtcbiAgICB9XG4gICAgaWYgKFwicGF0aFdpZHRoXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgcGF0aFdpZHRoID0gb3B0aW9ucy5wYXRoV2lkdGggLyAob3B0aW9ucy5oaURQSSA/IDIgOiAxKTtcbiAgICAgIHBhdGhTdHIgKz0gYHdpZHRoOiR7cGF0aFdpZHRoLnRvU3RyaW5nKCl9fGA7XG4gICAgfVxuICAgIHBhdGhTdHIgKz0gc2ltcGxpZnlBbmRTdHJpbmdpZnkob3B0aW9ucy5wYXRoKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwicGF0aFwiLCBwYXRoU3RyKTtcbiAgfVxuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICByZXR1cm4gZW5kcG9pbnQudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpYyhvcHRpb25zID0ge30pIHtcbiAgaWYgKCEoXCJtYXJrZXJzXCIgaW4gb3B0aW9ucykgJiYgIShcInBhdGhcIiBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQXV0b21hdGljIHN0YXRpYyBtYXBzIHJlcXVpcmUgbWFya2VycyBhbmQvb3IgcGF0aCB0byBiZSBjcmVhdGVkLlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHN0eWxlVG9TdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLmhpRFBJID8gXCJAMnhcIiA6IFwiXCI7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ID8/IFwicG5nXCI7XG4gIGxldCB3aWR0aCA9IH5+KG9wdGlvbnMud2lkdGggPz8gMTAyNCk7XG4gIGxldCBoZWlnaHQgPSB+fihvcHRpb25zLmhlaWdodCA/PyAxMDI0KTtcbiAgaWYgKG9wdGlvbnMuaGlEUEkpIHtcbiAgICB3aWR0aCA9IH5+KHdpZHRoIC8gMik7XG4gICAgaGVpZ2h0ID0gfn4oaGVpZ2h0IC8gMik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBtYXBzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgc3R5bGVcbiAgICApfS9zdGF0aWMvYXV0by8ke3dpZHRofXgke2hlaWdodH0ke3NjYWxlfS4ke2Zvcm1hdH1gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGlmIChcImF0dHJpYnV0aW9uXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJhdHRyaWJ1dGlvblwiLCBvcHRpb25zLmF0dHJpYnV0aW9uLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcInBhZGRpbmdcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInBhZGRpbmdcIiwgb3B0aW9ucy5wYWRkaW5nLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcIm1hcmtlcnNcIiBpbiBvcHRpb25zKSB7XG4gICAgbGV0IG1hcmtlclN0ciA9IFwiXCI7XG4gICAgY29uc3QgaGFzSWNvbiA9IFwibWFya2VySWNvblwiIGluIG9wdGlvbnM7XG4gICAgaWYgKGhhc0ljb24pIHtcbiAgICAgIG1hcmtlclN0ciArPSBgaWNvbjoke29wdGlvbnMubWFya2VySWNvbn18YDtcbiAgICB9XG4gICAgaWYgKGhhc0ljb24gJiYgXCJtYXJrZXJBbmNob3JcIiBpbiBvcHRpb25zKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYGFuY2hvcjoke29wdGlvbnMubWFya2VyQW5jaG9yfXxgO1xuICAgIH1cbiAgICBpZiAoaGFzSWNvbiAmJiBvcHRpb25zLmhpRFBJKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYHNjYWxlOjJ8YDtcbiAgICB9XG4gICAgY29uc3QgbWFya2VyTGlzdCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXJrZXJzWzBdKSA/IG9wdGlvbnMubWFya2VycyA6IFtvcHRpb25zLm1hcmtlcnNdO1xuICAgIG1hcmtlclN0ciArPSBtYXJrZXJMaXN0Lm1hcCgobSkgPT4gc3RhdGljTWFwTWFya2VyVG9TdHJpbmcobSwgIWhhc0ljb24pKS5qb2luKFwifFwiKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwibWFya2Vyc1wiLCBtYXJrZXJTdHIpO1xuICB9XG4gIGlmIChcInBhdGhcIiBpbiBvcHRpb25zKSB7XG4gICAgbGV0IHBhdGhTdHIgPSBcIlwiO1xuICAgIHBhdGhTdHIgKz0gYGZpbGw6JHtvcHRpb25zLnBhdGhGaWxsQ29sb3IgPz8gXCJub25lXCJ9fGA7XG4gICAgaWYgKFwicGF0aFN0cm9rZUNvbG9yXCIgaW4gb3B0aW9ucykge1xuICAgICAgcGF0aFN0ciArPSBgc3Ryb2tlOiR7b3B0aW9ucy5wYXRoU3Ryb2tlQ29sb3J9fGA7XG4gICAgfVxuICAgIGlmIChcInBhdGhXaWR0aFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBhdGhXaWR0aCA9IG9wdGlvbnMucGF0aFdpZHRoIC8gKG9wdGlvbnMuaGlEUEkgPyAyIDogMSk7XG4gICAgICBwYXRoU3RyICs9IGB3aWR0aDoke3BhdGhXaWR0aC50b1N0cmluZygpfXxgO1xuICAgIH1cbiAgICBwYXRoU3RyICs9IHNpbXBsaWZ5QW5kU3RyaW5naWZ5KG9wdGlvbnMucGF0aCk7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInBhdGhcIiwgcGF0aFN0cik7XG4gIH1cbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgcmV0dXJuIGVuZHBvaW50LnRvU3RyaW5nKCk7XG59XG5jb25zdCBzdGF0aWNNYXBzID0ge1xuICBjZW50ZXJlZCxcbiAgYm91bmRlZCxcbiAgYXV0b21hdGljXG59O1xuXG5jb25zdCBFQVJUSF9SQURJVVMgPSA2MzcxMDA4OGUtMTtcbmNvbnN0IEVBUlRIX0NJUkNVTUZFUkVOQ0UgPSAyICogTWF0aC5QSSAqIEVBUlRIX1JBRElVUztcbmZ1bmN0aW9uIGxvbmdpdHVkZVRvTWVyY2F0b3JYKGxuZykge1xuICByZXR1cm4gKDE4MCArIGxuZykgLyAzNjA7XG59XG5mdW5jdGlvbiBsYXRpdHVkZVRvTWVyY2F0b3JZKGxhdCkge1xuICByZXR1cm4gKDE4MCAtIDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGxhdCAqIE1hdGguUEkgLyAzNjApKSkgLyAzNjA7XG59XG5mdW5jdGlvbiB3Z3M4NFRvTWVyY2F0b3IocG9zaXRpb24pIHtcbiAgY29uc3Qgd3JhcHBlZFBvcyA9IHdyYXBXZ3M4NChwb3NpdGlvbik7XG4gIHJldHVybiBbXG4gICAgbG9uZ2l0dWRlVG9NZXJjYXRvclgod3JhcHBlZFBvc1swXSksXG4gICAgbGF0aXR1ZGVUb01lcmNhdG9yWSh3cmFwcGVkUG9zWzFdKVxuICBdO1xufVxuZnVuY3Rpb24gbWVyY2F0b3JYVG9Mb25naXR1ZGUoeCkge1xuICByZXR1cm4geCAqIDM2MCAtIDE4MDtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yWVRvTGF0aXR1ZGUoeSkge1xuICBjb25zdCB5MiA9IDE4MCAtIHkgKiAzNjA7XG4gIHJldHVybiAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTA7XG59XG5mdW5jdGlvbiBtZXJjYXRvclRvV2dzODQocG9zaXRpb24pIHtcbiAgcmV0dXJuIFttZXJjYXRvclhUb0xvbmdpdHVkZShwb3NpdGlvblswXSksIG1lcmNhdG9yWVRvTGF0aXR1ZGUocG9zaXRpb25bMV0pXTtcbn1cbmZ1bmN0aW9uIGhhdmVyc2luZURpc3RhbmNlV2dzODQoZnJvbSwgdG8pIHtcbiAgY29uc3QgcmFkID0gTWF0aC5QSSAvIDE4MDtcbiAgY29uc3QgbGF0MSA9IGZyb21bMV0gKiByYWQ7XG4gIGNvbnN0IGxhdDIgPSB0b1sxXSAqIHJhZDtcbiAgY29uc3QgYSA9IE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0MikgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MoKHRvWzBdIC0gZnJvbVswXSkgKiByYWQpO1xuICBjb25zdCBtYXhNZXRlcnMgPSBFQVJUSF9SQURJVVMgKiBNYXRoLmFjb3MoTWF0aC5taW4oYSwgMSkpO1xuICByZXR1cm4gbWF4TWV0ZXJzO1xufVxuZnVuY3Rpb24gaGF2ZXJzaW5lQ3VtdWxhdGVkRGlzdGFuY2VXZ3M4NChwb3NpdGlvbnMpIHtcbiAgY29uc3QgY3VtdWxhdGVkRGlzdGFuY2UgPSBBcnJheShwb3NpdGlvbnMubGVuZ3RoKTtcbiAgY3VtdWxhdGVkRGlzdGFuY2VbMF0gPSAwO1xuICBjb25zdCBsID0gY3VtdWxhdGVkRGlzdGFuY2UubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGw7IGkrKykge1xuICAgIGN1bXVsYXRlZERpc3RhbmNlW2ldID0gaGF2ZXJzaW5lRGlzdGFuY2VXZ3M4NChwb3NpdGlvbnNbaSAtIDFdLCBwb3NpdGlvbnNbaV0pICsgY3VtdWxhdGVkRGlzdGFuY2VbaSAtIDFdO1xuICB9XG4gIHJldHVybiBjdW11bGF0ZWREaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIHdyYXBXZ3M4NChwb3NpdGlvbikge1xuICBjb25zdCBsbmcgPSBwb3NpdGlvblswXTtcbiAgY29uc3QgbGF0ID0gcG9zaXRpb25bMV07XG4gIGNvbnN0IGQgPSAzNjA7XG4gIGNvbnN0IHcgPSAoKGxuZyArIDE4MCkgJSBkICsgZCkgJSBkIC0gMTgwO1xuICBjb25zdCB3cmFwTG9uZyA9IHcgPT09IC0xODAgPyAxODAgOiB3O1xuICByZXR1cm4gW3dyYXBMb25nLCBsYXRdO1xufVxuZnVuY3Rpb24gY2lyY3VtZmVyZW5jZUF0TGF0aXR1ZGUobGF0aXR1ZGUpIHtcbiAgcmV0dXJuIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBNYXRoLmNvcyhsYXRpdHVkZSAqIE1hdGguUEkgLyAxODApO1xufVxuZnVuY3Rpb24gbWVyY2F0b3JUb1RpbGVJbmRleChwb3NpdGlvbiwgem9vbSwgc3RyaWN0ID0gdHJ1ZSkge1xuICBjb25zdCBudW1iZXJPZlRpbGVQZXJBeGlzID0gMiAqKiB6b29tO1xuICBjb25zdCBmSW5kZXggPSBbXG4gICAgcG9zaXRpb25bMF0gKiBudW1iZXJPZlRpbGVQZXJBeGlzLFxuICAgIHBvc2l0aW9uWzFdICogbnVtYmVyT2ZUaWxlUGVyQXhpc1xuICBdO1xuICByZXR1cm4gc3RyaWN0ID8gW35+ZkluZGV4WzBdLCB+fmZJbmRleFsxXV0gOiBmSW5kZXg7XG59XG5mdW5jdGlvbiB3Z3M4NFRvVGlsZUluZGV4KHBvc2l0aW9uLCB6b29tLCBzdHJpY3QgPSB0cnVlKSB7XG4gIGNvbnN0IG1lcmMgPSB3Z3M4NFRvTWVyY2F0b3IocG9zaXRpb24pO1xuICByZXR1cm4gbWVyY2F0b3JUb1RpbGVJbmRleChtZXJjLCB6b29tLCBzdHJpY3QpO1xufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xufVxuZnVuY3Rpb24gaGF2ZXJzaW5lSW50ZXJtZWRpYXRlV2dzODQocG9zMSwgcG9zMiwgcmF0aW8pIHtcbiAgY29uc3QgZCA9IGhhdmVyc2luZURpc3RhbmNlV2dzODQocG9zMSwgcG9zMik7XG4gIGNvbnN0IFxcdTAzQkIxID0gdG9SYWRpYW5zKHBvczFbMF0pO1xuICBjb25zdCBcXHUwM0M2MSA9IHRvUmFkaWFucyhwb3MxWzFdKTtcbiAgY29uc3QgXFx1MDNCQjIgPSB0b1JhZGlhbnMocG9zMlswXSk7XG4gIGNvbnN0IFxcdTAzQzYyID0gdG9SYWRpYW5zKHBvczJbMV0pO1xuICBjb25zdCBcXHUwM0I0ID0gZCAvIEVBUlRIX1JBRElVUztcbiAgY29uc3QgYSA9IE1hdGguc2luKCgxIC0gcmF0aW8pICogXFx1MDNCNCkgLyBNYXRoLnNpbihcXHUwM0I0KTtcbiAgY29uc3QgYiA9IE1hdGguc2luKHJhdGlvICogXFx1MDNCNCkgLyBNYXRoLnNpbihcXHUwM0I0KTtcbiAgY29uc3QgeCA9IGEgKiBNYXRoLmNvcyhcXHUwM0M2MSkgKiBNYXRoLmNvcyhcXHUwM0JCMSkgKyBiICogTWF0aC5jb3MoXFx1MDNDNjIpICogTWF0aC5jb3MoXFx1MDNCQjIpO1xuICBjb25zdCB5ID0gYSAqIE1hdGguY29zKFxcdTAzQzYxKSAqIE1hdGguc2luKFxcdTAzQkIxKSArIGIgKiBNYXRoLmNvcyhcXHUwM0M2MikgKiBNYXRoLnNpbihcXHUwM0JCMik7XG4gIGNvbnN0IHogPSBhICogTWF0aC5zaW4oXFx1MDNDNjEpICsgYiAqIE1hdGguc2luKFxcdTAzQzYyKTtcbiAgY29uc3QgXFx1MDNDNjMgPSBNYXRoLmF0YW4yKHosIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSk7XG4gIGNvbnN0IFxcdTAzQkIzID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgcmV0dXJuIFt0b0RlZ3JlZXMoXFx1MDNCQjMpLCB0b0RlZ3JlZXMoXFx1MDNDNjMpXTtcbn1cbmNvbnN0IG1hdGggPSB7XG4gIEVBUlRIX1JBRElVUyxcbiAgRUFSVEhfQ0lSQ1VNRkVSRU5DRSxcbiAgbG9uZ2l0dWRlVG9NZXJjYXRvclgsXG4gIGxhdGl0dWRlVG9NZXJjYXRvclksXG4gIHdnczg0VG9NZXJjYXRvcixcbiAgbWVyY2F0b3JYVG9Mb25naXR1ZGUsXG4gIG1lcmNhdG9yWVRvTGF0aXR1ZGUsXG4gIG1lcmNhdG9yVG9XZ3M4NCxcbiAgaGF2ZXJzaW5lRGlzdGFuY2VXZ3M4NCxcbiAgd3JhcFdnczg0LFxuICBjaXJjdW1mZXJlbmNlQXRMYXRpdHVkZSxcbiAgbWVyY2F0b3JUb1RpbGVJbmRleCxcbiAgd2dzODRUb1RpbGVJbmRleCxcbiAgdG9SYWRpYW5zLFxuICB0b0RlZ3JlZXMsXG4gIGhhdmVyc2luZUludGVybWVkaWF0ZVdnczg0LFxuICBoYXZlcnNpbmVDdW11bGF0ZWREaXN0YW5jZVdnczg0XG59O1xuXG5sZXQgdGlsZUNhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIGdldFRpbGVDYWNoZSgpIHtcbiAgaWYgKCF0aWxlQ2FjaGUpIHtcbiAgICB0aWxlQ2FjaGUgPSBuZXcgUXVpY2tMUlUoeyBtYXhTaXplOiBjb25maWcudGlsZUNhY2hlU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gdGlsZUNhY2hlO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVmZmVyVG9QaXhlbERhdGFCcm93c2VyKGJ1ZmYpIHtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmXSk7XG4gIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGNhbnZhcy53aWR0aCA9IGltYWdlQml0bWFwLndpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VCaXRtYXAuaGVpZ2h0O1xuICBjdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcbiAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICByZXR1cm4ge1xuICAgIHBpeGVsczogaW1hZ2VEYXRhLmRhdGEsXG4gICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgY29tcG9uZW50czogaW1hZ2VEYXRhLmRhdGEubGVuZ3RoIC8gKGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRCdWZmZXJUb1BpeGVsRGF0YVBhcnNlcigpIHtcbiAgaWYgKGNvbmZpZy5idWZmZXJUb1BpeGVsRGF0YSkge1xuICAgIHJldHVybiBjb25maWcuYnVmZmVyVG9QaXhlbERhdGE7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gYnVmZmVyVG9QaXhlbERhdGFCcm93c2VyO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkFuIGltYWdlIGZpbGUgYnVmZmVyIHRvIHBpeGVsIGRhdGEgcGFyc2VyIGlzIG5lY2Vzc2FyeS4gU3BlY2lmeSBpdCBpbiBgY29uZmlnLmJ1ZmZlclRvUGl4ZWxEYXRhYFwiXG4gICk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZVBpeGVsRGF0YSgpIHtcbiAgcmV0dXJuICEhY29uZmlnLmJ1ZmZlclRvUGl4ZWxEYXRhIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmNvbnN0IFRFUlJBSU5fVElMRVNFVCA9IFwidGVycmFpbi1yZ2ItdjJcIjtcbmNvbnN0IEFQSV9CQVRDSF9TSVpFID0gNTA7XG5jb25zdCBBUElfV0FSTl9TSVpFID0gMWUzO1xubGV0IHRlcnJhaW5UaWxlSnNvbiA9IG51bGw7XG5jb25zdCBjdXN0b21NZXNzYWdlcyA9IHtcbiAgNDAzOiBcIktleSBpcyBtaXNzaW5nLCBpbnZhbGlkIG9yIHJlc3RyaWN0ZWRcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVPblNlcnZlcihwb3NpdGlvbnMsIGFwaUtleSkge1xuICBpZiAocG9zaXRpb25zLmxlbmd0aCA+IEFQSV9XQVJOX1NJWkUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkNvbXB1dGluZyBlbGV2YXRpb24gZm9yIGNvbXBsZXggZ2VvbWV0cmllcyBpcyBkaXNjb3VyYWdlZCAtIHNpbXBsaWZ5IHRoZSBnZW9tZXRyeSBiZWZvcmUgcHJvY2VlZGluZ1wiXG4gICAgKTtcbiAgfVxuICBjb25zdCBwYXJ0cyA9IE1hdGguY2VpbChwb3NpdGlvbnMubGVuZ3RoIC8gQVBJX0JBVENIX1NJWkUpO1xuICBjb25zdCByZXNwUHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBwYXJ0cyB9LCAoKSA9PiBudWxsKS5tYXAoXG4gICAgKF8sIHBhcnQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gcGFydCAqIEFQSV9CQVRDSF9TSVpFO1xuICAgICAgY29uc3QgYmF0Y2gyID0gcG9zaXRpb25zLnNsaWNlKHN0YXJ0UG9zLCBzdGFydFBvcyArIEFQSV9CQVRDSF9TSVpFKTtcbiAgICAgIGNvbnN0IGJhdGNoRW5jb2RlZCA9IGJhdGNoMi5tYXAoKHBvcykgPT4gcG9zLmpvaW4oXCIsXCIpKS5qb2luKFwiO1wiKTtcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICAgICAgYGVsZXZhdGlvbi8ke2JhdGNoRW5jb2RlZH0uanNvbmAsXG4gICAgICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICAgICApO1xuICAgICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBhcGlLZXkpO1xuICAgICAgcmV0dXJuIGNhbGxGZXRjaChlbmRwb2ludC50b1N0cmluZygpKTtcbiAgICB9XG4gICk7XG4gIGNvbnN0IHJlc3BzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlc3BQcm9taXNlcyk7XG4gIGNvbnN0IGpzb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgcmVzcHMubWFwKGFzeW5jIChyZXNwKSA9PiB7XG4gICAgICBpZiAocmVzcC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFNvbWUgc2VnbWVudHMgY291bGQgbm90IGJlIGZldGNoZWQsIGVycm9yOiAke3Jlc3AucmVhc29ufWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcC52YWx1ZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFNvbWUgc2VnbWVudHMgY291bGQgbm90IGJlIGZldGNoZWQsIHJlc3BvbnNlOiAke3Jlc3AudmFsdWUuc3RhdHVzfSAke2F3YWl0IHJlc3AudmFsdWUudGV4dCgpfSwgdXJsOiAke3Jlc3AudmFsdWUudXJsfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwLnZhbHVlLmpzb24oKTtcbiAgICB9KVxuICApO1xuICByZXR1cm4ganNvbnMuZmxhdCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gY29tcHV0ZU9uQ2xpZW50KHBvc2l0aW9ucywgYXBpS2V5LCB6b29tKSB7XG4gIGlmICghdGVycmFpblRpbGVKc29uKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgICAgYHRpbGVzLyR7VEVSUkFJTl9USUxFU0VUfS90aWxlcy5qc29uYCxcbiAgICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICAgKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIGFwaUtleSk7XG4gICAgY29uc3QgdXJsV2l0aFBhcmFtcyA9IGVuZHBvaW50LnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKHVybFdpdGhQYXJhbXMpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIHRlcnJhaW5UaWxlSnNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IocmVzLCBjdXN0b21NZXNzYWdlc1tyZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGlsZVBhcnNlciA9IGdldEJ1ZmZlclRvUGl4ZWxEYXRhUGFyc2VyKCk7XG4gIGNvbnN0IHRpbGVVUkxTY2hlbWEgPSB0ZXJyYWluVGlsZUpzb24udGlsZXNbMF07XG4gIGNvbnN0IGNhY2hlID0gZ2V0VGlsZUNhY2hlKCk7XG4gIGNvbnN0IG1heFpvb20gPSB0ZXJyYWluVGlsZUpzb24ubWF4em9vbTtcbiAgbGV0IHVzZWRab29tID0gfn4oem9vbSA/PyBtYXhab29tKTtcbiAgaWYgKHVzZWRab29tID4gbWF4Wm9vbSB8fCB1c2VkWm9vbSA8IDApIHtcbiAgICB1c2VkWm9vbSA9IG1heFpvb207XG4gIH1cbiAgY29uc3QgdGlsZUluZGljZXNGbG9hdHMgPSBwb3NpdGlvbnMubWFwKFxuICAgIChwb3NpdGlvbikgPT4gbWF0aC53Z3M4NFRvVGlsZUluZGV4KHBvc2l0aW9uLCB1c2VkWm9vbSwgZmFsc2UpXG4gICk7XG4gIGNvbnN0IHRpbGVJbmRpY2VzSW50ZWdlciA9IHRpbGVJbmRpY2VzRmxvYXRzLm1hcCgoaW5kZXgpID0+IFtcbiAgICB+fmluZGV4WzBdLFxuICAgIH5+aW5kZXhbMV1cbiAgXSk7XG4gIGNvbnN0IHRpbGVJRHMgPSB0aWxlSW5kaWNlc0ludGVnZXIubWFwKFxuICAgIChpbmRleCkgPT4gYHRlcnJhaW5fJHt1c2VkWm9vbS50b1N0cmluZygpfV8ke2luZGV4WzBdLnRvU3RyaW5nKCl9XyR7aW5kZXhbMV0udG9TdHJpbmcoKX1gXG4gICk7XG4gIGNvbnN0IHVuaXF1ZVRpbGVzVG9GZXRjaCA9IEFycmF5LmZyb20oXG4gICAgbmV3IFNldCh0aWxlSURzLmZpbHRlcigodGlsZUlEKSA9PiAhY2FjaGUuaGFzKHRpbGVJRCkpKVxuICApLm1hcCgodGlsZUlEKSA9PiB0aWxlSUQuc3BsaXQoXCJfXCIpLnNsaWNlKDEpKTtcbiAgY29uc3QgdGlsZVVSTHMgPSB1bmlxdWVUaWxlc1RvRmV0Y2gubWFwKFxuICAgICh6eHkpID0+IHRpbGVVUkxTY2hlbWEucmVwbGFjZShcInt4fVwiLCB6eHlbMV0udG9TdHJpbmcoKSkucmVwbGFjZShcInt5fVwiLCB6eHlbMl0udG9TdHJpbmcoKSkucmVwbGFjZShcInt6fVwiLCB6eHlbMF0udG9TdHJpbmcoKSlcbiAgKTtcbiAgY29uc3QgcHJvbWlzZXNGZXRjaFRpbGVzID0gdGlsZVVSTHMubWFwKCh1cmwpID0+IGNhbGxGZXRjaCh1cmwpKTtcbiAgY29uc3QgcmVzVGlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXNGZXRjaFRpbGVzKTtcbiAgY29uc3QgZnVsZmlsbGVkUmVzID0gcmVzVGlsZXMubWFwKFxuICAgIChlbCkgPT4gZWwuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiID8gZWwudmFsdWUgOiBudWxsXG4gICkuZmlsdGVyKChyZXMpID0+IHJlcyk7XG4gIGNvbnN0IGZ1bGZpbGxlZFJCdXROb3RPa1JlcyA9IGZ1bGZpbGxlZFJlcy5maWx0ZXIoKHJlcykgPT4gIXJlcy5vayk7XG4gIGlmIChmdWxmaWxsZWRSZXMubGVuZ3RoICE9PSBwcm9taXNlc0ZldGNoVGlsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZSB0aWxlcyBjb3VsZCBub3QgYmUgZmV0Y2hlZC5cIik7XG4gIH1cbiAgaWYgKGZ1bGZpbGxlZFJCdXROb3RPa1Jlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKFxuICAgICAgZnVsZmlsbGVkUkJ1dE5vdE9rUmVzWzBdLFxuICAgICAgY3VzdG9tTWVzc2FnZXNbZnVsZmlsbGVkUkJ1dE5vdE9rUmVzWzBdLnN0YXR1c10gPz8gXCJcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgdGlsZUFycmF5QnVmZmVycyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGZ1bGZpbGxlZFJlcy5tYXAoKHJlcykgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG4gICk7XG4gIGlmICghdGlsZUFycmF5QnVmZmVycy5ldmVyeSgoYnVmZikgPT4gYnVmZi5ieXRlTGVuZ3RoID4gMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb21lIHRpbGVzIGFyZSBub3QgYXZhaWxhYmxlLlwiKTtcbiAgfVxuICBjb25zdCB0aWxlUGl4ZWxEYXRhcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRpbGVBcnJheUJ1ZmZlcnMubWFwKChidWZmKSA9PiB0aWxlUGFyc2VyKGJ1ZmYpKVxuICApO1xuICB0aWxlUGl4ZWxEYXRhcy5mb3JFYWNoKCh0aWxlUGl4ZWxEYXRhLCBpKSA9PiB7XG4gICAgY29uc3Qgenh5ID0gdW5pcXVlVGlsZXNUb0ZldGNoW2ldO1xuICAgIGNvbnN0IHRpbGVJRCA9IGB0ZXJyYWluXyR7enh5WzBdLnRvU3RyaW5nKCl9XyR7enh5WzFdLnRvU3RyaW5nKCl9XyR7enh5WzJdLnRvU3RyaW5nKCl9YDtcbiAgICBjYWNoZS5zZXQodGlsZUlELCB0aWxlUGl4ZWxEYXRhKTtcbiAgfSk7XG4gIGNvbnN0IGVsZXZhdGVkUG9zaXRpb25zID0gcG9zaXRpb25zLm1hcCgocG9zaXRpb24sIGkpID0+IHtcbiAgICBjb25zdCB0aWxlSUQgPSB0aWxlSURzW2ldO1xuICAgIGNvbnN0IHRpbGVJbmRleEZsb2F0ID0gdGlsZUluZGljZXNGbG9hdHNbaV07XG4gICAgY29uc3QgdGlsZVBpeGVsRGF0YSA9IGNhY2hlLmdldCh0aWxlSUQpO1xuICAgIGNvbnN0IHBpeGVsWCA9IE1hdGgubWluKFxuICAgICAgTWF0aC5yb3VuZCh0aWxlUGl4ZWxEYXRhLndpZHRoICogKHRpbGVJbmRleEZsb2F0WzBdICUgMSkpLFxuICAgICAgdGlsZVBpeGVsRGF0YS53aWR0aCAtIDFcbiAgICApO1xuICAgIGNvbnN0IHBpeGVsWSA9IE1hdGgubWluKFxuICAgICAgTWF0aC5yb3VuZCh0aWxlUGl4ZWxEYXRhLmhlaWdodCAqICh0aWxlSW5kZXhGbG9hdFsxXSAlIDEpKSxcbiAgICAgIHRpbGVQaXhlbERhdGEuaGVpZ2h0IC0gMVxuICAgICk7XG4gICAgY29uc3QgcGl4ZWxEYXRhSW5kZXggPSAocGl4ZWxZICogdGlsZVBpeGVsRGF0YS53aWR0aCArIHBpeGVsWCkgKiB0aWxlUGl4ZWxEYXRhLmNvbXBvbmVudHM7XG4gICAgY29uc3QgUiA9IHRpbGVQaXhlbERhdGEucGl4ZWxzW3BpeGVsRGF0YUluZGV4XTtcbiAgICBjb25zdCBHID0gdGlsZVBpeGVsRGF0YS5waXhlbHNbcGl4ZWxEYXRhSW5kZXggKyAxXTtcbiAgICBjb25zdCBCID0gdGlsZVBpeGVsRGF0YS5waXhlbHNbcGl4ZWxEYXRhSW5kZXggKyAyXTtcbiAgICBjb25zdCBlbGV2YXRpb24yID0gLTFlNCArIChSICogMjU2ICogMjU2ICsgRyAqIDI1NiArIEIpICogMC4xO1xuICAgIHJldHVybiBbcG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCB+fihlbGV2YXRpb24yICogMWUzKSAvIDFlM107XG4gIH0pO1xuICByZXR1cm4gZWxldmF0ZWRQb3NpdGlvbnM7XG59XG5hc3luYyBmdW5jdGlvbiBhdChwb3NpdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGVsZXZhdGVkUG9zaXRpb25zID0gYXdhaXQgYmF0Y2goW3Bvc2l0aW9uXSwgb3B0aW9ucyk7XG4gIHJldHVybiBlbGV2YXRlZFBvc2l0aW9uc1swXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJhdGNoKHBvc2l0aW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIGNvbnN0IGFwaUtleSA9IG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXk7XG4gIGNvbnN0IGVsZXZhdGVkUG9zaXRpb25zID0gb3B0aW9ucy5jb21wdXRlT24gPT09IFwiY2xpZW50XCIgPyBhd2FpdCBjb21wdXRlT25DbGllbnQocG9zaXRpb25zLCBhcGlLZXksIG9wdGlvbnMuem9vbSkgOiBhd2FpdCBjb21wdXRlT25TZXJ2ZXIocG9zaXRpb25zLCBhcGlLZXkpO1xuICBpZiAob3B0aW9ucy5zbW9vdGhpbmdLZXJuZWxTaXplKSB7XG4gICAgY29uc3Qga2VybmVsU2l6ZSA9IH5+KG9wdGlvbnMuc21vb3RoaW5nS2VybmVsU2l6ZSAvIDIpICogMiArIDE7XG4gICAgY29uc3QgZWxldmF0aW9ucyA9IGVsZXZhdGVkUG9zaXRpb25zLm1hcCgocG9zKSA9PiBwb3NbMl0pO1xuICAgIGNvbnN0IGtlcm5lbFNwYW4gPSB+fihrZXJuZWxTaXplIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IGtlcm5lbFNwYW47IGkgPCBlbGV2YXRpb25zLmxlbmd0aCAtIGtlcm5lbFNwYW4gLSAxOyBpICs9IDEpIHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXJuZWxTaXplOyBqICs9IDEpIHtcbiAgICAgICAgY29uc3QgZWxldiA9IGVsZXZhdGlvbnNbaSAtIGtlcm5lbFNwYW4gKyBqXTtcbiAgICAgICAgc3VtICs9IGVsZXY7XG4gICAgICB9XG4gICAgICBzdW0gLz0ga2VybmVsU2l6ZTtcbiAgICAgIGVsZXZhdGVkUG9zaXRpb25zW2ldWzJdID0gc3VtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxldmF0ZWRQb3NpdGlvbnM7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tTGluZVN0cmluZyhscywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChscy50eXBlICE9PSBcIkxpbmVTdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgR2VvSlNPTiBMaW5lU3RyaW5nXCIpO1xuICB9XG4gIG9wdGlvbnMuY29tcHV0ZU9uID8/IChvcHRpb25zLmNvbXB1dGVPbiA9IGNhblBhcnNlUGl4ZWxEYXRhKCkgPyBcImNsaWVudFwiIDogXCJzZXJ2ZXJcIik7XG4gIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKGxzKTtcbiAgY29uc3QgZWxldmF0ZWRQb3NpdGlvbnMgPSBhd2FpdCBiYXRjaChjbG9uZS5jb29yZGluYXRlcywgb3B0aW9ucyk7XG4gIGNsb25lLmNvb3JkaW5hdGVzID0gZWxldmF0ZWRQb3NpdGlvbnM7XG4gIHJldHVybiBjbG9uZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZyb21NdWx0aUxpbmVTdHJpbmcobHMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAobHMudHlwZSAhPT0gXCJNdWx0aUxpbmVTdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgR2VvSlNPTiBNdWx0aUxpbmVTdHJpbmdcIik7XG4gIH1cbiAgb3B0aW9ucy5jb21wdXRlT24gPz8gKG9wdGlvbnMuY29tcHV0ZU9uID0gY2FuUGFyc2VQaXhlbERhdGEoKSA/IFwiY2xpZW50XCIgOiBcInNlcnZlclwiKTtcbiAgY29uc3QgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUobHMpO1xuICBjb25zdCBtdWx0aUxlbmd0aHMgPSBjbG9uZS5jb29yZGluYXRlcy5tYXAoKHBvc3MpID0+IHBvc3MubGVuZ3RoKTtcbiAgY29uc3QgZmxhdHRlblBvc2l0aW9ucyA9IGNsb25lLmNvb3JkaW5hdGVzLmZsYXQoKTtcbiAgY29uc3QgZmxhdHRlblBvc2l0aW9uc0VsZXZhdGVkID0gYXdhaXQgYmF0Y2goZmxhdHRlblBvc2l0aW9ucywgb3B0aW9ucyk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IGxlbmd0aCBvZiBtdWx0aUxlbmd0aHMpIHtcbiAgICByZXN1bHQucHVzaChmbGF0dGVuUG9zaXRpb25zRWxldmF0ZWQuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKSk7XG4gICAgaW5kZXggKz0gbGVuZ3RoO1xuICB9XG4gIGNsb25lLmNvb3JkaW5hdGVzID0gcmVzdWx0O1xuICByZXR1cm4gY2xvbmU7XG59XG5jb25zdCBlbGV2YXRpb24gPSB7XG4gIGF0LFxuICBiYXRjaCxcbiAgZnJvbUxpbmVTdHJpbmcsXG4gIGZyb21NdWx0aUxpbmVTdHJpbmdcbn07XG5cbmV4cG9ydCB7IENsaWVudENvbmZpZywgSVNPTGFuZ3VhZ2UsIExhbmd1YWdlLCBNYXBTdHlsZSwgTWFwU3R5bGVWYXJpYW50LCBOb25JU09MYW5ndWFnZSwgUmVmZXJlbmNlTWFwU3R5bGUsIFNlcnZpY2VFcnJvciwgYXJlU2FtZUxhbmd1YWdlcywgYnVmZmVyVG9QaXhlbERhdGFCcm93c2VyLCBjYW5QYXJzZVBpeGVsRGF0YSwgY2lyY3VtZmVyZW5jZUF0TGF0aXR1ZGUsIGNvbmZpZywgY29vcmRpbmF0ZXMsIGRhdGEsIGVsZXZhdGlvbiwgZXhwYW5kTWFwU3R5bGUsIGdlb2NvZGluZywgZ2VvbG9jYXRpb24sIGdldEF1dG9MYW5ndWFnZSwgZ2V0QnVmZmVyVG9QaXhlbERhdGFQYXJzZXIsIGdldExhbmd1YWdlSW5mb0Zyb21Db2RlLCBnZXRMYW5ndWFnZUluZm9Gcm9tRmxhZywgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUtleSwgZ2V0VGlsZUNhY2hlLCBpc0xhbmd1YWdlSW5mbywgbWFwU3R5bGVQcmVzZXRMaXN0LCBtYXRoLCBtaXNjLCBzdGF0aWNNYXBzLCBzdHlsZVRvU3R5bGUsIHRvTGFuZ3VhZ2VJbmZvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXB0aWxlci1jbGllbnQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@maptiler/leaflet-maptilersdk/dist/leaflet-maptilersdk.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@maptiler/leaflet-maptilersdk/dist/leaflet-maptilersdk.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Language: () => (/* reexport safe */ _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.Language),\n/* harmony export */   MapStyle: () => (/* reexport safe */ _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.MapStyle),\n/* harmony export */   MaptilerLayer: () => (/* binding */ d),\n/* harmony export */   maptilerLayer: () => (/* binding */ f)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"(ssr)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @maptiler/sdk */ \"(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs\");\n\n\n\nconst _ = \"@maptiler/leaflet-maptilersdk\", c = \"4.1.1\", d = leaflet__WEBPACK_IMPORTED_MODULE_0__.Layer.extend({\n  options: {\n    updateInterval: 32,\n    // How much to extend the overlay view (relative to map size)\n    // e.g. 0.1 would be 10% of map view in each direction\n    padding: 0.1,\n    // whether or not to register the mouse and keyboard\n    // events on the maptiler sdk overlay\n    interactive: !1,\n    // set the tilepane as the default pane to draw gl tiles\n    pane: \"tilePane\"\n  },\n  map: null,\n  initialize: function(t) {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.setOptions(this, t), this._throttledUpdate = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.throttle(this._update, this.options.updateInterval, this);\n  },\n  onAdd: function(t) {\n    var o;\n    this._container || this._initContainer();\n    const i = this.getPaneName();\n    (o = t.getPane(i)) == null || o.appendChild(this._container), this._initMaptilerSDK(), this._offset = this._map.containerPointToLayerPoint([0, 0]), t.options.zoomAnimation && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.on(\n      // @ts-ignore\n      t._proxy,\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.TRANSITION_END,\n      this._transitionEnd,\n      this\n    ), t.attributionControl.addAttribution(\n      '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> <a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>'\n    );\n  },\n  onRemove: function(t) {\n    var o;\n    this._map._proxy && this._map.options.zoomAnimation && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.off(this._map._proxy, leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.TRANSITION_END, this._transitionEnd, this);\n    const i = this.getPaneName();\n    (o = t.getPane(i)) == null || o.removeChild(this._container), this._maptilerMap.remove(), this._maptilerMap = null;\n  },\n  getEvents: function() {\n    return {\n      move: this._throttledUpdate,\n      // sensibly throttle updating while panning\n      zoomanim: this._animateZoom,\n      // applys the zoom animation to the <canvas>\n      zoom: this._pinchZoom,\n      // animate every zoom event for smoother pinch-zooming\n      zoomstart: this._zoomStart,\n      // flag starting a zoom to disable panning\n      zoomend: this._zoomEnd,\n      resize: this._resize\n    };\n  },\n  getMaptilerSDKMap: function() {\n    return this._maptilerMap;\n  },\n  getCanvas: function() {\n    return this._maptilerMap.getCanvas();\n  },\n  getSize: function() {\n    return this._map.getSize().multiplyBy(1 + this.options.padding * 2);\n  },\n  getBounds: function() {\n    const t = this.getSize().multiplyBy(0.5), i = this._map.latLngToContainerPoint(this._map.getCenter());\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(\n      this._map.containerPointToLatLng(i.subtract(t)),\n      this._map.containerPointToLatLng(i.add(t))\n    );\n  },\n  getContainer: function() {\n    return this._container;\n  },\n  // returns the pane name set in options if it is a valid pane, defaults to tilePane\n  getPaneName: function() {\n    return this._map.getPane(this.options.pane) ? this.options.pane : \"tilePane\";\n  },\n  setStyle: function(t) {\n    this._maptilerMap.setStyle(t);\n  },\n  setLanguage: function(t) {\n    this._maptilerMap.setLanguage(t);\n  },\n  _roundPoint: (t) => ({ x: Math.round(t.x), y: Math.round(t.y) }),\n  _initContainer: function() {\n    this._container = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create(\"div\", \"leaflet-gl-layer\");\n    const t = this.getSize(), i = this._map.getSize().multiplyBy(this.options.padding);\n    this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`;\n    const o = this._map.containerPointToLayerPoint([0, 0]).subtract(i);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setPosition(this._container, this._roundPoint(o));\n  },\n  _initMaptilerSDK: function() {\n    const t = this._map.getCenter(), i = this.options.maxBounds ? this.options.maxBounds : [\n      [Number.NEGATIVE_INFINITY, -90],\n      [Number.POSITIVE_INFINITY, 90]\n    ];\n    this._map.setMaxBounds(\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(i[0][1], i[0][0]), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(i[1][1], i[1][0]))\n    );\n    const o = {\n      maxBounds: i,\n      ...this.options,\n      projection: \"mercator\",\n      container: this._container,\n      center: [t.lng, t.lat],\n      zoom: this._map.getZoom() - 1,\n      attributionControl: !1\n    };\n    this.options.geolocate && (o.center = void 0, o.zoom = void 0), this._maptilerMap = new _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.Map(o), this._maptilerMap.telemetry.registerModule(_, c), this._maptilerMap.once(\"load\", () => {\n      this.fire(\"ready\");\n    }), this._maptilerMap.once(\"load\", async () => {\n      let a = { logo: null };\n      try {\n        const p = Object.keys(this._maptilerMap.style.sourceCaches).map((s) => this._maptilerMap.getSource(s)).filter((s) => s && \"url\" in s && typeof s.url == \"string\" && (s == null ? void 0 : s.url.includes(\"tiles.json\"))), n = new URL(p[0].url);\n        n.searchParams.has(\"key\") || n.searchParams.append(\"key\", o.apiKey), a = await (await fetch(n.href)).json();\n      } catch {\n      }\n      if (a.logo || o.maptilerLogo) {\n        const p = a.logo ?? \"https://api.maptiler.com/resources/logo.svg\", n = document.createElement(\"a\");\n        n.href = \"https://www.maptiler.com\", n.style.setProperty(\"position\", \"absolute\"), n.style.setProperty(\"left\", \"10px\"), n.style.setProperty(\"bottom\", \"2px\"), n.style.setProperty(\"z-index\", \"999\");\n        const l = document.createElement(\"img\");\n        l.src = p, l.alt = \"MapTiler logo\", l.width = 100, l.height = 30, n.appendChild(l), this._map.getContainer().appendChild(n);\n      }\n    }), this._maptilerMap.transform.freezeElevation = !0, this.options.geolocate && this._maptilerMap.on(\"load\", () => {\n      this._map.setView(this._maptilerMap.getCenter(), this._maptilerMap.getZoom() + 1);\n    }), this._transformGL(), this._maptilerMap._actualCanvas = this._maptilerMap._canvas;\n    const r = this._maptilerMap._actualCanvas;\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, \"leaflet-image-layer\"), leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, \"leaflet-zoom-animated\"), this.options.interactive && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, \"leaflet-interactive\"), this.options.className && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, this.options.className), this.addHeatmap = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addHeatmap(this._maptilerMap, a), this.addPolygon = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addPolygon(this._maptilerMap, a), this.addPoint = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addPoint(this._maptilerMap, a), this.addPolyline = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addPolyline(this._maptilerMap, a), this.takeScreenshot = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.takeScreenshot(this._maptilerMap, a);\n  },\n  _update: function() {\n    if (this._offset = this._map.containerPointToLayerPoint([0, 0]), this._zooming)\n      return;\n    const t = this.getSize(), i = this._map.getSize().multiplyBy(this.options.padding), o = this._map.containerPointToLayerPoint([0, 0]).subtract(i);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setPosition(this._container, this._roundPoint(o)), this._transformGL(), this._maptilerMap.transform.width !== t.x || this._maptilerMap.transform.height !== t.y ? (this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`, this._maptilerMap._resize !== null && this._maptilerMap._resize !== void 0 ? this._maptilerMap._resize() : this._maptilerMap.resize()) : this._maptilerMap._update !== null && this._maptilerMap._update !== void 0 ? this._maptilerMap._update() : this._maptilerMap.update();\n  },\n  _transformGL: function() {\n    this._maptilerMap.setCenter(this._map.getCenter()), this._maptilerMap.setZoom(this._map.getZoom() - 1);\n  },\n  // update the map constantly during a pinch zoom\n  _pinchZoom: function() {\n    this._maptilerMap.jumpTo({\n      zoom: this._map.getZoom() - 1,\n      center: this._map.getCenter()\n    });\n  },\n  // borrowed from L.ImageOverlay\n  // https://github.com/Leaflet/Leaflet/blob/master/src/layer/ImageOverlay.js#L139-L144\n  _animateZoom: function(t) {\n    const i = this._map.getZoomScale(t.zoom), o = this._map.getSize().multiplyBy(this.options.padding * i), r = this.getSize()._divideBy(2), a = this._map.project(t.center, t.zoom)._subtract(r)._add(this._map._getMapPanePos().add(o))._round(), p = this._map.project(this._map.getBounds().getNorthWest(), t.zoom)._subtract(a);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setTransform(this._maptilerMap.getCanvas(), p.subtract(this._offset), i);\n  },\n  _zoomStart: function() {\n    this._zooming = !0;\n  },\n  _zoomEnd: function() {\n    const t = this._map.getZoomScale(this._map.getZoom());\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setTransform(\n      this._maptilerMap.getCanvas(),\n      // https://github.com/mapbox/mapbox-gl-leaflet/pull/130\n      new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0),\n      t\n    ), this._zooming = !1, this._update();\n  },\n  _transitionEnd: function() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(() => {\n      const t = this._map.getZoom(), i = this._map.getCenter(), o = this._map.latLngToContainerPoint(this._map.getBounds().getNorthWest());\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setTransform(this._maptilerMap._actualCanvas, o, 1), this._maptilerMap.once(\n        \"moveend\",\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(() => {\n          this._zoomEnd();\n        }, this)\n      ), this._maptilerMap.jumpTo({\n        center: i,\n        zoom: t - 1\n      });\n    }, this);\n  },\n  // @ts-ignore\n  _resize: function(t) {\n    this._transitionEnd(t);\n  }\n});\nfunction f(t) {\n  return new d(t);\n}\n\n//# sourceMappingURL=leaflet-maptilersdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2xlYWZsZXQtbWFwdGlsZXJzZGsvZGlzdC9sZWFmbGV0LW1hcHRpbGVyc2RrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QjtBQUMrQjtBQUNNO0FBQzdELDREQUE0RCwwQ0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSwrQ0FBWSxtQ0FBbUMseUNBQU07QUFDekQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUxBQW1MLDZDQUFVO0FBQzdMO0FBQ0E7QUFDQSxNQUFNLDRDQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNGQUFzRjtBQUNsSztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkRBQTJELDZDQUFVLHVCQUF1Qiw0Q0FBUztBQUNyRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLGlEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBLHNCQUFzQiw0Q0FBUztBQUMvQjtBQUNBLHFDQUFxQyxJQUFJLHVDQUF1QyxJQUFJO0FBQ3BGO0FBQ0EsSUFBSSw0Q0FBUztBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlEQUFjLENBQUMsMkNBQVEsb0JBQW9CLDJDQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDhDQUFDO0FBQzdGO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLDRDQUFTLHFDQUFxQyw0Q0FBUyxtRUFBbUUsNENBQVMsK0RBQStELDRDQUFTLCtEQUErRCxrREFBQyw0REFBNEQsa0RBQUMsMERBQTBELGtEQUFDLDJEQUEyRCxrREFBQyxpRUFBaUUsa0RBQUM7QUFDcmdCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNENBQVMscU1BQXFNLElBQUksdUNBQXVDLElBQUk7QUFDalEsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUFTO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksNENBQVM7QUFDYjtBQUNBO0FBQ0EsVUFBVSwwQ0FBTztBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSx5Q0FBTTtBQUNWO0FBQ0EsTUFBTSw0Q0FBUztBQUNmO0FBQ0EsUUFBUSx5Q0FBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBwbGllci1kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2xlYWZsZXQtbWFwdGlsZXJzZGsvZGlzdC9sZWFmbGV0LW1hcHRpbGVyc2RrLmpzPzNjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGUgZnJvbSBcImxlYWZsZXRcIjtcbmltcG9ydCB7IE1hcCBhcyBoLCBoZWxwZXJzIGFzIG0gfSBmcm9tIFwiQG1hcHRpbGVyL3Nka1wiO1xuaW1wb3J0IHsgTGFuZ3VhZ2UgYXMgeiwgTWFwU3R5bGUgYXMgUCB9IGZyb20gXCJAbWFwdGlsZXIvc2RrXCI7XG5jb25zdCBfID0gXCJAbWFwdGlsZXIvbGVhZmxldC1tYXB0aWxlcnNka1wiLCBjID0gXCI0LjEuMVwiLCBkID0gZS5MYXllci5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgdXBkYXRlSW50ZXJ2YWw6IDMyLFxuICAgIC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgb3ZlcmxheSB2aWV3IChyZWxhdGl2ZSB0byBtYXAgc2l6ZSlcbiAgICAvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cbiAgICBwYWRkaW5nOiAwLjEsXG4gICAgLy8gd2hldGhlciBvciBub3QgdG8gcmVnaXN0ZXIgdGhlIG1vdXNlIGFuZCBrZXlib2FyZFxuICAgIC8vIGV2ZW50cyBvbiB0aGUgbWFwdGlsZXIgc2RrIG92ZXJsYXlcbiAgICBpbnRlcmFjdGl2ZTogITEsXG4gICAgLy8gc2V0IHRoZSB0aWxlcGFuZSBhcyB0aGUgZGVmYXVsdCBwYW5lIHRvIGRyYXcgZ2wgdGlsZXNcbiAgICBwYW5lOiBcInRpbGVQYW5lXCJcbiAgfSxcbiAgbWFwOiBudWxsLFxuICBpbml0aWFsaXplOiBmdW5jdGlvbih0KSB7XG4gICAgZS5zZXRPcHRpb25zKHRoaXMsIHQpLCB0aGlzLl90aHJvdHRsZWRVcGRhdGUgPSBlLlV0aWwudGhyb3R0bGUodGhpcy5fdXBkYXRlLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuICB9LFxuICBvbkFkZDogZnVuY3Rpb24odCkge1xuICAgIHZhciBvO1xuICAgIHRoaXMuX2NvbnRhaW5lciB8fCB0aGlzLl9pbml0Q29udGFpbmVyKCk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0UGFuZU5hbWUoKTtcbiAgICAobyA9IHQuZ2V0UGFuZShpKSkgPT0gbnVsbCB8fCBvLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX2luaXRNYXB0aWxlclNESygpLCB0aGlzLl9vZmZzZXQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoWzAsIDBdKSwgdC5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgZS5Eb21FdmVudC5vbihcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHQuX3Byb3h5LFxuICAgICAgZS5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELFxuICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZCxcbiAgICAgIHRoaXNcbiAgICApLCB0LmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbihcbiAgICAgICc8YSBocmVmPVwiaHR0cHM6Ly93d3cubWFwdGlsZXIuY29tL2NvcHlyaWdodC9cIiB0YXJnZXQ9XCJfYmxhbmtcIj4mY29weTsgTWFwVGlsZXI8L2E+IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIiB0YXJnZXQ9XCJfYmxhbmtcIj4mY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnM8L2E+J1xuICAgICk7XG4gIH0sXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIG87XG4gICAgdGhpcy5fbWFwLl9wcm94eSAmJiB0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIGUuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fcHJveHksIGUuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fdHJhbnNpdGlvbkVuZCwgdGhpcyk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0UGFuZU5hbWUoKTtcbiAgICAobyA9IHQuZ2V0UGFuZShpKSkgPT0gbnVsbCB8fCBvLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX21hcHRpbGVyTWFwLnJlbW92ZSgpLCB0aGlzLl9tYXB0aWxlck1hcCA9IG51bGw7XG4gIH0sXG4gIGdldEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdmU6IHRoaXMuX3Rocm90dGxlZFVwZGF0ZSxcbiAgICAgIC8vIHNlbnNpYmx5IHRocm90dGxlIHVwZGF0aW5nIHdoaWxlIHBhbm5pbmdcbiAgICAgIHpvb21hbmltOiB0aGlzLl9hbmltYXRlWm9vbSxcbiAgICAgIC8vIGFwcGx5cyB0aGUgem9vbSBhbmltYXRpb24gdG8gdGhlIDxjYW52YXM+XG4gICAgICB6b29tOiB0aGlzLl9waW5jaFpvb20sXG4gICAgICAvLyBhbmltYXRlIGV2ZXJ5IHpvb20gZXZlbnQgZm9yIHNtb290aGVyIHBpbmNoLXpvb21pbmdcbiAgICAgIHpvb21zdGFydDogdGhpcy5fem9vbVN0YXJ0LFxuICAgICAgLy8gZmxhZyBzdGFydGluZyBhIHpvb20gdG8gZGlzYWJsZSBwYW5uaW5nXG4gICAgICB6b29tZW5kOiB0aGlzLl96b29tRW5kLFxuICAgICAgcmVzaXplOiB0aGlzLl9yZXNpemVcbiAgICB9O1xuICB9LFxuICBnZXRNYXB0aWxlclNES01hcDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcHRpbGVyTWFwO1xuICB9LFxuICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXB0aWxlck1hcC5nZXRDYW52YXMoKTtcbiAgfSxcbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgxICsgdGhpcy5vcHRpb25zLnBhZGRpbmcgKiAyKTtcbiAgfSxcbiAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUpLCBpID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5fbWFwLmdldENlbnRlcigpKTtcbiAgICByZXR1cm4gZS5sYXRMbmdCb3VuZHMoXG4gICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhpLnN1YnRyYWN0KHQpKSxcbiAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKGkuYWRkKHQpKVxuICAgICk7XG4gIH0sXG4gIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgfSxcbiAgLy8gcmV0dXJucyB0aGUgcGFuZSBuYW1lIHNldCBpbiBvcHRpb25zIGlmIGl0IGlzIGEgdmFsaWQgcGFuZSwgZGVmYXVsdHMgdG8gdGlsZVBhbmVcbiAgZ2V0UGFuZU5hbWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZSh0aGlzLm9wdGlvbnMucGFuZSkgPyB0aGlzLm9wdGlvbnMucGFuZSA6IFwidGlsZVBhbmVcIjtcbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLl9tYXB0aWxlck1hcC5zZXRTdHlsZSh0KTtcbiAgfSxcbiAgc2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLl9tYXB0aWxlck1hcC5zZXRMYW5ndWFnZSh0KTtcbiAgfSxcbiAgX3JvdW5kUG9pbnQ6ICh0KSA9PiAoeyB4OiBNYXRoLnJvdW5kKHQueCksIHk6IE1hdGgucm91bmQodC55KSB9KSxcbiAgX2luaXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGUuRG9tVXRpbC5jcmVhdGUoXCJkaXZcIiwgXCJsZWFmbGV0LWdsLWxheWVyXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFNpemUoKSwgaSA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSh0aGlzLm9wdGlvbnMucGFkZGluZyk7XG4gICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7dC54fXB4YCwgdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke3QueX1weGA7XG4gICAgY29uc3QgbyA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChbMCwgMF0pLnN1YnRyYWN0KGkpO1xuICAgIGUuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRoaXMuX3JvdW5kUG9pbnQobykpO1xuICB9LFxuICBfaW5pdE1hcHRpbGVyU0RLOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbWFwLmdldENlbnRlcigpLCBpID0gdGhpcy5vcHRpb25zLm1heEJvdW5kcyA/IHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgOiBbXG4gICAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCAtOTBdLFxuICAgICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgOTBdXG4gICAgXTtcbiAgICB0aGlzLl9tYXAuc2V0TWF4Qm91bmRzKFxuICAgICAgZS5sYXRMbmdCb3VuZHMoZS5sYXRMbmcoaVswXVsxXSwgaVswXVswXSksIGUubGF0TG5nKGlbMV1bMV0sIGlbMV1bMF0pKVxuICAgICk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIG1heEJvdW5kczogaSxcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIHByb2plY3Rpb246IFwibWVyY2F0b3JcIixcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgY2VudGVyOiBbdC5sbmcsIHQubGF0XSxcbiAgICAgIHpvb206IHRoaXMuX21hcC5nZXRab29tKCkgLSAxLFxuICAgICAgYXR0cmlidXRpb25Db250cm9sOiAhMVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLmdlb2xvY2F0ZSAmJiAoby5jZW50ZXIgPSB2b2lkIDAsIG8uem9vbSA9IHZvaWQgMCksIHRoaXMuX21hcHRpbGVyTWFwID0gbmV3IGgobyksIHRoaXMuX21hcHRpbGVyTWFwLnRlbGVtZXRyeS5yZWdpc3Rlck1vZHVsZShfLCBjKSwgdGhpcy5fbWFwdGlsZXJNYXAub25jZShcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5maXJlKFwicmVhZHlcIik7XG4gICAgfSksIHRoaXMuX21hcHRpbGVyTWFwLm9uY2UoXCJsb2FkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhID0geyBsb2dvOiBudWxsIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwID0gT2JqZWN0LmtleXModGhpcy5fbWFwdGlsZXJNYXAuc3R5bGUuc291cmNlQ2FjaGVzKS5tYXAoKHMpID0+IHRoaXMuX21hcHRpbGVyTWFwLmdldFNvdXJjZShzKSkuZmlsdGVyKChzKSA9PiBzICYmIFwidXJsXCIgaW4gcyAmJiB0eXBlb2Ygcy51cmwgPT0gXCJzdHJpbmdcIiAmJiAocyA9PSBudWxsID8gdm9pZCAwIDogcy51cmwuaW5jbHVkZXMoXCJ0aWxlcy5qc29uXCIpKSksIG4gPSBuZXcgVVJMKHBbMF0udXJsKTtcbiAgICAgICAgbi5zZWFyY2hQYXJhbXMuaGFzKFwia2V5XCIpIHx8IG4uc2VhcmNoUGFyYW1zLmFwcGVuZChcImtleVwiLCBvLmFwaUtleSksIGEgPSBhd2FpdCAoYXdhaXQgZmV0Y2gobi5ocmVmKSkuanNvbigpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpZiAoYS5sb2dvIHx8IG8ubWFwdGlsZXJMb2dvKSB7XG4gICAgICAgIGNvbnN0IHAgPSBhLmxvZ28gPz8gXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vcmVzb3VyY2VzL2xvZ28uc3ZnXCIsIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbi5ocmVmID0gXCJodHRwczovL3d3dy5tYXB0aWxlci5jb21cIiwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIiksIG4uc3R5bGUuc2V0UHJvcGVydHkoXCJsZWZ0XCIsIFwiMTBweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcImJvdHRvbVwiLCBcIjJweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcInotaW5kZXhcIiwgXCI5OTlcIik7XG4gICAgICAgIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBsLnNyYyA9IHAsIGwuYWx0ID0gXCJNYXBUaWxlciBsb2dvXCIsIGwud2lkdGggPSAxMDAsIGwuaGVpZ2h0ID0gMzAsIG4uYXBwZW5kQ2hpbGQobCksIHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChuKTtcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5fbWFwdGlsZXJNYXAudHJhbnNmb3JtLmZyZWV6ZUVsZXZhdGlvbiA9ICEwLCB0aGlzLm9wdGlvbnMuZ2VvbG9jYXRlICYmIHRoaXMuX21hcHRpbGVyTWFwLm9uKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXAuc2V0Vmlldyh0aGlzLl9tYXB0aWxlck1hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwdGlsZXJNYXAuZ2V0Wm9vbSgpICsgMSk7XG4gICAgfSksIHRoaXMuX3RyYW5zZm9ybUdMKCksIHRoaXMuX21hcHRpbGVyTWFwLl9hY3R1YWxDYW52YXMgPSB0aGlzLl9tYXB0aWxlck1hcC5fY2FudmFzO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9tYXB0aWxlck1hcC5fYWN0dWFsQ2FudmFzO1xuICAgIGUuRG9tVXRpbC5hZGRDbGFzcyhyLCBcImxlYWZsZXQtaW1hZ2UtbGF5ZXJcIiksIGUuRG9tVXRpbC5hZGRDbGFzcyhyLCBcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSwgdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICYmIGUuRG9tVXRpbC5hZGRDbGFzcyhyLCBcImxlYWZsZXQtaW50ZXJhY3RpdmVcIiksIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgJiYgZS5Eb21VdGlsLmFkZENsYXNzKHIsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpLCB0aGlzLmFkZEhlYXRtYXAgPSAoYSkgPT4gbS5hZGRIZWF0bWFwKHRoaXMuX21hcHRpbGVyTWFwLCBhKSwgdGhpcy5hZGRQb2x5Z29uID0gKGEpID0+IG0uYWRkUG9seWdvbih0aGlzLl9tYXB0aWxlck1hcCwgYSksIHRoaXMuYWRkUG9pbnQgPSAoYSkgPT4gbS5hZGRQb2ludCh0aGlzLl9tYXB0aWxlck1hcCwgYSksIHRoaXMuYWRkUG9seWxpbmUgPSAoYSkgPT4gbS5hZGRQb2x5bGluZSh0aGlzLl9tYXB0aWxlck1hcCwgYSksIHRoaXMudGFrZVNjcmVlbnNob3QgPSAoYSkgPT4gbS50YWtlU2NyZWVuc2hvdCh0aGlzLl9tYXB0aWxlck1hcCwgYSk7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9vZmZzZXQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoWzAsIDBdKSwgdGhpcy5fem9vbWluZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRTaXplKCksIGkgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkodGhpcy5vcHRpb25zLnBhZGRpbmcpLCBvID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KFswLCAwXSkuc3VidHJhY3QoaSk7XG4gICAgZS5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fcm91bmRQb2ludChvKSksIHRoaXMuX3RyYW5zZm9ybUdMKCksIHRoaXMuX21hcHRpbGVyTWFwLnRyYW5zZm9ybS53aWR0aCAhPT0gdC54IHx8IHRoaXMuX21hcHRpbGVyTWFwLnRyYW5zZm9ybS5oZWlnaHQgIT09IHQueSA/ICh0aGlzLl9jb250YWluZXIuc3R5bGUud2lkdGggPSBgJHt0Lnh9cHhgLCB0aGlzLl9jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7dC55fXB4YCwgdGhpcy5fbWFwdGlsZXJNYXAuX3Jlc2l6ZSAhPT0gbnVsbCAmJiB0aGlzLl9tYXB0aWxlck1hcC5fcmVzaXplICE9PSB2b2lkIDAgPyB0aGlzLl9tYXB0aWxlck1hcC5fcmVzaXplKCkgOiB0aGlzLl9tYXB0aWxlck1hcC5yZXNpemUoKSkgOiB0aGlzLl9tYXB0aWxlck1hcC5fdXBkYXRlICE9PSBudWxsICYmIHRoaXMuX21hcHRpbGVyTWFwLl91cGRhdGUgIT09IHZvaWQgMCA/IHRoaXMuX21hcHRpbGVyTWFwLl91cGRhdGUoKSA6IHRoaXMuX21hcHRpbGVyTWFwLnVwZGF0ZSgpO1xuICB9LFxuICBfdHJhbnNmb3JtR0w6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcHRpbGVyTWFwLnNldENlbnRlcih0aGlzLl9tYXAuZ2V0Q2VudGVyKCkpLCB0aGlzLl9tYXB0aWxlck1hcC5zZXRab29tKHRoaXMuX21hcC5nZXRab29tKCkgLSAxKTtcbiAgfSxcbiAgLy8gdXBkYXRlIHRoZSBtYXAgY29uc3RhbnRseSBkdXJpbmcgYSBwaW5jaCB6b29tXG4gIF9waW5jaFpvb206IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcHRpbGVyTWFwLmp1bXBUbyh7XG4gICAgICB6b29tOiB0aGlzLl9tYXAuZ2V0Wm9vbSgpIC0gMSxcbiAgICAgIGNlbnRlcjogdGhpcy5fbWFwLmdldENlbnRlcigpXG4gICAgfSk7XG4gIH0sXG4gIC8vIGJvcnJvd2VkIGZyb20gTC5JbWFnZU92ZXJsYXlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9ibG9iL21hc3Rlci9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzI0wxMzktTDE0NFxuICBfYW5pbWF0ZVpvb206IGZ1bmN0aW9uKHQpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh0Lnpvb20pLCBvID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KHRoaXMub3B0aW9ucy5wYWRkaW5nICogaSksIHIgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMiksIGEgPSB0aGlzLl9tYXAucHJvamVjdCh0LmNlbnRlciwgdC56b29tKS5fc3VidHJhY3QocikuX2FkZCh0aGlzLl9tYXAuX2dldE1hcFBhbmVQb3MoKS5hZGQobykpLl9yb3VuZCgpLCBwID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fbWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLCB0Lnpvb20pLl9zdWJ0cmFjdChhKTtcbiAgICBlLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX21hcHRpbGVyTWFwLmdldENhbnZhcygpLCBwLnN1YnRyYWN0KHRoaXMuX29mZnNldCksIGkpO1xuICB9LFxuICBfem9vbVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl96b29taW5nID0gITA7XG4gIH0sXG4gIF96b29tRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICBlLkRvbVV0aWwuc2V0VHJhbnNmb3JtKFxuICAgICAgdGhpcy5fbWFwdGlsZXJNYXAuZ2V0Q2FudmFzKCksXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1sZWFmbGV0L3B1bGwvMTMwXG4gICAgICBuZXcgZS5Qb2ludCgwLCAwKSxcbiAgICAgIHRcbiAgICApLCB0aGlzLl96b29taW5nID0gITEsIHRoaXMuX3VwZGF0ZSgpO1xuICB9LFxuICBfdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgZS5VdGlsLnJlcXVlc3RBbmltRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX21hcC5nZXRab29tKCksIGkgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIG8gPSB0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuZ2V0Tm9ydGhXZXN0KCkpO1xuICAgICAgZS5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9tYXB0aWxlck1hcC5fYWN0dWFsQ2FudmFzLCBvLCAxKSwgdGhpcy5fbWFwdGlsZXJNYXAub25jZShcbiAgICAgICAgXCJtb3ZlZW5kXCIsXG4gICAgICAgIGUuVXRpbC5iaW5kKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl96b29tRW5kKCk7XG4gICAgICAgIH0sIHRoaXMpXG4gICAgICApLCB0aGlzLl9tYXB0aWxlck1hcC5qdW1wVG8oe1xuICAgICAgICBjZW50ZXI6IGksXG4gICAgICAgIHpvb206IHQgLSAxXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBfcmVzaXplOiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5fdHJhbnNpdGlvbkVuZCh0KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBmKHQpIHtcbiAgcmV0dXJuIG5ldyBkKHQpO1xufVxuZXhwb3J0IHtcbiAgeiBhcyBMYW5ndWFnZSxcbiAgUCBhcyBNYXBTdHlsZSxcbiAgZCBhcyBNYXB0aWxlckxheWVyLFxuICBmIGFzIG1hcHRpbGVyTGF5ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0LW1hcHRpbGVyc2RrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/leaflet-maptilersdk/dist/leaflet-maptilersdk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AJAXError: () => (/* binding */ rf),\n/* harmony export */   AttributionControl: () => (/* binding */ fp),\n/* harmony export */   AttributionControlMLGL: () => (/* binding */ Np),\n/* harmony export */   BoxZoomHandler: () => (/* binding */ hp),\n/* harmony export */   BoxZoomHandlerMLGL: () => (/* binding */ qp),\n/* harmony export */   CanvasSource: () => (/* binding */ op),\n/* harmony export */   CanvasSourceMLGL: () => (/* binding */ _p),\n/* harmony export */   ColorRamp: () => (/* binding */ T),\n/* harmony export */   ColorRampCollection: () => (/* binding */ gi),\n/* harmony export */   CooperativeGesturesHandler: () => (/* binding */ yp),\n/* harmony export */   CooperativeGesturesHandlerMLGL: () => (/* binding */ Gp),\n/* harmony export */   CubemapFaceNames: () => (/* binding */ Be),\n/* harmony export */   CubemapImagesPresets: () => (/* binding */ Zu),\n/* harmony export */   CubemapLayer: () => (/* binding */ Br),\n/* harmony export */   DOMcreate: () => (/* binding */ Te),\n/* harmony export */   DOMremove: () => (/* binding */ Et),\n/* harmony export */   DoubleClickZoomHandler: () => (/* binding */ pf),\n/* harmony export */   DragPanHandler: () => (/* binding */ uf),\n/* harmony export */   DragRotateHandler: () => (/* binding */ lf),\n/* harmony export */   EdgeInsets: () => (/* binding */ sf),\n/* harmony export */   Evented: () => (/* binding */ tf),\n/* harmony export */   FullscreenControl: () => (/* binding */ Oi),\n/* harmony export */   FullscreenControlMLGL: () => (/* binding */ Up),\n/* harmony export */   GeoJSONSource: () => (/* binding */ ip),\n/* harmony export */   GeoJSONSourceMLGL: () => (/* binding */ Ip),\n/* harmony export */   GeolocateControl: () => (/* binding */ Pi),\n/* harmony export */   GeolocateControlMLGL: () => (/* binding */ Fp),\n/* harmony export */   GeolocationType: () => (/* binding */ sc),\n/* harmony export */   Hash: () => (/* binding */ of),\n/* harmony export */   ImageSource: () => (/* binding */ sp),\n/* harmony export */   ImageSourceMLGL: () => (/* binding */ Mp),\n/* harmony export */   ImageViewer: () => (/* binding */ Lc),\n/* harmony export */   ImageViewerEvent: () => (/* binding */ re),\n/* harmony export */   ImageViewerMarker: () => (/* binding */ kp),\n/* harmony export */   ImageViewerMarkerEvent: () => (/* binding */ Ic),\n/* harmony export */   KeyboardHandler: () => (/* binding */ gp),\n/* harmony export */   KeyboardHandlerMLGL: () => (/* binding */ Hp),\n/* harmony export */   Language: () => (/* binding */ z),\n/* harmony export */   LngLat: () => (/* binding */ vi),\n/* harmony export */   LngLatBounds: () => (/* binding */ Xc),\n/* harmony export */   LogoControl: () => (/* binding */ Ri),\n/* harmony export */   LogoControlMLGL: () => (/* binding */ jp),\n/* harmony export */   Map: () => (/* binding */ Go),\n/* harmony export */   MapMLGL: () => (/* binding */ Ep),\n/* harmony export */   MapMouseEvent: () => (/* binding */ Sp),\n/* harmony export */   MapMouseEventMLGL: () => (/* binding */ Yp),\n/* harmony export */   MapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle),\n/* harmony export */   MapStyleVariant: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyleVariant),\n/* harmony export */   MapTouchEvent: () => (/* binding */ wp),\n/* harmony export */   MapTouchEventMLGL: () => (/* binding */ Xp),\n/* harmony export */   MapWheelEvent: () => (/* binding */ bp),\n/* harmony export */   MapWheelEventMLGL: () => (/* binding */ Kp),\n/* harmony export */   MaptilerCustomControl: () => (/* binding */ bu),\n/* harmony export */   MaptilerExternalControl: () => (/* binding */ tn),\n/* harmony export */   MaptilerGeolocateControl: () => (/* binding */ vu),\n/* harmony export */   MaptilerLogoControl: () => (/* binding */ Wn),\n/* harmony export */   MaptilerNavigationControl: () => (/* binding */ yu),\n/* harmony export */   MaptilerProjectionControl: () => (/* binding */ wu),\n/* harmony export */   MaptilerTerrainControl: () => (/* binding */ mu),\n/* harmony export */   Marker: () => (/* binding */ Mi),\n/* harmony export */   MarkerMLGL: () => (/* binding */ Cp),\n/* harmony export */   MercatorCoordinate: () => (/* binding */ fn),\n/* harmony export */   NavigationControMLGL: () => (/* binding */ $p),\n/* harmony export */   NavigationControl: () => (/* binding */ Wa),\n/* harmony export */   Point: () => (/* binding */ bi),\n/* harmony export */   Popup: () => (/* binding */ np),\n/* harmony export */   PopupMLGL: () => (/* binding */ Ap),\n/* harmony export */   RadialGradientLayer: () => (/* binding */ qr),\n/* harmony export */   RasterDEMTileSource: () => (/* binding */ up),\n/* harmony export */   RasterDEMTileSourceMLGL: () => (/* binding */ Rp),\n/* harmony export */   RasterTileSource: () => (/* binding */ lp),\n/* harmony export */   RasterTileSourceMLGL: () => (/* binding */ Pp),\n/* harmony export */   ReferenceMapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.ReferenceMapStyle),\n/* harmony export */   ScaleControl: () => (/* binding */ zi),\n/* harmony export */   ScaleControlMLGL: () => (/* binding */ Dp),\n/* harmony export */   ScrollZoomHandler: () => (/* binding */ mp),\n/* harmony export */   ScrollZoomHandlerMLGL: () => (/* binding */ Vp),\n/* harmony export */   SdkConfig: () => (/* binding */ $i),\n/* harmony export */   ServiceError: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.ServiceError),\n/* harmony export */   Style: () => (/* binding */ ap),\n/* harmony export */   StyleMLGL: () => (/* binding */ Tp),\n/* harmony export */   TerrainControMLGL: () => (/* binding */ Bp),\n/* harmony export */   TerrainControl: () => (/* binding */ dp),\n/* harmony export */   TwoFingersTouchPitchHandler: () => (/* binding */ vp),\n/* harmony export */   TwoFingersTouchPitchHandlerMLGL: () => (/* binding */ Zp),\n/* harmony export */   TwoFingersTouchRotateHandler: () => (/* binding */ df),\n/* harmony export */   TwoFingersTouchZoomHandler: () => (/* binding */ ff),\n/* harmony export */   TwoFingersTouchZoomRotateHandler: () => (/* binding */ cf),\n/* harmony export */   VectorTileSource: () => (/* binding */ cp),\n/* harmony export */   VectorTileSourceMLGL: () => (/* binding */ zp),\n/* harmony export */   VideoSource: () => (/* binding */ pp),\n/* harmony export */   VideoSourceMLGL: () => (/* binding */ Op),\n/* harmony export */   addProtocol: () => (/* binding */ xf),\n/* harmony export */   addSourceType: () => (/* binding */ wf),\n/* harmony export */   areSameLanguages: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.areSameLanguages),\n/* harmony export */   bufferToPixelDataBrowser: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.bufferToPixelDataBrowser),\n/* harmony export */   canParsePixelData: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.canParsePixelData),\n/* harmony export */   circumferenceAtLatitude: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.circumferenceAtLatitude),\n/* harmony export */   clearPrewarmedResources: () => (/* binding */ af),\n/* harmony export */   config: () => (/* binding */ j),\n/* harmony export */   configMLGL: () => (/* binding */ Wp),\n/* harmony export */   coordinates: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.coordinates),\n/* harmony export */   cubemapPresets: () => (/* binding */ Ke),\n/* harmony export */   data: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.data),\n/* harmony export */   displayWebGLContextLostWarning: () => (/* binding */ xp),\n/* harmony export */   elevation: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.elevation),\n/* harmony export */   expandMapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.expandMapStyle),\n/* harmony export */   geocoding: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geocoding),\n/* harmony export */   geolocation: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geolocation),\n/* harmony export */   getAutoLanguage: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getAutoLanguage),\n/* harmony export */   getBrowserLanguage: () => (/* binding */ Yn),\n/* harmony export */   getBufferToPixelDataParser: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getBufferToPixelDataParser),\n/* harmony export */   getLanguageInfoFromCode: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getLanguageInfoFromCode),\n/* harmony export */   getLanguageInfoFromFlag: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getLanguageInfoFromFlag),\n/* harmony export */   getLanguageInfoFromKey: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getLanguageInfoFromKey),\n/* harmony export */   getMapLibreVersion: () => (/* binding */ Jp),\n/* harmony export */   getMaxParallelImageRequests: () => (/* binding */ yf),\n/* harmony export */   getRTLTextPluginStatus: () => (/* binding */ ef),\n/* harmony export */   getTileCache: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getTileCache),\n/* harmony export */   getVersion: () => (/* binding */ Kc),\n/* harmony export */   getWebGLSupportError: () => (/* binding */ Gi),\n/* harmony export */   getWorkerCount: () => (/* binding */ hf),\n/* harmony export */   getWorkerUrl: () => (/* binding */ vf),\n/* harmony export */   gpx: () => (/* binding */ ii),\n/* harmony export */   gpxOrKml: () => (/* binding */ jc),\n/* harmony export */   hasChildNodeWithName: () => (/* binding */ oi),\n/* harmony export */   helpers: () => (/* binding */ Lp),\n/* harmony export */   importScriptInWorkers: () => (/* binding */ Sf),\n/* harmony export */   isLanguageInfo: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.isLanguageInfo),\n/* harmony export */   kml: () => (/* binding */ si),\n/* harmony export */   mapStylePresetList: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.mapStylePresetList),\n/* harmony export */   math: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.math),\n/* harmony export */   misc: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.misc),\n/* harmony export */   prewarm: () => (/* binding */ nf),\n/* harmony export */   removeProtocol: () => (/* binding */ kf),\n/* harmony export */   setMaxParallelImageRequests: () => (/* binding */ gf),\n/* harmony export */   setRTLTextPlugin: () => (/* binding */ Qp),\n/* harmony export */   setWorkerCount: () => (/* binding */ mf),\n/* harmony export */   setWorkerUrl: () => (/* binding */ bf),\n/* harmony export */   staticMaps: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.staticMaps),\n/* harmony export */   str2xml: () => (/* binding */ $n),\n/* harmony export */   styleToStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.styleToStyle),\n/* harmony export */   toLanguageInfo: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.toLanguageInfo),\n/* harmony export */   toggleProjection: () => (/* binding */ Do),\n/* harmony export */   toggleTerrain: () => (/* binding */ jo),\n/* harmony export */   xml2str: () => (/* binding */ qa)\n/* harmony export */ });\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maplibre-gl */ \"(ssr)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var _maptiler_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @maptiler/client */ \"(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm/v4.js\");\nvar Si = Object.defineProperty;\nvar Hn = (r) => {\n  throw TypeError(r);\n};\nvar xi = (r, e, t) => e in r ? Si(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar g = (r, e, t) => xi(r, typeof e != \"symbol\" ? e + \"\" : e, t), Lr = (r, e, t) => e.has(r) || Hn(\"Cannot \" + t);\nvar k = (r, e, t) => (Lr(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)), Z = (r, e, t) => e.has(r) ? Hn(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t), K = (r, e, t, n) => (Lr(r, e, \"write to private field\"), n ? n.call(r, t) : e.set(r, t), t), X = (r, e, t) => (Lr(r, e, \"access private method\"), t);\n\n\n\n\n\n\nlet Mi = class extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker {\n  addTo(e) {\n    return super.addTo(e);\n  }\n};\nclass np extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup {\n  addTo(e) {\n    return super.addTo(e);\n  }\n}\nclass ap extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Style {\n  constructor(e, t = {}) {\n    super(e, t);\n  }\n}\nclass op extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CanvasSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass ip extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeoJSONSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass sp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ImageSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass lp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass up extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterDEMTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass cp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VectorTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass pp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VideoSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Wa extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Pi extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeolocateControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass fp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Ri extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LogoControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass zi extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScaleControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Oi extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.FullscreenControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass dp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TerrainControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass hp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.BoxZoomHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass mp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScrollZoomHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass yp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CooperativeGesturesHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass gp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.KeyboardHandler {\n  constructor(e) {\n    super(e);\n  }\n}\nclass vp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TwoFingersTouchPitchHandler {\n  constructor(e) {\n    super(e);\n  }\n}\nclass bp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapWheelEvent {\n  constructor(e, t, n) {\n    super(e, t, n);\n  }\n}\nclass wp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapTouchEvent {\n  constructor(e, t, n) {\n    super(e, t, n);\n  }\n}\nclass Sp extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapMouseEvent {\n  constructor(e, t, n, a = {}) {\n    super(e, t, n, a);\n  }\n}\nconst z = {\n  /**\n   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR: {\n    code: null,\n    flag: \"visitor\",\n    name: \"Visitor\",\n    latin: !0,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in both the local language and English, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR_ENGLISH: {\n    code: null,\n    flag: \"visitor_en\",\n    name: \"Visitor English\",\n    latin: !0,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in a language enforced in the style.\n   */\n  STYLE: {\n    code: null,\n    flag: \"style\",\n    name: \"Style\",\n    latin: !1,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.\n   */\n  STYLE_LOCK: {\n    code: null,\n    flag: \"style_lock\",\n    name: \"Style Lock\",\n    latin: !1,\n    isMode: !0,\n    geocoding: !1\n  },\n  ..._maptiler_client__WEBPACK_IMPORTED_MODULE_2__.Language\n};\nfunction Yn() {\n  if (typeof navigator > \"u\") {\n    const e = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0], t = (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getLanguageInfoFromCode)(e);\n    return t || z.ENGLISH;\n  }\n  return Array.from(new Set(navigator.languages.map((e) => e.split(\"-\")[0]))).map((e) => (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getLanguageInfoFromCode)(e)).filter((e) => e)[0] ?? z.LOCAL;\n}\nconst J = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  telemetryURL: \"https://api.maptiler.com/metrics\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: z.STYLE,\n  secondaryLanguage: z.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(J);\nconst dn = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\nclass $i extends events__WEBPACK_IMPORTED_MODULE_1__ {\n  constructor() {\n    super(...arguments);\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    g(this, \"primaryLanguage\", J.primaryLanguage);\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    g(this, \"secondaryLanguage\");\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    g(this, \"session\", !0);\n    /**\n     * Enables client-side caching of requests for tiles and fonts.\n     * The cached requests persist multiple browser sessions and will be reused when possible.\n     * Works only for requests to the MapTiler Cloud API when sessions are enabled.\n     */\n    g(this, \"caching\", !0);\n    /**\n     * Telemetry is enabled by default but can be opted-out by setting this value to `false`.\n     * The telemetry is very valuable to the team at MapTiler because it shares information\n     * about where to add the extra effort. It also helps spotting some incompatibility issues\n     * that may arise between the SDK and a specific version of a module.\n     *\n     * It consists in sending metrics about usage of the following features:\n     * - SDK version [string]\n     * - API key [string]\n     * - MapTiler sesion ID (if opted-in) [string]\n     * - if tile caching is enabled [boolean]\n     * - if language specified at initialization [boolean]\n     * - if terrain is activated at initialization [boolean]\n     * - if globe projection is activated at initialization [boolean]\n     *\n     * In addition, each official module will be added to a list, alongside its version number.\n     */\n    g(this, \"telemetry\", !0);\n    /**\n     * Unit to be used\n     */\n    g(this, \"_unit\", \"metric\");\n    /**\n     * MapTiler Cloud API key\n     */\n    g(this, \"_apiKey\", \"\");\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(t) {\n    this._unit = t, this.emit(\"unit\", t);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(t) {\n    this._apiKey = t, _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.config.apiKey = t, this.emit(\"apiKey\", t);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(t) {\n    _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.config.fetch = t;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.config.fetch;\n  }\n}\nconst j = new $i();\nclass Wn extends Ri {\n  constructor(t = {}) {\n    super(t);\n    g(this, \"logoURL\", \"\");\n    g(this, \"linkURL\", \"\");\n    this.logoURL = t.logoURL ?? J.maptilerLogoURL, this.linkURL = t.linkURL ?? J.maptilerURL;\n  }\n  onAdd(t) {\n    this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement(\"div\"), this._container.className = \"maplibregl-ctrl\";\n    const n = window.document.createElement(\"a\");\n    return n.style.backgroundRepeat = \"no-repeat\", n.style.cursor = \"pointer\", n.style.display = \"block\", n.style.height = \"23px\", n.style.margin = \"0 0 -4px -4px\", n.style.overflow = \"hidden\", n.style.width = \"88px\", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = \"100px 30px\", n.style.width = \"100px\", n.style.height = \"30px\", n.target = \"_blank\", n.rel = \"noopener\", n.href = this.linkURL, n.setAttribute(\"aria-label\", \"MapTiler logo\"), n.setAttribute(\"rel\", \"noopener\"), this._container.appendChild(n), this._container.style.display = \"block\", this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n  }\n}\nconst Vr = \"localcache_source\", Gr = \"localcache\", Fi = \"maptiler_sdk\", Ni = 1e3, ji = 100, Hr = typeof caches < \"u\", { addProtocol: Jn } = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\nfunction Di(r, e) {\n  if (Hr && j.caching && j.session && r.host === J.maptilerApiHost) {\n    if (e === \"Source\" && r.href.includes(\"tiles.json\"))\n      return r.href.replace(\"https://\", `${Vr}://`);\n    if (e === \"Tile\" || e === \"Glyphs\")\n      return r.href.replace(\"https://\", `${Gr}://`);\n  }\n  return r.href;\n}\nlet Ar;\nasync function Ja() {\n  return Ar || (Ar = await caches.open(Fi)), Ar;\n}\nlet Qn = 0;\nasync function Ui() {\n  const r = await Ja(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Ni, 0));\n  for (const n of t)\n    r.delete(n);\n}\nfunction Bi() {\n  Jn(\n    Vr,\n    async (r, e) => {\n      if (!r.url) throw new Error(\"\");\n      r.url = r.url.replace(`${Vr}://`, \"https://\");\n      const t = r;\n      t.signal = e.signal;\n      const n = await fetch(r.url, t), a = await n.json();\n      return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get(\"Last-Modified\")}`), {\n        data: a,\n        cacheControl: n.headers.get(\"Cache-Control\"),\n        expires: n.headers.get(\"Expires\")\n      };\n    }\n  ), Jn(Gr, async (r, e) => {\n    if (!r.url) throw new Error(\"\");\n    r.url = r.url.replace(`${Gr}://`, \"https://\");\n    const t = new URL(r.url), n = new URL(t);\n    n.searchParams.delete(\"mtsid\"), n.searchParams.delete(\"key\");\n    const a = n.toString(), o = new URL(t);\n    o.searchParams.delete(\"last-modified\");\n    const i = o.toString(), s = async (d) => ({\n      data: await d.arrayBuffer(),\n      cacheControl: d.headers.get(\"Cache-Control\"),\n      expires: d.headers.get(\"Expires\")\n    }), l = await Ja(), u = await l.match(a);\n    if (u)\n      return s(u);\n    const c = r;\n    c.signal = e.signal;\n    const p = await fetch(i, c);\n    return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {\n    }), ++Qn > ji && (Ui(), Qn = 0)), s(p);\n  });\n}\nfunction qi(r, e) {\n  for (const t of r)\n    typeof e[t] == \"function\" && (e[t] = e[t].bind(e));\n}\nfunction ea(r, e) {\n  let t = null;\n  try {\n    t = new URL(r);\n  } catch {\n    return {\n      url: r\n    };\n  }\n  return t.host === J.maptilerApiHost && (t.searchParams.has(\"key\") || t.searchParams.append(\"key\", j.apiKey), j.session && t.searchParams.append(\"mtsid\", dn)), {\n    url: Di(t, e)\n  };\n}\nfunction ta(r) {\n  return (e, t) => {\n    if (r != null) {\n      const n = r(e, t), a = ea((n == null ? void 0 : n.url) ?? \"\", t);\n      return {\n        ...n,\n        ...a\n      };\n    }\n    return ea(e, t);\n  };\n}\nfunction Qa() {\n  return Math.random().toString(36).substring(2);\n}\nfunction ir(r) {\n  return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi.test(r);\n}\nfunction Vi(r) {\n  try {\n    return JSON.parse(r);\n  } catch {\n  }\n  return null;\n}\nfunction Gi() {\n  return document.createElement(\"canvas\").getContext(\"webgl2\") ? null : typeof WebGL2RenderingContext < \"u\" ? \"Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed.\" : \"Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.\";\n}\nfunction Hi(r) {\n  const e = Gi();\n  if (!e) return;\n  let t = null;\n  if (typeof r == \"string\" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t)\n    throw new Error(\"The Map container must be provided.\");\n  const n = document.createElement(\"div\");\n  throw n.innerHTML = e, n.classList.add(\"webgl-warning-div\"), t.appendChild(n), new Error(e);\n}\nfunction xp(r) {\n  const e = \"The WebGL context was lost.\", t = r.getContainer(), n = document.createElement(\"div\");\n  n.innerHTML = e, n.classList.add(\"webgl-warning-div\"), t.appendChild(n);\n}\nfunction ra(r, e) {\n  return !(!Array.isArray(r) || r.length !== 2 || r[0] !== \"get\" || typeof r[1] != \"string\" || e && !r[1].startsWith(\"name:\") || !e && r[1] !== \"name\");\n}\nfunction Zi(r, e, t) {\n  const n = structuredClone(r), a = (o) => {\n    if (typeof o != \"string\")\n      for (let i = 0; i < o.length; i += 1)\n        ra(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);\n  };\n  return ra(n, t) ? e : (a(n), n);\n}\nfunction Ki(r, e) {\n  const t = e ? /\\{name:\\S+\\}/ : /\\{name\\}/;\n  return {\n    contains: t.test(r),\n    exactMatch: new RegExp(`^${t.source}$`).test(r)\n  };\n}\nfunction Xi(r, e, t) {\n  const n = t ? /\\{name:\\S+\\}/ : /\\{name\\}/, a = r.split(n);\n  return [\"concat\", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];\n}\nfunction Yi(r) {\n  var n;\n  const e = /\\{name(?::(?<language>\\S+))?\\}/g, t = [];\n  for (; ; ) {\n    const a = e.exec(r);\n    if (!a) break;\n    const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;\n    t.push(o);\n  }\n  return t;\n}\nfunction Wi(r) {\n  return !Array.isArray(r) || r.length !== 2 || r[0] !== \"get\" || typeof r[1] != \"string\" ? null : r[1].trim() === \"name\" ? {\n    isLanguage: !0,\n    localization: null\n  } : r[1].trim().startsWith(\"name:\") ? {\n    isLanguage: !0,\n    localization: r[1].trim().split(\":\").pop()\n  } : null;\n}\nfunction Ji(r) {\n  const e = [], t = structuredClone(r), n = (a) => {\n    if (typeof a != \"string\")\n      for (let o = 0; o < a.length; o += 1) {\n        const i = Wi(a[o]);\n        i ? e.push(i.localization) : n(a[o]);\n      }\n  };\n  return n([t]), e;\n}\nfunction Qi(r, e) {\n  const t = [];\n  for (const o of r) {\n    if (o.type !== \"symbol\")\n      continue;\n    const i = o, { id: s, layout: l } = i;\n    if (!l || !(\"text-field\" in l))\n      continue;\n    const u = e.getLayoutProperty(s, \"text-field\");\n    if (u)\n      if (typeof u == \"string\") {\n        const c = Yi(u);\n        t.push(c);\n      } else {\n        const c = Ji(u);\n        t.push(c);\n      }\n  }\n  const n = t.flat(), a = {\n    unlocalized: 0,\n    localized: {}\n  };\n  for (const o of n)\n    o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);\n  return a;\n}\nvar es = 8, ts = {\n  version: {\n    required: !0,\n    type: \"enum\",\n    values: [\n      8\n    ]\n  },\n  name: {\n    type: \"string\"\n  },\n  metadata: {\n    type: \"*\"\n  },\n  center: {\n    type: \"array\",\n    value: \"number\"\n  },\n  centerAltitude: {\n    type: \"number\"\n  },\n  zoom: {\n    type: \"number\"\n  },\n  bearing: {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    units: \"degrees\"\n  },\n  pitch: {\n    type: \"number\",\n    default: 0,\n    units: \"degrees\"\n  },\n  roll: {\n    type: \"number\",\n    default: 0,\n    units: \"degrees\"\n  },\n  state: {\n    type: \"state\",\n    default: {}\n  },\n  light: {\n    type: \"light\"\n  },\n  sky: {\n    type: \"sky\"\n  },\n  projection: {\n    type: \"projection\"\n  },\n  terrain: {\n    type: \"terrain\"\n  },\n  sources: {\n    required: !0,\n    type: \"sources\"\n  },\n  sprite: {\n    type: \"sprite\"\n  },\n  glyphs: {\n    type: \"string\"\n  },\n  transition: {\n    type: \"transition\"\n  },\n  layers: {\n    required: !0,\n    type: \"array\",\n    value: \"layer\"\n  }\n}, rs = {\n  \"*\": {\n    type: \"source\"\n  }\n}, ns = [\n  \"source_vector\",\n  \"source_raster\",\n  \"source_raster_dem\",\n  \"source_geojson\",\n  \"source_video\",\n  \"source_image\"\n], as = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      vector: {}\n    }\n  },\n  url: {\n    type: \"string\"\n  },\n  tiles: {\n    type: \"array\",\n    value: \"string\"\n  },\n  bounds: {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      -180,\n      -85.051129,\n      180,\n      85.051129\n    ]\n  },\n  scheme: {\n    type: \"enum\",\n    values: {\n      xyz: {},\n      tms: {}\n    },\n    default: \"xyz\"\n  },\n  minzoom: {\n    type: \"number\",\n    default: 0\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 22\n  },\n  attribution: {\n    type: \"string\"\n  },\n  promoteId: {\n    type: \"promoteId\"\n  },\n  volatile: {\n    type: \"boolean\",\n    default: !1\n  },\n  \"*\": {\n    type: \"*\"\n  }\n}, os = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      raster: {}\n    }\n  },\n  url: {\n    type: \"string\"\n  },\n  tiles: {\n    type: \"array\",\n    value: \"string\"\n  },\n  bounds: {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      -180,\n      -85.051129,\n      180,\n      85.051129\n    ]\n  },\n  minzoom: {\n    type: \"number\",\n    default: 0\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 22\n  },\n  tileSize: {\n    type: \"number\",\n    default: 512,\n    units: \"pixels\"\n  },\n  scheme: {\n    type: \"enum\",\n    values: {\n      xyz: {},\n      tms: {}\n    },\n    default: \"xyz\"\n  },\n  attribution: {\n    type: \"string\"\n  },\n  volatile: {\n    type: \"boolean\",\n    default: !1\n  },\n  \"*\": {\n    type: \"*\"\n  }\n}, is = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      \"raster-dem\": {}\n    }\n  },\n  url: {\n    type: \"string\"\n  },\n  tiles: {\n    type: \"array\",\n    value: \"string\"\n  },\n  bounds: {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      -180,\n      -85.051129,\n      180,\n      85.051129\n    ]\n  },\n  minzoom: {\n    type: \"number\",\n    default: 0\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 22\n  },\n  tileSize: {\n    type: \"number\",\n    default: 512,\n    units: \"pixels\"\n  },\n  attribution: {\n    type: \"string\"\n  },\n  encoding: {\n    type: \"enum\",\n    values: {\n      terrarium: {},\n      mapbox: {},\n      custom: {}\n    },\n    default: \"mapbox\"\n  },\n  redFactor: {\n    type: \"number\",\n    default: 1\n  },\n  blueFactor: {\n    type: \"number\",\n    default: 1\n  },\n  greenFactor: {\n    type: \"number\",\n    default: 1\n  },\n  baseShift: {\n    type: \"number\",\n    default: 0\n  },\n  volatile: {\n    type: \"boolean\",\n    default: !1\n  },\n  \"*\": {\n    type: \"*\"\n  }\n}, ss = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      geojson: {}\n    }\n  },\n  data: {\n    required: !0,\n    type: \"*\"\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 18\n  },\n  attribution: {\n    type: \"string\"\n  },\n  buffer: {\n    type: \"number\",\n    default: 128,\n    maximum: 512,\n    minimum: 0\n  },\n  filter: {\n    type: \"*\"\n  },\n  tolerance: {\n    type: \"number\",\n    default: 0.375\n  },\n  cluster: {\n    type: \"boolean\",\n    default: !1\n  },\n  clusterRadius: {\n    type: \"number\",\n    default: 50,\n    minimum: 0\n  },\n  clusterMaxZoom: {\n    type: \"number\"\n  },\n  clusterMinPoints: {\n    type: \"number\"\n  },\n  clusterProperties: {\n    type: \"*\"\n  },\n  lineMetrics: {\n    type: \"boolean\",\n    default: !1\n  },\n  generateId: {\n    type: \"boolean\",\n    default: !1\n  },\n  promoteId: {\n    type: \"promoteId\"\n  }\n}, ls = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      video: {}\n    }\n  },\n  urls: {\n    required: !0,\n    type: \"array\",\n    value: \"string\"\n  },\n  coordinates: {\n    required: !0,\n    type: \"array\",\n    length: 4,\n    value: {\n      type: \"array\",\n      length: 2,\n      value: \"number\"\n    }\n  }\n}, us = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      image: {}\n    }\n  },\n  url: {\n    required: !0,\n    type: \"string\"\n  },\n  coordinates: {\n    required: !0,\n    type: \"array\",\n    length: 4,\n    value: {\n      type: \"array\",\n      length: 2,\n      value: \"number\"\n    }\n  }\n}, cs = {\n  id: {\n    type: \"string\",\n    required: !0\n  },\n  type: {\n    type: \"enum\",\n    values: {\n      fill: {},\n      line: {},\n      symbol: {},\n      circle: {},\n      heatmap: {},\n      \"fill-extrusion\": {},\n      raster: {},\n      hillshade: {},\n      \"color-relief\": {},\n      background: {}\n    },\n    required: !0\n  },\n  metadata: {\n    type: \"*\"\n  },\n  source: {\n    type: \"string\"\n  },\n  \"source-layer\": {\n    type: \"string\"\n  },\n  minzoom: {\n    type: \"number\",\n    minimum: 0,\n    maximum: 24\n  },\n  maxzoom: {\n    type: \"number\",\n    minimum: 0,\n    maximum: 24\n  },\n  filter: {\n    type: \"filter\"\n  },\n  layout: {\n    type: \"layout\"\n  },\n  paint: {\n    type: \"paint\"\n  }\n}, ps = [\n  \"layout_fill\",\n  \"layout_line\",\n  \"layout_circle\",\n  \"layout_heatmap\",\n  \"layout_fill-extrusion\",\n  \"layout_symbol\",\n  \"layout_raster\",\n  \"layout_hillshade\",\n  \"layout_color-relief\",\n  \"layout_background\"\n], fs = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, ds = {\n  \"fill-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, hs = {\n  \"circle-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, ms = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, ys = {\n  \"line-cap\": {\n    type: \"enum\",\n    values: {\n      butt: {},\n      round: {},\n      square: {}\n    },\n    default: \"butt\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-join\": {\n    type: \"enum\",\n    values: {\n      bevel: {},\n      round: {},\n      miter: {}\n    },\n    default: \"miter\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-miter-limit\": {\n    type: \"number\",\n    default: 2,\n    requires: [\n      {\n        \"line-join\": \"miter\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-round-limit\": {\n    type: \"number\",\n    default: 1.05,\n    requires: [\n      {\n        \"line-join\": \"round\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, gs = {\n  \"symbol-placement\": {\n    type: \"enum\",\n    values: {\n      point: {},\n      line: {},\n      \"line-center\": {}\n    },\n    default: \"point\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"symbol-spacing\": {\n    type: \"number\",\n    default: 250,\n    minimum: 1,\n    units: \"pixels\",\n    requires: [\n      {\n        \"symbol-placement\": \"line\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"symbol-avoid-edges\": {\n    type: \"boolean\",\n    default: !1,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"symbol-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"symbol-z-order\": {\n    type: \"enum\",\n    values: {\n      auto: {},\n      \"viewport-y\": {},\n      source: {}\n    },\n    default: \"auto\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-allow-overlap\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\",\n      {\n        \"!\": \"icon-overlap\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-overlap\": {\n    type: \"enum\",\n    values: {\n      never: {},\n      always: {},\n      cooperative: {}\n    },\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-ignore-placement\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-optional\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\",\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-rotation-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-size\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    units: \"factor of the original icon size\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-text-fit\": {\n    type: \"enum\",\n    values: {\n      none: {},\n      width: {},\n      height: {},\n      both: {}\n    },\n    default: \"none\",\n    requires: [\n      \"icon-image\",\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-text-fit-padding\": {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      0,\n      0,\n      0,\n      0\n    ],\n    units: \"pixels\",\n    requires: [\n      \"icon-image\",\n      \"text-field\",\n      {\n        \"icon-text-fit\": [\n          \"both\",\n          \"width\",\n          \"height\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-image\": {\n    type: \"resolvedImage\",\n    tokens: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-rotate\": {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    units: \"degrees\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-padding\": {\n    type: \"padding\",\n    default: [\n      2\n    ],\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-keep-upright\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\",\n      {\n        \"icon-rotation-alignment\": \"map\"\n      },\n      {\n        \"symbol-placement\": [\n          \"line\",\n          \"line-center\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-offset\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-anchor\": {\n    type: \"enum\",\n    values: {\n      center: {},\n      left: {},\n      right: {},\n      top: {},\n      bottom: {},\n      \"top-left\": {},\n      \"top-right\": {},\n      \"bottom-left\": {},\n      \"bottom-right\": {}\n    },\n    default: \"center\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-pitch-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-pitch-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-rotation-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      \"viewport-glyph\": {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-field\": {\n    type: \"formatted\",\n    default: \"\",\n    tokens: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-font\": {\n    type: \"array\",\n    value: \"string\",\n    default: [\n      \"Open Sans Regular\",\n      \"Arial Unicode MS Regular\"\n    ],\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-size\": {\n    type: \"number\",\n    default: 16,\n    minimum: 0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-max-width\": {\n    type: \"number\",\n    default: 10,\n    minimum: 0,\n    units: \"ems\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-line-height\": {\n    type: \"number\",\n    default: 1.2,\n    units: \"ems\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-letter-spacing\": {\n    type: \"number\",\n    default: 0,\n    units: \"ems\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-justify\": {\n    type: \"enum\",\n    values: {\n      auto: {},\n      left: {},\n      center: {},\n      right: {}\n    },\n    default: \"center\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-radial-offset\": {\n    type: \"number\",\n    units: \"ems\",\n    default: 0,\n    requires: [\n      \"text-field\"\n    ],\n    \"property-type\": \"data-driven\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    }\n  },\n  \"text-variable-anchor\": {\n    type: \"array\",\n    value: \"enum\",\n    values: {\n      center: {},\n      left: {},\n      right: {},\n      top: {},\n      bottom: {},\n      \"top-left\": {},\n      \"top-right\": {},\n      \"bottom-left\": {},\n      \"bottom-right\": {}\n    },\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"point\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-variable-anchor-offset\": {\n    type: \"variableAnchorOffsetCollection\",\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"point\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-anchor\": {\n    type: \"enum\",\n    values: {\n      center: {},\n      left: {},\n      right: {},\n      top: {},\n      bottom: {},\n      \"top-left\": {},\n      \"top-right\": {},\n      \"bottom-left\": {},\n      \"bottom-right\": {}\n    },\n    default: \"center\",\n    requires: [\n      \"text-field\",\n      {\n        \"!\": \"text-variable-anchor\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-max-angle\": {\n    type: \"number\",\n    default: 45,\n    units: \"degrees\",\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"line\",\n          \"line-center\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-writing-mode\": {\n    type: \"array\",\n    value: \"enum\",\n    values: {\n      horizontal: {},\n      vertical: {}\n    },\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"point\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-rotate\": {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    units: \"degrees\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-padding\": {\n    type: \"number\",\n    default: 2,\n    minimum: 0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-keep-upright\": {\n    type: \"boolean\",\n    default: !0,\n    requires: [\n      \"text-field\",\n      {\n        \"text-rotation-alignment\": \"map\"\n      },\n      {\n        \"symbol-placement\": [\n          \"line\",\n          \"line-center\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-transform\": {\n    type: \"enum\",\n    values: {\n      none: {},\n      uppercase: {},\n      lowercase: {}\n    },\n    default: \"none\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-offset\": {\n    type: \"array\",\n    value: \"number\",\n    units: \"ems\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    requires: [\n      \"text-field\",\n      {\n        \"!\": \"text-radial-offset\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-allow-overlap\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"text-field\",\n      {\n        \"!\": \"text-overlap\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-overlap\": {\n    type: \"enum\",\n    values: {\n      never: {},\n      always: {},\n      cooperative: {}\n    },\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-ignore-placement\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-optional\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"text-field\",\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, vs = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, bs = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, ws = {\n  type: \"array\",\n  value: \"*\"\n}, Ss = {\n  type: \"enum\",\n  values: {\n    \"==\": {},\n    \"!=\": {},\n    \">\": {},\n    \">=\": {},\n    \"<\": {},\n    \"<=\": {},\n    in: {},\n    \"!in\": {},\n    all: {},\n    any: {},\n    none: {},\n    has: {},\n    \"!has\": {}\n  }\n}, xs = {\n  type: \"enum\",\n  values: {\n    Point: {},\n    LineString: {},\n    Polygon: {}\n  }\n}, ks = {\n  type: \"array\",\n  minimum: 0,\n  maximum: 24,\n  value: [\n    \"number\",\n    \"color\"\n  ],\n  length: 2\n}, Ls = {\n  type: \"array\",\n  value: \"*\",\n  minimum: 1\n}, Es = {\n  anchor: {\n    type: \"enum\",\n    default: \"viewport\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    \"property-type\": \"data-constant\",\n    transition: !1,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    }\n  },\n  position: {\n    type: \"array\",\n    default: [\n      1.15,\n      210,\n      30\n    ],\n    length: 3,\n    value: \"number\",\n    \"property-type\": \"data-constant\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    }\n  },\n  color: {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#ffffff\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  intensity: {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.5,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  }\n}, Cs = {\n  \"sky-color\": {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#88C6FC\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"horizon-color\": {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#ffffff\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"fog-color\": {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#ffffff\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"fog-ground-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.5,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"horizon-fog-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.8,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"sky-horizon-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.8,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"atmosphere-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.8,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  }\n}, As = {\n  source: {\n    type: \"string\",\n    required: !0\n  },\n  exaggeration: {\n    type: \"number\",\n    minimum: 0,\n    default: 1\n  }\n}, Ts = {\n  type: {\n    type: \"projectionDefinition\",\n    default: \"mercator\",\n    \"property-type\": \"data-constant\",\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    }\n  }\n}, _s = [\n  \"paint_fill\",\n  \"paint_line\",\n  \"paint_circle\",\n  \"paint_heatmap\",\n  \"paint_fill-extrusion\",\n  \"paint_symbol\",\n  \"paint_raster\",\n  \"paint_hillshade\",\n  \"paint_color-relief\",\n  \"paint_background\"\n], Is = {\n  \"fill-antialias\": {\n    type: \"boolean\",\n    default: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"fill-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"fill-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"fill-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"fill-outline-color\": {\n    type: \"color\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"fill-pattern\"\n      },\n      {\n        \"fill-antialias\": !0\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"fill-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"fill-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"fill-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"fill-pattern\": {\n    type: \"resolvedImage\",\n    transition: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"cross-faded-data-driven\"\n  }\n}, Ms = {\n  \"line-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"line-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"line-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-width\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-gap-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-offset\": {\n    type: \"number\",\n    default: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-blur\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-dasharray\": {\n    type: \"array\",\n    value: \"number\",\n    minimum: 0,\n    transition: !0,\n    units: \"line widths\",\n    requires: [\n      {\n        \"!\": \"line-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"cross-faded\"\n  },\n  \"line-pattern\": {\n    type: \"resolvedImage\",\n    transition: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"cross-faded-data-driven\"\n  },\n  \"line-gradient\": {\n    type: \"color\",\n    transition: !1,\n    requires: [\n      {\n        \"!\": \"line-dasharray\"\n      },\n      {\n        \"!\": \"line-pattern\"\n      },\n      {\n        source: \"geojson\",\n        has: {\n          lineMetrics: !0\n        }\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"line-progress\"\n      ]\n    },\n    \"property-type\": \"color-ramp\"\n  }\n}, Ps = {\n  \"circle-radius\": {\n    type: \"number\",\n    default: 5,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-blur\": {\n    type: \"number\",\n    default: 0,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"circle-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-pitch-scale\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-pitch-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"viewport\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-stroke-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-stroke-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-stroke-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  }\n}, Rs = {\n  \"heatmap-radius\": {\n    type: \"number\",\n    default: 30,\n    minimum: 1,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"heatmap-weight\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"heatmap-intensity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"heatmap-color\": {\n    type: \"color\",\n    default: [\n      \"interpolate\",\n      [\n        \"linear\"\n      ],\n      [\n        \"heatmap-density\"\n      ],\n      0,\n      \"rgba(0, 0, 255, 0)\",\n      0.1,\n      \"royalblue\",\n      0.3,\n      \"cyan\",\n      0.5,\n      \"lime\",\n      0.7,\n      \"yellow\",\n      1,\n      \"red\"\n    ],\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"heatmap-density\"\n      ]\n    },\n    \"property-type\": \"color-ramp\"\n  },\n  \"heatmap-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, zs = {\n  \"icon-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-halo-color\": {\n    type: \"color\",\n    default: \"rgba(0, 0, 0, 0)\",\n    transition: !0,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-halo-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-halo-blur\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"icon-image\",\n      \"icon-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    overridable: !0,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-halo-color\": {\n    type: \"color\",\n    default: \"rgba(0, 0, 0, 0)\",\n    transition: !0,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-halo-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-halo-blur\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"text-field\",\n      \"text-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, Os = {\n  \"raster-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-hue-rotate\": {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    transition: !0,\n    units: \"degrees\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-brightness-min\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-brightness-max\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-saturation\": {\n    type: \"number\",\n    default: 0,\n    minimum: -1,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-contrast\": {\n    type: \"number\",\n    default: 0,\n    minimum: -1,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-resampling\": {\n    type: \"enum\",\n    values: {\n      linear: {},\n      nearest: {}\n    },\n    default: \"linear\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-fade-duration\": {\n    type: \"number\",\n    default: 300,\n    minimum: 0,\n    transition: !1,\n    units: \"milliseconds\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, $s = {\n  \"hillshade-illumination-direction\": {\n    type: \"numberArray\",\n    default: 335,\n    minimum: 0,\n    maximum: 359,\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-illumination-altitude\": {\n    type: \"numberArray\",\n    default: 45,\n    minimum: 0,\n    maximum: 90,\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-illumination-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"viewport\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-exaggeration\": {\n    type: \"number\",\n    default: 0.5,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-shadow-color\": {\n    type: \"colorArray\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-highlight-color\": {\n    type: \"colorArray\",\n    default: \"#FFFFFF\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-accent-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-method\": {\n    type: \"enum\",\n    values: {\n      standard: {},\n      basic: {},\n      combined: {},\n      igor: {},\n      multidirectional: {}\n    },\n    default: \"standard\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, Fs = {\n  \"background-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"background-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"background-pattern\": {\n    type: \"resolvedImage\",\n    transition: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"cross-faded\"\n  },\n  \"background-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, Ns = {\n  duration: {\n    type: \"number\",\n    default: 300,\n    minimum: 0,\n    units: \"milliseconds\"\n  },\n  delay: {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    units: \"milliseconds\"\n  }\n}, js = {\n  \"*\": {\n    type: \"string\"\n  }\n}, Ds = {\n  $version: es,\n  $root: ts,\n  sources: rs,\n  source: ns,\n  source_vector: as,\n  source_raster: os,\n  source_raster_dem: is,\n  source_geojson: ss,\n  source_video: ls,\n  source_image: us,\n  layer: cs,\n  layout: ps,\n  layout_background: fs,\n  layout_fill: ds,\n  layout_circle: hs,\n  layout_heatmap: ms,\n  \"layout_fill-extrusion\": {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  layout_line: ys,\n  layout_symbol: gs,\n  layout_raster: vs,\n  layout_hillshade: bs,\n  \"layout_color-relief\": {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  filter: ws,\n  filter_operator: Ss,\n  geometry_type: xs,\n  function: {\n    expression: {\n      type: \"expression\"\n    },\n    stops: {\n      type: \"array\",\n      value: \"function_stop\"\n    },\n    base: {\n      type: \"number\",\n      default: 1,\n      minimum: 0\n    },\n    property: {\n      type: \"string\",\n      default: \"$zoom\"\n    },\n    type: {\n      type: \"enum\",\n      values: {\n        identity: {},\n        exponential: {},\n        interval: {},\n        categorical: {}\n      },\n      default: \"exponential\"\n    },\n    colorSpace: {\n      type: \"enum\",\n      values: {\n        rgb: {},\n        lab: {},\n        hcl: {}\n      },\n      default: \"rgb\"\n    },\n    default: {\n      type: \"*\",\n      required: !1\n    }\n  },\n  function_stop: ks,\n  expression: Ls,\n  light: Es,\n  sky: Cs,\n  terrain: As,\n  projection: Ts,\n  paint: _s,\n  paint_fill: Is,\n  \"paint_fill-extrusion\": {\n    \"fill-extrusion-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      requires: [\n        {\n          \"!\": \"fill-extrusion-pattern\"\n        }\n      ],\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\",\n          \"feature\",\n          \"feature-state\"\n        ]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [\n        0,\n        0\n      ],\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\n        \"fill-extrusion-translate\"\n      ],\n      expression: {\n        interpolated: !1,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-pattern\": {\n      type: \"resolvedImage\",\n      transition: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\n          \"zoom\",\n          \"feature\"\n        ]\n      },\n      \"property-type\": \"cross-faded-data-driven\"\n    },\n    \"fill-extrusion-height\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      units: \"meters\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\",\n          \"feature\",\n          \"feature-state\"\n        ]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-base\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      units: \"meters\",\n      transition: !0,\n      requires: [\n        \"fill-extrusion-height\"\n      ],\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\",\n          \"feature\",\n          \"feature-state\"\n        ]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-vertical-gradient\": {\n      type: \"boolean\",\n      default: !0,\n      transition: !1,\n      expression: {\n        interpolated: !1,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  paint_line: Ms,\n  paint_circle: Ps,\n  paint_heatmap: Rs,\n  paint_symbol: zs,\n  paint_raster: Os,\n  paint_hillshade: $s,\n  \"paint_color-relief\": {\n    \"color-relief-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"color-relief-color\": {\n      type: \"color\",\n      transition: !1,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"elevation\"\n        ]\n      },\n      \"property-type\": \"color-ramp\"\n    }\n  },\n  paint_background: Fs,\n  transition: Ns,\n  \"property-type\": {\n    \"data-driven\": {\n      type: \"property-type\"\n    },\n    \"cross-faded\": {\n      type: \"property-type\"\n    },\n    \"cross-faded-data-driven\": {\n      type: \"property-type\"\n    },\n    \"color-ramp\": {\n      type: \"property-type\"\n    },\n    \"data-constant\": {\n      type: \"property-type\"\n    },\n    constant: {\n      type: \"property-type\"\n    }\n  },\n  promoteId: js\n};\nclass b {\n  constructor(e, t, n, a) {\n    this.message = (e ? `${e}: ` : \"\") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);\n  }\n}\nfunction Yt(r, ...e) {\n  for (const t of e)\n    for (const n in t)\n      r[n] = t[n];\n  return r;\n}\nclass we extends Error {\n  constructor(e, t) {\n    super(t), this.message = t, this.key = e;\n  }\n}\nclass hn {\n  constructor(e, t = []) {\n    this.parent = e, this.bindings = {};\n    for (const [n, a] of t)\n      this.bindings[n] = a;\n  }\n  concat(e) {\n    return new hn(this, e);\n  }\n  get(e) {\n    if (this.bindings[e])\n      return this.bindings[e];\n    if (this.parent)\n      return this.parent.get(e);\n    throw new Error(`${e} not found in scope.`);\n  }\n  has(e) {\n    return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;\n  }\n}\nconst sr = { kind: \"null\" }, S = { kind: \"number\" }, P = { kind: \"string\" }, M = { kind: \"boolean\" }, Se = { kind: \"color\" }, lr = { kind: \"projectionDefinition\" }, Ve = { kind: \"object\" }, I = { kind: \"value\" }, Us = { kind: \"error\" }, ur = { kind: \"collator\" }, cr = { kind: \"formatted\" }, pr = { kind: \"padding\" }, vt = { kind: \"colorArray\" }, fr = { kind: \"numberArray\" }, _t = { kind: \"resolvedImage\" }, dr = { kind: \"variableAnchorOffsetCollection\" };\nfunction ne(r, e) {\n  return {\n    kind: \"array\",\n    itemType: r,\n    N: e\n  };\n}\nfunction D(r) {\n  if (r.kind === \"array\") {\n    const e = D(r.itemType);\n    return typeof r.N == \"number\" ? `array<${e}, ${r.N}>` : r.itemType.kind === \"value\" ? \"array\" : `array<${e}>`;\n  } else\n    return r.kind;\n}\nconst Bs = [\n  sr,\n  S,\n  P,\n  M,\n  Se,\n  lr,\n  cr,\n  Ve,\n  ne(I),\n  pr,\n  fr,\n  vt,\n  _t,\n  dr\n];\nfunction bt(r, e) {\n  if (e.kind === \"error\")\n    return null;\n  if (r.kind === \"array\") {\n    if (e.kind === \"array\" && (e.N === 0 && e.itemType.kind === \"value\" || !bt(r.itemType, e.itemType)) && (typeof r.N != \"number\" || r.N === e.N))\n      return null;\n  } else {\n    if (r.kind === e.kind)\n      return null;\n    if (r.kind === \"value\") {\n      for (const t of Bs)\n        if (!bt(t, e))\n          return null;\n    }\n  }\n  return `Expected ${D(r)} but found ${D(e)} instead.`;\n}\nfunction mn(r, e) {\n  return e.some((t) => t.kind === r.kind);\n}\nfunction Ge(r, e) {\n  return e.some((t) => t === \"null\" ? r === null : t === \"array\" ? Array.isArray(r) : t === \"object\" ? r && !Array.isArray(r) && typeof r == \"object\" : t === typeof r);\n}\nfunction Ie(r, e) {\n  return r.kind === \"array\" && e.kind === \"array\" ? r.itemType.kind === e.itemType.kind && typeof r.N == \"number\" : r.kind === e.kind;\n}\nconst eo = 0.96422, to = 1, ro = 0.82521, no = 4 / 29, rt = 6 / 29, ao = 3 * rt * rt, qs = rt * rt * rt, Vs = Math.PI / 180, Gs = 180 / Math.PI;\nfunction oo(r) {\n  return r = r % 360, r < 0 && (r += 360), r;\n}\nfunction io([r, e, t, n]) {\n  r = Tr(r), e = Tr(e), t = Tr(t);\n  let a, o;\n  const i = _r((0.2225045 * r + 0.7168786 * e + 0.0606169 * t) / to);\n  r === e && e === t ? a = o = i : (a = _r((0.4360747 * r + 0.3850649 * e + 0.1430804 * t) / eo), o = _r((0.0139322 * r + 0.0971045 * e + 0.7141733 * t) / ro));\n  const s = 116 * i - 16;\n  return [s < 0 ? 0 : s, 500 * (a - i), 200 * (i - o), n];\n}\nfunction Tr(r) {\n  return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);\n}\nfunction _r(r) {\n  return r > qs ? Math.pow(r, 1 / 3) : r / ao + no;\n}\nfunction so([r, e, t, n]) {\n  let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;\n  return a = to * Mr(a), o = eo * Mr(o), i = ro * Mr(i), [\n    Ir(3.1338561 * o - 1.6168667 * a - 0.4906146 * i),\n    // D50 -> sRGB\n    Ir(-0.9787684 * o + 1.9161415 * a + 0.033454 * i),\n    Ir(0.0719453 * o - 0.2289914 * a + 1.4052427 * i),\n    n\n  ];\n}\nfunction Ir(r) {\n  return r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055, r < 0 ? 0 : r > 1 ? 1 : r;\n}\nfunction Mr(r) {\n  return r > rt ? r * r * r : ao * (r - no);\n}\nfunction Hs(r) {\n  const [e, t, n, a] = io(r), o = Math.sqrt(t * t + n * n);\n  return [Math.round(o * 1e4) ? oo(Math.atan2(n, t) * Gs) : NaN, o, e, a];\n}\nfunction Zs([r, e, t, n]) {\n  return r = isNaN(r) ? 0 : r * Vs, so([t, Math.cos(r) * e, Math.sin(r) * e, n]);\n}\nfunction Ks([r, e, t, n]) {\n  r = oo(r), e /= 100, t /= 100;\n  function a(o) {\n    const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);\n    return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));\n  }\n  return [a(0), a(8), a(4), n];\n}\nconst Xs = Object.hasOwn || function(e, t) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n};\nfunction mt(r, e) {\n  return Xs(r, e) ? r[e] : void 0;\n}\nfunction Ys(r) {\n  if (r = r.toLowerCase().trim(), r === \"transparent\")\n    return [0, 0, 0, 0];\n  const e = mt(Ws, r);\n  if (e) {\n    const [a, o, i] = e;\n    return [a / 255, o / 255, i / 255, 1];\n  }\n  if (r.startsWith(\"#\") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {\n    const o = r.length < 6 ? 1 : 2;\n    let i = 1;\n    return [\n      Ut(r.slice(i, i += o)),\n      Ut(r.slice(i, i += o)),\n      Ut(r.slice(i, i += o)),\n      Ut(r.slice(i, i + o) || \"ff\")\n    ];\n  }\n  if (r.startsWith(\"rgb\")) {\n    const a = /^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/, o = r.match(a);\n    if (o) {\n      const [\n        i,\n        // eslint-disable-line @typescript-eslint/no-unused-vars\n        s,\n        // <numeric>\n        l,\n        // %         (optional)\n        u,\n        // ,         (optional)\n        c,\n        // <numeric>\n        p,\n        // %         (optional)\n        d,\n        // ,         (optional)\n        f,\n        // <numeric>\n        h,\n        // %         (optional)\n        m,\n        // ,|/       (optional)\n        y,\n        // <numeric> (optional)\n        w\n        // %         (optional)\n      ] = o, v = [u || \" \", d || \" \", m].join(\"\");\n      if (v === \"  \" || v === \"  /\" || v === \",,\" || v === \",,,\") {\n        const x = [l, p, h].join(\"\"), A = x === \"%%%\" ? 100 : x === \"\" ? 255 : 0;\n        if (A) {\n          const E = [\n            et(+s / A, 0, 1),\n            et(+c / A, 0, 1),\n            et(+f / A, 0, 1),\n            y ? na(+y, w) : 1\n          ];\n          if (aa(E))\n            return E;\n        }\n      }\n      return;\n    }\n  }\n  const t = /^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/, n = r.match(t);\n  if (n) {\n    const [\n      a,\n      // eslint-disable-line @typescript-eslint/no-unused-vars\n      o,\n      // <numeric>\n      i,\n      // ,         (optional)\n      s,\n      // <numeric>\n      l,\n      // ,         (optional)\n      u,\n      // <numeric>\n      c,\n      // ,|/       (optional)\n      p,\n      // <numeric> (optional)\n      d\n      // %         (optional)\n    ] = n, f = [i || \" \", l || \" \", c].join(\"\");\n    if (f === \"  \" || f === \"  /\" || f === \",,\" || f === \",,,\") {\n      const h = [\n        +o,\n        et(+s, 0, 100),\n        et(+u, 0, 100),\n        p ? na(+p, d) : 1\n      ];\n      if (aa(h))\n        return Ks(h);\n    }\n  }\n}\nfunction Ut(r) {\n  return parseInt(r.padEnd(2, r), 16) / 255;\n}\nfunction na(r, e) {\n  return et(e ? r / 100 : r, 0, 1);\n}\nfunction et(r, e, t) {\n  return Math.min(Math.max(e, r), t);\n}\nfunction aa(r) {\n  return !r.some(Number.isNaN);\n}\nconst Ws = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  grey: [128, 128, 128],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  rebeccapurple: [102, 51, 153],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\nfunction Ne(r, e, t) {\n  return r + t * (e - r);\n}\nfunction ot(r, e, t) {\n  return r.map((n, a) => Ne(n, e[a], t));\n}\nclass $ {\n  /**\n   * @param r Red component premultiplied by `alpha` 0..1\n   * @param g Green component premultiplied by `alpha` 0..1\n   * @param b Blue component premultiplied by `alpha` 0..1\n   * @param [alpha=1] Alpha component 0..1\n   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already\n   * been multiplied by alpha. If `true` nothing happens if `false` then they will\n   * be multiplied automatically.\n   */\n  constructor(e, t, n, a = 1, o = !0) {\n    this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter(\"rgb\", [e, t, n, a]));\n  }\n  /**\n   * Parses CSS color strings and converts colors to sRGB color space if needed.\n   * Officially supported color formats:\n   * - keyword, e.g. 'aquamarine' or 'steelblue'\n   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'\n   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'\n   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'\n   *\n   * @param input CSS color string to parse.\n   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.\n   */\n  static parse(e) {\n    if (e instanceof $)\n      return e;\n    if (typeof e != \"string\")\n      return;\n    const t = Ys(e);\n    if (t)\n      return new $(...t, !1);\n  }\n  /**\n   * Used in color interpolation and by 'to-rgba' expression.\n   *\n   * @returns Gien color, with reversed alpha blending, in sRGB color space.\n   */\n  get rgb() {\n    const { r: e, g: t, b: n, a } = this, o = a || 1 / 0;\n    return this.overwriteGetter(\"rgb\", [e / o, t / o, n / o, a]);\n  }\n  /**\n   * Used in color interpolation.\n   *\n   * @returns Gien color, with reversed alpha blending, in HCL color space.\n   */\n  get hcl() {\n    return this.overwriteGetter(\"hcl\", Hs(this.rgb));\n  }\n  /**\n   * Used in color interpolation.\n   *\n   * @returns Gien color, with reversed alpha blending, in LAB color space.\n   */\n  get lab() {\n    return this.overwriteGetter(\"lab\", io(this.rgb));\n  }\n  /**\n   * Lazy getter pattern. When getter is called for the first time lazy value\n   * is calculated and then overwrites getter function in given object instance.\n   *\n   * @example:\n   * const redColor = Color.parse('red');\n   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate\n   * // the value of red in HCL space and invoke this `overwriteGetter` function\n   * // which in turn will set a field with a key 'hcl' in the `redColor` object.\n   * // In other words it will override `get hcl()` from its `Color` prototype\n   * // with its own property: hcl = [calculated red value in hcl].\n   * let y = redColor.hcl; // next call will no longer invoke getter but simply\n   * // return the previously calculated value\n   * x === y; // true - `x` is exactly the same object as `y`\n   *\n   * @param getterKey Getter key\n   * @param lazyValue Lazily calculated value to be memoized by current instance\n   * @private\n   */\n  overwriteGetter(e, t) {\n    return Object.defineProperty(this, e, { value: t }), t;\n  }\n  /**\n   * Used by 'to-string' expression.\n   *\n   * @returns Serialized color in format `rgba(r,g,b,a)`\n   * where r,g,b are numbers within 0..255 and alpha is number within 1..0\n   *\n   * @example\n   * var purple = new Color.parse('purple');\n   * purple.toString; // = \"rgba(128,0,128,1)\"\n   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');\n   * translucentGreen.toString(); // = \"rgba(26,207,26,0.73)\"\n   */\n  toString() {\n    const [e, t, n, a] = this.rgb;\n    return `rgba(${[e, t, n].map((o) => Math.round(o * 255)).join(\",\")},${a})`;\n  }\n  static interpolate(e, t, n, a = \"rgb\") {\n    switch (a) {\n      case \"rgb\": {\n        const [o, i, s, l] = ot(e.rgb, t.rgb, n);\n        return new $(o, i, s, l, !1);\n      }\n      case \"hcl\": {\n        const [o, i, s, l] = e.hcl, [u, c, p, d] = t.hcl;\n        let f, h;\n        if (!isNaN(o) && !isNaN(u)) {\n          let x = u - o;\n          u > o && x > 180 ? x -= 360 : u < o && o - u > 180 && (x += 360), f = o + n * x;\n        } else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (h = c)) : (f = o, (p === 1 || p === 0) && (h = i));\n        const [m, y, w, v] = Zs([\n          f,\n          h ?? Ne(i, c, n),\n          Ne(s, p, n),\n          Ne(l, d, n)\n        ]);\n        return new $(m, y, w, v, !1);\n      }\n      case \"lab\": {\n        const [o, i, s, l] = so(ot(e.lab, t.lab, n));\n        return new $(o, i, s, l, !1);\n      }\n    }\n  }\n}\n$.black = new $(0, 0, 0, 1);\n$.white = new $(1, 1, 1, 1);\n$.transparent = new $(0, 0, 0, 0);\n$.red = new $(1, 0, 0, 1);\nclass yn {\n  constructor(e, t, n) {\n    e ? this.sensitivity = t ? \"variant\" : \"case\" : this.sensitivity = t ? \"accent\" : \"base\", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: \"search\" });\n  }\n  compare(e, t) {\n    return this.collator.compare(e, t);\n  }\n  resolvedLocale() {\n    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n  }\n}\nconst Js = [\"bottom\", \"center\", \"top\"];\nclass Zr {\n  constructor(e, t, n, a, o, i) {\n    this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;\n  }\n}\nclass Ae {\n  constructor(e) {\n    this.sections = e;\n  }\n  static fromString(e) {\n    return new Ae([new Zr(e, null, null, null, null, null)]);\n  }\n  isEmpty() {\n    return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);\n  }\n  static factory(e) {\n    return e instanceof Ae ? e : Ae.fromString(e);\n  }\n  toString() {\n    return this.sections.length === 0 ? \"\" : this.sections.map((e) => e.text).join(\"\");\n  }\n}\nclass ie {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * Numeric padding values\n   * @param input A padding value\n   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.\n   */\n  static parse(e) {\n    if (e instanceof ie)\n      return e;\n    if (typeof e == \"number\")\n      return new ie([e, e, e, e]);\n    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {\n      for (const t of e)\n        if (typeof t != \"number\")\n          return;\n      switch (e.length) {\n        case 1:\n          e = [e[0], e[0], e[0], e[0]];\n          break;\n        case 2:\n          e = [e[0], e[1], e[0], e[1]];\n          break;\n        case 3:\n          e = [e[0], e[1], e[2], e[1]];\n          break;\n      }\n      return new ie(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    return new ie(ot(e.values, t.values, n));\n  }\n}\nclass se {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * Numeric NumberArray values\n   * @param input A NumberArray value\n   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.\n   */\n  static parse(e) {\n    if (e instanceof se)\n      return e;\n    if (typeof e == \"number\")\n      return new se([e]);\n    if (Array.isArray(e)) {\n      for (const t of e)\n        if (typeof t != \"number\")\n          return;\n      return new se(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    return new se(ot(e.values, t.values, n));\n  }\n}\nclass Q {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * ColorArray values\n   * @param input A ColorArray value\n   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.\n   */\n  static parse(e) {\n    if (e instanceof Q)\n      return e;\n    if (typeof e == \"string\") {\n      const n = $.parse(e);\n      return n ? new Q([n]) : void 0;\n    }\n    if (!Array.isArray(e))\n      return;\n    const t = [];\n    for (const n of e) {\n      if (typeof n != \"string\")\n        return;\n      const a = $.parse(n);\n      if (!a)\n        return;\n      t.push(a);\n    }\n    return new Q(t);\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n, a = \"rgb\") {\n    const o = [];\n    if (e.values.length != t.values.length)\n      throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);\n    for (let i = 0; i < e.values.length; i++)\n      o.push($.interpolate(e.values[i], t.values[i], n, a));\n    return new Q(o);\n  }\n}\nclass U extends Error {\n  constructor(e) {\n    super(e), this.name = \"RuntimeError\";\n  }\n  toJSON() {\n    return this.message;\n  }\n}\nconst Qs = /* @__PURE__ */ new Set([\"center\", \"left\", \"right\", \"top\", \"bottom\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]);\nclass ye {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  static parse(e) {\n    if (e instanceof ye)\n      return e;\n    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {\n      for (let t = 0; t < e.length; t += 2) {\n        const n = e[t], a = e[t + 1];\n        if (typeof n != \"string\" || !Qs.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != \"number\" || typeof a[1] != \"number\")\n          return;\n      }\n      return new ye(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    const a = e.values, o = t.values;\n    if (a.length !== o.length)\n      throw new U(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);\n    const i = [];\n    for (let s = 0; s < a.length; s += 2) {\n      if (a[s] !== o[s])\n        throw new U(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);\n      i.push(a[s]);\n      const [l, u] = a[s + 1], [c, p] = o[s + 1];\n      i.push([Ne(l, c, n), Ne(u, p, n)]);\n    }\n    return new ye(i);\n  }\n}\nclass De {\n  constructor(e) {\n    this.name = e.name, this.available = e.available;\n  }\n  toString() {\n    return this.name;\n  }\n  static fromString(e) {\n    return e ? new De({ name: e, available: !1 }) : null;\n  }\n}\nclass de {\n  constructor(e, t, n) {\n    this.from = e, this.to = t, this.transition = n;\n  }\n  static interpolate(e, t, n) {\n    return new de(e, t, n);\n  }\n  static parse(e) {\n    if (e instanceof de)\n      return e;\n    if (Array.isArray(e) && e.length === 3 && typeof e[0] == \"string\" && typeof e[1] == \"string\" && typeof e[2] == \"number\")\n      return new de(e[0], e[1], e[2]);\n    if (typeof e == \"object\" && typeof e.from == \"string\" && typeof e.to == \"string\" && typeof e.transition == \"number\")\n      return new de(e.from, e.to, e.transition);\n    if (typeof e == \"string\")\n      return new de(e, e, 1);\n  }\n}\nfunction lo(r, e, t, n) {\n  return typeof r == \"number\" && r >= 0 && r <= 255 && typeof e == \"number\" && e >= 0 && e <= 255 && typeof t == \"number\" && t >= 0 && t <= 255 ? typeof n > \"u\" || typeof n == \"number\" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[r, e, t, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == \"number\" ? [r, e, t, n] : [r, e, t]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n}\nfunction wt(r) {\n  if (r === null || typeof r == \"string\" || typeof r == \"boolean\" || typeof r == \"number\" || r instanceof de || r instanceof $ || r instanceof yn || r instanceof Ae || r instanceof ie || r instanceof se || r instanceof Q || r instanceof ye || r instanceof De)\n    return !0;\n  if (Array.isArray(r)) {\n    for (const e of r)\n      if (!wt(e))\n        return !1;\n    return !0;\n  } else if (typeof r == \"object\") {\n    for (const e in r)\n      if (!wt(r[e]))\n        return !1;\n    return !0;\n  } else\n    return !1;\n}\nfunction q(r) {\n  if (r === null)\n    return sr;\n  if (typeof r == \"string\")\n    return P;\n  if (typeof r == \"boolean\")\n    return M;\n  if (typeof r == \"number\")\n    return S;\n  if (r instanceof $)\n    return Se;\n  if (r instanceof de)\n    return lr;\n  if (r instanceof yn)\n    return ur;\n  if (r instanceof Ae)\n    return cr;\n  if (r instanceof ie)\n    return pr;\n  if (r instanceof se)\n    return fr;\n  if (r instanceof Q)\n    return vt;\n  if (r instanceof ye)\n    return dr;\n  if (r instanceof De)\n    return _t;\n  if (Array.isArray(r)) {\n    const e = r.length;\n    let t;\n    for (const n of r) {\n      const a = q(n);\n      if (!t)\n        t = a;\n      else {\n        if (t === a)\n          continue;\n        t = I;\n        break;\n      }\n    }\n    return ne(t || I, e);\n  } else\n    return Ve;\n}\nfunction yt(r) {\n  const e = typeof r;\n  return r === null ? \"\" : e === \"string\" || e === \"number\" || e === \"boolean\" ? String(r) : r instanceof $ || r instanceof de || r instanceof Ae || r instanceof ie || r instanceof se || r instanceof Q || r instanceof ye || r instanceof De ? r.toString() : JSON.stringify(r);\n}\nclass it {\n  constructor(e, t) {\n    this.type = e, this.value = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (!wt(e[1]))\n      return t.error(\"invalid value\");\n    const n = e[1];\n    let a = q(n);\n    const o = t.expectedType;\n    return a.kind === \"array\" && a.N === 0 && o && o.kind === \"array\" && (typeof o.N != \"number\" || o.N === 0) && (a = o), new it(a, n);\n  }\n  evaluate() {\n    return this.value;\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nconst Bt = {\n  string: P,\n  number: S,\n  boolean: M,\n  object: Ve\n};\nclass he {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    let n = 1, a;\n    const o = e[0];\n    if (o === \"array\") {\n      let s;\n      if (e.length > 2) {\n        const u = e[1];\n        if (typeof u != \"string\" || !(u in Bt) || u === \"object\")\n          return t.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n        s = Bt[u], n++;\n      } else\n        s = I;\n      let l;\n      if (e.length > 3) {\n        if (e[2] !== null && (typeof e[2] != \"number\" || e[2] < 0 || e[2] !== Math.floor(e[2])))\n          return t.error('The length argument to \"array\" must be a positive integer literal', 2);\n        l = e[2], n++;\n      }\n      a = ne(s, l);\n    } else {\n      if (!Bt[o])\n        throw new Error(`Types doesn't contain name = ${o}`);\n      a = Bt[o];\n    }\n    const i = [];\n    for (; n < e.length; n++) {\n      const s = t.parse(e[n], n, I);\n      if (!s)\n        return null;\n      i.push(s);\n    }\n    return new he(a, i);\n  }\n  evaluate(e) {\n    for (let t = 0; t < this.args.length; t++) {\n      const n = this.args[t].evaluate(e);\n      if (bt(this.type, q(n))) {\n        if (t === this.args.length - 1)\n          throw new U(`Expected value to be of type ${D(this.type)}, but found ${D(q(n))} instead.`);\n      } else return n;\n    }\n    throw new Error();\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every((e) => e.outputDefined());\n  }\n}\nconst oa = {\n  \"to-boolean\": M,\n  \"to-color\": Se,\n  \"to-number\": S,\n  \"to-string\": P\n};\nclass $e {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    const n = e[0];\n    if (!oa[n])\n      throw new Error(`Can't parse ${n} as it is not part of the known types`);\n    if ((n === \"to-boolean\" || n === \"to-string\") && e.length !== 2)\n      return t.error(\"Expected one argument.\");\n    const a = oa[n], o = [];\n    for (let i = 1; i < e.length; i++) {\n      const s = t.parse(e[i], i, I);\n      if (!s)\n        return null;\n      o.push(s);\n    }\n    return new $e(a, o);\n  }\n  evaluate(e) {\n    switch (this.type.kind) {\n      case \"boolean\":\n        return !!this.args[0].evaluate(e);\n      case \"color\": {\n        let t, n;\n        for (const a of this.args) {\n          if (t = a.evaluate(e), n = null, t instanceof $)\n            return t;\n          if (typeof t == \"string\") {\n            const o = e.parseColor(t);\n            if (o)\n              return o;\n          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = lo(t[0], t[1], t[2], t[3]), !n))\n            return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);\n        }\n        throw new U(n || `Could not parse color from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"padding\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = ie.parse(t);\n          if (a)\n            return a;\n        }\n        throw new U(`Could not parse padding from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"numberArray\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = se.parse(t);\n          if (a)\n            return a;\n        }\n        throw new U(`Could not parse numberArray from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"colorArray\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = Q.parse(t);\n          if (a)\n            return a;\n        }\n        throw new U(`Could not parse colorArray from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"variableAnchorOffsetCollection\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = ye.parse(t);\n          if (a)\n            return a;\n        }\n        throw new U(`Could not parse variableAnchorOffsetCollection from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"number\": {\n        let t = null;\n        for (const n of this.args) {\n          if (t = n.evaluate(e), t === null)\n            return 0;\n          const a = Number(t);\n          if (!isNaN(a))\n            return a;\n        }\n        throw new U(`Could not convert ${JSON.stringify(t)} to number.`);\n      }\n      case \"formatted\":\n        return Ae.fromString(yt(this.args[0].evaluate(e)));\n      case \"resolvedImage\":\n        return De.fromString(yt(this.args[0].evaluate(e)));\n      case \"projectionDefinition\":\n        return this.args[0].evaluate(e);\n      default:\n        return yt(this.args[0].evaluate(e));\n    }\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every((e) => e.outputDefined());\n  }\n}\nconst el = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\nclass uo {\n  constructor() {\n    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;\n  }\n  id() {\n    return this.feature && \"id\" in this.feature ? this.feature.id : null;\n  }\n  geometryType() {\n    return this.feature ? typeof this.feature.type == \"number\" ? el[this.feature.type] : this.feature.type : null;\n  }\n  geometry() {\n    return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n  }\n  canonicalID() {\n    return this.canonical;\n  }\n  properties() {\n    return this.feature && this.feature.properties || {};\n  }\n  parseColor(e) {\n    let t = this._parseColorCache.get(e);\n    return t || (t = $.parse(e), this._parseColorCache.set(e, t)), t;\n  }\n}\nclass hr {\n  constructor(e, t, n = [], a, o = new hn(), i = []) {\n    this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(\"\"), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;\n  }\n  /**\n   * @param expr the JSON expression to parse\n   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed\n   * @param options\n   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.\n   * @private\n   */\n  parse(e, t, n, a, o = {}) {\n    return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);\n  }\n  _parse(e, t) {\n    (e === null || typeof e == \"string\" || typeof e == \"boolean\" || typeof e == \"number\") && (e = [\"literal\", e]);\n    function n(a, o, i) {\n      return i === \"assert\" ? new he(o, [a]) : i === \"coerce\" ? new $e(o, [a]) : a;\n    }\n    if (Array.isArray(e)) {\n      if (e.length === 0)\n        return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n      const a = e[0];\n      if (typeof a != \"string\")\n        return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n      const o = this.registry[a];\n      if (o) {\n        let i = o.parse(e, this);\n        if (!i)\n          return null;\n        if (this.expectedType) {\n          const s = this.expectedType, l = i.type;\n          if ((s.kind === \"string\" || s.kind === \"number\" || s.kind === \"boolean\" || s.kind === \"object\" || s.kind === \"array\") && l.kind === \"value\")\n            i = n(i, s, t.typeAnnotation || \"assert\");\n          else if (s.kind === \"projectionDefinition\" && [\"string\", \"array\"].includes(l.kind) || [\"color\", \"formatted\", \"resolvedImage\"].includes(s.kind) && [\"value\", \"string\"].includes(l.kind) || [\"padding\", \"numberArray\"].includes(s.kind) && [\"value\", \"number\", \"array\"].includes(l.kind) || s.kind === \"colorArray\" && [\"value\", \"string\", \"array\"].includes(l.kind) || s.kind === \"variableAnchorOffsetCollection\" && [\"value\", \"array\"].includes(l.kind))\n            i = n(i, s, t.typeAnnotation || \"coerce\");\n          else if (this.checkSubtype(s, l))\n            return null;\n        }\n        if (!(i instanceof it) && i.type.kind !== \"resolvedImage\" && this._isConstant(i)) {\n          const s = new uo();\n          try {\n            i = new it(i.type, i.evaluate(s));\n          } catch (l) {\n            return this.error(l.message), null;\n          }\n        }\n        return i;\n      }\n      return this.error(`Unknown expression \"${a}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n    } else return typeof e > \"u\" ? this.error(\"'undefined' value invalid. Use null instead.\") : typeof e == \"object\" ? this.error('Bare objects invalid. Use [\"literal\", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);\n  }\n  /**\n   * Returns a copy of this context suitable for parsing the subexpression at\n   * index `index`, optionally appending to 'let' binding map.\n   *\n   * Note that `errors` property, intended for collecting errors while\n   * parsing, is copied by reference rather than cloned.\n   * @private\n   */\n  concat(e, t, n) {\n    const a = typeof e == \"number\" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;\n    return new hr(this.registry, this._isConstant, a, t || null, o, this.errors);\n  }\n  /**\n   * Push a parsing (or type checking) error into the `this.errors`\n   * @param error The message\n   * @param keys Optionally specify the source of the error at a child\n   * of the current expression at `this.key`.\n   * @private\n   */\n  error(e, ...t) {\n    const n = `${this.key}${t.map((a) => `[${a}]`).join(\"\")}`;\n    this.errors.push(new we(n, e));\n  }\n  /**\n   * Returns null if `t` is a subtype of `expected`; otherwise returns an\n   * error message and also pushes it to `this.errors`.\n   * @param expected The expected type\n   * @param t The actual type\n   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message\n   */\n  checkSubtype(e, t) {\n    const n = bt(e, t);\n    return n && this.error(n), n;\n  }\n}\nclass mr {\n  constructor(e, t) {\n    this.type = t.type, this.bindings = [].concat(e), this.result = t;\n  }\n  evaluate(e) {\n    return this.result.evaluate(e);\n  }\n  eachChild(e) {\n    for (const t of this.bindings)\n      e(t[1]);\n    e(this.result);\n  }\n  static parse(e, t) {\n    if (e.length < 4)\n      return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);\n    const n = [];\n    for (let o = 1; o < e.length - 1; o += 2) {\n      const i = e[o];\n      if (typeof i != \"string\")\n        return t.error(`Expected string, but found ${typeof i} instead.`, o);\n      if (/[^a-zA-Z0-9_]/.test(i))\n        return t.error(\"Variable names must contain only alphanumeric characters or '_'.\", o);\n      const s = t.parse(e[o + 1], o + 1);\n      if (!s)\n        return null;\n      n.push([i, s]);\n    }\n    const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);\n    return a ? new mr(n, a) : null;\n  }\n  outputDefined() {\n    return this.result.outputDefined();\n  }\n}\nclass yr {\n  constructor(e, t) {\n    this.type = t.type, this.name = e, this.boundExpression = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2 || typeof e[1] != \"string\")\n      return t.error(\"'var' expression requires exactly one string literal argument.\");\n    const n = e[1];\n    return t.scope.has(n) ? new yr(n, t.scope.get(n)) : t.error(`Unknown variable \"${n}\". Make sure \"${n}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n  }\n  evaluate(e) {\n    return this.boundExpression.evaluate(e);\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass gn {\n  constructor(e, t, n) {\n    this.type = e, this.index = t, this.input = n;\n  }\n  static parse(e, t) {\n    if (e.length !== 3)\n      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, S), a = t.parse(e[2], 2, ne(t.expectedType || I));\n    if (!n || !a)\n      return null;\n    const o = a.type;\n    return new gn(o.itemType, n, a);\n  }\n  evaluate(e) {\n    const t = this.index.evaluate(e), n = this.input.evaluate(e);\n    if (t < 0)\n      throw new U(`Array index out of bounds: ${t} < 0.`);\n    if (t >= n.length)\n      throw new U(`Array index out of bounds: ${t} > ${n.length - 1}.`);\n    if (t !== Math.floor(t))\n      throw new U(`Array index must be an integer, but found ${t} instead.`);\n    return n[t];\n  }\n  eachChild(e) {\n    e(this.index), e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass vn {\n  constructor(e, t) {\n    this.type = M, this.needle = e, this.haystack = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 3)\n      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);\n    return !n || !a ? null : mn(n.type, [M, P, S, sr, I]) ? new vn(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);\n  }\n  evaluate(e) {\n    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);\n    if (!n)\n      return !1;\n    if (!Ge(t, [\"boolean\", \"string\", \"number\", \"null\"]))\n      throw new U(`Expected first argument to be of type boolean, string, number or null, but found ${D(q(t))} instead.`);\n    if (!Ge(n, [\"string\", \"array\"]))\n      throw new U(`Expected second argument to be of type array or string, but found ${D(q(n))} instead.`);\n    return n.indexOf(t) >= 0;\n  }\n  eachChild(e) {\n    e(this.needle), e(this.haystack);\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass Wt {\n  constructor(e, t, n) {\n    this.type = S, this.needle = e, this.haystack = t, this.fromIndex = n;\n  }\n  static parse(e, t) {\n    if (e.length <= 2 || e.length >= 5)\n      return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);\n    if (!n || !a)\n      return null;\n    if (!mn(n.type, [M, P, S, sr, I]))\n      return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);\n    if (e.length === 4) {\n      const o = t.parse(e[3], 3, S);\n      return o ? new Wt(n, a, o) : null;\n    } else\n      return new Wt(n, a);\n  }\n  evaluate(e) {\n    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);\n    if (!Ge(t, [\"boolean\", \"string\", \"number\", \"null\"]))\n      throw new U(`Expected first argument to be of type boolean, string, number or null, but found ${D(q(t))} instead.`);\n    let a;\n    if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ge(n, [\"string\"])) {\n      const o = n.indexOf(t, a);\n      return o === -1 ? -1 : [...n.slice(0, o)].length;\n    } else {\n      if (Ge(n, [\"array\"]))\n        return n.indexOf(t, a);\n      throw new U(`Expected second argument to be of type array or string, but found ${D(q(n))} instead.`);\n    }\n  }\n  eachChild(e) {\n    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass bn {\n  constructor(e, t, n, a, o, i) {\n    this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;\n  }\n  static parse(e, t) {\n    if (e.length < 5)\n      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if (e.length % 2 !== 1)\n      return t.error(\"Expected an even number of arguments.\");\n    let n, a;\n    t.expectedType && t.expectedType.kind !== \"value\" && (a = t.expectedType);\n    const o = {}, i = [];\n    for (let u = 2; u < e.length - 1; u += 2) {\n      let c = e[u];\n      const p = e[u + 1];\n      Array.isArray(c) || (c = [c]);\n      const d = t.concat(u);\n      if (c.length === 0)\n        return d.error(\"Expected at least one branch label.\");\n      for (const h of c) {\n        if (typeof h != \"number\" && typeof h != \"string\")\n          return d.error(\"Branch labels must be numbers or strings.\");\n        if (typeof h == \"number\" && Math.abs(h) > Number.MAX_SAFE_INTEGER)\n          return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n        if (typeof h == \"number\" && Math.floor(h) !== h)\n          return d.error(\"Numeric branch labels must be integer values.\");\n        if (!n)\n          n = q(h);\n        else if (d.checkSubtype(n, q(h)))\n          return null;\n        if (typeof o[String(h)] < \"u\")\n          return d.error(\"Branch labels must be unique.\");\n        o[String(h)] = i.length;\n      }\n      const f = t.parse(p, u, a);\n      if (!f)\n        return null;\n      a = a || f.type, i.push(f);\n    }\n    const s = t.parse(e[1], 1, I);\n    if (!s)\n      return null;\n    const l = t.parse(e[e.length - 1], e.length - 1, a);\n    return !l || s.type.kind !== \"value\" && t.concat(1).checkSubtype(n, s.type) ? null : new bn(n, a, s, o, i, l);\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e);\n    return (q(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);\n  }\n  eachChild(e) {\n    e(this.input), this.outputs.forEach(e), e(this.otherwise);\n  }\n  outputDefined() {\n    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();\n  }\n}\nclass wn {\n  constructor(e, t, n) {\n    this.type = e, this.branches = t, this.otherwise = n;\n  }\n  static parse(e, t) {\n    if (e.length < 4)\n      return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);\n    if (e.length % 2 !== 0)\n      return t.error(\"Expected an odd number of arguments.\");\n    let n;\n    t.expectedType && t.expectedType.kind !== \"value\" && (n = t.expectedType);\n    const a = [];\n    for (let i = 1; i < e.length - 1; i += 2) {\n      const s = t.parse(e[i], i, M);\n      if (!s)\n        return null;\n      const l = t.parse(e[i + 1], i + 1, n);\n      if (!l)\n        return null;\n      a.push([s, l]), n = n || l.type;\n    }\n    const o = t.parse(e[e.length - 1], e.length - 1, n);\n    if (!o)\n      return null;\n    if (!n)\n      throw new Error(\"Can't infer output type\");\n    return new wn(n, a, o);\n  }\n  evaluate(e) {\n    for (const [t, n] of this.branches)\n      if (t.evaluate(e))\n        return n.evaluate(e);\n    return this.otherwise.evaluate(e);\n  }\n  eachChild(e) {\n    for (const [t, n] of this.branches)\n      e(t), e(n);\n    e(this.otherwise);\n  }\n  outputDefined() {\n    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();\n  }\n}\nclass Jt {\n  constructor(e, t, n, a) {\n    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;\n  }\n  static parse(e, t) {\n    if (e.length <= 2 || e.length >= 5)\n      return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, S);\n    if (!n || !a)\n      return null;\n    if (!mn(n.type, [ne(I), P, I]))\n      return t.error(`Expected first argument to be of type array or string, but found ${D(n.type)} instead`);\n    if (e.length === 4) {\n      const o = t.parse(e[3], 3, S);\n      return o ? new Jt(n.type, n, a, o) : null;\n    } else\n      return new Jt(n.type, n, a);\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);\n    let a;\n    if (this.endIndex && (a = this.endIndex.evaluate(e)), Ge(t, [\"string\"]))\n      return [...t].slice(n, a).join(\"\");\n    if (Ge(t, [\"array\"]))\n      return t.slice(n, a);\n    throw new U(`Expected first argument to be of type array or string, but found ${D(q(t))} instead.`);\n  }\n  eachChild(e) {\n    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nfunction co(r, e) {\n  const t = r.length - 1;\n  let n = 0, a = t, o = 0, i, s;\n  for (; n <= a; )\n    if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {\n      if (o === t || e < s)\n        return o;\n      n = o + 1;\n    } else if (i > e)\n      a = o - 1;\n    else\n      throw new U(\"Input is not a number.\");\n  return 0;\n}\nclass gr {\n  constructor(e, t, n) {\n    this.type = e, this.input = t, this.labels = [], this.outputs = [];\n    for (const [a, o] of n)\n      this.labels.push(a), this.outputs.push(o);\n  }\n  static parse(e, t) {\n    if (e.length - 1 < 4)\n      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if ((e.length - 1) % 2 !== 0)\n      return t.error(\"Expected an even number of arguments.\");\n    const n = t.parse(e[1], 1, S);\n    if (!n)\n      return null;\n    const a = [];\n    let o = null;\n    t.expectedType && t.expectedType.kind !== \"value\" && (o = t.expectedType);\n    for (let i = 1; i < e.length; i += 2) {\n      const s = i === 1 ? -1 / 0 : e[i], l = e[i + 1], u = i, c = i + 1;\n      if (typeof s != \"number\")\n        return t.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);\n      if (a.length && a[a.length - 1][0] >= s)\n        return t.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', u);\n      const p = t.parse(l, c, o);\n      if (!p)\n        return null;\n      o = o || p.type, a.push([s, p]);\n    }\n    return new gr(o, n, a);\n  }\n  evaluate(e) {\n    const t = this.labels, n = this.outputs;\n    if (t.length === 1)\n      return n[0].evaluate(e);\n    const a = this.input.evaluate(e);\n    if (a <= t[0])\n      return n[0].evaluate(e);\n    const o = t.length;\n    if (a >= t[o - 1])\n      return n[o - 1].evaluate(e);\n    const i = co(t, a);\n    return n[i].evaluate(e);\n  }\n  eachChild(e) {\n    e(this.input);\n    for (const t of this.outputs)\n      e(t);\n  }\n  outputDefined() {\n    return this.outputs.every((e) => e.outputDefined());\n  }\n}\nfunction tl(r) {\n  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, \"default\") ? r.default : r;\n}\nvar Pr, ia;\nfunction rl() {\n  if (ia) return Pr;\n  ia = 1, Pr = r;\n  function r(e, t, n, a) {\n    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;\n  }\n  return r.prototype = {\n    sampleCurveX: function(e) {\n      return ((this.ax * e + this.bx) * e + this.cx) * e;\n    },\n    sampleCurveY: function(e) {\n      return ((this.ay * e + this.by) * e + this.cy) * e;\n    },\n    sampleCurveDerivativeX: function(e) {\n      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;\n    },\n    solveCurveX: function(e, t) {\n      if (t === void 0 && (t = 1e-6), e < 0) return 0;\n      if (e > 1) return 1;\n      for (var n = e, a = 0; a < 8; a++) {\n        var o = this.sampleCurveX(n) - e;\n        if (Math.abs(o) < t) return n;\n        var i = this.sampleCurveDerivativeX(n);\n        if (Math.abs(i) < 1e-6) break;\n        n = n - o / i;\n      }\n      var s = 0, l = 1;\n      for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++)\n        e > o ? s = n : l = n, n = (l - s) * 0.5 + s;\n      return n;\n    },\n    solve: function(e, t) {\n      return this.sampleCurveY(this.solveCurveX(e, t));\n    }\n  }, Pr;\n}\nvar nl = rl(), al = /* @__PURE__ */ tl(nl);\nclass xe {\n  constructor(e, t, n, a, o) {\n    this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];\n    for (const [i, s] of o)\n      this.labels.push(i), this.outputs.push(s);\n  }\n  static interpolationFactor(e, t, n, a) {\n    let o = 0;\n    if (e.name === \"exponential\")\n      o = Rr(t, e.base, n, a);\n    else if (e.name === \"linear\")\n      o = Rr(t, 1, n, a);\n    else if (e.name === \"cubic-bezier\") {\n      const i = e.controlPoints;\n      o = new al(i[0], i[1], i[2], i[3]).solve(Rr(t, 1, n, a));\n    }\n    return o;\n  }\n  static parse(e, t) {\n    let [n, a, o, ...i] = e;\n    if (!Array.isArray(a) || a.length === 0)\n      return t.error(\"Expected an interpolation type expression.\", 1);\n    if (a[0] === \"linear\")\n      a = { name: \"linear\" };\n    else if (a[0] === \"exponential\") {\n      const u = a[1];\n      if (typeof u != \"number\")\n        return t.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n      a = {\n        name: \"exponential\",\n        base: u\n      };\n    } else if (a[0] === \"cubic-bezier\") {\n      const u = a.slice(1);\n      if (u.length !== 4 || u.some((c) => typeof c != \"number\" || c < 0 || c > 1))\n        return t.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n      a = {\n        name: \"cubic-bezier\",\n        controlPoints: u\n      };\n    } else\n      return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);\n    if (e.length - 1 < 4)\n      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if ((e.length - 1) % 2 !== 0)\n      return t.error(\"Expected an even number of arguments.\");\n    if (o = t.parse(o, 2, S), !o)\n      return null;\n    const s = [];\n    let l = null;\n    (n === \"interpolate-hcl\" || n === \"interpolate-lab\") && t.expectedType != vt ? l = Se : t.expectedType && t.expectedType.kind !== \"value\" && (l = t.expectedType);\n    for (let u = 0; u < i.length; u += 2) {\n      const c = i[u], p = i[u + 1], d = u + 3, f = u + 4;\n      if (typeof c != \"number\")\n        return t.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', d);\n      if (s.length && s[s.length - 1][0] >= c)\n        return t.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', d);\n      const h = t.parse(p, f, l);\n      if (!h)\n        return null;\n      l = l || h.type, s.push([c, h]);\n    }\n    return !Ie(l, S) && !Ie(l, lr) && !Ie(l, Se) && !Ie(l, pr) && !Ie(l, fr) && !Ie(l, vt) && !Ie(l, dr) && !Ie(l, ne(S)) ? t.error(`Type ${D(l)} is not interpolatable.`) : new xe(l, n, a, o, s);\n  }\n  evaluate(e) {\n    const t = this.labels, n = this.outputs;\n    if (t.length === 1)\n      return n[0].evaluate(e);\n    const a = this.input.evaluate(e);\n    if (a <= t[0])\n      return n[0].evaluate(e);\n    const o = t.length;\n    if (a >= t[o - 1])\n      return n[o - 1].evaluate(e);\n    const i = co(t, a), s = t[i], l = t[i + 1], u = xe.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);\n    switch (this.operator) {\n      case \"interpolate\":\n        switch (this.type.kind) {\n          case \"number\":\n            return Ne(c, p, u);\n          case \"color\":\n            return $.interpolate(c, p, u);\n          case \"padding\":\n            return ie.interpolate(c, p, u);\n          case \"colorArray\":\n            return Q.interpolate(c, p, u);\n          case \"numberArray\":\n            return se.interpolate(c, p, u);\n          case \"variableAnchorOffsetCollection\":\n            return ye.interpolate(c, p, u);\n          case \"array\":\n            return ot(c, p, u);\n          case \"projectionDefinition\":\n            return de.interpolate(c, p, u);\n        }\n      case \"interpolate-hcl\":\n        switch (this.type.kind) {\n          case \"color\":\n            return $.interpolate(c, p, u, \"hcl\");\n          case \"colorArray\":\n            return Q.interpolate(c, p, u, \"hcl\");\n        }\n      case \"interpolate-lab\":\n        switch (this.type.kind) {\n          case \"color\":\n            return $.interpolate(c, p, u, \"lab\");\n          case \"colorArray\":\n            return Q.interpolate(c, p, u, \"lab\");\n        }\n    }\n  }\n  eachChild(e) {\n    e(this.input);\n    for (const t of this.outputs)\n      e(t);\n  }\n  outputDefined() {\n    return this.outputs.every((e) => e.outputDefined());\n  }\n}\nfunction Rr(r, e, t, n) {\n  const a = n - t, o = r - t;\n  return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);\n}\n$.interpolate, ie.interpolate, se.interpolate, Q.interpolate, ye.interpolate;\nclass St {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    let n = null;\n    const a = t.expectedType;\n    a && a.kind !== \"value\" && (n = a);\n    const o = [];\n    for (const s of e.slice(1)) {\n      const l = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: \"omit\" });\n      if (!l)\n        return null;\n      n = n || l.type, o.push(l);\n    }\n    if (!n)\n      throw new Error(\"No output type\");\n    return a && o.some((s) => bt(a, s.type)) ? new St(I, o) : new St(n, o);\n  }\n  evaluate(e) {\n    let t = null, n = 0, a;\n    for (const o of this.args)\n      if (n++, t = o.evaluate(e), t && t instanceof De && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null)\n        break;\n    return t;\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every((e) => e.outputDefined());\n  }\n}\nfunction sa(r, e) {\n  return r === \"==\" || r === \"!=\" ? e.kind === \"boolean\" || e.kind === \"string\" || e.kind === \"number\" || e.kind === \"null\" || e.kind === \"value\" : e.kind === \"string\" || e.kind === \"number\" || e.kind === \"value\";\n}\nfunction ol(r, e, t) {\n  return e === t;\n}\nfunction il(r, e, t) {\n  return e !== t;\n}\nfunction sl(r, e, t) {\n  return e < t;\n}\nfunction ll(r, e, t) {\n  return e > t;\n}\nfunction ul(r, e, t) {\n  return e <= t;\n}\nfunction cl(r, e, t) {\n  return e >= t;\n}\nfunction po(r, e, t, n) {\n  return n.compare(e, t) === 0;\n}\nfunction pl(r, e, t, n) {\n  return !po(r, e, t, n);\n}\nfunction fl(r, e, t, n) {\n  return n.compare(e, t) < 0;\n}\nfunction dl(r, e, t, n) {\n  return n.compare(e, t) > 0;\n}\nfunction hl(r, e, t, n) {\n  return n.compare(e, t) <= 0;\n}\nfunction ml(r, e, t, n) {\n  return n.compare(e, t) >= 0;\n}\nfunction lt(r, e, t) {\n  const n = r !== \"==\" && r !== \"!=\";\n  return class fo {\n    constructor(o, i, s) {\n      this.type = M, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === \"value\" || i.type.kind === \"value\";\n    }\n    static parse(o, i) {\n      if (o.length !== 3 && o.length !== 4)\n        return i.error(\"Expected two or three arguments.\");\n      const s = o[0];\n      let l = i.parse(o[1], 1, I);\n      if (!l)\n        return null;\n      if (!sa(s, l.type))\n        return i.concat(1).error(`\"${s}\" comparisons are not supported for type '${D(l.type)}'.`);\n      let u = i.parse(o[2], 2, I);\n      if (!u)\n        return null;\n      if (!sa(s, u.type))\n        return i.concat(2).error(`\"${s}\" comparisons are not supported for type '${D(u.type)}'.`);\n      if (l.type.kind !== u.type.kind && l.type.kind !== \"value\" && u.type.kind !== \"value\")\n        return i.error(`Cannot compare types '${D(l.type)}' and '${D(u.type)}'.`);\n      n && (l.type.kind === \"value\" && u.type.kind !== \"value\" ? l = new he(u.type, [l]) : l.type.kind !== \"value\" && u.type.kind === \"value\" && (u = new he(l.type, [u])));\n      let c = null;\n      if (o.length === 4) {\n        if (l.type.kind !== \"string\" && u.type.kind !== \"string\" && l.type.kind !== \"value\" && u.type.kind !== \"value\")\n          return i.error(\"Cannot use collator to compare non-string types.\");\n        if (c = i.parse(o[3], 3, ur), !c)\n          return null;\n      }\n      return new fo(l, u, c);\n    }\n    evaluate(o) {\n      const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);\n      if (n && this.hasUntypedArgument) {\n        const l = q(i), u = q(s);\n        if (l.kind !== u.kind || !(l.kind === \"string\" || l.kind === \"number\"))\n          throw new U(`Expected arguments for \"${r}\" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);\n      }\n      if (this.collator && !n && this.hasUntypedArgument) {\n        const l = q(i), u = q(s);\n        if (l.kind !== \"string\" || u.kind !== \"string\")\n          return e(o, i, s);\n      }\n      return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);\n    }\n    eachChild(o) {\n      o(this.lhs), o(this.rhs), this.collator && o(this.collator);\n    }\n    outputDefined() {\n      return !0;\n    }\n  };\n}\nconst yl = lt(\"==\", ol, po), gl = lt(\"!=\", il, pl), vl = lt(\"<\", sl, fl), bl = lt(\">\", ll, dl), wl = lt(\"<=\", ul, hl), Sl = lt(\">=\", cl, ml);\nclass vr {\n  constructor(e, t, n) {\n    this.type = ur, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(\"Expected one argument.\");\n    const n = e[1];\n    if (typeof n != \"object\" || Array.isArray(n))\n      return t.error(\"Collator options argument must be an object.\");\n    const a = t.parse(n[\"case-sensitive\"] === void 0 ? !1 : n[\"case-sensitive\"], 1, M);\n    if (!a)\n      return null;\n    const o = t.parse(n[\"diacritic-sensitive\"] === void 0 ? !1 : n[\"diacritic-sensitive\"], 1, M);\n    if (!o)\n      return null;\n    let i = null;\n    return n.locale && (i = t.parse(n.locale, 1, P), !i) ? null : new vr(a, o, i);\n  }\n  evaluate(e) {\n    return new yn(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);\n  }\n  eachChild(e) {\n    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass Sn {\n  constructor(e, t, n, a, o) {\n    this.type = P, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;\n  }\n  static parse(e, t) {\n    if (e.length !== 3)\n      return t.error(\"Expected two arguments.\");\n    const n = t.parse(e[1], 1, S);\n    if (!n)\n      return null;\n    const a = e[2];\n    if (typeof a != \"object\" || Array.isArray(a))\n      return t.error(\"NumberFormat options argument must be an object.\");\n    let o = null;\n    if (a.locale && (o = t.parse(a.locale, 1, P), !o))\n      return null;\n    let i = null;\n    if (a.currency && (i = t.parse(a.currency, 1, P), !i))\n      return null;\n    let s = null;\n    if (a[\"min-fraction-digits\"] && (s = t.parse(a[\"min-fraction-digits\"], 1, S), !s))\n      return null;\n    let l = null;\n    return a[\"max-fraction-digits\"] && (l = t.parse(a[\"max-fraction-digits\"], 1, S), !l) ? null : new Sn(n, o, i, s, l);\n  }\n  evaluate(e) {\n    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {\n      style: this.currency ? \"currency\" : \"decimal\",\n      currency: this.currency ? this.currency.evaluate(e) : void 0,\n      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,\n      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0\n    }).format(this.number.evaluate(e));\n  }\n  eachChild(e) {\n    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass xn {\n  constructor(e) {\n    this.type = cr, this.sections = e;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    const n = e[1];\n    if (!Array.isArray(n) && typeof n == \"object\")\n      return t.error(\"First argument must be an image or text section.\");\n    const a = [];\n    let o = !1;\n    for (let i = 1; i <= e.length - 1; ++i) {\n      const s = e[i];\n      if (o && typeof s == \"object\" && !Array.isArray(s)) {\n        o = !1;\n        let l = null;\n        if (s[\"font-scale\"] && (l = t.parse(s[\"font-scale\"], 1, S), !l))\n          return null;\n        let u = null;\n        if (s[\"text-font\"] && (u = t.parse(s[\"text-font\"], 1, ne(P)), !u))\n          return null;\n        let c = null;\n        if (s[\"text-color\"] && (c = t.parse(s[\"text-color\"], 1, Se), !c))\n          return null;\n        let p = null;\n        if (s[\"vertical-align\"]) {\n          if (typeof s[\"vertical-align\"] == \"string\" && !Js.includes(s[\"vertical-align\"]))\n            return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s[\"vertical-align\"]}' instead.`);\n          if (p = t.parse(s[\"vertical-align\"], 1, P), !p)\n            return null;\n        }\n        const d = a[a.length - 1];\n        d.scale = l, d.font = u, d.textColor = c, d.verticalAlign = p;\n      } else {\n        const l = t.parse(e[i], 1, I);\n        if (!l)\n          return null;\n        const u = l.type.kind;\n        if (u !== \"string\" && u !== \"value\" && u !== \"null\" && u !== \"resolvedImage\")\n          return t.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n        o = !0, a.push({ content: l, scale: null, font: null, textColor: null, verticalAlign: null });\n      }\n    }\n    return new xn(a);\n  }\n  evaluate(e) {\n    const t = (n) => {\n      const a = n.content.evaluate(e);\n      return q(a) === _t ? new Zr(\"\", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new Zr(yt(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(\",\") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);\n    };\n    return new Ae(this.sections.map(t));\n  }\n  eachChild(e) {\n    for (const t of this.sections)\n      e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass kn {\n  constructor(e) {\n    this.type = _t, this.input = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(\"Expected two arguments.\");\n    const n = t.parse(e[1], 1, P);\n    return n ? new kn(n) : t.error(\"No image name provided.\");\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e), n = De.fromString(t);\n    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;\n  }\n  eachChild(e) {\n    e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass Ln {\n  constructor(e) {\n    this.type = S, this.input = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1);\n    return n ? n.type.kind !== \"array\" && n.type.kind !== \"string\" && n.type.kind !== \"value\" ? t.error(`Expected argument of type string or array, but found ${D(n.type)} instead.`) : new Ln(n) : null;\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e);\n    if (typeof t == \"string\")\n      return [...t].length;\n    if (Array.isArray(t))\n      return t.length;\n    throw new U(`Expected value to be of type string or array, but found ${D(q(t))} instead.`);\n  }\n  eachChild(e) {\n    e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nconst ke = 8192;\nfunction xl(r, e) {\n  const t = kl(r[0]), n = El(r[1]), a = Math.pow(2, e.z);\n  return [Math.round(t * a * ke), Math.round(n * a * ke)];\n}\nfunction En(r, e) {\n  const t = Math.pow(2, e.z), n = (r[0] / ke + e.x) / t, a = (r[1] / ke + e.y) / t;\n  return [Ll(n), Cl(a)];\n}\nfunction kl(r) {\n  return (180 + r) / 360;\n}\nfunction Ll(r) {\n  return r * 360 - 180;\n}\nfunction El(r) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;\n}\nfunction Cl(r) {\n  return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;\n}\nfunction It(r, e) {\n  r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);\n}\nfunction xt(r, e) {\n  return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);\n}\nfunction Al(r, e, t) {\n  return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];\n}\nfunction Tl(r, e, t) {\n  const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];\n  return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;\n}\nfunction br(r, e, t, n) {\n  const a = [e[0] - r[0], e[1] - r[1]], o = [n[0] - t[0], n[1] - t[1]];\n  return Pl(o, a) === 0 ? !1 : !!(la(r, e, t, n) && la(t, n, r, e));\n}\nfunction _l(r, e, t) {\n  for (const n of t)\n    for (let a = 0; a < n.length - 1; ++a)\n      if (br(r, e, n[a], n[a + 1]))\n        return !0;\n  return !1;\n}\nfunction ut(r, e, t = !1) {\n  let n = !1;\n  for (const a of e)\n    for (let o = 0; o < a.length - 1; o++) {\n      if (Tl(r, a[o], a[o + 1]))\n        return t;\n      Al(r, a[o], a[o + 1]) && (n = !n);\n    }\n  return n;\n}\nfunction Il(r, e) {\n  for (const t of e)\n    if (ut(r, t))\n      return !0;\n  return !1;\n}\nfunction ho(r, e) {\n  for (const t of r)\n    if (!ut(t, e))\n      return !1;\n  for (let t = 0; t < r.length - 1; ++t)\n    if (_l(r[t], r[t + 1], e))\n      return !1;\n  return !0;\n}\nfunction Ml(r, e) {\n  for (const t of e)\n    if (ho(r, t))\n      return !0;\n  return !1;\n}\nfunction Pl(r, e) {\n  return r[0] * e[1] - r[1] * e[0];\n}\nfunction la(r, e, t, n) {\n  const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;\n  return c > 0 && p < 0 || c < 0 && p > 0;\n}\nfunction Cn(r, e, t) {\n  const n = [];\n  for (let a = 0; a < r.length; a++) {\n    const o = [];\n    for (let i = 0; i < r[a].length; i++) {\n      const s = xl(r[a][i], t);\n      It(e, s), o.push(s);\n    }\n    n.push(o);\n  }\n  return n;\n}\nfunction mo(r, e, t) {\n  const n = [];\n  for (let a = 0; a < r.length; a++) {\n    const o = Cn(r[a], e, t);\n    n.push(o);\n  }\n  return n;\n}\nfunction yo(r, e, t, n) {\n  if (r[0] < t[0] || r[0] > t[2]) {\n    const a = n * 0.5;\n    let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;\n    o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;\n  }\n  It(e, r);\n}\nfunction Rl(r) {\n  r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;\n}\nfunction ua(r, e, t, n) {\n  const a = Math.pow(2, n.z) * ke, o = [n.x * ke, n.y * ke], i = [];\n  for (const s of r)\n    for (const l of s) {\n      const u = [l.x + o[0], l.y + o[1]];\n      yo(u, e, t, a), i.push(u);\n    }\n  return i;\n}\nfunction ca(r, e, t, n) {\n  const a = Math.pow(2, n.z) * ke, o = [n.x * ke, n.y * ke], i = [];\n  for (const s of r) {\n    const l = [];\n    for (const u of s) {\n      const c = [u.x + o[0], u.y + o[1]];\n      It(e, c), l.push(c);\n    }\n    i.push(l);\n  }\n  if (e[2] - e[0] <= a / 2) {\n    Rl(e);\n    for (const s of i)\n      for (const l of s)\n        yo(l, e, t, a);\n  }\n  return i;\n}\nfunction zl(r, e) {\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();\n  if (e.type === \"Polygon\") {\n    const o = Cn(e.coordinates, n, a), i = ua(r.geometry(), t, n, a);\n    if (!xt(t, n))\n      return !1;\n    for (const s of i)\n      if (!ut(s, o))\n        return !1;\n  }\n  if (e.type === \"MultiPolygon\") {\n    const o = mo(e.coordinates, n, a), i = ua(r.geometry(), t, n, a);\n    if (!xt(t, n))\n      return !1;\n    for (const s of i)\n      if (!Il(s, o))\n        return !1;\n  }\n  return !0;\n}\nfunction Ol(r, e) {\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();\n  if (e.type === \"Polygon\") {\n    const o = Cn(e.coordinates, n, a), i = ca(r.geometry(), t, n, a);\n    if (!xt(t, n))\n      return !1;\n    for (const s of i)\n      if (!ho(s, o))\n        return !1;\n  }\n  if (e.type === \"MultiPolygon\") {\n    const o = mo(e.coordinates, n, a), i = ca(r.geometry(), t, n, a);\n    if (!xt(t, n))\n      return !1;\n    for (const s of i)\n      if (!Ml(s, o))\n        return !1;\n  }\n  return !0;\n}\nclass He {\n  constructor(e, t) {\n    this.type = M, this.geojson = e, this.geometries = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (wt(e[1])) {\n      const n = e[1];\n      if (n.type === \"FeatureCollection\") {\n        const a = [];\n        for (const o of n.features) {\n          const { type: i, coordinates: s } = o.geometry;\n          i === \"Polygon\" && a.push(s), i === \"MultiPolygon\" && a.push(...s);\n        }\n        if (a.length) {\n          const o = {\n            type: \"MultiPolygon\",\n            coordinates: a\n          };\n          return new He(n, o);\n        }\n      } else if (n.type === \"Feature\") {\n        const a = n.geometry.type;\n        if (a === \"Polygon\" || a === \"MultiPolygon\")\n          return new He(n, n.geometry);\n      } else if (n.type === \"Polygon\" || n.type === \"MultiPolygon\")\n        return new He(n, n);\n    }\n    return t.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n  }\n  evaluate(e) {\n    if (e.geometry() != null && e.canonicalID() != null) {\n      if (e.geometryType() === \"Point\")\n        return zl(e, this.geometries);\n      if (e.geometryType() === \"LineString\")\n        return Ol(e, this.geometries);\n    }\n    return !1;\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass go {\n  constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {\n    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)\n      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);\n  }\n  push(e) {\n    this.data.push(e), this._up(this.length++);\n  }\n  pop() {\n    if (this.length === 0) return;\n    const e = this.data[0], t = this.data.pop();\n    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;\n  }\n  peek() {\n    return this.data[0];\n  }\n  _up(e) {\n    const { data: t, compare: n } = this, a = t[e];\n    for (; e > 0; ) {\n      const o = e - 1 >> 1, i = t[o];\n      if (n(a, i) >= 0) break;\n      t[e] = i, e = o;\n    }\n    t[e] = a;\n  }\n  _down(e) {\n    const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];\n    for (; e < a; ) {\n      let i = (e << 1) + 1;\n      const s = i + 1;\n      if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;\n      t[e] = t[i], e = i;\n    }\n    t[e] = o;\n  }\n}\nfunction $l(r, e) {\n  if (r.length <= 1)\n    return [r];\n  const n = [];\n  let a, o;\n  for (const i of r) {\n    const s = Fl(i);\n    s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));\n  }\n  return a && n.push(a), n;\n}\nfunction Fl(r) {\n  let e = 0;\n  for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++)\n    o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);\n  return e;\n}\nconst Nl = 6378.137, pa = 1 / 298.257223563, fa = pa * (2 - pa), da = Math.PI / 180;\nclass An {\n  constructor(e) {\n    const t = da * Nl * 1e3, n = Math.cos(e * da), a = 1 / (1 - fa * (1 - n * n)), o = Math.sqrt(a);\n    this.kx = t * o * n, this.ky = t * o * a * (1 - fa);\n  }\n  /**\n   * Given two points of the form [longitude, latitude], returns the distance.\n   *\n   * @param a - point [longitude, latitude]\n   * @param b - point [longitude, latitude]\n   * @returns distance\n   * @example\n   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);\n   * //=distance\n   */\n  distance(e, t) {\n    const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;\n    return Math.sqrt(n * n + a * a);\n  }\n  /**\n   * Returns an object of the form {point, index, t}, where point is closest point on the line\n   * from the given point, index is the start index of the segment with the closest point,\n   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.\n   *\n   * @param line - an array of points that form the line\n   * @param p - point [longitude, latitude]\n   * @returns the nearest point, its index in the array and the proportion along the line\n   * @example\n   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;\n   * //=point\n   */\n  pointOnLine(e, t) {\n    let n = 1 / 0, a, o, i, s;\n    for (let l = 0; l < e.length - 1; l++) {\n      let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, d = (e[l + 1][1] - c) * this.ky, f = 0;\n      (p !== 0 || d !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * d) / (p * p + d * d), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += d / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, d = (t[1] - c) * this.ky;\n      const h = p * p + d * d;\n      h < n && (n = h, a = u, o = c, i = l, s = f);\n    }\n    return {\n      point: [a, o],\n      index: i,\n      t: Math.max(0, Math.min(1, s))\n    };\n  }\n  wrap(e) {\n    for (; e < -180; )\n      e += 360;\n    for (; e > 180; )\n      e -= 360;\n    return e;\n  }\n}\nconst Kr = 100, Xr = 50;\nfunction vo(r, e) {\n  return e[0] - r[0];\n}\nfunction Qt(r) {\n  return r[1] - r[0] + 1;\n}\nfunction _e(r, e) {\n  return r[1] >= r[0] && r[1] < e;\n}\nfunction Yr(r, e) {\n  if (r[0] > r[1])\n    return [null, null];\n  const t = Qt(r);\n  if (e) {\n    if (t === 2)\n      return [r, null];\n    const a = Math.floor(t / 2);\n    return [\n      [r[0], r[0] + a],\n      [r[0] + a, r[1]]\n    ];\n  }\n  if (t === 1)\n    return [r, null];\n  const n = Math.floor(t / 2) - 1;\n  return [\n    [r[0], r[0] + n],\n    [r[0] + n + 1, r[1]]\n  ];\n}\nfunction Wr(r, e) {\n  if (!_e(e, r.length))\n    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  for (let n = e[0]; n <= e[1]; ++n)\n    It(t, r[n]);\n  return t;\n}\nfunction Jr(r) {\n  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  for (const t of r)\n    for (const n of t)\n      It(e, n);\n  return e;\n}\nfunction ha(r) {\n  return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;\n}\nfunction Tn(r, e, t) {\n  if (!ha(r) || !ha(e))\n    return NaN;\n  let n = 0, a = 0;\n  return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);\n}\nfunction qe(r, e, t) {\n  const n = t.pointOnLine(e, r);\n  return t.distance(r, n.point);\n}\nfunction _n(r, e, t, n, a) {\n  const o = Math.min(qe(r, [t, n], a), qe(e, [t, n], a)), i = Math.min(qe(t, [r, e], a), qe(n, [r, e], a));\n  return Math.min(o, i);\n}\nfunction jl(r, e, t, n, a) {\n  if (!(_e(e, r.length) && _e(n, t.length)))\n    return 1 / 0;\n  let i = 1 / 0;\n  for (let s = e[0]; s < e[1]; ++s) {\n    const l = r[s], u = r[s + 1];\n    for (let c = n[0]; c < n[1]; ++c) {\n      const p = t[c], d = t[c + 1];\n      if (br(l, u, p, d))\n        return 0;\n      i = Math.min(i, _n(l, u, p, d, a));\n    }\n  }\n  return i;\n}\nfunction Dl(r, e, t, n, a) {\n  if (!(_e(e, r.length) && _e(n, t.length)))\n    return NaN;\n  let i = 1 / 0;\n  for (let s = e[0]; s <= e[1]; ++s)\n    for (let l = n[0]; l <= n[1]; ++l)\n      if (i = Math.min(i, a.distance(r[s], t[l])), i === 0)\n        return i;\n  return i;\n}\nfunction Ul(r, e, t) {\n  if (ut(r, e, !0))\n    return 0;\n  let n = 1 / 0;\n  for (const a of e) {\n    const o = a[0], i = a[a.length - 1];\n    if (o !== i && (n = Math.min(n, qe(r, [i, o], t)), n === 0))\n      return n;\n    const s = t.pointOnLine(a, r);\n    if (n = Math.min(n, t.distance(r, s.point)), n === 0)\n      return n;\n  }\n  return n;\n}\nfunction Bl(r, e, t, n) {\n  if (!_e(e, r.length))\n    return NaN;\n  for (let o = e[0]; o <= e[1]; ++o)\n    if (ut(r[o], t, !0))\n      return 0;\n  let a = 1 / 0;\n  for (let o = e[0]; o < e[1]; ++o) {\n    const i = r[o], s = r[o + 1];\n    for (const l of t)\n      for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {\n        const d = l[p], f = l[u];\n        if (br(i, s, d, f))\n          return 0;\n        a = Math.min(a, _n(i, s, d, f, n));\n      }\n  }\n  return a;\n}\nfunction ma(r, e) {\n  for (const t of r)\n    for (const n of t)\n      if (ut(n, e, !0))\n        return !0;\n  return !1;\n}\nfunction ql(r, e, t, n = 1 / 0) {\n  const a = Jr(r), o = Jr(e);\n  if (n !== 1 / 0 && Tn(a, o, t) >= n)\n    return n;\n  if (xt(a, o)) {\n    if (ma(r, e))\n      return 0;\n  } else if (ma(e, r))\n    return 0;\n  let i = 1 / 0;\n  for (const s of r)\n    for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {\n      const p = s[c], d = s[l];\n      for (const f of e)\n        for (let h = 0, m = f.length, y = m - 1; h < m; y = h++) {\n          const w = f[y], v = f[h];\n          if (br(p, d, w, v))\n            return 0;\n          i = Math.min(i, _n(p, d, w, v, t));\n        }\n    }\n  return i;\n}\nfunction ya(r, e, t, n, a, o) {\n  if (!o)\n    return;\n  const i = Tn(Wr(n, o), a, t);\n  i < e && r.push([i, o, [0, 0]]);\n}\nfunction qt(r, e, t, n, a, o, i) {\n  if (!o || !i)\n    return;\n  const s = Tn(Wr(n, o), Wr(a, i), t);\n  s < e && r.push([s, o, i]);\n}\nfunction er(r, e, t, n, a = 1 / 0) {\n  let o = Math.min(n.distance(r[0], t[0][0]), a);\n  if (o === 0)\n    return o;\n  const i = new go([[0, [0, r.length - 1], [0, 0]]], vo), s = Jr(t);\n  for (; i.length > 0; ) {\n    const l = i.pop();\n    if (l[0] >= o)\n      continue;\n    const u = l[1], c = e ? Xr : Kr;\n    if (Qt(u) <= c) {\n      if (!_e(u, r.length))\n        return NaN;\n      if (e) {\n        const p = Bl(r, u, t, n);\n        if (isNaN(p) || p === 0)\n          return p;\n        o = Math.min(o, p);\n      } else\n        for (let p = u[0]; p <= u[1]; ++p) {\n          const d = Ul(r[p], t, n);\n          if (o = Math.min(o, d), o === 0)\n            return 0;\n        }\n    } else {\n      const p = Yr(u, e);\n      ya(i, o, n, r, s, p[0]), ya(i, o, n, r, s, p[1]);\n    }\n  }\n  return o;\n}\nfunction tr(r, e, t, n, a, o = 1 / 0) {\n  let i = Math.min(o, a.distance(r[0], t[0]));\n  if (i === 0)\n    return i;\n  const s = new go([[0, [0, r.length - 1], [0, t.length - 1]]], vo);\n  for (; s.length > 0; ) {\n    const l = s.pop();\n    if (l[0] >= i)\n      continue;\n    const u = l[1], c = l[2], p = e ? Xr : Kr, d = n ? Xr : Kr;\n    if (Qt(u) <= p && Qt(c) <= d) {\n      if (!_e(u, r.length) && _e(c, t.length))\n        return NaN;\n      let f;\n      if (e && n)\n        f = jl(r, u, t, c, a), i = Math.min(i, f);\n      else if (e && !n) {\n        const h = r.slice(u[0], u[1] + 1);\n        for (let m = c[0]; m <= c[1]; ++m)\n          if (f = qe(t[m], h, a), i = Math.min(i, f), i === 0)\n            return i;\n      } else if (!e && n) {\n        const h = t.slice(c[0], c[1] + 1);\n        for (let m = u[0]; m <= u[1]; ++m)\n          if (f = qe(r[m], h, a), i = Math.min(i, f), i === 0)\n            return i;\n      } else\n        f = Dl(r, u, t, c, a), i = Math.min(i, f);\n    } else {\n      const f = Yr(u, e), h = Yr(c, n);\n      qt(s, i, a, r, t, f[0], h[0]), qt(s, i, a, r, t, f[0], h[1]), qt(s, i, a, r, t, f[1], h[0]), qt(s, i, a, r, t, f[1], h[1]);\n    }\n  }\n  return i;\n}\nfunction Vl(r, e) {\n  const t = r.geometry(), n = t.flat().map((i) => En([i.x, i.y], r.canonical));\n  if (t.length === 0)\n    return NaN;\n  const a = new An(n[0][1]);\n  let o = 1 / 0;\n  for (const i of e) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, tr(n, !1, [i.coordinates], !1, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, tr(n, !1, i.coordinates, !0, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, er(n, !1, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0)\n      return o;\n  }\n  return o;\n}\nfunction Gl(r, e) {\n  const t = r.geometry(), n = t.flat().map((i) => En([i.x, i.y], r.canonical));\n  if (t.length === 0)\n    return NaN;\n  const a = new An(n[0][1]);\n  let o = 1 / 0;\n  for (const i of e) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, tr(n, !0, [i.coordinates], !1, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, tr(n, !0, i.coordinates, !0, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, er(n, !0, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0)\n      return o;\n  }\n  return o;\n}\nfunction Hl(r, e) {\n  const t = r.geometry();\n  if (t.length === 0 || t[0].length === 0)\n    return NaN;\n  const n = $l(t).map((i) => i.map((s) => s.map((l) => En([l.x, l.y], r.canonical)))), a = new An(n[0][0][0][1]);\n  let o = 1 / 0;\n  for (const i of e)\n    for (const s of n) {\n      switch (i.type) {\n        case \"Point\":\n          o = Math.min(o, er([i.coordinates], !1, s, a, o));\n          break;\n        case \"LineString\":\n          o = Math.min(o, er(i.coordinates, !0, s, a, o));\n          break;\n        case \"Polygon\":\n          o = Math.min(o, ql(s, i.coordinates, a, o));\n          break;\n      }\n      if (o === 0)\n        return o;\n    }\n  return o;\n}\nfunction zr(r) {\n  return r.type === \"MultiPolygon\" ? r.coordinates.map((e) => ({\n    type: \"Polygon\",\n    coordinates: e\n  })) : r.type === \"MultiLineString\" ? r.coordinates.map((e) => ({\n    type: \"LineString\",\n    coordinates: e\n  })) : r.type === \"MultiPoint\" ? r.coordinates.map((e) => ({\n    type: \"Point\",\n    coordinates: e\n  })) : [r];\n}\nclass Ze {\n  constructor(e, t) {\n    this.type = S, this.geojson = e, this.geometries = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (wt(e[1])) {\n      const n = e[1];\n      if (n.type === \"FeatureCollection\")\n        return new Ze(n, n.features.map((a) => zr(a.geometry)).flat());\n      if (n.type === \"Feature\")\n        return new Ze(n, zr(n.geometry));\n      if (\"type\" in n && \"coordinates\" in n)\n        return new Ze(n, zr(n));\n    }\n    return t.error(\"'distance' expression requires valid geojson object that contains polygon geometry type.\");\n  }\n  evaluate(e) {\n    if (e.geometry() != null && e.canonicalID() != null) {\n      if (e.geometryType() === \"Point\")\n        return Vl(e, this.geometries);\n      if (e.geometryType() === \"LineString\")\n        return Gl(e, this.geometries);\n      if (e.geometryType() === \"Polygon\")\n        return Hl(e, this.geometries);\n    }\n    return NaN;\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass Mt {\n  constructor(e) {\n    this.type = I, this.key = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);\n    const n = e[1];\n    return n == null ? t.error(\"Global state property must be defined.\") : typeof n != \"string\" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new Mt(n);\n  }\n  evaluate(e) {\n    var t;\n    const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;\n    return !n || Object.keys(n).length === 0 ? null : mt(n, this.key);\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nconst In = {\n  // special forms\n  \"==\": yl,\n  \"!=\": gl,\n  \">\": bl,\n  \"<\": vl,\n  \">=\": Sl,\n  \"<=\": wl,\n  array: he,\n  at: gn,\n  boolean: he,\n  case: wn,\n  coalesce: St,\n  collator: vr,\n  format: xn,\n  image: kn,\n  in: vn,\n  \"index-of\": Wt,\n  interpolate: xe,\n  \"interpolate-hcl\": xe,\n  \"interpolate-lab\": xe,\n  length: Ln,\n  let: mr,\n  literal: it,\n  match: bn,\n  number: he,\n  \"number-format\": Sn,\n  object: he,\n  slice: Jt,\n  step: gr,\n  string: he,\n  \"to-boolean\": $e,\n  \"to-color\": $e,\n  \"to-number\": $e,\n  \"to-string\": $e,\n  var: yr,\n  within: He,\n  distance: Ze,\n  \"global-state\": Mt\n};\nclass me {\n  constructor(e, t, n, a) {\n    this.name = e, this.type = t, this._evaluate = n, this.args = a;\n  }\n  evaluate(e) {\n    return this._evaluate(e, this.args);\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return !1;\n  }\n  static parse(e, t) {\n    const n = e[0], a = me.definitions[n];\n    if (!a)\n      return t.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n    const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(([u]) => !Array.isArray(u) || // varags\n    u.length === e.length - 1);\n    let l = null;\n    for (const [u, c] of s) {\n      l = new hr(t.registry, rr, t.path, null, t.scope);\n      const p = [];\n      let d = !1;\n      for (let f = 1; f < e.length; f++) {\n        const h = e[f], m = Array.isArray(u) ? u[f - 1] : u.type, y = l.parse(h, 1 + p.length, m);\n        if (!y) {\n          d = !0;\n          break;\n        }\n        p.push(y);\n      }\n      if (!d) {\n        if (Array.isArray(u) && u.length !== p.length) {\n          l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);\n          continue;\n        }\n        for (let f = 0; f < p.length; f++) {\n          const h = Array.isArray(u) ? u[f] : u.type, m = p[f];\n          l.concat(f + 1).checkSubtype(h, m.type);\n        }\n        if (l.errors.length === 0)\n          return new me(n, o, c, p);\n      }\n    }\n    if (s.length === 1)\n      t.errors.push(...l.errors);\n    else {\n      const c = (s.length ? s : i).map(([d]) => Kl(d)).join(\" | \"), p = [];\n      for (let d = 1; d < e.length; d++) {\n        const f = t.parse(e[d], 1 + p.length);\n        if (!f)\n          return null;\n        p.push(D(f.type));\n      }\n      t.error(`Expected arguments of type ${c}, but found (${p.join(\", \")}) instead.`);\n    }\n    return null;\n  }\n  static register(e, t) {\n    me.definitions = t;\n    for (const n in t)\n      e[n] = me;\n  }\n}\nfunction ga(r, [e, t, n, a]) {\n  e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);\n  const o = a ? a.evaluate(r) : 1, i = lo(e, t, n, o);\n  if (i)\n    throw new U(i);\n  return new $(e / 255, t / 255, n / 255, o, !1);\n}\nfunction va(r, e) {\n  return r in e;\n}\nfunction Or(r, e) {\n  const t = e[r];\n  return typeof t > \"u\" ? null : t;\n}\nfunction Zl(r, e, t, n) {\n  for (; t <= n; ) {\n    const a = t + n >> 1;\n    if (e[a] === r)\n      return !0;\n    e[a] > r ? n = a - 1 : t = a + 1;\n  }\n  return !1;\n}\nfunction Ue(r) {\n  return { type: r };\n}\nme.register(In, {\n  error: [\n    Us,\n    [P],\n    (r, [e]) => {\n      throw new U(e.evaluate(r));\n    }\n  ],\n  typeof: [\n    P,\n    [I],\n    (r, [e]) => D(q(e.evaluate(r)))\n  ],\n  \"to-rgba\": [\n    ne(S, 4),\n    [Se],\n    (r, [e]) => {\n      const [t, n, a, o] = e.evaluate(r).rgb;\n      return [t * 255, n * 255, a * 255, o];\n    }\n  ],\n  rgb: [\n    Se,\n    [S, S, S],\n    ga\n  ],\n  rgba: [\n    Se,\n    [S, S, S, S],\n    ga\n  ],\n  has: {\n    type: M,\n    overloads: [\n      [\n        [P],\n        (r, [e]) => va(e.evaluate(r), r.properties())\n      ],\n      [\n        [P, Ve],\n        (r, [e, t]) => va(e.evaluate(r), t.evaluate(r))\n      ]\n    ]\n  },\n  get: {\n    type: I,\n    overloads: [\n      [\n        [P],\n        (r, [e]) => Or(e.evaluate(r), r.properties())\n      ],\n      [\n        [P, Ve],\n        (r, [e, t]) => Or(e.evaluate(r), t.evaluate(r))\n      ]\n    ]\n  },\n  \"feature-state\": [\n    I,\n    [P],\n    (r, [e]) => Or(e.evaluate(r), r.featureState || {})\n  ],\n  properties: [\n    Ve,\n    [],\n    (r) => r.properties()\n  ],\n  \"geometry-type\": [\n    P,\n    [],\n    (r) => r.geometryType()\n  ],\n  id: [\n    I,\n    [],\n    (r) => r.id()\n  ],\n  zoom: [\n    S,\n    [],\n    (r) => r.globals.zoom\n  ],\n  \"heatmap-density\": [\n    S,\n    [],\n    (r) => r.globals.heatmapDensity || 0\n  ],\n  elevation: [\n    S,\n    [],\n    (r) => r.globals.elevation || 0\n  ],\n  \"line-progress\": [\n    S,\n    [],\n    (r) => r.globals.lineProgress || 0\n  ],\n  accumulated: [\n    I,\n    [],\n    (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated\n  ],\n  \"+\": [\n    S,\n    Ue(S),\n    (r, e) => {\n      let t = 0;\n      for (const n of e)\n        t += n.evaluate(r);\n      return t;\n    }\n  ],\n  \"*\": [\n    S,\n    Ue(S),\n    (r, e) => {\n      let t = 1;\n      for (const n of e)\n        t *= n.evaluate(r);\n      return t;\n    }\n  ],\n  \"-\": {\n    type: S,\n    overloads: [\n      [\n        [S, S],\n        (r, [e, t]) => e.evaluate(r) - t.evaluate(r)\n      ],\n      [\n        [S],\n        (r, [e]) => -e.evaluate(r)\n      ]\n    ]\n  },\n  \"/\": [\n    S,\n    [S, S],\n    (r, [e, t]) => e.evaluate(r) / t.evaluate(r)\n  ],\n  \"%\": [\n    S,\n    [S, S],\n    (r, [e, t]) => e.evaluate(r) % t.evaluate(r)\n  ],\n  ln2: [\n    S,\n    [],\n    () => Math.LN2\n  ],\n  pi: [\n    S,\n    [],\n    () => Math.PI\n  ],\n  e: [\n    S,\n    [],\n    () => Math.E\n  ],\n  \"^\": [\n    S,\n    [S, S],\n    (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))\n  ],\n  sqrt: [\n    S,\n    [S],\n    (r, [e]) => Math.sqrt(e.evaluate(r))\n  ],\n  log10: [\n    S,\n    [S],\n    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10\n  ],\n  ln: [\n    S,\n    [S],\n    (r, [e]) => Math.log(e.evaluate(r))\n  ],\n  log2: [\n    S,\n    [S],\n    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2\n  ],\n  sin: [\n    S,\n    [S],\n    (r, [e]) => Math.sin(e.evaluate(r))\n  ],\n  cos: [\n    S,\n    [S],\n    (r, [e]) => Math.cos(e.evaluate(r))\n  ],\n  tan: [\n    S,\n    [S],\n    (r, [e]) => Math.tan(e.evaluate(r))\n  ],\n  asin: [\n    S,\n    [S],\n    (r, [e]) => Math.asin(e.evaluate(r))\n  ],\n  acos: [\n    S,\n    [S],\n    (r, [e]) => Math.acos(e.evaluate(r))\n  ],\n  atan: [\n    S,\n    [S],\n    (r, [e]) => Math.atan(e.evaluate(r))\n  ],\n  min: [\n    S,\n    Ue(S),\n    (r, e) => Math.min(...e.map((t) => t.evaluate(r)))\n  ],\n  max: [\n    S,\n    Ue(S),\n    (r, e) => Math.max(...e.map((t) => t.evaluate(r)))\n  ],\n  abs: [\n    S,\n    [S],\n    (r, [e]) => Math.abs(e.evaluate(r))\n  ],\n  round: [\n    S,\n    [S],\n    (r, [e]) => {\n      const t = e.evaluate(r);\n      return t < 0 ? -Math.round(-t) : Math.round(t);\n    }\n  ],\n  floor: [\n    S,\n    [S],\n    (r, [e]) => Math.floor(e.evaluate(r))\n  ],\n  ceil: [\n    S,\n    [S],\n    (r, [e]) => Math.ceil(e.evaluate(r))\n  ],\n  \"filter-==\": [\n    M,\n    [P, I],\n    (r, [e, t]) => r.properties()[e.value] === t.value\n  ],\n  \"filter-id-==\": [\n    M,\n    [I],\n    (r, [e]) => r.id() === e.value\n  ],\n  \"filter-type-==\": [\n    M,\n    [P],\n    (r, [e]) => r.geometryType() === e.value\n  ],\n  \"filter-<\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n < a;\n    }\n  ],\n  \"filter-id-<\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t < n;\n    }\n  ],\n  \"filter->\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n > a;\n    }\n  ],\n  \"filter-id->\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t > n;\n    }\n  ],\n  \"filter-<=\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n <= a;\n    }\n  ],\n  \"filter-id-<=\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t <= n;\n    }\n  ],\n  \"filter->=\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n >= a;\n    }\n  ],\n  \"filter-id->=\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t >= n;\n    }\n  ],\n  \"filter-has\": [\n    M,\n    [I],\n    (r, [e]) => e.value in r.properties()\n  ],\n  \"filter-has-id\": [\n    M,\n    [],\n    (r) => r.id() !== null && r.id() !== void 0\n  ],\n  \"filter-type-in\": [\n    M,\n    [ne(P)],\n    (r, [e]) => e.value.indexOf(r.geometryType()) >= 0\n  ],\n  \"filter-id-in\": [\n    M,\n    [ne(I)],\n    (r, [e]) => e.value.indexOf(r.id()) >= 0\n  ],\n  \"filter-in-small\": [\n    M,\n    [P, ne(I)],\n    // assumes v is an array literal\n    (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0\n  ],\n  \"filter-in-large\": [\n    M,\n    [P, ne(I)],\n    // assumes v is a array literal with values sorted in ascending order and of a single type\n    (r, [e, t]) => Zl(r.properties()[e.value], t.value, 0, t.value.length - 1)\n  ],\n  all: {\n    type: M,\n    overloads: [\n      [\n        [M, M],\n        (r, [e, t]) => e.evaluate(r) && t.evaluate(r)\n      ],\n      [\n        Ue(M),\n        (r, e) => {\n          for (const t of e)\n            if (!t.evaluate(r))\n              return !1;\n          return !0;\n        }\n      ]\n    ]\n  },\n  any: {\n    type: M,\n    overloads: [\n      [\n        [M, M],\n        (r, [e, t]) => e.evaluate(r) || t.evaluate(r)\n      ],\n      [\n        Ue(M),\n        (r, e) => {\n          for (const t of e)\n            if (t.evaluate(r))\n              return !0;\n          return !1;\n        }\n      ]\n    ]\n  },\n  \"!\": [\n    M,\n    [M],\n    (r, [e]) => !e.evaluate(r)\n  ],\n  \"is-supported-script\": [\n    M,\n    [P],\n    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant\n    (r, [e]) => {\n      const t = r.globals && r.globals.isSupportedScript;\n      return t ? t(e.evaluate(r)) : !0;\n    }\n  ],\n  upcase: [\n    P,\n    [P],\n    (r, [e]) => e.evaluate(r).toUpperCase()\n  ],\n  downcase: [\n    P,\n    [P],\n    (r, [e]) => e.evaluate(r).toLowerCase()\n  ],\n  concat: [\n    P,\n    Ue(I),\n    (r, e) => e.map((t) => yt(t.evaluate(r))).join(\"\")\n  ],\n  \"resolved-locale\": [\n    P,\n    [ur],\n    (r, [e]) => e.evaluate(r).resolvedLocale()\n  ]\n});\nfunction Kl(r) {\n  return Array.isArray(r) ? `(${r.map(D).join(\", \")})` : `(${D(r.type)}...)`;\n}\nfunction rr(r) {\n  if (r instanceof yr)\n    return rr(r.boundExpression);\n  if (r instanceof me && r.name === \"error\")\n    return !1;\n  if (r instanceof vr)\n    return !1;\n  if (r instanceof He)\n    return !1;\n  if (r instanceof Ze)\n    return !1;\n  if (r instanceof Mt)\n    return !1;\n  const e = r instanceof $e || r instanceof he;\n  let t = !0;\n  return r.eachChild((n) => {\n    e ? t = t && rr(n) : t = t && n instanceof it;\n  }), t ? wr(r) && Sr(r, [\"zoom\", \"heatmap-density\", \"elevation\", \"line-progress\", \"accumulated\", \"is-supported-script\"]) : !1;\n}\nfunction wr(r) {\n  if (r instanceof me) {\n    if (r.name === \"get\" && r.args.length === 1)\n      return !1;\n    if (r.name === \"feature-state\")\n      return !1;\n    if (r.name === \"has\" && r.args.length === 1)\n      return !1;\n    if (r.name === \"properties\" || r.name === \"geometry-type\" || r.name === \"id\")\n      return !1;\n    if (/^filter-/.test(r.name))\n      return !1;\n  }\n  if (r instanceof He || r instanceof Ze)\n    return !1;\n  let e = !0;\n  return r.eachChild((t) => {\n    e && !wr(t) && (e = !1);\n  }), e;\n}\nfunction kt(r) {\n  if (r instanceof me && r.name === \"feature-state\")\n    return !1;\n  let e = !0;\n  return r.eachChild((t) => {\n    e && !kt(t) && (e = !1);\n  }), e;\n}\nfunction Sr(r, e) {\n  if (r instanceof me && e.indexOf(r.name) >= 0)\n    return !1;\n  let t = !0;\n  return r.eachChild((n) => {\n    t && !Sr(n, e) && (t = !1);\n  }), t;\n}\nfunction Qr(r) {\n  return { result: \"success\", value: r };\n}\nfunction tt(r) {\n  return { result: \"error\", value: r };\n}\nfunction nr(r) {\n  return r[\"property-type\"] === \"data-driven\" || r[\"property-type\"] === \"cross-faded-data-driven\";\n}\nfunction bo(r) {\n  return !!r.expression && r.expression.parameters.indexOf(\"zoom\") > -1;\n}\nfunction wo(r) {\n  return !!r.expression && r.expression.interpolated;\n}\nfunction R(r) {\n  return r instanceof Number ? \"number\" : r instanceof String ? \"string\" : r instanceof Boolean ? \"boolean\" : Array.isArray(r) ? \"array\" : r === null ? \"null\" : typeof r;\n}\nfunction Mn(r) {\n  return typeof r == \"object\" && r !== null && !Array.isArray(r) && q(r) === Ve;\n}\nclass Xl {\n  constructor(e, t) {\n    this.expression = e, this._warningHistory = {}, this._evaluator = new uo(), this._defaultValue = t ? Jl(t) : null, this._enumValues = t && t.type === \"enum\" ? t.values : null;\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);\n  }\n  evaluate(e, t, n, a, o, i) {\n    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;\n    try {\n      const s = this.expression.evaluate(this._evaluator);\n      if (s == null || typeof s == \"number\" && s !== s)\n        return this._defaultValue;\n      if (this._enumValues && !(s in this._enumValues))\n        throw new U(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(\", \")}, but found ${JSON.stringify(s)} instead.`);\n      return s;\n    } catch (s) {\n      return this._warningHistory[s.message] || (this._warningHistory[s.message] = !0, typeof console < \"u\" && console.warn(s.message)), this._defaultValue;\n    }\n  }\n}\nfunction So(r) {\n  return Array.isArray(r) && r.length > 0 && typeof r[0] == \"string\" && r[0] in In;\n}\nfunction xo(r, e) {\n  const t = new hr(In, rr, [], e ? Wl(e) : void 0), n = t.parse(r, void 0, void 0, void 0, e && e.type === \"string\" ? { typeAnnotation: \"coerce\" } : void 0);\n  return n ? Qr(new Xl(n, e)) : tt(t.errors);\n}\nclass ba {\n  constructor(e, t) {\n    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== \"constant\" && !kt(t.expression), this.globalStateRefs = Pn(t.expression);\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);\n  }\n  evaluate(e, t, n, a, o, i) {\n    return this._styleExpression.evaluate(e, t, n, a, o, i);\n  }\n}\nclass wa {\n  constructor(e, t, n, a) {\n    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== \"camera\" && !kt(t.expression), this.globalStateRefs = Pn(t.expression), this.interpolationType = a;\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);\n  }\n  evaluate(e, t, n, a, o, i) {\n    return this._styleExpression.evaluate(e, t, n, a, o, i);\n  }\n  interpolationFactor(e, t, n) {\n    return this.interpolationType ? xe.interpolationFactor(this.interpolationType, e, t, n) : 0;\n  }\n}\nfunction Yl(r, e) {\n  const t = xo(r, e);\n  if (t.result === \"error\")\n    return t;\n  const n = t.value.expression, a = wr(n);\n  if (!a && !nr(e))\n    return tt([new we(\"\", \"data expressions not supported\")]);\n  const o = Sr(n, [\"zoom\"]);\n  if (!o && !bo(e))\n    return tt([new we(\"\", \"zoom expressions not supported\")]);\n  const i = Ht(n);\n  if (!i && !o)\n    return tt([new we(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n  if (i instanceof we)\n    return tt([i]);\n  if (i instanceof xe && !wo(e))\n    return tt([new we(\"\", '\"interpolate\" expressions cannot be used with this property')]);\n  if (!i)\n    return Qr(a ? new ba(\"constant\", t.value) : new ba(\"source\", t.value));\n  const s = i instanceof xe ? i.interpolation : void 0;\n  return Qr(a ? new wa(\"camera\", t.value, i.labels, s) : new wa(\"composite\", t.value, i.labels, s));\n}\nfunction Ht(r) {\n  let e = null;\n  if (r instanceof mr)\n    e = Ht(r.result);\n  else if (r instanceof St) {\n    for (const t of r.args)\n      if (e = Ht(t), e)\n        break;\n  } else (r instanceof gr || r instanceof xe) && r.input instanceof me && r.input.name === \"zoom\" && (e = r);\n  return e instanceof we || r.eachChild((t) => {\n    const n = Ht(t);\n    n instanceof we ? e = n : !e && n ? e = new we(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : e && n && e !== n && (e = new we(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n  }), e;\n}\nfunction Pn(r, e = /* @__PURE__ */ new Set()) {\n  return r instanceof Mt && e.add(r.key), r.eachChild((t) => {\n    Pn(t, e);\n  }), e;\n}\nfunction Wl(r) {\n  const e = {\n    color: Se,\n    string: P,\n    number: S,\n    enum: P,\n    boolean: M,\n    formatted: cr,\n    padding: pr,\n    numberArray: fr,\n    colorArray: vt,\n    projectionDefinition: lr,\n    resolvedImage: _t,\n    variableAnchorOffsetCollection: dr\n  };\n  return r.type === \"array\" ? ne(e[r.value] || I, r.length) : e[r.type];\n}\nfunction Jl(r) {\n  if (r.type === \"color\" && Mn(r.default))\n    return new $(0, 0, 0, 0);\n  switch (r.type) {\n    case \"color\":\n      return $.parse(r.default) || null;\n    case \"padding\":\n      return ie.parse(r.default) || null;\n    case \"numberArray\":\n      return se.parse(r.default) || null;\n    case \"colorArray\":\n      return Q.parse(r.default) || null;\n    case \"variableAnchorOffsetCollection\":\n      return ye.parse(r.default) || null;\n    case \"projectionDefinition\":\n      return de.parse(r.default) || null;\n    default:\n      return r.default === void 0 ? null : r.default;\n  }\n}\nfunction ko(r) {\n  if (r === !0 || r === !1)\n    return !0;\n  if (!Array.isArray(r) || r.length === 0)\n    return !1;\n  switch (r[0]) {\n    case \"has\":\n      return r.length >= 2 && r[1] !== \"$id\" && r[1] !== \"$type\";\n    case \"in\":\n      return r.length >= 3 && (typeof r[1] != \"string\" || Array.isArray(r[2]));\n    case \"!in\":\n    case \"!has\":\n    case \"none\":\n      return !1;\n    case \"==\":\n    case \"!=\":\n    case \">\":\n    case \">=\":\n    case \"<\":\n    case \"<=\":\n      return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);\n    case \"any\":\n    case \"all\":\n      for (const e of r.slice(1))\n        if (!ko(e) && typeof e != \"boolean\")\n          return !1;\n      return !0;\n    default:\n      return !0;\n  }\n}\nfunction Lo(r) {\n  const e = r.key, t = r.value;\n  return t ? [new b(e, t, \"constants have been deprecated as of v8\")] : [];\n}\nfunction B(r) {\n  return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;\n}\nfunction Ye(r) {\n  if (Array.isArray(r))\n    return r.map(Ye);\n  if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {\n    const e = {};\n    for (const t in r)\n      e[t] = Ye(r[t]);\n    return e;\n  }\n  return B(r);\n}\nfunction le(r) {\n  const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;\n  let l = [];\n  const u = R(t);\n  if (u !== \"object\")\n    return [new b(e, t, `object expected, ${u} found`)];\n  for (const c in t) {\n    const p = c.split(\".\")[0], d = mt(n, p) || n[\"*\"];\n    let f;\n    if (mt(a, p))\n      f = a[p];\n    else if (mt(n, p))\n      f = s;\n    else if (a[\"*\"])\n      f = a[\"*\"];\n    else if (n[\"*\"])\n      f = s;\n    else {\n      l.push(new b(e, t[c], `unknown property \"${c}\"`));\n      continue;\n    }\n    l = l.concat(f({\n      key: (e && `${e}.`) + c,\n      value: t[c],\n      valueSpec: d,\n      style: o,\n      styleSpec: i,\n      object: t,\n      objectKey: c,\n      validateSpec: s\n    }, t));\n  }\n  for (const c in n)\n    a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new b(e, t, `missing required property \"${c}\"`));\n  return l;\n}\nfunction Rn(r) {\n  const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;\n  if (R(e) !== \"array\")\n    return [new b(i, e, `array expected, ${R(e)} found`)];\n  if (t.length && e.length !== t.length)\n    return [new b(i, e, `array length ${t.length} expected, length ${e.length} found`)];\n  if (t[\"min-length\"] && e.length < t[\"min-length\"])\n    return [new b(i, e, `array length at least ${t[\"min-length\"]} expected, length ${e.length} found`)];\n  let l = {\n    type: t.value,\n    values: t.values\n  };\n  o.$version < 7 && (l.function = t.function), R(t.value) === \"object\" && (l = t.value);\n  let u = [];\n  for (let c = 0; c < e.length; c++)\n    u = u.concat(s({\n      array: e,\n      arrayIndex: c,\n      value: e[c],\n      valueSpec: l,\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: o,\n      key: `${i}[${c}]`\n    }));\n  return u;\n}\nfunction xr(r) {\n  const e = r.key, t = r.value, n = r.valueSpec;\n  let a = R(t);\n  return a === \"number\" && t !== t && (a = \"NaN\"), a !== \"number\" ? [new b(e, t, `number expected, ${a} found`)] : \"minimum\" in n && t < n.minimum ? [new b(e, t, `${t} is less than the minimum value ${n.minimum}`)] : \"maximum\" in n && t > n.maximum ? [new b(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];\n}\nfunction Eo(r) {\n  const e = r.valueSpec, t = B(r.value.type);\n  let n, a = {}, o, i;\n  const s = t !== \"categorical\" && r.value.property === void 0, l = !s, u = R(r.value.stops) === \"array\" && R(r.value.stops[0]) === \"array\" && R(r.value.stops[0][0]) === \"object\", c = le({\n    key: r.key,\n    value: r.value,\n    valueSpec: r.styleSpec.function,\n    validateSpec: r.validateSpec,\n    style: r.style,\n    styleSpec: r.styleSpec,\n    objectElementValidators: {\n      stops: p,\n      default: h\n    }\n  });\n  return t === \"identity\" && s && c.push(new b(r.key, r.value, 'missing required property \"property\"')), t !== \"identity\" && !r.value.stops && c.push(new b(r.key, r.value, 'missing required property \"stops\"')), t === \"exponential\" && r.valueSpec.expression && !wo(r.valueSpec) && c.push(new b(r.key, r.value, \"exponential functions not supported\")), r.styleSpec.$version >= 8 && (l && !nr(r.valueSpec) ? c.push(new b(r.key, r.value, \"property functions not supported\")) : s && !bo(r.valueSpec) && c.push(new b(r.key, r.value, \"zoom functions not supported\"))), (t === \"categorical\" || u) && r.value.property === void 0 && c.push(new b(r.key, r.value, '\"property\" property is required')), c;\n  function p(m) {\n    if (t === \"identity\")\n      return [new b(m.key, m.value, 'identity function may not have a \"stops\" property')];\n    let y = [];\n    const w = m.value;\n    return y = y.concat(Rn({\n      key: m.key,\n      value: w,\n      valueSpec: m.valueSpec,\n      validateSpec: m.validateSpec,\n      style: m.style,\n      styleSpec: m.styleSpec,\n      arrayElementValidator: d\n    })), R(w) === \"array\" && w.length === 0 && y.push(new b(m.key, w, \"array must have at least one stop\")), y;\n  }\n  function d(m) {\n    let y = [];\n    const w = m.value, v = m.key;\n    if (R(w) !== \"array\")\n      return [new b(v, w, `array expected, ${R(w)} found`)];\n    if (w.length !== 2)\n      return [new b(v, w, `array length 2 expected, length ${w.length} found`)];\n    if (u) {\n      if (R(w[0]) !== \"object\")\n        return [new b(v, w, `object expected, ${R(w[0])} found`)];\n      if (w[0].zoom === void 0)\n        return [new b(v, w, \"object stop key must have zoom\")];\n      if (w[0].value === void 0)\n        return [new b(v, w, \"object stop key must have value\")];\n      if (i && i > B(w[0].zoom))\n        return [new b(v, w[0].zoom, \"stop zoom values must appear in ascending order\")];\n      B(w[0].zoom) !== i && (i = B(w[0].zoom), o = void 0, a = {}), y = y.concat(le({\n        key: `${v}[0]`,\n        value: w[0],\n        valueSpec: { zoom: {} },\n        validateSpec: m.validateSpec,\n        style: m.style,\n        styleSpec: m.styleSpec,\n        objectElementValidators: { zoom: xr, value: f }\n      }));\n    } else\n      y = y.concat(f({\n        key: `${v}[0]`,\n        value: w[0],\n        validateSpec: m.validateSpec,\n        style: m.style,\n        styleSpec: m.styleSpec\n      }, w));\n    return So(Ye(w[1])) ? y.concat([new b(`${v}[1]`, w[1], \"expressions are not allowed in function stops.\")]) : y.concat(m.validateSpec({\n      key: `${v}[1]`,\n      value: w[1],\n      valueSpec: e,\n      validateSpec: m.validateSpec,\n      style: m.style,\n      styleSpec: m.styleSpec\n    }));\n  }\n  function f(m, y) {\n    const w = R(m.value), v = B(m.value), x = m.value !== null ? m.value : y;\n    if (!n)\n      n = w;\n    else if (w !== n)\n      return [new b(m.key, x, `${w} stop domain type must match previous stop domain type ${n}`)];\n    if (w !== \"number\" && w !== \"string\" && w !== \"boolean\")\n      return [new b(m.key, x, \"stop domain value must be a number, string, or boolean\")];\n    if (w !== \"number\" && t !== \"categorical\") {\n      let A = `number expected, ${w} found`;\n      return nr(e) && t === void 0 && (A += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new b(m.key, x, A)];\n    }\n    return t === \"categorical\" && w === \"number\" && (!isFinite(v) || Math.floor(v) !== v) ? [new b(m.key, x, `integer expected, found ${v}`)] : t !== \"categorical\" && w === \"number\" && o !== void 0 && v < o ? [new b(m.key, x, \"stop domain values must appear in ascending order\")] : (o = v, t === \"categorical\" && v in a ? [new b(m.key, x, \"stop domain values must be unique\")] : (a[v] = !0, []));\n  }\n  function h(m) {\n    return m.validateSpec({\n      key: m.key,\n      value: m.value,\n      valueSpec: e,\n      validateSpec: m.validateSpec,\n      style: m.style,\n      styleSpec: m.styleSpec\n    });\n  }\n}\nfunction st(r) {\n  const e = (r.expressionContext === \"property\" ? Yl : xo)(Ye(r.value), r.valueSpec);\n  if (e.result === \"error\")\n    return e.value.map((n) => new b(`${r.key}${n.key}`, r.value, n.message));\n  const t = e.value.expression || e.value._styleExpression.expression;\n  if (r.expressionContext === \"property\" && r.propertyKey === \"text-font\" && !t.outputDefined())\n    return [new b(r.key, r.value, `Invalid data expression for \"${r.propertyKey}\". Output values must be contained as literals within the expression.`)];\n  if (r.expressionContext === \"property\" && r.propertyType === \"layout\" && !kt(t))\n    return [new b(r.key, r.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n  if (r.expressionContext === \"filter\" && !kt(t))\n    return [new b(r.key, r.value, '\"feature-state\" data expressions are not supported with filters.')];\n  if (r.expressionContext && r.expressionContext.indexOf(\"cluster\") === 0) {\n    if (!Sr(t, [\"zoom\", \"feature-state\"]))\n      return [new b(r.key, r.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n    if (r.expressionContext === \"cluster-initial\" && !wr(t))\n      return [new b(r.key, r.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n  }\n  return [];\n}\nfunction Ql(r) {\n  const e = r.value, t = r.key, n = R(e);\n  return n !== \"boolean\" ? [new b(t, e, `boolean expected, ${n} found`)] : [];\n}\nfunction en(r) {\n  const e = r.key, t = r.value, n = R(t);\n  return n !== \"string\" ? [new b(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new b(e, t, `color expected, \"${t}\" found`)];\n}\nfunction Lt(r) {\n  const e = r.key, t = r.value, n = r.valueSpec, a = [];\n  return Array.isArray(n.values) ? n.values.indexOf(B(t)) === -1 && a.push(new b(e, t, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(B(t)) === -1 && a.push(new b(e, t, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(t)} found`)), a;\n}\nfunction zn(r) {\n  return ko(Ye(r.value)) ? st(Yt({}, r, {\n    expressionContext: \"filter\",\n    valueSpec: { value: \"boolean\" }\n  })) : Co(r);\n}\nfunction Co(r) {\n  const e = r.value, t = r.key;\n  if (R(e) !== \"array\")\n    return [new b(t, e, `array expected, ${R(e)} found`)];\n  const n = r.styleSpec;\n  let a, o = [];\n  if (e.length < 1)\n    return [new b(t, e, \"filter array must have at least 1 element\")];\n  switch (o = o.concat(Lt({\n    key: `${t}[0]`,\n    value: e[0],\n    valueSpec: n.filter_operator,\n    style: r.style,\n    styleSpec: r.styleSpec\n  })), B(e[0])) {\n    case \"<\":\n    case \"<=\":\n    case \">\":\n    case \">=\":\n      e.length >= 2 && B(e[1]) === \"$type\" && o.push(new b(t, e, `\"$type\" cannot be use with operator \"${e[0]}\"`));\n    /* falls through */\n    case \"==\":\n    case \"!=\":\n      e.length !== 3 && o.push(new b(t, e, `filter array for operator \"${e[0]}\" must have 3 elements`));\n    /* falls through */\n    case \"in\":\n    case \"!in\":\n      e.length >= 2 && (a = R(e[1]), a !== \"string\" && o.push(new b(`${t}[1]`, e[1], `string expected, ${a} found`)));\n      for (let i = 2; i < e.length; i++)\n        a = R(e[i]), B(e[1]) === \"$type\" ? o = o.concat(Lt({\n          key: `${t}[${i}]`,\n          value: e[i],\n          valueSpec: n.geometry_type,\n          style: r.style,\n          styleSpec: r.styleSpec\n        })) : a !== \"string\" && a !== \"number\" && a !== \"boolean\" && o.push(new b(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));\n      break;\n    case \"any\":\n    case \"all\":\n    case \"none\":\n      for (let i = 1; i < e.length; i++)\n        o = o.concat(Co({\n          key: `${t}[${i}]`,\n          value: e[i],\n          style: r.style,\n          styleSpec: r.styleSpec\n        }));\n      break;\n    case \"has\":\n    case \"!has\":\n      a = R(e[1]), e.length !== 2 ? o.push(new b(t, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : a !== \"string\" && o.push(new b(`${t}[1]`, e[1], `string expected, ${a} found`));\n      break;\n  }\n  return o;\n}\nfunction Ao(r, e) {\n  const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];\n  if (!l)\n    return [];\n  const u = s.match(/^(.*)-transition$/);\n  if (e === \"paint\" && u && l[u[1]] && l[u[1]].transition)\n    return n({\n      key: t,\n      value: i,\n      valueSpec: o.transition,\n      style: a,\n      styleSpec: o\n    });\n  const c = r.valueSpec || l[s];\n  if (!c)\n    return [new b(t, i, `unknown property \"${s}\"`)];\n  let p;\n  if (R(i) === \"string\" && nr(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i)))\n    return [new b(t, i, `\"${s}\" does not support interpolation syntax\nUse an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(p[1])} }\\`.`)];\n  const d = [];\n  return r.layerType === \"symbol\" && (s === \"text-field\" && a && !a.glyphs && d.push(new b(t, i, 'use of \"text-field\" requires a style \"glyphs\" property')), s === \"text-font\" && Mn(Ye(i)) && B(i.type) === \"identity\" && d.push(new b(t, i, '\"text-font\" does not support identity functions'))), d.concat(n({\n    key: r.key,\n    value: i,\n    valueSpec: c,\n    style: a,\n    styleSpec: o,\n    expressionContext: \"property\",\n    propertyType: e,\n    propertyKey: s\n  }));\n}\nfunction To(r) {\n  return Ao(r, \"paint\");\n}\nfunction _o(r) {\n  return Ao(r, \"layout\");\n}\nfunction Io(r) {\n  let e = [];\n  const t = r.value, n = r.key, a = r.style, o = r.styleSpec;\n  if (R(t) !== \"object\")\n    return [new b(n, t, `object expected, ${R(t)} found`)];\n  !t.type && !t.ref && e.push(new b(n, t, 'either \"type\" or \"ref\" is required'));\n  let i = B(t.type);\n  const s = B(t.ref);\n  if (t.id) {\n    const l = B(t.id);\n    for (let u = 0; u < r.arrayIndex; u++) {\n      const c = a.layers[u];\n      B(c.id) === l && e.push(new b(n, t.id, `duplicate layer id \"${t.id}\", previously used at line ${c.id.__line__}`));\n    }\n  }\n  if (\"ref\" in t) {\n    [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach((u) => {\n      u in t && e.push(new b(n, t[u], `\"${u}\" is prohibited for ref layers`));\n    });\n    let l;\n    a.layers.forEach((u) => {\n      B(u.id) === s && (l = u);\n    }), l ? l.ref ? e.push(new b(n, t.ref, \"ref cannot reference another ref layer\")) : i = B(l.type) : e.push(new b(n, t.ref, `ref layer \"${s}\" not found`));\n  } else if (i !== \"background\")\n    if (!t.source)\n      e.push(new b(n, t, 'missing required property \"source\"'));\n    else {\n      const l = a.sources && a.sources[t.source], u = l && B(l.type);\n      l ? u === \"vector\" && i === \"raster\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a raster source`)) : u !== \"raster-dem\" && i === \"hillshade\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a raster-dem source`)) : u !== \"raster-dem\" && i === \"color-relief\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a raster-dem source`)) : u === \"raster\" && i !== \"raster\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a vector source`)) : u === \"vector\" && !t[\"source-layer\"] ? e.push(new b(n, t, `layer \"${t.id}\" must specify a \"source-layer\"`)) : u === \"raster-dem\" && i !== \"hillshade\" && i !== \"color-relief\" ? e.push(new b(n, t.source, \"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.\")) : i === \"line\" && t.paint && t.paint[\"line-gradient\"] && (u !== \"geojson\" || !l.lineMetrics) && e.push(new b(n, t, `layer \"${t.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new b(n, t.source, `source \"${t.source}\" not found`));\n    }\n  return e = e.concat(le({\n    key: n,\n    value: t,\n    valueSpec: o.layer,\n    style: r.style,\n    styleSpec: r.styleSpec,\n    validateSpec: r.validateSpec,\n    objectElementValidators: {\n      \"*\"() {\n        return [];\n      },\n      // We don't want to enforce the spec's `\"requires\": true` for backward compatibility with refs;\n      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.\n      type() {\n        return r.validateSpec({\n          key: `${n}.type`,\n          value: t.type,\n          valueSpec: o.layer.type,\n          style: r.style,\n          styleSpec: r.styleSpec,\n          validateSpec: r.validateSpec,\n          object: t,\n          objectKey: \"type\"\n        });\n      },\n      filter: zn,\n      layout(l) {\n        return le({\n          layer: t,\n          key: l.key,\n          value: l.value,\n          style: l.style,\n          styleSpec: l.styleSpec,\n          validateSpec: l.validateSpec,\n          objectElementValidators: {\n            \"*\"(u) {\n              return _o(Yt({ layerType: i }, u));\n            }\n          }\n        });\n      },\n      paint(l) {\n        return le({\n          layer: t,\n          key: l.key,\n          value: l.value,\n          style: l.style,\n          styleSpec: l.styleSpec,\n          validateSpec: l.validateSpec,\n          objectElementValidators: {\n            \"*\"(u) {\n              return To(Yt({ layerType: i }, u));\n            }\n          }\n        });\n      }\n    }\n  })), e;\n}\nfunction We(r) {\n  const e = r.value, t = r.key, n = R(e);\n  return n !== \"string\" ? [new b(t, e, `string expected, ${n} found`)] : [];\n}\nfunction eu(r) {\n  var e;\n  const t = (e = r.sourceName) !== null && e !== void 0 ? e : \"\", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;\n  let s = [];\n  const l = R(n);\n  if (n === void 0)\n    return s;\n  if (l !== \"object\")\n    return s.push(new b(\"source_raster_dem\", n, `object expected, ${l} found`)), s;\n  const c = B(n.encoding) === \"custom\", p = [\"redFactor\", \"greenFactor\", \"blueFactor\", \"baseShift\"], d = r.value.encoding ? `\"${r.value.encoding}\"` : \"Default\";\n  for (const f in n)\n    !c && p.includes(f) ? s.push(new b(f, n[f], `In \"${t}\": \"${f}\" is only valid when \"encoding\" is set to \"custom\". ${d} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({\n      key: f,\n      value: n[f],\n      valueSpec: o[f],\n      validateSpec: r.validateSpec,\n      style: i,\n      styleSpec: a\n    })) : s.push(new b(f, n[f], `unknown property \"${f}\"`));\n  return s;\n}\nconst Sa = {\n  promoteId: tu\n};\nfunction Mo(r) {\n  const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;\n  if (!e.type)\n    return [new b(t, e, '\"type\" is required')];\n  const i = B(e.type);\n  let s;\n  switch (i) {\n    case \"vector\":\n    case \"raster\":\n      return s = le({\n        key: t,\n        value: e,\n        valueSpec: n[`source_${i.replace(\"-\", \"_\")}`],\n        style: r.style,\n        styleSpec: n,\n        objectElementValidators: Sa,\n        validateSpec: o\n      }), s;\n    case \"raster-dem\":\n      return s = eu({\n        sourceName: t,\n        value: e,\n        style: r.style,\n        styleSpec: n,\n        validateSpec: o\n      }), s;\n    case \"geojson\":\n      if (s = le({\n        key: t,\n        value: e,\n        valueSpec: n.source_geojson,\n        style: a,\n        styleSpec: n,\n        validateSpec: o,\n        objectElementValidators: Sa\n      }), e.cluster)\n        for (const l in e.clusterProperties) {\n          const [u, c] = e.clusterProperties[l], p = typeof u == \"string\" ? [u, [\"accumulated\"], [\"get\", l]] : u;\n          s.push(...st({\n            key: `${t}.${l}.map`,\n            value: c,\n            expressionContext: \"cluster-map\"\n          })), s.push(...st({\n            key: `${t}.${l}.reduce`,\n            value: p,\n            expressionContext: \"cluster-reduce\"\n          }));\n        }\n      return s;\n    case \"video\":\n      return le({\n        key: t,\n        value: e,\n        valueSpec: n.source_video,\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n    case \"image\":\n      return le({\n        key: t,\n        value: e,\n        valueSpec: n.source_image,\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n    case \"canvas\":\n      return [new b(t, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n    default:\n      return Lt({\n        key: `${t}.type`,\n        value: e.type,\n        valueSpec: { values: [\"vector\", \"raster\", \"raster-dem\", \"geojson\", \"video\", \"image\"] }\n      });\n  }\n}\nfunction tu({ key: r, value: e }) {\n  if (R(e) === \"string\")\n    return We({ key: r, value: e });\n  {\n    const t = [];\n    for (const n in e)\n      t.push(...We({ key: `${r}.${n}`, value: e[n] }));\n    return t;\n  }\n}\nfunction Po(r) {\n  const e = r.value, t = r.styleSpec, n = t.light, a = r.style;\n  let o = [];\n  const i = R(e);\n  if (e === void 0)\n    return o;\n  if (i !== \"object\")\n    return o = o.concat([new b(\"light\", e, `object expected, ${i} found`)]), o;\n  for (const s in e) {\n    const l = s.match(/^(.*)-transition$/);\n    l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: t.transition,\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : n[s] ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : o = o.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  }\n  return o;\n}\nfunction Ro(r) {\n  const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = R(e);\n  if (e === void 0)\n    return [];\n  if (o !== \"object\")\n    return [new b(\"sky\", e, `object expected, ${o} found`)];\n  let i = [];\n  for (const s in e)\n    n[s] ? i = i.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      style: a,\n      styleSpec: t\n    })) : i = i.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  return i;\n}\nfunction zo(r) {\n  const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;\n  let o = [];\n  const i = R(e);\n  if (e === void 0)\n    return o;\n  if (i !== \"object\")\n    return o = o.concat([new b(\"terrain\", e, `object expected, ${i} found`)]), o;\n  for (const s in e)\n    n[s] ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : o = o.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  return o;\n}\nfunction ru(r) {\n  return We(r).length === 0 ? [] : st(r);\n}\nfunction nu(r) {\n  return We(r).length === 0 ? [] : st(r);\n}\nfunction au(r) {\n  const e = r.key, t = r.value;\n  if (R(t) === \"array\") {\n    if (t.length < 1 || t.length > 4)\n      return [new b(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];\n    const a = {\n      type: \"number\"\n    };\n    let o = [];\n    for (let i = 0; i < t.length; i++)\n      o = o.concat(r.validateSpec({\n        key: `${e}[${i}]`,\n        value: t[i],\n        validateSpec: r.validateSpec,\n        valueSpec: a\n      }));\n    return o;\n  } else\n    return xr({\n      key: e,\n      value: t,\n      valueSpec: {}\n    });\n}\nfunction ou(r) {\n  const e = r.key, t = r.value;\n  if (R(t) === \"array\") {\n    const a = {\n      type: \"number\"\n    };\n    if (t.length < 1)\n      return [new b(e, t, \"array length at least 1 expected, length 0 found\")];\n    let o = [];\n    for (let i = 0; i < t.length; i++)\n      o = o.concat(r.validateSpec({\n        key: `${e}[${i}]`,\n        value: t[i],\n        validateSpec: r.validateSpec,\n        valueSpec: a\n      }));\n    return o;\n  } else\n    return xr({\n      key: e,\n      value: t,\n      valueSpec: {}\n    });\n}\nfunction iu(r) {\n  const e = r.key, t = r.value;\n  if (R(t) === \"array\") {\n    if (t.length < 1)\n      return [new b(e, t, \"array length at least 1 expected, length 0 found\")];\n    let a = [];\n    for (let o = 0; o < t.length; o++)\n      a = a.concat(en({\n        key: `${e}[${o}]`,\n        value: t[o]\n      }));\n    return a;\n  } else\n    return en({\n      key: e,\n      value: t\n    });\n}\nfunction su(r) {\n  const e = r.key, t = r.value, n = R(t), a = r.styleSpec;\n  if (n !== \"array\" || t.length < 1 || t.length % 2 !== 0)\n    return [new b(e, t, \"variableAnchorOffsetCollection requires a non-empty array of even length\")];\n  let o = [];\n  for (let i = 0; i < t.length; i += 2)\n    o = o.concat(Lt({\n      key: `${e}[${i}]`,\n      value: t[i],\n      valueSpec: a.layout_symbol[\"text-anchor\"]\n    })), o = o.concat(Rn({\n      key: `${e}[${i + 1}]`,\n      value: t[i + 1],\n      valueSpec: {\n        length: 2,\n        value: \"number\"\n      },\n      validateSpec: r.validateSpec,\n      style: r.style,\n      styleSpec: a\n    }));\n  return o;\n}\nfunction Oo(r) {\n  let e = [];\n  const t = r.value, n = r.key;\n  if (Array.isArray(t)) {\n    const a = [], o = [];\n    for (const i in t) {\n      t[i].id && a.includes(t[i].id) && e.push(new b(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new b(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);\n      const s = {\n        id: {\n          type: \"string\",\n          required: !0\n        },\n        url: {\n          type: \"string\",\n          required: !0\n        }\n      };\n      e = e.concat(le({\n        key: `${n}[${i}]`,\n        value: t[i],\n        valueSpec: s,\n        validateSpec: r.validateSpec\n      }));\n    }\n    return e;\n  } else\n    return We({\n      key: n,\n      value: t\n    });\n}\nfunction lu(r) {\n  const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = R(e);\n  if (e === void 0)\n    return [];\n  if (o !== \"object\")\n    return [new b(\"projection\", e, `object expected, ${o} found`)];\n  let i = [];\n  for (const s in e)\n    n[s] ? i = i.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      style: a,\n      styleSpec: t\n    })) : i = i.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  return i;\n}\nfunction uu(r) {\n  const e = r.key;\n  let t = r.value;\n  t = t instanceof String ? t.valueOf() : t;\n  const n = R(t);\n  return n === \"array\" && !pu(t) && !cu(t) ? [new b(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : [\"array\", \"string\"].includes(n) ? [] : [new b(e, t, `projection expected, invalid type \"${n}\" found`)];\n}\nfunction cu(r) {\n  return !![\"interpolate\", \"step\", \"literal\"].includes(r[0]);\n}\nfunction pu(r) {\n  return Array.isArray(r) && r.length === 3 && typeof r[0] == \"string\" && typeof r[1] == \"string\" && typeof r[2] == \"number\";\n}\nfunction fu(r) {\n  return !!r && r.constructor === Object;\n}\nfunction $o(r) {\n  return fu(r.value) ? [] : [\n    new b(r.key, r.value, `object expected, ${R(r.value)} found`)\n  ];\n}\nconst xa = {\n  \"*\"() {\n    return [];\n  },\n  array: Rn,\n  boolean: Ql,\n  number: xr,\n  color: en,\n  constants: Lo,\n  enum: Lt,\n  filter: zn,\n  function: Eo,\n  layer: Io,\n  object: le,\n  source: Mo,\n  light: Po,\n  sky: Ro,\n  terrain: zo,\n  projection: lu,\n  projectionDefinition: uu,\n  string: We,\n  formatted: ru,\n  resolvedImage: nu,\n  padding: au,\n  numberArray: ou,\n  colorArray: iu,\n  variableAnchorOffsetCollection: su,\n  sprite: Oo,\n  state: $o\n};\nfunction ar(r) {\n  const e = r.value, t = r.valueSpec, n = r.styleSpec;\n  return r.validateSpec = ar, t.expression && Mn(B(e)) ? Eo(r) : t.expression && So(Ye(e)) ? st(r) : t.type && xa[t.type] ? xa[t.type](r) : le(Yt({}, r, {\n    valueSpec: t.type ? n[t.type] : t\n  }));\n}\nfunction Fo(r) {\n  const e = r.value, t = r.key, n = We(r);\n  return n.length || (e.indexOf(\"{fontstack}\") === -1 && n.push(new b(t, e, '\"glyphs\" url must include a \"{fontstack}\" token')), e.indexOf(\"{range}\") === -1 && n.push(new b(t, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n}\nfunction ae(r, e = Ds) {\n  let t = [];\n  return t = t.concat(ar({\n    key: \"\",\n    value: r,\n    valueSpec: e.$root,\n    styleSpec: e,\n    style: r,\n    validateSpec: ar,\n    objectElementValidators: {\n      glyphs: Fo,\n      \"*\"() {\n        return [];\n      }\n    }\n  })), r.constants && (t = t.concat(Lo({\n    key: \"constants\",\n    value: r.constants\n  }))), No(t);\n}\nae.source = ve(ge(Mo));\nae.sprite = ve(ge(Oo));\nae.glyphs = ve(ge(Fo));\nae.light = ve(ge(Po));\nae.sky = ve(ge(Ro));\nae.terrain = ve(ge(zo));\nae.state = ve(ge($o));\nae.layer = ve(ge(Io));\nae.filter = ve(ge(zn));\nae.paintProperty = ve(ge(To));\nae.layoutProperty = ve(ge(_o));\nfunction ge(r) {\n  return function(e) {\n    return r({\n      ...e,\n      validateSpec: ar\n    });\n  };\n}\nfunction No(r) {\n  return [].concat(r).sort((e, t) => e.line - t.line);\n}\nfunction ve(r) {\n  return function(...e) {\n    return No(r.apply(this, e));\n  };\n}\nfunction ka(r) {\n  if (!r)\n    return {\n      style: _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n      requiresUrlMonitoring: !1,\n      // default styles don't require URL monitoring\n      isFallback: !0\n    };\n  if (typeof r == \"string\") {\n    const t = hu(r);\n    return t.isValidStyle ? {\n      style: t.styleObject,\n      requiresUrlMonitoring: !1,\n      isFallback: !1\n    } : t.isValidJSON ? {\n      style: _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n      requiresUrlMonitoring: !1,\n      // default styles don't require URL monitoring\n      isFallback: !0\n    } : r.startsWith(\"http\") ? { style: r, requiresUrlMonitoring: !0, isFallback: !1 } : r.toLowerCase().includes(\".json\") ? {\n      style: du(r),\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    } : {\n      style: (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.expandMapStyle)(r),\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    };\n  }\n  return r instanceof _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyleVariant ? {\n    style: r.getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : r instanceof _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.ReferenceMapStyle ? {\n    style: r.getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : ae(r).length === 0 ? {\n    style: r,\n    requiresUrlMonitoring: !1,\n    isFallback: !1,\n    isJSON: !0\n  } : {\n    style: _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    // default styles don't require URL monitoring\n    isFallback: !0\n  };\n}\nfunction du(r) {\n  try {\n    return new URL(r).href;\n  } catch {\n  }\n  return new URL(r, location.origin).href;\n}\nfunction hu(r) {\n  try {\n    const e = JSON.parse(r), t = ae(e);\n    return {\n      isValidJSON: !0,\n      isValidStyle: t.length === 0,\n      styleObject: t.length === 0 ? e : null\n    };\n  } catch {\n    return {\n      isValidJSON: !1,\n      isValidStyle: !1,\n      styleObject: null\n    };\n  }\n}\nfunction Te(r, e, t) {\n  const n = window.document.createElement(r);\n  return e !== void 0 && (n.className = e), t && t.appendChild(n), n;\n}\nfunction Et(r) {\n  r.parentNode && r.parentNode.removeChild(r);\n}\nclass mu {\n  constructor() {\n    g(this, \"_map\");\n    g(this, \"_container\");\n    g(this, \"_terrainButton\");\n    qi([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(e) {\n    return this._map = e, this._container = Te(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"), this._terrainButton = Te(\"button\", \"maplibregl-ctrl-terrain\", this._container), Te(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\"aria-hidden\", \"true\"), this._terrainButton.type = \"button\", this._terrainButton.addEventListener(\"click\", this._toggleTerrain), this._updateTerrainIcon(), this._map.on(\"terrain\", this._updateTerrainIcon), this._container;\n  }\n  onRemove() {\n    Et(this._container), this._map.off(\"terrain\", this._updateTerrainIcon), this._map = void 0;\n  }\n  _toggleTerrain() {\n    jo(this._map), this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\"), this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\"), this._map.hasTerrain() ? (this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\"), this._terrainButton.title = this._map._getUIString(\"TerrainControl.Disable\")) : (this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\"), this._terrainButton.title = this._map._getUIString(\"TerrainControl.Enable\"));\n  }\n}\nfunction jo(r) {\n  r.hasTerrain() ? r.disableTerrain() : r.enableTerrain();\n}\nclass yu extends Wa {\n  constructor(t = {}) {\n    super({\n      showCompass: t.showCompass ?? !0,\n      showZoom: t.showZoom ?? !0,\n      visualizePitch: t.visualizePitch ?? !0\n    });\n    /**\n     * Overloading: Limit how flat the compass icon can get\n     */\n    g(this, \"_rotateCompassArrow\", () => {\n      const t = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t}deg)` : `rotate(${-t}deg)`;\n      this._compassIcon.style.transform = a;\n    });\n    this._compass && (this._compass.removeEventListener(\"click\", this._compass.clickFunction), this._compass.addEventListener(\"click\", (n) => {\n      this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });\n    }));\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(t, n) {\n    const a = super._createButton(t, n);\n    return a.clickFunction = n, a;\n  }\n}\nconst La = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker, Ea = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLat, gu = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds;\nclass vu extends Pi {\n  constructor() {\n    super(...arguments);\n    g(this, \"lastUpdatedCenter\", new Ea(0, 0));\n    /**\n     * Update the camera location to center on the current position\n     *\n     * @param {Position} position the Geolocation API Position\n     * @private\n     */\n    g(this, \"_updateCamera\", (t) => {\n      var c;\n      const n = new Ea(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {\n        bearing: this._map.getBearing(),\n        ...this.options.fitBoundsOptions,\n        linear: !0\n      }, s = this._map.getZoom();\n      s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(gu.fromLngLat(n, a), i, {\n        geolocateSource: !0\n        // tag this camera change so it won't cause the control to change to background state\n      });\n      let l = !1;\n      const u = () => {\n        l = !0;\n      };\n      this._map.once(\"click\", u), this._map.once(\"dblclick\", u), this._map.once(\"dragstart\", u), this._map.once(\"mousedown\", u), this._map.once(\"touchstart\", u), this._map.once(\"wheel\", u), this._map.once(\"moveend\", () => {\n        this._map.off(\"click\", u), this._map.off(\"dblclick\", u), this._map.off(\"dragstart\", u), this._map.off(\"mousedown\", u), this._map.off(\"touchstart\", u), this._map.off(\"wheel\", u), !l && (this.lastUpdatedCenter = this._map.getCenter());\n      });\n    });\n    g(this, \"_finishSetupUI\", (t) => {\n      if (this._map) {\n        if (t === !1) {\n          const n = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n          this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute(\"aria-label\", n);\n        } else {\n          const n = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n          this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute(\"aria-label\", n);\n        }\n        this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = Te(\"div\", \"maplibregl-user-location-dot\"), this._userLocationDotMarker = new La({ element: this._dotElement }), this._circleElement = Te(\"div\", \"maplibregl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new La({\n          element: this._circleElement,\n          pitchAlignment: \"map\"\n        }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"move\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"moveend\", (n) => {\n          const a = n.originalEvent && n.originalEvent.type === \"resize\", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());\n          !n.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !a && o > 1 && (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this.fire(new Event(\"trackuserlocationend\")));\n        });\n      }\n    });\n    g(this, \"_onZoom\", () => {\n      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n    });\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\")\n      return;\n    const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);\n    this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;\n  }\n  // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the\n  // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.\n  // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294\n  _setErrorState() {\n    switch (this._watchState) {\n      case \"WAITING_ACTIVE\":\n        this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\");\n        break;\n      case \"ACTIVE_LOCK\":\n        this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\");\n        break;\n      case \"BACKGROUND\":\n        this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\");\n        break;\n      case \"ACTIVE_ERROR\":\n        break;\n      case \"BACKGROUND_ERROR\":\n        break;\n      default:\n        throw new Error(`Unexpected watchState ${this._watchState}`);\n    }\n  }\n}\nvar Me, Y, Pe, Re, nt;\nclass bu {\n  /**\n   * @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM\n   * @param onClick Function called when the element is clicked\n   * @param onRender Function called every time the underlying map renders a new state\n   */\n  constructor(e, t, n) {\n    Z(this, Me);\n    Z(this, Y);\n    Z(this, Pe);\n    Z(this, Re);\n    Z(this, nt);\n    if (typeof e == \"string\") {\n      const a = document.querySelector(e);\n      if (!a) throw new Error(`No element has been found with selector \"${e}\" when creating an external control.`);\n      K(this, Y, a);\n    } else\n      K(this, Y, e);\n    t && K(this, Pe, (a) => {\n      t(k(this, Me), k(this, Y), a);\n    }), n && K(this, Re, (a) => {\n      n(k(this, Me), k(this, Y), a);\n    }), K(this, nt, k(this, Y).parentElement);\n  }\n  onAdd(e) {\n    return K(this, Me, e), k(this, Pe) && k(this, Y).addEventListener(\"click\", k(this, Pe)), k(this, Re) && k(this, Me).on(\"render\", k(this, Re)), Et(k(this, Y)), k(this, Y);\n  }\n  onRemove() {\n    k(this, Pe) && k(this, Y).removeEventListener(\"click\", k(this, Pe)), k(this, Re) && k(this, Me).off(\"render\", k(this, Re)), k(this, nt) ? k(this, nt).appendChild(k(this, Y)) : Et(k(this, Y));\n  }\n}\nMe = new WeakMap(), Y = new WeakMap(), Pe = new WeakMap(), Re = new WeakMap(), nt = new WeakMap();\nclass wu {\n  constructor() {\n    g(this, \"map\");\n    g(this, \"container\");\n    g(this, \"projectionButton\");\n  }\n  onAdd(e) {\n    return this.map = e, this.container = Te(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"), this.projectionButton = Te(\"button\", \"maplibregl-ctrl-projection\", this.container), Te(\"span\", \"maplibregl-ctrl-icon\", this.projectionButton).setAttribute(\"aria-hidden\", \"true\"), this.projectionButton.type = \"button\", this.projectionButton.addEventListener(\"click\", this.toggleProjection.bind(this)), e.on(\"projectiontransition\", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;\n  }\n  onRemove() {\n    Et(this.container), this.map.off(\"projectiontransition\", this.updateProjectionIcon), this.map = void 0;\n  }\n  toggleProjection() {\n    Do(this.map), this.updateProjectionIcon();\n  }\n  updateProjectionIcon() {\n    this.projectionButton.classList.remove(\"maplibregl-ctrl-projection-globe\"), this.projectionButton.classList.remove(\"maplibregl-ctrl-projection-mercator\"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add(\"maplibregl-ctrl-projection-mercator\"), this.projectionButton.title = \"Enable Mercator projection\") : (this.projectionButton.classList.add(\"maplibregl-ctrl-projection-globe\"), this.projectionButton.title = \"Enable Globe projection\");\n  }\n}\nfunction Do(r) {\n  r.getProjection() === void 0 && r.setProjection({ type: \"mercator\" }), r.isGlobeProjection() ? r.enableMercatorProjection() : r.enableGlobeProjection();\n}\nconst pt = {\n  \"zoom-in\": (r) => r.zoomIn(),\n  \"zoom-out\": (r) => r.zoomOut(),\n  \"toggle-projection\": Do,\n  \"toggle-terrain\": jo,\n  \"reset-view\": (r) => {\n    r.getPitch() === 0 ? r.easeTo({ pitch: Math.min(r.getMaxPitch(), 80) }) : r.resetNorthPitch();\n  },\n  \"reset-bearing\": (r) => {\n    r.rotateTo(0);\n  },\n  \"reset-pitch\": (r) => {\n    r.setPitch(0);\n  },\n  \"reset-roll\": (r) => {\n    r.setRoll(0);\n  }\n};\nvar At, at;\nclass tn extends bu {\n  /**\n   * Constructs an instance of External Control to have a predefined functionality\n   * @param controlElement Element to be used as control, specified as reference to element itself\n   * @param controlType One of the predefined types of functionality\n   */\n  constructor(t, n) {\n    if (n && !(n in pt)) throw new Error(`data-maptiler-control value \"${n}\" is invalid.`);\n    super(t, n && pt[n]);\n    Z(this, At);\n    Z(this, at, /* @__PURE__ */ new Map());\n  }\n  onAdd(t) {\n    return K(this, At, t), super.onAdd(t);\n  }\n  onRemove() {\n    for (const [t, n] of k(this, at)) {\n      const a = t.deref();\n      a && a.removeEventListener(\"click\", n);\n    }\n    k(this, at).clear(), super.onRemove();\n  }\n  /**\n   * Configure a child element to be part of this control and to have a predefined functionality added\n   * @param controlElement Element that is a descendant of the control element and that optionally should have some functionality\n   * @param controlType One of the predefined types of functionality\n   */\n  configureGroupItem(t, n) {\n    if (!n) return;\n    if (!(n in pt)) throw new Error(`data-maptiler-control value \"${n}\" is invalid.`);\n    const a = (o) => {\n      pt[n](k(this, At), t, o);\n    };\n    t.addEventListener(\"click\", a), k(this, at).set(new WeakRef(t), a);\n  }\n}\nAt = new WeakMap(), at = new WeakMap(), g(tn, \"controlCallbacks\", pt);\nvar W, fe, ze, Oe, te, Tt, G, Uo, oe, Bo;\nclass $r {\n  constructor(e, t) {\n    Z(this, G);\n    Z(this, W);\n    g(this, \"map\");\n    Z(this, fe);\n    Z(this, ze);\n    Z(this, Oe);\n    Z(this, te, !1);\n    Z(this, Tt);\n    e.style !== void 0 && K(this, te, !0), K(this, W, {\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\",\n      // inherit map options\n      ...t,\n      // override any lingering control options\n      forceNoAttributionControl: !0,\n      attributionControl: !1,\n      navigationControl: !1,\n      geolocateControl: !1,\n      maptilerLogo: !1,\n      minimap: !1,\n      hash: !1,\n      pitchAdjust: !1,\n      // override map options with new user defined minimap options\n      ...e,\n      containerStyle: {\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\",\n        ...e.containerStyle ?? {}\n      }\n    }), e.lockZoom !== void 0 && (k(this, W).minZoom = e.lockZoom, k(this, W).maxZoom = e.lockZoom);\n  }\n  setStyle(e, t) {\n    k(this, te) || this.map.setStyle(e, t), X(this, G, oe).call(this);\n  }\n  addLayer(e, t) {\n    return k(this, te) || this.map.addLayer(e, t), X(this, G, oe).call(this), this.map;\n  }\n  moveLayer(e, t) {\n    return k(this, te) || this.map.moveLayer(e, t), X(this, G, oe).call(this), this.map;\n  }\n  removeLayer(e) {\n    return k(this, te) || this.map.removeLayer(e), X(this, G, oe).call(this), this;\n  }\n  setLayerZoomRange(e, t, n) {\n    return k(this, te) || this.map.setLayerZoomRange(e, t, n), X(this, G, oe).call(this), this;\n  }\n  setFilter(e, t, n) {\n    return k(this, te) || this.map.setFilter(e, t, n), X(this, G, oe).call(this), this;\n  }\n  setPaintProperty(e, t, n, a) {\n    return k(this, te) || this.map.setPaintProperty(e, t, n, a), X(this, G, oe).call(this), this;\n  }\n  setLayoutProperty(e, t, n, a) {\n    return k(this, te) || this.map.setLayoutProperty(e, t, n, a), X(this, G, oe).call(this), this;\n  }\n  setGlyphs(e, t) {\n    return k(this, te) || this.map.setGlyphs(e, t), X(this, G, oe).call(this), this;\n  }\n  onAdd(e) {\n    K(this, fe, e), K(this, ze, Te(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"));\n    for (const [t, n] of Object.entries(k(this, W).containerStyle))\n      k(this, ze).style.setProperty(t, n);\n    return k(this, W).container = k(this, ze), k(this, W).zoom = e.getZoom() + k(this, W).zoomAdjust, this.map = new Go(k(this, W)), this.map.once(\"style.load\", () => {\n      this.map.resize();\n    }), this.map.once(\"load\", () => {\n      X(this, G, Uo).call(this, k(this, W).parentRect), K(this, Tt, X(this, G, Bo).call(this));\n    }), k(this, ze);\n  }\n  onRemove() {\n    var e;\n    (e = k(this, Tt)) == null || e.call(this), Et(k(this, ze));\n  }\n}\nW = new WeakMap(), fe = new WeakMap(), ze = new WeakMap(), Oe = new WeakMap(), te = new WeakMap(), Tt = new WeakMap(), G = new WeakSet(), Uo = function(e) {\n  e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (K(this, Oe, {\n    type: \"Feature\",\n    properties: {\n      name: \"parentRect\"\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[[], [], [], [], []]]\n    }\n  }), this.map.addSource(\"parentRect\", {\n    type: \"geojson\",\n    data: k(this, Oe)\n  }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({\n    id: \"parentRectOutline\",\n    type: \"line\",\n    source: \"parentRect\",\n    layout: {\n      ...e.lineLayout\n    },\n    paint: {\n      \"line-color\": \"#FFF\",\n      \"line-width\": 1,\n      \"line-opacity\": 0.85,\n      ...e.linePaint\n    }\n  }), e.fillPaint !== void 0 && this.map.addLayer({\n    id: \"parentRectFill\",\n    type: \"fill\",\n    source: \"parentRect\",\n    layout: {},\n    paint: {\n      \"fill-color\": \"#08F\",\n      \"fill-opacity\": 0.135,\n      ...e.fillPaint\n    }\n  }), X(this, G, oe).call(this));\n}, oe = function() {\n  if (k(this, Oe) === void 0) return;\n  const { devicePixelRatio: e } = window, t = k(this, fe).getCanvas(), n = t.width / e, a = t.height / e, o = k(this, fe).unproject.bind(k(this, fe)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);\n  k(this, Oe).geometry.coordinates = [[l.toArray(), u.toArray(), s.toArray(), i.toArray(), l.toArray()]];\n  const c = this.map.getSource(\"parentRect\");\n  c !== void 0 && c.setData(k(this, Oe));\n}, Bo = function() {\n  const { pitchAdjust: e } = k(this, W), t = () => {\n    i(\"parent\");\n  }, n = () => {\n    i(\"minimap\");\n  }, a = () => {\n    k(this, fe).on(\"move\", t), this.map.on(\"move\", n);\n  }, o = () => {\n    k(this, fe).off(\"move\", t), this.map.off(\"move\", n);\n  }, i = (s) => {\n    o();\n    const l = s === \"parent\" ? k(this, fe) : this.map, u = s === \"parent\" ? this.map : k(this, fe), c = l.getCenter(), p = l.getZoom() + k(this, W).zoomAdjust * (s === \"parent\" ? 1 : -1), d = l.getBearing(), f = l.getPitch();\n    u.jumpTo({\n      center: c,\n      zoom: p,\n      bearing: d,\n      pitch: e ? f : 0\n    }), X(this, G, oe).call(this), a();\n  };\n  return a(), () => {\n    o();\n  };\n};\nclass Su {\n  /**\n   *\n   * @param map : a Map instance\n   * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)\n   */\n  constructor(e, t = 2e3) {\n    g(this, \"map\");\n    g(this, \"registeredModules\", /* @__PURE__ */ new Set());\n    g(this, \"viewerType\");\n    this.map = e, this.viewerType = \"Map\", setTimeout(\n      async () => {\n        if (!j.telemetry)\n          return;\n        const n = this.preparePayload();\n        try {\n          (await fetch(n, { method: \"POST\" })).ok || console.warn(\"The metrics could not be sent to MapTiler Cloud\");\n        } catch (a) {\n          console.warn(\"The metrics could not be sent to MapTiler Cloud\", a);\n        }\n      },\n      Math.max(1e3, t)\n    );\n  }\n  /**\n   * Register a module to the telemetry system of the SDK.\n   * The arguments `name` and `version` likely come from the package.json\n   * of each module.\n   */\n  registerModule(e, t) {\n    this.registeredModules.add(`${e}:${t}`);\n  }\n  registerViewerType(e = \"Map\") {\n    this.viewerType = e;\n  }\n  preparePayload() {\n    const e = new URL(J.telemetryURL);\n    return e.searchParams.append(\"sdk\", Kc()), e.searchParams.append(\"key\", j.apiKey), e.searchParams.append(\"mtsid\", dn), e.searchParams.append(\"session\", j.session ? \"1\" : \"0\"), e.searchParams.append(\"caching\", j.caching ? \"1\" : \"0\"), e.searchParams.append(\"lang-updated\", this.map.isLanguageUpdated() ? \"1\" : \"0\"), e.searchParams.append(\"terrain\", this.map.getTerrain() ? \"1\" : \"0\"), e.searchParams.append(\"globe\", this.map.isGlobeProjection() ? \"1\" : \"0\"), e.searchParams.append(\"viewerType\", this.viewerType), this.registeredModules.size > 0 && e.searchParams.append(\"modules\", Array.from(this.registeredModules).join(\"|\")), e.href;\n  }\n}\nvar Ct = typeof Float32Array < \"u\" ? Float32Array : Array;\nfunction gt() {\n  var r = new Ct(16);\n  return Ct != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;\n}\nfunction xu(r, e, t, n, a, o, i, s, l, u, c, p, d, f, h, m, y) {\n  return r[0] = e, r[1] = t, r[2] = n, r[3] = a, r[4] = o, r[5] = i, r[6] = s, r[7] = l, r[8] = u, r[9] = c, r[10] = p, r[11] = d, r[12] = f, r[13] = h, r[14] = m, r[15] = y, r;\n}\nfunction ku(r, e, t) {\n  var n = e[0], a = e[1], o = e[2], i = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], d = e[9], f = e[10], h = e[11], m = e[12], y = e[13], w = e[14], v = e[15], x = t[0], A = t[1], E = t[2], C = t[3];\n  return r[0] = x * n + A * s + E * p + C * m, r[1] = x * a + A * l + E * d + C * y, r[2] = x * o + A * u + E * f + C * w, r[3] = x * i + A * c + E * h + C * v, x = t[4], A = t[5], E = t[6], C = t[7], r[4] = x * n + A * s + E * p + C * m, r[5] = x * a + A * l + E * d + C * y, r[6] = x * o + A * u + E * f + C * w, r[7] = x * i + A * c + E * h + C * v, x = t[8], A = t[9], E = t[10], C = t[11], r[8] = x * n + A * s + E * p + C * m, r[9] = x * a + A * l + E * d + C * y, r[10] = x * o + A * u + E * f + C * w, r[11] = x * i + A * c + E * h + C * v, x = t[12], A = t[13], E = t[14], C = t[15], r[12] = x * n + A * s + E * p + C * m, r[13] = x * a + A * l + E * d + C * y, r[14] = x * o + A * u + E * f + C * w, r[15] = x * i + A * c + E * h + C * v, r;\n}\nfunction Lu(r, e, t) {\n  var n = t[0], a = t[1], o = t[2];\n  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * a, r[5] = e[5] * a, r[6] = e[6] * a, r[7] = e[7] * a, r[8] = e[8] * o, r[9] = e[9] * o, r[10] = e[10] * o, r[11] = e[11] * o, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;\n}\nfunction Ca(r, e, t) {\n  var n = Math.sin(t), a = Math.cos(t), o = e[4], i = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], d = e[11];\n  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = o * a + u * n, r[5] = i * a + c * n, r[6] = s * a + p * n, r[7] = l * a + d * n, r[8] = u * a - o * n, r[9] = c * a - i * n, r[10] = p * a - s * n, r[11] = d * a - l * n, r;\n}\nfunction Eu(r, e, t) {\n  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], d = e[11];\n  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a - u * n, r[1] = i * a - c * n, r[2] = s * a - p * n, r[3] = l * a - d * n, r[8] = o * n + u * a, r[9] = i * n + c * a, r[10] = s * n + p * a, r[11] = l * n + d * a, r;\n}\nfunction Aa(r, e, t) {\n  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], d = e[7];\n  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a + u * n, r[1] = i * a + c * n, r[2] = s * a + p * n, r[3] = l * a + d * n, r[4] = u * a - o * n, r[5] = c * a - i * n, r[6] = p * a - s * n, r[7] = d * a - l * n, r;\n}\nfunction Cu(r, e, t, n, a) {\n  var o = 1 / Math.tan(e / 2);\n  if (r[0] = o / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, a != null && a !== 1 / 0) {\n    var i = 1 / (n - a);\n    r[10] = (a + n) * i, r[14] = 2 * a * n * i;\n  } else\n    r[10] = -1, r[14] = -2 * n;\n  return r;\n}\nvar Au = Cu;\nfunction Zt() {\n  var r = new Ct(3);\n  return Ct != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;\n}\nfunction Tu(r, e, t) {\n  var n = new Ct(3);\n  return n[0] = r, n[1] = e, n[2] = t, n;\n}\nfunction Fr(r, e) {\n  var t = e[0], n = e[1], a = e[2], o = t * t + n * n + a * a;\n  return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = e[0] * o, r[1] = e[1] * o, r[2] = e[2] * o, r;\n}\nfunction Ta(r, e, t) {\n  var n = e[0], a = e[1], o = e[2], i = t[0], s = t[1], l = t[2];\n  return r[0] = a * l - o * s, r[1] = o * i - n * l, r[2] = n * s - a * i, r;\n}\n(function() {\n  var r = Zt();\n  return function(e, t, n, a, o, i) {\n    var s, l;\n    for (t || (t = 3), n || (n = 0), a ? l = Math.min(a * t + n, e.length) : l = e.length, s = n; s < l; s += t)\n      r[0] = e[s], r[1] = e[s + 1], r[2] = e[s + 2], o(r, r, i), e[s] = r[0], e[s + 1] = r[1], e[s + 2] = r[2];\n    return e;\n  };\n})();\nfunction _u(r) {\n  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, \"default\") ? r.default : r;\n}\nvar Nr, _a;\nfunction Iu() {\n  return _a || (_a = 1, Nr = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  }), Nr;\n}\nvar jr, Ia;\nfunction qo() {\n  if (Ia) return jr;\n  Ia = 1;\n  const r = Iu(), e = {};\n  for (const a of Object.keys(r))\n    e[r[a]] = a;\n  const t = {\n    rgb: { channels: 3, labels: \"rgb\" },\n    hsl: { channels: 3, labels: \"hsl\" },\n    hsv: { channels: 3, labels: \"hsv\" },\n    hwb: { channels: 3, labels: \"hwb\" },\n    cmyk: { channels: 4, labels: \"cmyk\" },\n    xyz: { channels: 3, labels: \"xyz\" },\n    lab: { channels: 3, labels: \"lab\" },\n    lch: { channels: 3, labels: \"lch\" },\n    hex: { channels: 1, labels: [\"hex\"] },\n    keyword: { channels: 1, labels: [\"keyword\"] },\n    ansi16: { channels: 1, labels: [\"ansi16\"] },\n    ansi256: { channels: 1, labels: [\"ansi256\"] },\n    hcg: { channels: 3, labels: [\"h\", \"c\", \"g\"] },\n    apple: { channels: 3, labels: [\"r16\", \"g16\", \"b16\"] },\n    gray: { channels: 1, labels: [\"gray\"] }\n  };\n  jr = t;\n  for (const a of Object.keys(t)) {\n    if (!(\"channels\" in t[a]))\n      throw new Error(\"missing channels property: \" + a);\n    if (!(\"labels\" in t[a]))\n      throw new Error(\"missing channel labels property: \" + a);\n    if (t[a].labels.length !== t[a].channels)\n      throw new Error(\"channel and label counts mismatch: \" + a);\n    const { channels: o, labels: i } = t[a];\n    delete t[a].channels, delete t[a].labels, Object.defineProperty(t[a], \"channels\", { value: o }), Object.defineProperty(t[a], \"labels\", { value: i });\n  }\n  t.rgb.hsl = function(a) {\n    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(o, i, s), u = Math.max(o, i, s), c = u - l;\n    let p, d;\n    u === l ? p = 0 : o === u ? p = (i - s) / c : i === u ? p = 2 + (s - o) / c : s === u && (p = 4 + (o - i) / c), p = Math.min(p * 60, 360), p < 0 && (p += 360);\n    const f = (l + u) / 2;\n    return u === l ? d = 0 : f <= 0.5 ? d = c / (u + l) : d = c / (2 - u - l), [p, d * 100, f * 100];\n  }, t.rgb.hsv = function(a) {\n    let o, i, s, l, u;\n    const c = a[0] / 255, p = a[1] / 255, d = a[2] / 255, f = Math.max(c, p, d), h = f - Math.min(c, p, d), m = function(y) {\n      return (f - y) / 6 / h + 1 / 2;\n    };\n    return h === 0 ? (l = 0, u = 0) : (u = h / f, o = m(c), i = m(p), s = m(d), c === f ? l = s - i : p === f ? l = 1 / 3 + o - s : d === f && (l = 2 / 3 + i - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [\n      l * 360,\n      u * 100,\n      f * 100\n    ];\n  }, t.rgb.hwb = function(a) {\n    const o = a[0], i = a[1];\n    let s = a[2];\n    const l = t.rgb.hsl(a)[0], u = 1 / 255 * Math.min(o, Math.min(i, s));\n    return s = 1 - 1 / 255 * Math.max(o, Math.max(i, s)), [l, u * 100, s * 100];\n  }, t.rgb.cmyk = function(a) {\n    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(1 - o, 1 - i, 1 - s), u = (1 - o - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, p = (1 - s - l) / (1 - l) || 0;\n    return [u * 100, c * 100, p * 100, l * 100];\n  };\n  function n(a, o) {\n    return (a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2 + (a[2] - o[2]) ** 2;\n  }\n  return t.rgb.keyword = function(a) {\n    const o = e[a];\n    if (o)\n      return o;\n    let i = 1 / 0, s;\n    for (const l of Object.keys(r)) {\n      const u = r[l], c = n(a, u);\n      c < i && (i = c, s = l);\n    }\n    return s;\n  }, t.keyword.rgb = function(a) {\n    return r[a];\n  }, t.rgb.xyz = function(a) {\n    let o = a[0] / 255, i = a[1] / 255, s = a[2] / 255;\n    o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92, i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92, s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92;\n    const l = o * 0.4124 + i * 0.3576 + s * 0.1805, u = o * 0.2126 + i * 0.7152 + s * 0.0722, c = o * 0.0193 + i * 0.1192 + s * 0.9505;\n    return [l * 100, u * 100, c * 100];\n  }, t.rgb.lab = function(a) {\n    const o = t.rgb.xyz(a);\n    let i = o[0], s = o[1], l = o[2];\n    i /= 95.047, s /= 100, l /= 108.883, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, l = l > 8856e-6 ? l ** (1 / 3) : 7.787 * l + 16 / 116;\n    const u = 116 * s - 16, c = 500 * (i - s), p = 200 * (s - l);\n    return [u, c, p];\n  }, t.hsl.rgb = function(a) {\n    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;\n    let l, u, c;\n    if (i === 0)\n      return c = s * 255, [c, c, c];\n    s < 0.5 ? l = s * (1 + i) : l = s + i - s * i;\n    const p = 2 * s - l, d = [0, 0, 0];\n    for (let f = 0; f < 3; f++)\n      u = o + 1 / 3 * -(f - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = p + (l - p) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = p + (l - p) * (2 / 3 - u) * 6 : c = p, d[f] = c * 255;\n    return d;\n  }, t.hsl.hsv = function(a) {\n    const o = a[0];\n    let i = a[1] / 100, s = a[2] / 100, l = i;\n    const u = Math.max(s, 0.01);\n    s *= 2, i *= s <= 1 ? s : 2 - s, l *= u <= 1 ? u : 2 - u;\n    const c = (s + i) / 2, p = s === 0 ? 2 * l / (u + l) : 2 * i / (s + i);\n    return [o, p * 100, c * 100];\n  }, t.hsv.rgb = function(a) {\n    const o = a[0] / 60, i = a[1] / 100;\n    let s = a[2] / 100;\n    const l = Math.floor(o) % 6, u = o - Math.floor(o), c = 255 * s * (1 - i), p = 255 * s * (1 - i * u), d = 255 * s * (1 - i * (1 - u));\n    switch (s *= 255, l) {\n      case 0:\n        return [s, d, c];\n      case 1:\n        return [p, s, c];\n      case 2:\n        return [c, s, d];\n      case 3:\n        return [c, p, s];\n      case 4:\n        return [d, c, s];\n      case 5:\n        return [s, c, p];\n    }\n  }, t.hsv.hsl = function(a) {\n    const o = a[0], i = a[1] / 100, s = a[2] / 100, l = Math.max(s, 0.01);\n    let u, c;\n    c = (2 - i) * s;\n    const p = (2 - i) * l;\n    return u = i * l, u /= p <= 1 ? p : 2 - p, u = u || 0, c /= 2, [o, u * 100, c * 100];\n  }, t.hwb.rgb = function(a) {\n    const o = a[0] / 360;\n    let i = a[1] / 100, s = a[2] / 100;\n    const l = i + s;\n    let u;\n    l > 1 && (i /= l, s /= l);\n    const c = Math.floor(6 * o), p = 1 - s;\n    u = 6 * o - c, c & 1 && (u = 1 - u);\n    const d = i + u * (p - i);\n    let f, h, m;\n    switch (c) {\n      default:\n      case 6:\n      case 0:\n        f = p, h = d, m = i;\n        break;\n      case 1:\n        f = d, h = p, m = i;\n        break;\n      case 2:\n        f = i, h = p, m = d;\n        break;\n      case 3:\n        f = i, h = d, m = p;\n        break;\n      case 4:\n        f = d, h = i, m = p;\n        break;\n      case 5:\n        f = p, h = i, m = d;\n        break;\n    }\n    return [f * 255, h * 255, m * 255];\n  }, t.cmyk.rgb = function(a) {\n    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, o * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), p = 1 - Math.min(1, s * (1 - l) + l);\n    return [u * 255, c * 255, p * 255];\n  }, t.xyz.rgb = function(a) {\n    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100;\n    let l, u, c;\n    return l = o * 3.2406 + i * -1.5372 + s * -0.4986, u = o * -0.9689 + i * 1.8758 + s * 0.0415, c = o * 0.0557 + i * -0.204 + s * 1.057, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, u = u > 31308e-7 ? 1.055 * u ** (1 / 2.4) - 0.055 : u * 12.92, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [l * 255, u * 255, c * 255];\n  }, t.xyz.lab = function(a) {\n    let o = a[0], i = a[1], s = a[2];\n    o /= 95.047, i /= 100, s /= 108.883, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;\n    const l = 116 * i - 16, u = 500 * (o - i), c = 200 * (i - s);\n    return [l, u, c];\n  }, t.lab.xyz = function(a) {\n    const o = a[0], i = a[1], s = a[2];\n    let l, u, c;\n    u = (o + 16) / 116, l = i / 500 + u, c = u - s / 200;\n    const p = u ** 3, d = l ** 3, f = c ** 3;\n    return u = p > 8856e-6 ? p : (u - 16 / 116) / 7.787, l = d > 8856e-6 ? d : (l - 16 / 116) / 7.787, c = f > 8856e-6 ? f : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [l, u, c];\n  }, t.lab.lch = function(a) {\n    const o = a[0], i = a[1], s = a[2];\n    let l;\n    l = Math.atan2(s, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);\n    const c = Math.sqrt(i * i + s * s);\n    return [o, c, l];\n  }, t.lch.lab = function(a) {\n    const o = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI, u = i * Math.cos(l), c = i * Math.sin(l);\n    return [o, u, c];\n  }, t.rgb.ansi16 = function(a, o = null) {\n    const [i, s, l] = a;\n    let u = o === null ? t.rgb.hsv(a)[2] : o;\n    if (u = Math.round(u / 50), u === 0)\n      return 30;\n    let c = 30 + (Math.round(l / 255) << 2 | Math.round(s / 255) << 1 | Math.round(i / 255));\n    return u === 2 && (c += 60), c;\n  }, t.hsv.ansi16 = function(a) {\n    return t.rgb.ansi16(t.hsv.rgb(a), a[2]);\n  }, t.rgb.ansi256 = function(a) {\n    const o = a[0], i = a[1], s = a[2];\n    return o === i && i === s ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(s / 255 * 5);\n  }, t.ansi16.rgb = function(a) {\n    let o = a % 10;\n    if (o === 0 || o === 7)\n      return a > 50 && (o += 3.5), o = o / 10.5 * 255, [o, o, o];\n    const i = (~~(a > 50) + 1) * 0.5, s = (o & 1) * i * 255, l = (o >> 1 & 1) * i * 255, u = (o >> 2 & 1) * i * 255;\n    return [s, l, u];\n  }, t.ansi256.rgb = function(a) {\n    if (a >= 232) {\n      const u = (a - 232) * 10 + 8;\n      return [u, u, u];\n    }\n    a -= 16;\n    let o;\n    const i = Math.floor(a / 36) / 5 * 255, s = Math.floor((o = a % 36) / 6) / 5 * 255, l = o % 6 / 5 * 255;\n    return [i, s, l];\n  }, t.rgb.hex = function(a) {\n    const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();\n    return \"000000\".substring(i.length) + i;\n  }, t.hex.rgb = function(a) {\n    const o = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n    if (!o)\n      return [0, 0, 0];\n    let i = o[0];\n    o[0].length === 3 && (i = i.split(\"\").map((p) => p + p).join(\"\"));\n    const s = parseInt(i, 16), l = s >> 16 & 255, u = s >> 8 & 255, c = s & 255;\n    return [l, u, c];\n  }, t.rgb.hcg = function(a) {\n    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.max(Math.max(o, i), s), u = Math.min(Math.min(o, i), s), c = l - u;\n    let p, d;\n    return c < 1 ? p = u / (1 - c) : p = 0, c <= 0 ? d = 0 : l === o ? d = (i - s) / c % 6 : l === i ? d = 2 + (s - o) / c : d = 4 + (o - i) / c, d /= 6, d %= 1, [d * 360, c * 100, p * 100];\n  }, t.hsl.hcg = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = i < 0.5 ? 2 * o * i : 2 * o * (1 - i);\n    let l = 0;\n    return s < 1 && (l = (i - 0.5 * s) / (1 - s)), [a[0], s * 100, l * 100];\n  }, t.hsv.hcg = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = o * i;\n    let l = 0;\n    return s < 1 && (l = (i - s) / (1 - s)), [a[0], s * 100, l * 100];\n  }, t.hcg.rgb = function(a) {\n    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;\n    if (i === 0)\n      return [s * 255, s * 255, s * 255];\n    const l = [0, 0, 0], u = o % 1 * 6, c = u % 1, p = 1 - c;\n    let d = 0;\n    switch (Math.floor(u)) {\n      case 0:\n        l[0] = 1, l[1] = c, l[2] = 0;\n        break;\n      case 1:\n        l[0] = p, l[1] = 1, l[2] = 0;\n        break;\n      case 2:\n        l[0] = 0, l[1] = 1, l[2] = c;\n        break;\n      case 3:\n        l[0] = 0, l[1] = p, l[2] = 1;\n        break;\n      case 4:\n        l[0] = c, l[1] = 0, l[2] = 1;\n        break;\n      default:\n        l[0] = 1, l[1] = 0, l[2] = p;\n    }\n    return d = (1 - i) * s, [\n      (i * l[0] + d) * 255,\n      (i * l[1] + d) * 255,\n      (i * l[2] + d) * 255\n    ];\n  }, t.hcg.hsv = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);\n    let l = 0;\n    return s > 0 && (l = o / s), [a[0], l * 100, s * 100];\n  }, t.hcg.hsl = function(a) {\n    const o = a[1] / 100, s = a[2] / 100 * (1 - o) + 0.5 * o;\n    let l = 0;\n    return s > 0 && s < 0.5 ? l = o / (2 * s) : s >= 0.5 && s < 1 && (l = o / (2 * (1 - s))), [a[0], l * 100, s * 100];\n  }, t.hcg.hwb = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);\n    return [a[0], (s - o) * 100, (1 - s) * 100];\n  }, t.hwb.hcg = function(a) {\n    const o = a[1] / 100, s = 1 - a[2] / 100, l = s - o;\n    let u = 0;\n    return l < 1 && (u = (s - l) / (1 - l)), [a[0], l * 100, u * 100];\n  }, t.apple.rgb = function(a) {\n    return [a[0] / 65535 * 255, a[1] / 65535 * 255, a[2] / 65535 * 255];\n  }, t.rgb.apple = function(a) {\n    return [a[0] / 255 * 65535, a[1] / 255 * 65535, a[2] / 255 * 65535];\n  }, t.gray.rgb = function(a) {\n    return [a[0] / 100 * 255, a[0] / 100 * 255, a[0] / 100 * 255];\n  }, t.gray.hsl = function(a) {\n    return [0, 0, a[0]];\n  }, t.gray.hsv = t.gray.hsl, t.gray.hwb = function(a) {\n    return [0, 100, a[0]];\n  }, t.gray.cmyk = function(a) {\n    return [0, 0, 0, a[0]];\n  }, t.gray.lab = function(a) {\n    return [a[0], 0, 0];\n  }, t.gray.hex = function(a) {\n    const o = Math.round(a[0] / 100 * 255) & 255, s = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();\n    return \"000000\".substring(s.length) + s;\n  }, t.rgb.gray = function(a) {\n    return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];\n  }, jr;\n}\nvar Dr, Ma;\nfunction Mu() {\n  if (Ma) return Dr;\n  Ma = 1;\n  const r = qo();\n  function e() {\n    const o = {}, i = Object.keys(r);\n    for (let s = i.length, l = 0; l < s; l++)\n      o[i[l]] = {\n        // http://jsperf.com/1-vs-infinity\n        // micro-opt, but this is simple.\n        distance: -1,\n        parent: null\n      };\n    return o;\n  }\n  function t(o) {\n    const i = e(), s = [o];\n    for (i[o].distance = 0; s.length; ) {\n      const l = s.pop(), u = Object.keys(r[l]);\n      for (let c = u.length, p = 0; p < c; p++) {\n        const d = u[p], f = i[d];\n        f.distance === -1 && (f.distance = i[l].distance + 1, f.parent = l, s.unshift(d));\n      }\n    }\n    return i;\n  }\n  function n(o, i) {\n    return function(s) {\n      return i(o(s));\n    };\n  }\n  function a(o, i) {\n    const s = [i[o].parent, o];\n    let l = r[i[o].parent][o], u = i[o].parent;\n    for (; i[u].parent; )\n      s.unshift(i[u].parent), l = n(r[i[u].parent][u], l), u = i[u].parent;\n    return l.conversion = s, l;\n  }\n  return Dr = function(o) {\n    const i = t(o), s = {}, l = Object.keys(i);\n    for (let u = l.length, c = 0; c < u; c++) {\n      const p = l[c];\n      i[p].parent !== null && (s[p] = a(p, i));\n    }\n    return s;\n  }, Dr;\n}\nvar Ur, Pa;\nfunction Pu() {\n  if (Pa) return Ur;\n  Pa = 1;\n  const r = qo(), e = Mu(), t = {}, n = Object.keys(r);\n  function a(i) {\n    const s = function(...l) {\n      const u = l[0];\n      return u == null ? u : (u.length > 1 && (l = u), i(l));\n    };\n    return \"conversion\" in i && (s.conversion = i.conversion), s;\n  }\n  function o(i) {\n    const s = function(...l) {\n      const u = l[0];\n      if (u == null)\n        return u;\n      u.length > 1 && (l = u);\n      const c = i(l);\n      if (typeof c == \"object\")\n        for (let p = c.length, d = 0; d < p; d++)\n          c[d] = Math.round(c[d]);\n      return c;\n    };\n    return \"conversion\" in i && (s.conversion = i.conversion), s;\n  }\n  return n.forEach((i) => {\n    t[i] = {}, Object.defineProperty(t[i], \"channels\", { value: r[i].channels }), Object.defineProperty(t[i], \"labels\", { value: r[i].labels });\n    const s = e(i);\n    Object.keys(s).forEach((u) => {\n      const c = s[u];\n      t[i][u] = o(c), t[i][u].raw = a(c);\n    });\n  }), Ur = t, Ur;\n}\nvar Ru = Pu();\nconst zu = /* @__PURE__ */ _u(Ru);\nfunction Ra({ gl: r, type: e, source: t }) {\n  const n = r.createShader(e);\n  if (n === null)\n    throw new Error(\"Cannot create shader\");\n  if (r.shaderSource(n, t), r.compileShader(n), !r.getShaderParameter(n, r.COMPILE_STATUS))\n    throw console.error(\"Shader compilation error:\", r.getShaderInfoLog(n)), r.deleteShader(n), new Error(\"Cannot compile shader\");\n  return n;\n}\nfunction Ou({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }) {\n  const n = Ra({\n    gl: r,\n    type: r.VERTEX_SHADER,\n    source: e\n  }), a = Ra({ gl: r, type: r.FRAGMENT_SHADER, source: t }), o = r.createProgram();\n  if (r.attachShader(o, n), r.attachShader(o, a), r.linkProgram(o), !r.getProgramParameter(o, r.LINK_STATUS))\n    throw console.error(\"Error: \", r.getProgramInfoLog(o)), new Error(\"Cannot link shader program\");\n  return o;\n}\nfunction $u(r, e, t) {\n  const n = r.getUniformLocation(e, t);\n  if (n === null)\n    throw new Error(`Cannot get uniform location for ${t}`);\n  return n;\n}\nfunction Vo({\n  gl: r,\n  vertexShaderSource: e,\n  fragmentShaderSource: t,\n  attributesKeys: n,\n  uniformsKeys: a,\n  vertices: o,\n  indices: i\n}) {\n  const s = Ou({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }), l = n.reduce((f, h) => (f[h] = r.getAttribLocation(s, `a_${h}`), f), {}), u = a.reduce((f, h) => (f[h] = $u(r, s, `u_${h}`), f), {}), c = r.createBuffer();\n  r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, new Float32Array(o), r.STATIC_DRAW);\n  let p, d;\n  return i !== void 0 && (p = r.createBuffer(), d = i.length, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, p), r.bufferData(r.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), r.STATIC_DRAW)), {\n    shaderProgram: s,\n    programInfo: {\n      attributesLocations: l,\n      uniformsLocations: u\n    },\n    positionBuffer: c,\n    indexBuffer: p,\n    indexBufferLength: d\n  };\n}\nfunction Kt(r) {\n  if (!r)\n    return [1, 1, 1, 0];\n  if (r === \"transparent\")\n    return [1, 1, 1, 0];\n  try {\n    const e = Fu(r), t = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i.exec(e);\n    if (t != null && t.length) {\n      const a = !!t[4];\n      return [...zu.hex.rgb(e).map((o) => o / 255), a ? parseInt(t[4], 16) / 255 : 1];\n    }\n    const n = e.match(/(\\d\\.\\d(\\d+)?|\\d{3}|\\d{2}|\\d{1})/gi) ?? [\"0\", \"0\", \"0\"];\n    if (e.includes(\"rgb\")) {\n      const a = e.includes(\"rgba\"), o = [\n        ...n.map((i) => parseFloat(i)).map((i, s) => s < 3 ? i / 255 : i)\n        // because alpha is in the range 0 - 1, not 0 - 255\n      ];\n      return a || o.push(1), o;\n    }\n  } catch {\n  }\n  return console.warn([`[parseColorStringToVec4]: Color ${r} is either not a valid color or its type is not supported, defaulting to black`]), [0, 0, 0, 1];\n}\nlet ft;\nfunction Fu(r) {\n  return ft = ft ?? document.createElement(\"canvas\").getContext(\"2d\"), ft ? (ft.fillStyle = r, ft.fillStyle) : \"#000000\";\n}\nconst On = 1, ue = On / 2, ce = On / 2, pe = On / 2, Nu = [-0.5, -0.5, pe, ue, -0.5, pe, ue, ce, pe, -0.5, ce, pe], ju = [-0.5, -0.5, -0.5, -0.5, ce, -0.5, ue, ce, -0.5, ue, -0.5, -0.5], Du = [-0.5, ce, -0.5, -0.5, ce, pe, ue, ce, pe, ue, ce, -0.5], Uu = [-0.5, -0.5, -0.5, ue, -0.5, -0.5, ue, -0.5, pe, -0.5, -0.5, pe], Bu = [ue, -0.5, -0.5, ue, ce, -0.5, ue, ce, pe, ue, -0.5, pe], qu = [-0.5, -0.5, -0.5, -0.5, -0.5, pe, -0.5, ce, pe, -0.5, ce, -0.5], Vu = [...Nu, ...ju, ...Du, ...Uu, ...Bu, ...qu], Gu = [\n  // Front\n  0,\n  1,\n  2,\n  0,\n  2,\n  3,\n  // Back\n  4,\n  5,\n  6,\n  4,\n  6,\n  7,\n  // Left\n  8,\n  9,\n  10,\n  8,\n  10,\n  11,\n  // Right\n  12,\n  13,\n  14,\n  12,\n  14,\n  15,\n  // Up\n  16,\n  17,\n  18,\n  16,\n  18,\n  19,\n  // Down\n  20,\n  21,\n  22,\n  20,\n  22,\n  23\n], Hu = `attribute vec3 a_vertexPosition;\nvarying vec3 vTextureCoord;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_modelViewMatrix;\n  \nvoid main(void) {\n  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);\n  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);\n}\n`, za = `precision mediump float;\n\nvarying vec3 vTextureCoord;\n\n%USE_TEXTURE_MACRO_MARKER%\n\n# ifdef USE_TEXTURE\nuniform samplerCube u_cubeSampler;\nuniform float u_fadeOpacity;\n# endif\n\nuniform vec4 u_bgColor;\n\nvoid main(void) {\n  #ifdef USE_TEXTURE\n  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);\n\n    gl_FragColor = mix(\n      u_bgColor,\n      texColor,\n      min(texColor.a, u_fadeOpacity)\n    );\n\n    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);\n\n  #else\n  gl_FragColor = u_bgColor;\n  #endif\n}\n`;\nvar Zu = /* @__PURE__ */ ((r) => (r.UNIVERSE_DARK = \"universe-dark\", r))(Zu || {});\nconst Ke = {\n  stars: {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"stars\"\n  },\n  space: {\n    color: \"hsl(210, 100%, 4%)\",\n    preset: \"space\"\n  },\n  milkyway: {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"milkyway\"\n  },\n  \"milkyway-subtle\": {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"milkyway-subtle\"\n  },\n  \"milkyway-bright\": {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"milkyway-bright\"\n  },\n  \"milkyway-colored\": {\n    color: \"black\",\n    preset: \"milkyway-colored\"\n  }\n};\nvar Be = /* @__PURE__ */ ((r) => (r.POSITIVE_X = \"pX\", r.NEGATIVE_X = \"nX\", r.POSITIVE_Y = \"pY\", r.NEGATIVE_Y = \"nY\", r.POSITIVE_Z = \"pZ\", r.NEGATIVE_Z = \"nZ\", r))(Be || {});\nconst Vt = /* @__PURE__ */ new Map(), Oa = /* @__PURE__ */ new Map();\nlet $a;\nfunction Ku({ gl: r, faces: e, onReady: t, forceRefresh: n }) {\n  if (Vt.get(r) && !n && $a === JSON.stringify(e)) {\n    t(Vt.get(r), Oa.get(r));\n    return;\n  }\n  $a = JSON.stringify(e);\n  const a = Vt.get(r) ?? r.createTexture();\n  if (!e) {\n    console.warn(\"[CubemapLayer][loadCubemapTexture]: Faces are null\");\n    return;\n  }\n  const o = Object.keys(e).length;\n  if (o !== 6) {\n    console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${o}`);\n    return;\n  }\n  const i = Object.entries(e).map(([s, l]) => new Promise((u, c) => {\n    const p = s;\n    if (l === void 0) {\n      c(new Error(`[CubemapLayer][loadCubemapTexture]: Face ${s} is undefined`));\n      return;\n    }\n    const d = new Image();\n    d.crossOrigin = \"anonymous\";\n    const f = () => {\n      u({ image: d, key: p });\n    };\n    d.src = l, d.complete && d.naturalWidth > 0 ? f() : d.onload = f, d.onerror = () => {\n      c(new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${l}`));\n    };\n  }));\n  Promise.all(i).then((s) => {\n    for (let u = 0; u < s.length; u++) {\n      const p = r.RGBA, d = r.RGBA, f = r.UNSIGNED_BYTE, { image: h, key: m } = s[u] ?? {};\n      if (!h || !m) {\n        console.warn(\"[CubemapLayer][loadCubemapTexture]: Image or key is null\");\n        continue;\n      }\n      const y = Xu(r, m);\n      r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(y, 0, p, d, f, h);\n    }\n    r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.generateMipmap(r.TEXTURE_CUBE_MAP), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);\n    const l = s.map((u) => u.image);\n    t(a, l), Oa.set(r, l), Vt.set(r, a);\n  }).catch((s) => {\n    console.error(\"[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture\", s);\n  });\n}\nfunction Xu(r, e) {\n  if (e === Be.POSITIVE_X)\n    return r.TEXTURE_CUBE_MAP_POSITIVE_X;\n  if (e === Be.NEGATIVE_X)\n    return r.TEXTURE_CUBE_MAP_NEGATIVE_X;\n  if (e === Be.POSITIVE_Y)\n    return r.TEXTURE_CUBE_MAP_POSITIVE_Y;\n  if (e === Be.NEGATIVE_Y)\n    return r.TEXTURE_CUBE_MAP_NEGATIVE_Y;\n  if (e === Be.POSITIVE_Z)\n    return r.TEXTURE_CUBE_MAP_POSITIVE_Z;\n  if (e === Be.NEGATIVE_Z)\n    return r.TEXTURE_CUBE_MAP_NEGATIVE_Z;\n  throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${e}`);\n}\nfunction Yu(r, e, t) {\n  return [\n    Fe(r[0], e[0], t),\n    Fe(r[1], e[1], t),\n    Fe(r[2], e[2], t),\n    Fe(r[3], e[3], t)\n  ];\n}\nfunction Fe(r, e, t) {\n  return r + (e - r) * t;\n}\nfunction or(r) {\n  if (!r)\n    return {};\n  const e = Object.keys(r).sort().map((t) => [t, r[t]]);\n  return Object.fromEntries(e);\n}\nconst Je = \"https://api.maptiler.com/resources/space\", Wu = [\"vertexPosition\"], Ju = [\"projectionMatrix\", \"modelViewMatrix\", \"cubeSampler\", \"bgColor\", \"fadeOpacity\"], Fa = \"%USE_TEXTURE_MACRO_MARKER%\", Qu = \"#define USE_TEXTURE\", Na = Ke.stars;\nfunction ec(r, e) {\n  if (!rn(r))\n    return {\n      color: \"transparent\"\n    };\n  if (r === !0)\n    return e;\n  const t = {\n    ...r\n  };\n  if (r.faces || r.path)\n    return delete t.preset, t;\n  const n = r.preset;\n  if (!(n === void 0) && !(n in Ke))\n    throw new Error(`[CubemapLayer]: Invalid preset \"${n}\". Available presets: ${Object.keys(Ke).join(\", \")}`);\n  return {\n    ...t,\n    // this _could_ be nullish_\n    color: t.color ?? Ke[n].color ?? \"hsl(233,100%,92%)\"\n  };\n}\nclass Br {\n  /**\n   * Creates a new instance of CubemapLayer\n   *\n   * @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.\n   * Can specify faces, preset, path, and color properties to configure the cubemap.\n   *\n   * @remarks You shouldn't have to use this class directly.\n   * Instead, use the `Map.setHalo` method to create and add a halo layer to the map.\n   * The constructor initializes the cubemap with the provided configuration.\n   * It processes the faces definition, sets up background colors, and determines\n   * whether to use a cubemap texture based on the provided options.\n   */\n  constructor(e) {\n    g(this, \"id\", \"Cubemap Layer\");\n    g(this, \"type\", \"custom\");\n    g(this, \"renderingMode\", \"3d\");\n    /**\n     * The map instance to which this layer is added.\n     * @type {MapSDK}\n     * @private\n     */\n    g(this, \"map\");\n    /**\n     * The cubemap faces definition, which can be either a preset, path, or explicit face URLs.\n     * @type {CubemapFaces | null}\n     * @remarks\n     * This property is set during the initialization of the layer and can be updated later.\n     * If no faces are defined, it will be `null`.\n     */\n    g(this, \"faces\");\n    /**\n     * Indicates whether to use a cubemap texture for rendering.\n     * @type {boolean}\n     * @private\n     * @default true\n     */\n    g(this, \"useCubemapTexture\", !0);\n    /**\n     * The current opacity of the fade effect applied to the cubemap image texture, used for fading in and out.\n     * @type {number}\n     * @private\n     * @default 0.0\n     */\n    g(this, \"currentFadeOpacity\", 0);\n    /**\n     * Indicates whether the cubemap needs to be updated, typically when the faces or texture changes.\n     * @type {boolean}\n     * @private\n     * @default false\n     */\n    g(this, \"cubeMapNeedsUpdate\", !1);\n    /**\n     * The background color of the cubemap layer, represented as a Vec4 (RGBA).\n     * @type {Vec4}\n     * @private\n     */\n    g(this, \"bgColor\");\n    /**\n     * The previous background color used for transition animations.\n     * @type {Vec4}\n     * @private\n     */\n    g(this, \"previousBgColor\", [0, 0, 0, 0]);\n    /**\n     * The target background color to which the layer will transition.\n     * @type {Vec4}\n     * @private\n     */\n    g(this, \"targetBgColor\", [0, 0, 0, 0]);\n    /**\n     * The delta value used for transitioning the background color. 0 = start of transition, 1 = end of transition.\n     * This value is incremented over time to create a smooth transition effect.\n     * @type {number}\n     * @private\n     */\n    g(this, \"transitionDelta\", 0);\n    /**\n     * The WebGL context used for rendering the cubemap layer.\n     * @type {WebGLContext}\n     * @private\n     */\n    g(this, \"gl\");\n    /**\n     * The cubemap object that contains the shader program, buffers and uniform locations for rendering.\n     * @type {Object3D}\n     * @private\n     */\n    g(this, \"cubemap\");\n    /**\n     * The WebGL texture used for the cubemap, which is created from the defined faces.\n     * This texture is used to render the cubemap in the scene.\n     * @type {WebGLTexture | undefined}\n     * @private\n     */\n    g(this, \"texture\");\n    /**\n     * The key representing the current faces definition, used to diff / track changes in the cubemap faces.\n     * @type {string}\n     */\n    g(this, \"currentFacesDefinitionKey\", \"\");\n    /**\n     * The configuration options for the cubemap layer.\n     * @type {CubemapLayerConstructorOptions}\n     * @private\n     */\n    g(this, \"options\");\n    g(this, \"animationActive\", !0);\n    /**\n     * Animates the cubemap image fading in.\n     * This method gradually increases the opacity of the cubemap image to create a fade-in effect.\n     *\n     * @private\n     */\n    g(this, \"imageIsAnimating\", !1);\n    /**\n     * The delta value used for the image fade-in animation.\n     * This value is incremented over time to create a smooth fade-in effect.\n     * @type {number}\n     * @private\n     */\n    g(this, \"imageFadeInDelta\", 0);\n    const t = ec(e, Na);\n    this.options = t, this.currentFacesDefinitionKey = JSON.stringify(t.faces ?? t.preset ?? t.path), this.bgColor = [0, 0, 0, 0], this.targetBgColor = Kt(t.color), this.faces = ja(t), this.useCubemapTexture = this.faces !== null;\n  }\n  /**\n   * Updates the cubemap object with the current faces and shader configuration.\n   * This method is called when the cubemap faces change or when the layer is initialized.\n   * @returns {void}\n   * @remarks\n   * It creates a new Object3D instance with the specified vertex and fragment shaders,\n   * attributes, and uniforms. The cubemap will be rendered using this configuration.\n   */\n  updateCubemap({ facesNeedUpdate: e } = { facesNeedUpdate: !0 }) {\n    this.useCubemapTexture = this.faces !== null;\n    const t = Ju.filter((n) => n === \"cubeSampler\" || n === \"fadeOpacity\" ? this.useCubemapTexture : !0);\n    this.cubemap = Vo({\n      gl: this.gl,\n      vertexShaderSource: Hu,\n      // Because we only want to use the read the texture in gl if we're supposed to\n      fragmentShaderSource: this.useCubemapTexture ? za.replace(Fa, Qu) : za.replace(Fa, \"\"),\n      attributesKeys: Wu,\n      uniformsKeys: t,\n      vertices: Vu,\n      indices: Gu\n    }), this.cubeMapNeedsUpdate = e, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();\n  }\n  /**\n   * Called when the layer is added to the map.\n   * Initializes the cubemap and sets up the WebGL context.\n   *\n   * @param {MapSDK} map - The map instance to which this layer is added.\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.\n   */\n  onAdd(e, t) {\n    this.map = e, this.gl = t, this.updateCubemap();\n  }\n  /**\n   * Called when the layer is removed from the map.\n   * Cleans up the cubemap resources and WebGL buffers.\n   *\n   * @param {MapSDK} _map - The map instance from which this layer is removed.\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.\n   */\n  onRemove(e, t) {\n    this.cubemap && (this.texture && t.deleteTexture(this.texture), t.deleteProgram(this.cubemap.shaderProgram), t.deleteBuffer(this.cubemap.positionBuffer), this.texture = void 0);\n  }\n  /**\n   * Updates the cubemap texture with the provided faces.\n   * This method is called when the cubemap faces change or when the layer is initialized.\n   *\n   * @param {WebGLContext} gl - The WebGL context used for rendering.\n   * @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.\n   */\n  updateTexture(e, t) {\n    if (this.cubeMapNeedsUpdate === !0 && !this.imageIsAnimating) {\n      if (this.cubeMapNeedsUpdate = !1, !this.useCubemapTexture)\n        return;\n      Ku({\n        gl: e,\n        faces: t,\n        onReady: (n) => {\n          this.texture = n, this.animateIn();\n        }\n      });\n    }\n  }\n  /**\n   * Called before the layer is rendered.\n   * Updates the cubemap texture with the current faces.\n   *\n   * @param {WebGLContext} gl - The WebGL context used for rendering.\n   * @param {CustomRenderMethodInput} _options - Additional options for the render method.\n   */\n  prerender(e, t) {\n    this.faces && this.updateTexture(this.gl, this.faces);\n  }\n  /**\n   * Lerps the background color transition of the cubemap layer.\n   * This method smoothly transitions the background color from the previous color to the target color.\n   *\n   * @private\n   */\n  animateColorChange() {\n    const e = () => {\n      this.transitionDelta < 1 && (requestAnimationFrame(e), this.bgColor = Yu(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += 0.075, this.map.triggerRepaint());\n    };\n    requestAnimationFrame(e);\n  }\n  /**\n   * Animates the cubemap image fading in.\n   * This method gradually increases the opacity of the cubemap image to create a fade-in effect.\n   * @private\n   */\n  async animateIn() {\n    if (!this.imageIsAnimating) {\n      if (!this.animationActive) {\n        this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();\n        return;\n      }\n      return new Promise((e) => {\n        this.imageIsAnimating = !0;\n        const t = () => {\n          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Fe(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {\n            requestAnimationFrame(t);\n            return;\n          }\n          this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();\n        };\n        requestAnimationFrame(t);\n      });\n    }\n  }\n  /**\n   * Animates the cubemap image fading out.\n   * This method gradually decreases the opacity of the cubemap image to create a fade-out effect.\n   * @returns {Promise<void>} A promise that resolves when the animation is complete.\n   * @private\n   */\n  async animateOut() {\n    if (!(this.imageIsAnimating || !this.animationActive))\n      return new Promise((e) => {\n        const t = () => {\n          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Fe(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {\n            this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();\n            return;\n          }\n          requestAnimationFrame(t);\n        };\n        requestAnimationFrame(t);\n      });\n  }\n  setAnimationActive(e) {\n    this.animationActive = e;\n  }\n  /**\n   * Renders the cubemap layer to the WebGL context.\n   * This method is called internally during the rendering phase of the map.\n   *\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.\n   * @param {CustomRenderMethodInput} _options - Additional options for the render method.\n   * @throws Error if the map, cubemap, or texture is undefined.\n   */\n  render(e, t) {\n    if (!this.map.isGlobeProjection())\n      return;\n    if (this.map === void 0)\n      throw new Error(\"[CubemapLayer]: Map is undefined\");\n    if (this.cubemap === void 0)\n      throw new Error(\"[CubemapLayer]: Cubemap is undefined\");\n    this.texture, e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA), e.useProgram(this.cubemap.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer), e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);\n    const n = 0.1, a = 1e4, o = e.canvas, i = o.clientWidth / o.clientHeight, s = this.map.transform, l = s.fov * (Math.PI / 180), u = gt();\n    Au(u, l, i, n, a), Aa(u, u, s.rollInRadians), Ca(u, u, -s.pitchInRadians), Aa(u, u, s.bearingInRadians);\n    const c = s.center.lat * Math.PI / 180, p = s.center.lng * Math.PI / 180;\n    Ca(u, u, c), Eu(u, u, -p), e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, u);\n    const d = gt();\n    if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, d), e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture), e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0)\n      throw new Error(\"Index buffer is undefined\");\n    if (this.cubemap.indexBufferLength === void 0)\n      throw new Error(\"Index buffer length is undefined\");\n    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0);\n  }\n  setBgColor(e) {\n    this.targetBgColor = e, this.previousBgColor = this.bgColor, this.transitionDelta = 0;\n  }\n  /**\n   * Returns the current configuration options for the cubemap layer.\n   * @returns {CubemapLayerConstructorOptions} The current configuration options.\n   */\n  getConfig() {\n    return this.options;\n  }\n  /**\n   * Checks if the cubemap needs to be updated based on the provided specification.\n   *\n   * @param {CubemapDefinition} spec - The cubemap specification to compare with the current cubemap.\n   * @returns {boolean} True if the cubemap needs to be updated, false otherwise.\n   */\n  shouldUpdate(e) {\n    const t = this.getConfig();\n    if (e === void 0 && t)\n      return !1;\n    const n = or(e), a = or(t);\n    return JSON.stringify(n) !== JSON.stringify(a);\n  }\n  async setCubemapFaces(e) {\n    if (await this.animateOut(), !e.faces && !e.preset && !e.path) {\n      this.faces = null, this.useCubemapTexture = !1, this.currentFacesDefinitionKey = \"empty\", await this.animateIn();\n      return;\n    }\n    this.faces = ja(e), this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path);\n  }\n  /**\n   * Sets the cubemap for the layer based on the provided definition.\n   * This method updates the cubemap faces, background color, and triggers a repaint of the map.\n   *\n   * @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.\n   * @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.\n   * @remarks\n   * This method checks if the provided cubemap definition has a color, and if so, it updates the background color.\n   * It also checks if the faces definition has changed compared to the current one,\n   * and if so, it updates the cubemap faces.\n   * Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.\n   */\n  async setCubemap(e) {\n    const t = typeof e == \"boolean\" ? Na : e;\n    this.options = t;\n    const n = JSON.stringify(t.faces ?? t.preset ?? t.path), a = this.currentFacesDefinitionKey !== n;\n    a && (await this.setCubemapFaces(t), this.cubeMapNeedsUpdate = !0);\n    const o = Kt(t.color);\n    if (t.color && this.targetBgColor.toString() !== o.toString())\n      this.setBgColor(o);\n    else if (!t.color && t.preset && t.preset in Ke) {\n      const i = Ke[t.preset];\n      this.setBgColor(Kt(i.color));\n    }\n    this.updateCubemap({ facesNeedUpdate: a });\n  }\n  /**\n   * Shows the cubemap layer by setting its visibility to \"visible\".\n   * This method is used to make the cubemap layer visible on the map.\n   */\n  show() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"visible\");\n  }\n  /**\n   * Hides the cubemap layer by setting its visibility to \"none\".\n   * This method is used to remove the cubemap layer from the map without deleting it.\n   */\n  hide() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"none\");\n  }\n}\nfunction rn(r) {\n  return r ? typeof r == \"boolean\" ? !0 : !(!r.path && !r.preset && !r.faces && !r.color || r.preset && !(r.preset in Ke) || r.faces && (!r.faces.pX || !r.faces.nX || !r.faces.pY || !r.faces.nY || !r.faces.pZ || !r.faces.nZ)) : !1;\n}\nfunction ja(r) {\n  if (r.faces)\n    return r.faces;\n  if (r.preset)\n    return {\n      pX: `${Je}/${r.preset}/px.webp`,\n      nX: `${Je}/${r.preset}/nx.webp`,\n      pY: `${Je}/${r.preset}/py.webp`,\n      nY: `${Je}/${r.preset}/ny.webp`,\n      pZ: `${Je}/${r.preset}/pz.webp`,\n      nZ: `${Je}/${r.preset}/nz.webp`\n    };\n  if (r.path) {\n    const e = r.path.baseUrl, t = r.path.format ?? \"png\";\n    return {\n      pX: `${e}/px.${t}`,\n      nX: `${e}/nx.${t}`,\n      pY: `${e}/py.${t}`,\n      nY: `${e}/ny.${t}`,\n      pZ: `${e}/pz.${t}`,\n      nZ: `${e}/nz.${t}`\n    };\n  }\n  return null;\n}\nconst tc = `attribute vec3 a_position;\n\nuniform mat4 u_matrix;\nuniform mat4 u_rotationMatrix;\n\nuniform float u_scale;\n\nvarying vec2 v_pos;\nvarying float v_scale;\n\nvoid main() {\n  v_scale = u_scale;\n  v_pos = a_position.xy * u_scale;\n  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);\n}\n`, rc = `precision mediump float;\nvarying vec2 v_pos;\n      \nuniform int u_stopsNumber;\nuniform float u_stops[100];\nuniform vec4 u_colors[100];\nuniform float u_maxDistance;\n\nvarying float v_scale;\n\nconst float EPSILON = 0.000001;\n\nvec2 center = vec2(0.0, 0.0);\nvoid main() {\n  float rawDistance = distance(center, v_pos);\n  float distanceFromGlobeEdge = rawDistance - 1.0;\n\n    vec4 color = u_colors[0];\n\n  // if we're further than the max distance, we should not render anything.\n  // This is to always render a circle, otherwise we end up rendering\n  // to the corners of the plane.\n  if (distance(center, v_pos) > u_maxDistance * v_scale) {\n    discard;\n  }\n\n  for (int i = 1; i < 100; i++) {\n    // if we're past the last stop\n    // we should fill to the end with the last stop color\n    if (i >= u_stopsNumber) {\n      color = u_colors[i - 1];\n      break;\n    }\n\n    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);\n    float lastStopValue = u_stops[i - 1];\n    float thisStopValue = u_stops[i];\n\n    // this is to avoid blending errors when the stops are the same\n    // eg when you would want a sharp edge between two stops.\n    // \\`numbersAreEqual\\` will be 1.0 if the numbers are equal, 0.0 if they are not.\n    // We then subtract EPSILON from the last stop making the stop value _almost_ equal\n    // to the next stop but not enough to cause blending issues.\n    // It's more efficient to do this than an if / else statement.\n    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));\n    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;\n\n    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);\n\n    if (distanceFromGlobeEdge <= scaledStopPosition) {\n      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);\n      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);\n      break;\n    }\n  }\n  \n  // gl_FragColor = color;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n`, dt = 2, nc = [\"position\"], ac = [\"matrix\", \"rotationMatrix\", \"stopsNumber\", \"stops\", \"colors\", \"maxDistance\", \"scale\"], oc = [\n  -2,\n  -2,\n  0,\n  dt,\n  -2,\n  0,\n  -2,\n  dt,\n  0,\n  dt,\n  dt,\n  0\n], Qe = {\n  scale: 0.9,\n  stops: [\n    [0, \"rgba(176, 208, 240, 1)\"],\n    [0.1, \"rgba(98, 168, 229, 0.3)\"],\n    [0.2, \"rgba(98, 168, 229, 0.0)\"]\n  ]\n}, Da = 0.06;\nclass qr {\n  /**\n   * Creates a new RadialGradientLayer instance.\n   *\n   * @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.\n   * If a boolean is provided, default configuration options will be used.\n   * If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.\n   */\n  constructor(e) {\n    g(this, \"id\", \"Halo Layer\");\n    g(this, \"type\", \"custom\");\n    g(this, \"renderingMode\", \"3d\");\n    /**\n     * The gradient definition used by this layer.\n     * It contains the stops and scale for the radial gradient.\n     * @private\n     * @type {GradientDefinition}\n     */\n    g(this, \"gradient\");\n    /**\n     * The scale of the radial gradient, which determines its size.\n     * This value is animated from 0 to the target scale during the layer's appearance.\n     * @private\n     * @type {number}\n     */\n    g(this, \"scale\", 0);\n    /**\n     * The animation delta value used to control the progress of the gradient's appearance animation.\n     * It is incremented during each frame of the animation until it reaches 1.\n     * @private\n     * @type {number}\n     */\n    g(this, \"animationDelta\", 0);\n    /**\n     * The MapSDK instance to which this layer is added.\n     * This is set when the layer is added to the map.\n     * @private\n     * @type {MapSDK}\n     */\n    g(this, \"map\");\n    /**\n     * The 3D object representing the radial gradient plane.\n     * This object is created when the layer is added to the map and contains the shader program and buffers.\n     * It is used for rendering the radial gradient effect.\n     * @private\n     * @type {Object3D<(typeof ATTRIBUTES_KEYS)[number], (typeof UNIFORMS_KEYS)[number]>}\n     */\n    g(this, \"plane\");\n    /**\n     * Whether the halo should be animated in and out.\n     * @private\n     * @type {boolean}\n     */\n    g(this, \"animationActive\", !0);\n    if (typeof e == \"boolean\") {\n      this.gradient = Qe;\n      return;\n    }\n    const t = Ua(e);\n    if (t.length > 0)\n      throw new Error(`[RadialGradientLayer]: Invalid Halo specification:\n - ${t.join(`\n - `)}\n    `);\n    this.gradient = {\n      ...Qe,\n      ...e\n    };\n  }\n  /**\n   * Adds the radial gradient layer to the specified map.\n   * This method is called by the map when the layer is added to it.\n   *\n   * @param {MapSDK} map - The MapSDK instance to which this layer is being added\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer\n   * @returns void\n   */\n  onAdd(e, t) {\n    this.map = e, this.plane = Vo({\n      gl: t,\n      vertexShaderSource: tc,\n      fragmentShaderSource: rc,\n      attributesKeys: nc,\n      uniformsKeys: ac,\n      vertices: oc\n    }), this.animateIn();\n  }\n  /**\n   * Returns the current gradient configuration of the radial gradient layer.\n   *\n   * @returns {GradientDefinition} The current gradient configuration.\n   */\n  getConfig() {\n    return this.gradient;\n  }\n  /**\n   * Checks if the gradient needs to be updated based on the provided specification.\n   *\n   * @param {GradientDefinition} spec - The gradient specification to compare with the current gradient.\n   * @returns {boolean} True if the gradient needs to be updated, false otherwise.\n   */\n  shouldUpdate(e) {\n    const t = this.getConfig();\n    if (e === void 0 && t)\n      return !1;\n    const n = or(e), a = or(t);\n    return JSON.stringify(n) !== JSON.stringify(a);\n  }\n  /**\n   * Animates the radial gradient into view by gradually scaling from 0 to the target scale.\n   *\n   * This method uses requestAnimationFrame to create a smooth scaling animation effect.\n   * During each frame, it:\n   *   1. Interpolates the scale value between 0 and the target scale\n   *   2. Increments the animation progress (animationDelta)\n   *   3. Triggers a map repaint\n   *\n   * @private\n   * @returns {Promise<void>} A promise that resolves when the animation completes\n   */\n  async animateIn() {\n    if (!this.animationActive) {\n      this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();\n      return;\n    }\n    return new Promise((e) => {\n      this.animationDelta = 0;\n      const t = () => {\n        if (this.animationDelta < 1) {\n          this.scale = Fe(0, this.gradient.scale, this.animationDelta), this.animationDelta += Da, this.map.triggerRepaint(), requestAnimationFrame(t);\n          return;\n        }\n        e();\n      };\n      requestAnimationFrame(t);\n    });\n  }\n  /**\n   * Animates the radial gradient layer out by gradually reducing its scale to zero.\n   *\n   * This method creates a smooth transition effect by linearly interpolating the scale\n   * from its current value to zero over multiple animation frames. During each frame,\n   * the animation progresses by incrementing the internal animation delta value.\n   *\n   * The map is repainted after each animation step to reflect the updated scale.\n   *\n   * @private\n   * @returns A Promise that resolves when the animation is complete.\n   */\n  async animateOut() {\n    if (this.animationActive)\n      return this.animationDelta = 0, new Promise((e) => {\n        const t = () => {\n          if (this.animationDelta < 1) {\n            this.scale = Fe(this.gradient.scale, 0, this.animationDelta), this.animationDelta += Da, this.map.triggerRepaint(), requestAnimationFrame(t);\n            return;\n          }\n          e();\n        };\n        t();\n      });\n  }\n  onRemove(e, t) {\n    this.plane !== void 0 && (t.deleteProgram(this.plane.shaderProgram), t.deleteBuffer(this.plane.positionBuffer));\n  }\n  prerender(e, t) {\n  }\n  render(e, t) {\n    if (this.map === void 0)\n      throw new Error(\"[RadialGradientLayer]: Map is undefined\");\n    if (!this.map.isGlobeProjection())\n      return;\n    if (this.plane === void 0)\n      throw new Error(\"[RadialGradientLayer]: Plane is undefined\");\n    e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.useProgram(this.plane.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);\n    const n = this.plane.programInfo.attributesLocations.position;\n    e.enableVertexAttribArray(n), e.vertexAttribPointer(n, 3, e.FLOAT, !1, 0, 0);\n    const a = gt(), o = this.scale;\n    Lu(a, a, [o, o, o]);\n    const i = gt();\n    ku(i, t.defaultProjectionData.mainMatrix, a);\n    const s = this.plane.programInfo.uniformsLocations.matrix;\n    e.uniformMatrix4fv(s, !1, i);\n    const l = gt(), u = this.map.transform.cameraPosition, c = Fr(Zt(), u), p = Tu(0, 1, 0), d = Zt();\n    Ta(d, p, c), Fr(d, d);\n    const f = Zt();\n    Ta(f, c, d), Fr(f, f), xu(l, d[0], d[1], d[2], 0, f[0], f[1], f[2], 0, c[0], c[1], c[2], 0, 0, 0, 0, 1);\n    const h = this.plane.programInfo.uniformsLocations.rotationMatrix;\n    e.uniformMatrix4fv(h, !1, l);\n    const m = this.gradient.stops.length, y = [], w = [];\n    for (let v = 0; v <= m; v++)\n      if (v < m) {\n        y[v] = this.gradient.stops[v][0];\n        const x = Kt(this.gradient.stops[v][1]);\n        w.push(...x);\n      }\n    e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, m), e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(y)), e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(w)), e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, dt), e.uniform1f(this.plane.programInfo.uniformsLocations.scale, o), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);\n  }\n  /**\n   * Sets a new gradient for the radial gradient layer and animates the transition.\n   *\n   * This method first animates the current gradient out, then updates the gradient\n   * property with the new gradient definition, and finally animates the new gradient in.\n   *\n   * @param {GradientDefinition} gradient - The new gradient definition to set for this layer.\n   * @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.\n   */\n  async setGradient(e) {\n    if (e === !1) {\n      await this.animateOut();\n      return;\n    }\n    await this.animateOut();\n    const t = Ua(e);\n    if (t.length > 0)\n      throw new Error(`[RadialGradientLayer]: Invalid Halo specification:\n - ${t.join(`\n - `)}\n    `);\n    e === !0 ? (this.gradient.scale = Qe.scale, this.gradient.stops = Qe.stops) : (this.gradient.scale = e.scale ?? Qe.scale, this.gradient.stops = e.stops ?? Qe.stops), await this.animateIn();\n  }\n  setAnimationActive(e) {\n    this.animationActive = e;\n  }\n  show() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"visible\");\n  }\n  hide() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"none\");\n  }\n}\nconst ic = [\"scale\", \"stops\"];\nfunction Ua(r) {\n  var t;\n  const e = [];\n  if (typeof r == \"boolean\")\n    return [];\n  try {\n    const n = Object.keys(r).filter((a) => !ic.includes(a));\n    n.length > 0 && e.push(`Properties ${n.map((a) => `\\`${a}\\``).join(\", \")} are not supported.`);\n  } catch {\n    e.push(\"Halo specification is not an object.\");\n  }\n  return typeof r.scale != \"number\" && e.push(\"Halo `scale` property is not a number.\"), (!r.stops || r.stops.length === 0) && e.push(\"Halo `stops` property is not an array.\"), (t = r.stops) != null && t.some((n) => typeof n[0] != \"number\" || typeof n[1] != \"string\") && e.push(\"Halo `stops` property is not an array of [number, string]\"), e;\n}\nconst sc = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nlet Go = class Ho extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map {\n  constructor(t) {\n    Hi(t.container), t.apiKey && (j.apiKey = t.apiKey);\n    const { style: n, requiresUrlMonitoring: a, isFallback: o } = ka(t.style);\n    o && console.warn(\n      \"Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.\"\n    ), j.apiKey || console.warn(\"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\");\n    const i = location.hash;\n    let s = {\n      compact: !1\n    };\n    t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == \"object\" && (s = {\n      ...s,\n      ...t.attributionControl\n    });\n    const l = {\n      ...t,\n      style: n,\n      maplibreLogo: !1,\n      transformRequest: ta(t.transformRequest),\n      attributionControl: t.forceNoAttributionControl === !0 ? !1 : s\n    };\n    delete l.style;\n    super(l);\n    g(this, \"telemetry\");\n    g(this, \"space\");\n    g(this, \"halo\");\n    g(this, \"options\");\n    g(this, \"isTerrainEnabled\", !1);\n    g(this, \"terrainExaggeration\", 1);\n    g(this, \"primaryLanguage\");\n    g(this, \"terrainGrowing\", !1);\n    g(this, \"terrainFlattening\", !1);\n    g(this, \"minimap\");\n    g(this, \"forceLanguageUpdate\");\n    g(this, \"languageAlwaysBeenStyle\");\n    g(this, \"isReady\", !1);\n    g(this, \"terrainAnimationDuration\", 1e3);\n    g(this, \"monitoredStyleUrls\");\n    g(this, \"styleInProcess\", !1);\n    g(this, \"curentProjection\");\n    g(this, \"originalLabelStyle\", new window.Map());\n    g(this, \"isStyleLocalized\", !1);\n    g(this, \"languageIsUpdated\", !1);\n    this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);\n    const u = () => {\n      let h = \"The distant style could not be loaded.\";\n      this.getStyle() ? h += \" Leaving the style as is.\" : (this.setStyle(_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle.STREETS), h += `Loading default MapTiler Cloud style \"${_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.MapStyle.STREETS.getDefaultVariant().getId()}\" as a fallback.`), console.warn(h);\n    };\n    if (this.on(\"style.load\", () => {\n      this.styleInProcess = !1;\n    }), this.on(\"error\", (h) => {\n      if (console.error(h.error), h.error instanceof maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AJAXError) {\n        const y = h.error.url, w = new URL(y);\n        w.search = \"\";\n        const v = w.href;\n        this.monitoredStyleUrls && this.monitoredStyleUrls.has(v) && (this.monitoredStyleUrls.delete(v), u());\n        return;\n      }\n      if (this.styleInProcess) {\n        u();\n        return;\n      }\n    }), j.caching && !Hr && console.warn(\"The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache\"), j.caching && Hr && Bi(), typeof t.language > \"u\")\n      this.primaryLanguage = j.primaryLanguage;\n    else {\n      const h = (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.toLanguageInfo)(t.language, z);\n      this.primaryLanguage = h ?? j.primaryLanguage;\n    }\n    this.forceLanguageUpdate = !(this.primaryLanguage === z.STYLE || this.primaryLanguage === z.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === z.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on(\"style.load\", (h) => {\n      this.curentProjection === \"mercator\" ? this.setProjection({ type: \"mercator\" }) : this.curentProjection === \"globe\" && this.setProjection({ type: \"globe\" });\n    }), this.once(\"styledata\", async () => {\n      if (!t.geolocate || t.center || t.hash && i)\n        return;\n      try {\n        if (t.geolocate === sc.COUNTRY) {\n          await this.fitToIpBounds();\n          return;\n        }\n      } catch (y) {\n        console.warn(y.message);\n      }\n      let h;\n      try {\n        await this.centerOnIpPoint(t.zoom), h = this.getCameraHash();\n      } catch (y) {\n        console.warn(y.message);\n      }\n      (await navigator.permissions.query({\n        name: \"geolocation\"\n      })).state === \"granted\" && navigator.geolocation.getCurrentPosition(\n        // success callback\n        (y) => {\n          h === this.getCameraHash() && (this.terrain ? this.easeTo({\n            center: [y.coords.longitude, y.coords.latitude],\n            zoom: t.zoom || 12,\n            duration: 2e3\n          }) : this.once(\"terrain\", () => {\n            this.easeTo({\n              center: [y.coords.longitude, y.coords.latitude],\n              zoom: t.zoom || 12,\n              duration: 2e3\n            });\n          }));\n        },\n        // error callback\n        null,\n        // options\n        {\n          maximumAge: 24 * 3600 * 1e3,\n          // a day in millisec\n          timeout: 5e3,\n          // milliseconds\n          enableHighAccuracy: !1\n        }\n      );\n    }), this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    }), this.on(\"styledata\", () => {\n      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);\n    }), this.once(\"load\", async () => {\n      let h = { logo: null };\n      try {\n        const m = Object.keys(this.style.sourceCaches).map((v) => this.getSource(v)).filter((v) => v && \"url\" in v && typeof v.url == \"string\" && v.url.includes(\"tiles.json\")), y = new URL(m[0].url);\n        y.searchParams.has(\"key\") || y.searchParams.append(\"key\", j.apiKey), h = await (await fetch(y.href)).json();\n      } catch {\n      }\n      if (t.customControls) {\n        const m = \"[data-maptiler-control-group]\", y = \"[data-maptiler-control]\", w = (C) => {\n          let N = C.dataset.maptilerControl;\n          return (N === \"true\" || N === \"\") && (N = void 0), N;\n        }, v = (C) => C.dataset.maptilerPosition;\n        let x = [...this._container.ownerDocument.querySelectorAll(m)], A = [...this._container.ownerDocument.querySelectorAll(y)].filter(\n          (C) => C.closest(m) === null\n        );\n        if (typeof t.customControls == \"string\") {\n          const C = t.customControls;\n          x = x.filter((N) => N.matches(C) || N.closest(C) !== null), A = A.filter((N) => N.matches(C) || N.closest(C) !== null);\n        }\n        for (const C of x) {\n          const N = new tn(C);\n          this.addControl(N, v(C));\n          for (const ee of C.querySelectorAll(y))\n            N.configureGroupItem(ee, w(ee));\n        }\n        for (const C of A)\n          this.addControl(new tn(C, w(C)), v(C));\n        const E = () => {\n          const { lng: C, lat: N } = this.getCenter();\n          this._container.style.setProperty(\"--maptiler-center-lng\", String(C)), this._container.style.setProperty(\"--maptiler-center-lat\", String(N)), this._container.style.setProperty(\"--maptiler-zoom\", String(this.getZoom())), this._container.style.setProperty(\"--maptiler-bearing\", String(this.getBearing())), this._container.style.setProperty(\"--maptiler-pitch\", String(this.getPitch())), this._container.style.setProperty(\"--maptiler-roll\", String(this.getRoll())), this._container.style.setProperty(\"--maptiler-is-globe-projection\", String(this.isGlobeProjection())), this._container.style.setProperty(\"--maptiler-has-terrain\", String(this.hasTerrain()));\n        };\n        E(), this.on(\"render\", E);\n      }\n      if (t.forceNoAttributionControl !== !0)\n        if (\"logo\" in h && h.logo) {\n          const m = h.logo;\n          this.addControl(new Wn({ logoURL: m }), t.logoPosition);\n        } else t.maptilerLogo && this.addControl(new Wn(), t.logoPosition);\n      if (t.scaleControl) {\n        const m = t.scaleControl === !0 || t.scaleControl === void 0 ? \"bottom-right\" : t.scaleControl, y = new zi({ unit: j.unit });\n        this.addControl(y, m), j.on(\"unit\", (w) => {\n          y.setUnit(w);\n        });\n      }\n      if (t.navigationControl !== !1) {\n        const m = t.navigationControl === !0 || t.navigationControl === void 0 ? \"top-right\" : t.navigationControl;\n        this.addControl(new yu(), m);\n      }\n      if (t.geolocateControl !== !1) {\n        const m = t.geolocateControl === !0 || t.geolocateControl === void 0 ? \"top-right\" : t.geolocateControl;\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new vu({\n            positionOptions: {\n              enableHighAccuracy: !0,\n              maximumAge: 0,\n              timeout: 6e3\n            },\n            fitBoundsOptions: {\n              maxZoom: 15\n            },\n            trackUserLocation: !0,\n            showAccuracyCircle: !0,\n            showUserLocation: !0\n          }),\n          m\n        );\n      }\n      if (t.terrainControl) {\n        const m = t.terrainControl === !0 || t.terrainControl === void 0 ? \"top-right\" : t.terrainControl;\n        this.addControl(new mu(), m);\n      }\n      if (t.projectionControl) {\n        const m = t.projectionControl === !0 || t.projectionControl === void 0 ? \"top-right\" : t.projectionControl;\n        this.addControl(new wu(), m);\n      }\n      if (t.fullscreenControl) {\n        const m = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? \"top-right\" : t.fullscreenControl;\n        this.addControl(new Oi({}), m);\n      }\n      this.isReady = !0, this.fire(\"ready\", { target: this });\n    });\n    let c = !1, p = !1, d;\n    this.once(\"ready\", () => {\n      c = !0, p && this.fire(\"loadWithTerrain\", d);\n    }), this.once(\"style.load\", () => {\n      const { minimap: h } = t;\n      if (typeof h == \"object\") {\n        const {\n          zoom: m,\n          center: y,\n          style: w,\n          language: v,\n          apiKey: x,\n          maptilerLogo: A,\n          canvasContextAttributes: E,\n          refreshExpiredTiles: C,\n          maxBounds: N,\n          scrollZoom: ee,\n          minZoom: Le,\n          maxZoom: Ee,\n          boxZoom: V,\n          locale: be,\n          fadeDuration: zt,\n          crossSourceCollisions: Ot,\n          clickTolerance: $t,\n          bounds: Ft,\n          fitBoundsOptions: Nt,\n          pixelRatio: jt,\n          validateStyle: Dt\n        } = t;\n        this.minimap = new $r(h, {\n          zoom: m,\n          center: y,\n          style: w,\n          language: v,\n          apiKey: x,\n          container: \"null\",\n          maptilerLogo: A,\n          canvasContextAttributes: E,\n          refreshExpiredTiles: C,\n          maxBounds: N,\n          scrollZoom: ee,\n          minZoom: Le,\n          maxZoom: Ee,\n          boxZoom: V,\n          locale: be,\n          fadeDuration: zt,\n          crossSourceCollisions: Ot,\n          clickTolerance: $t,\n          bounds: Ft,\n          fitBoundsOptions: Nt,\n          pixelRatio: jt,\n          validateStyle: Dt\n        }), this.addControl(this.minimap, h.position ?? \"bottom-left\");\n      } else h === !0 ? (this.minimap = new $r({}, t), this.addControl(this.minimap, \"bottom-left\")) : h !== void 0 && h !== !1 && (this.minimap = new $r({}, t), this.addControl(this.minimap, h));\n    });\n    const f = (h) => {\n      h.terrain && (p = !0, d = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: h.terrain\n      }, this.off(\"terrain\", f), c && this.fire(\"loadWithTerrain\", d));\n    };\n    this.on(\"terrain\", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once(\"load\", () => {\n      this.getCanvas().addEventListener(\"webglcontextlost\", (h) => {\n        if (this._removed === !0) {\n          console.warn(\"[webglcontextlost]\", \"WebGL context lost after map removal. This is harmless.\");\n          return;\n        }\n        console.warn(\"[webglcontextlost]\", \"Unexpected loss of WebGL context!\"), this.fire(\"webglContextLost\", h);\n      }), t.halo && this.initHalo({ options: t, before: this.getLayersOrder()[0] }), t.space && this.initSpace({ options: t, before: this.getLayersOrder()[0] });\n    }), this.telemetry = new Su(this);\n  }\n  getSpace() {\n    return this.space;\n  }\n  /**\n   * Sets the space for the map.\n   * @param {CubemapDefinition} space the `CubemapDefinition` options to set.\n   * @remarks This method, at present, ** overwrites ** the current config.\n   * If an option is not set it will internally revert to the default option\n   * unless explicitly set when calling.\n   */\n  setSpace(t, n = !0) {\n    if (n && (this.options.space = t), t === !1) {\n      this.space = void 0;\n      return;\n    }\n    if (this.space) {\n      this.space.setCubemap(t), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);\n      return;\n    }\n    this.space = new Br(t), this.once(\"load\", () => {\n      const a = this.getLayersOrder()[0];\n      this.space && this.addLayer(this.space, a);\n    });\n  }\n  /**\n   * Enables the animations for the space layer.\n   */\n  enableSpaceAnimations() {\n    this.setSpaceAnimationActive(!0);\n  }\n  /**\n   * Disables the animations for the space layer.\n   */\n  disableSpaceAnimations() {\n    this.setSpaceAnimationActive(!1);\n  }\n  /**\n   * Enables the animations for the halo layer.\n   */\n  enableHaloAnimations() {\n    this.setHaloAnimationActive(!0);\n  }\n  /**\n   * Disables the animations for the halo layer.\n   */\n  disableHaloAnimations() {\n    this.setHaloAnimationActive(!1);\n  }\n  /**\n   * Sets whether the halo layer should be animated in and out.\n   * @param active - Whether the animation should be active.\n   */\n  setHaloAnimationActive(t) {\n    this.halo ? this.halo.setAnimationActive(t) : this.once(\"load\", () => {\n      var n;\n      (n = this.halo) == null || n.setAnimationActive(t);\n    });\n  }\n  /**\n   * Sets whether the space layer should be animated in and out.\n   * @param active - Whether the animation should be active.\n   */\n  setSpaceAnimationActive(t) {\n    this.space ? this.space.setAnimationActive(t) : this.once(\"load\", () => {\n      var n;\n      (n = this.space) == null || n.setAnimationActive(t);\n    });\n  }\n  setSpaceFromSpec({ spec: t }) {\n    var o;\n    if (this.options.space === !1)\n      return;\n    if (typeof t == \"boolean\") {\n      this.setSpace(t, !0);\n      return;\n    }\n    if (this.options.space !== !0 && rn(this.options.space)) {\n      this.setSpace(this.options.space, !0);\n      return;\n    }\n    const n = rn(t);\n    if (JSON.stringify((o = this.space) == null ? void 0 : o.getConfig()) === JSON.stringify(t)) {\n      if (this.space && !this.getLayer(this.space.id)) {\n        const i = this.getLayersOrder()[0];\n        this.addLayer(this.space, i);\n      }\n      return;\n    }\n    if (n) {\n      this.setSpace(t, !1);\n      return;\n    }\n    if (this.options.space === !0) {\n      this.setSpace(!0);\n      return;\n    }\n    (() => {\n      this.space && this.isGlobeProjection() && this.space.setCubemap(t);\n    })();\n  }\n  setHaloFromSpec({ spec: t }) {\n    var a, o;\n    if (this.options.halo === !1) {\n      console.log(\"options.halo is false\");\n      return;\n    }\n    if (typeof t == \"boolean\") {\n      console.log(\"spec is boolean\", t), this.setHalo(t);\n      return;\n    }\n    if (JSON.stringify((a = this.halo) == null ? void 0 : a.getConfig()) === JSON.stringify(t)) {\n      if (console.log(\"HALO IS THE SAME\", t), this.halo && !this.getLayer(this.halo.id)) {\n        const i = this.getLayersOrder().indexOf(((o = this.space) == null ? void 0 : o.id) ?? \"\") + 1, s = this.getLayersOrder()[i];\n        this.addLayer(this.halo, s);\n      }\n      return;\n    }\n    if (!t && !this.options.halo) {\n      console.log(\"spec is false, and options.halo is false\"), this.setHalo({\n        stops: [\n          [0, \"transparent\"],\n          [1, \"transparent\"]\n        ],\n        scale: 1\n      });\n      return;\n    }\n    (() => {\n      var i;\n      if (console.log(\"updateHalo\", t), this.halo) {\n        if (console.log(\"halo exists\", this.getLayer(this.halo.id)), !this.getLayer(this.halo.id)) {\n          console.log(\"halo not in map, adding it\");\n          const s = this.getLayersOrder().indexOf(((i = this.space) == null ? void 0 : i.id) ?? \"\") + 1, l = this.getLayersOrder()[s];\n          this.addLayer(this.halo, l);\n        }\n        t && (console.log(\"SET HALO FROM SPEC\", t), this.halo.setGradient(t));\n      }\n    })();\n  }\n  initSpace({ options: t = this.options, before: n = this.getLayersOrder()[0], spec: a }) {\n    if (this.space) {\n      this.getLayer(this.space.id) || this.addLayer(this.space, n);\n      return;\n    }\n    if (t.space === !1) return;\n    const o = a;\n    if (t.space) {\n      this.space = new Br(t.space), this.addLayer(this.space, n);\n      return;\n    }\n    o && (this.space = new Br(o), this.addLayer(this.space, n));\n  }\n  initHalo({ options: t = this.options, before: n = this.getLayersOrder()[0], spec: a }) {\n    if (this.halo && this.getLayer(this.halo.id) || t.halo === !1) return;\n    const o = a;\n    if (t.halo) {\n      this.halo = new qr(t.halo), this.addLayer(this.halo, n);\n      return;\n    }\n    o && (this.halo = new qr(o), this.addLayer(this.halo, n));\n  }\n  getHalo() {\n    return this.halo;\n  }\n  setHalo(t) {\n    if (this.options.halo = t, !!this.isGlobeProjection()) {\n      if (this.halo) {\n        this.halo.setGradient(t);\n        return;\n      }\n      this.halo = new qr(t), this.once(\"load\", () => {\n        var s;\n        const n = this.getLayersOrder(), a = n[0], o = n.indexOf(((s = this.space) == null ? void 0 : s.id) ?? \"\") + 2, i = n[o];\n        this.halo && this.addLayer(this.halo, this.space ? i : a);\n      });\n    }\n  }\n  /**\n   * Recreates the map instance with the same options.\n   * Useful for WebGL context loss.\n   */\n  recreate() {\n    const t = {\n      center: this.getCenter(),\n      zoom: this.getZoom(),\n      bearing: this.getBearing(),\n      pitch: this.getPitch()\n    };\n    this.remove(), Object.assign(this, new Ho({ ...this.options })), this.once(\"load\", () => {\n      this.jumpTo(t);\n    });\n  }\n  /**\n   * Set the duration (millisec) of the terrain animation for growing or flattening.\n   * Must be positive. (Built-in default: `1000` milliseconds)\n   */\n  setTerrainAnimationDuration(t) {\n    this.terrainAnimationDuration = Math.max(t, 0);\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  async onLoadAsync() {\n    return new Promise((t) => {\n      if (this.loaded()) {\n        t(this);\n        return;\n      }\n      this.once(\"load\", () => {\n        t(this);\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  async onReadyAsync() {\n    return new Promise((t) => {\n      if (this.isReady) {\n        t(this);\n        return;\n      }\n      this.once(\"ready\", () => {\n        t(this);\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  async onLoadWithTerrainAsync() {\n    return new Promise((t) => {\n      if (this.isReady && this.terrain) {\n        t(this);\n        return;\n      }\n      this.once(\"loadWithTerrain\", () => {\n        t(this);\n      });\n    });\n  }\n  monitorStyleUrl(t) {\n    typeof this.monitoredStyleUrls > \"u\" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());\n    const n = new URL(t);\n    n.search = \"\", this.monitoredStyleUrls.add(n.href);\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  setStyle(t, n = {}) {\n    var s, l, u, c, p;\n    const o = {\n      transformStyle: (d, f) => {\n        var E, C, N, ee, Le, Ee, V, be, zt, Ot, $t, Ft, Nt, jt, Dt, jn, Dn, Un, Bn, qn, Vn, Gn;\n        const h = !((C = (E = f == null ? void 0 : f.metadata) == null ? void 0 : E.maptiler) != null && C.space) && !!((ee = (N = d == null ? void 0 : d.metadata) == null ? void 0 : N.maptiler) != null && ee.space), m = !((Ee = (Le = f == null ? void 0 : f.metadata) == null ? void 0 : Le.maptiler) != null && Ee.halo) && !!((be = (V = d == null ? void 0 : d.metadata) == null ? void 0 : V.maptiler) != null && be.halo);\n        h && (console.trace(\"space has been removed from style, removing it\"), (zt = this.space) == null || zt.onRemove(this, this.getCanvas().getContext(\"webgl2\")), this.space = void 0), m && (console.trace(\"halo has been removed from style, removing it\"), (Ot = this.halo) == null || Ot.onRemove(this, this.getCanvas().getContext(\"webgl2\")), this.halo = void 0);\n        const y = this.space ? this.space.shouldUpdate((Ft = ($t = f == null ? void 0 : f.metadata) == null ? void 0 : $t.maptiler) == null ? void 0 : Ft.space) : !0, w = this.halo ? this.halo.shouldUpdate((jt = (Nt = f == null ? void 0 : f.metadata) == null ? void 0 : Nt.maptiler) == null ? void 0 : jt.halo) : !0, v = ((Dt = d == null ? void 0 : d.terrain) == null ? void 0 : Dt.source) !== ((jn = f == null ? void 0 : f.terrain) == null ? void 0 : jn.source) || ((Dn = d == null ? void 0 : d.terrain) == null ? void 0 : Dn.exaggeration) !== ((Un = f == null ? void 0 : f.terrain) == null ? void 0 : Un.exaggeration), x = y || v, A = w || v;\n        if (x)\n          try {\n            const Ce = ((qn = (Bn = f == null ? void 0 : f.metadata) == null ? void 0 : Bn.maptiler) == null ? void 0 : qn.space) ?? !1;\n            this.once(\"style.load\", () => {\n              var ct;\n              this.getLayer(((ct = this.space) == null ? void 0 : ct.id) ?? \"\") ? this.setSpaceFromSpec({ spec: Ce }) : this.initSpace({ spec: Ce });\n            });\n          } catch (Ce) {\n            console.error(Ce);\n          }\n        if (A)\n          try {\n            const Ce = ((Gn = (Vn = f == null ? void 0 : f.metadata) == null ? void 0 : Vn.maptiler) == null ? void 0 : Gn.halo) ?? !1;\n            this.once(\"style.load\", () => {\n              var ct;\n              this.getLayer(((ct = this.halo) == null ? void 0 : ct.id) ?? \"\") ? this.setHaloFromSpec({ spec: Ce }) : this.initHalo({ spec: Ce });\n            });\n          } catch (Ce) {\n            console.error(Ce);\n          }\n        return {\n          ...f\n        };\n      },\n      diff: !0,\n      ...n\n    };\n    this.originalLabelStyle.clear(), (s = this.minimap) == null || s.setStyle(t, {}), this.forceLanguageUpdate = !0, this.once(\"idle\", () => {\n      this.forceLanguageUpdate = !1;\n    });\n    const i = ka(t);\n    if (i.requiresUrlMonitoring && this.monitorStyleUrl(i.style), i.isFallback) {\n      if (this.getStyle())\n        return console.warn(\n          \"[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead.\"\n        ), this;\n      console.warn(\n        \"[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.\"\n      );\n    }\n    try {\n      super.setStyle(i.style, o), this.styleInProcess = !0;\n    } catch (d) {\n      this.styleInProcess = !1, console.error(\"[Map.setStyle]: Error while setting style:\", d);\n    }\n    try {\n      if (i.isJSON) {\n        const d = (u = (l = i.style.metadata) == null ? void 0 : l.maptiler) == null ? void 0 : u.halo, f = (p = (c = i.style.metadata) == null ? void 0 : c.maptiler) == null ? void 0 : p.space;\n        d && this.setHalo(d), f && this.setSpace(f);\n      }\n    } catch (d) {\n      console.error(\"[Map.setStyle]: Error while setting halo or space from style:\", d);\n    }\n    return this;\n  }\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);\n  }\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);\n  }\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(t) {\n    var n;\n    return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);\n  }\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(t, n, a) {\n    var o;\n    return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);\n  }\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(t, n, a) {\n    var o;\n    return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);\n  }\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(t, n, a, o) {\n    var i;\n    return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);\n  }\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(t, n, a, o) {\n    var i;\n    return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);\n  }\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);\n  }\n  getStyleLanguage() {\n    return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != \"object\" ? null : \"maptiler:language\" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata[\"maptiler:language\"] == \"string\" ? (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.getLanguageInfoFromFlag)(this.style.stylesheet.metadata[\"maptiler:language\"]) : null;\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(t) {\n    var n;\n    (n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {\n      this.setPrimaryLanguage(t);\n    });\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setPrimaryLanguage(t) {\n    const n = this.getStyleLanguage(), a = (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_2__.toLanguageInfo)(t, z);\n    if (!a) {\n      console.warn(`The language \"${a}\" is not supported.`);\n      return;\n    }\n    if (!(a.flag === z.STYLE.flag && n && (n.flag === z.AUTO.flag || n.flag === z.VISITOR.flag)) && (a.flag !== z.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate))\n      return;\n    if (this.primaryLanguage.flag === z.STYLE_LOCK.flag) {\n      console.warn(\"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\");\n      return;\n    }\n    this.primaryLanguage = a;\n    let o = a;\n    if (a.flag === z.STYLE.flag) {\n      if (!n) {\n        console.warn(\"The style has no default languages or has an invalid one.\");\n        return;\n      }\n      o = n;\n    }\n    let i = z.LOCAL.flag, s = [\"get\", i];\n    o.flag === z.VISITOR.flag ? (i = Yn().flag, s = [\n      \"case\",\n      [\"all\", [\"has\", i], [\"has\", z.LOCAL.flag]],\n      [\n        \"case\",\n        [\"==\", [\"get\", i], [\"get\", z.LOCAL.flag]],\n        [\"get\", z.LOCAL.flag],\n        [\"format\", [\"get\", i], { \"font-scale\": 0.8 }, `\n`, [\"get\", z.LOCAL.flag], { \"font-scale\": 1.1 }]\n      ],\n      [\"get\", z.LOCAL.flag]\n    ]) : o.flag === z.VISITOR_ENGLISH.flag ? (i = z.ENGLISH.flag, s = [\n      \"case\",\n      [\"all\", [\"has\", i], [\"has\", z.LOCAL.flag]],\n      [\n        \"case\",\n        [\"==\", [\"get\", i], [\"get\", z.LOCAL.flag]],\n        [\"get\", z.LOCAL.flag],\n        [\"format\", [\"get\", i], { \"font-scale\": 0.8 }, `\n`, [\"get\", z.LOCAL.flag], { \"font-scale\": 1.1 }]\n      ],\n      [\"get\", z.LOCAL.flag]\n    ]) : o.flag === z.AUTO.flag ? (i = Yn().flag, s = [\"coalesce\", [\"get\", i], [\"get\", z.LOCAL.flag]]) : o === z.LOCAL ? (i = z.LOCAL.flag, s = [\"get\", i]) : (i = o.flag, s = [\"coalesce\", [\"get\", i], [\"get\", z.LOCAL.flag]]);\n    const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;\n    if (u) {\n      const c = Qi(l, this);\n      this.isStyleLocalized = Object.keys(c.localized).length > 0;\n    }\n    for (const c of l) {\n      if (c.type !== \"symbol\")\n        continue;\n      const p = c, d = this.getSource(p.source);\n      if (!d || !(\"url\" in d && typeof d.url == \"string\") || new URL(d.url).host !== J.maptilerApiHost)\n        continue;\n      const { id: h, layout: m } = p;\n      if (!m || !(\"text-field\" in m))\n        continue;\n      let y;\n      if (u ? (y = this.getLayoutProperty(h, \"text-field\"), this.originalLabelStyle.set(h, y)) : y = this.originalLabelStyle.get(h), typeof y == \"string\") {\n        const { contains: w, exactMatch: v } = Ki(y, this.isStyleLocalized);\n        if (!w) continue;\n        if (v)\n          this.setLayoutProperty(h, \"text-field\", s);\n        else {\n          const x = Xi(y, s, this.isStyleLocalized);\n          this.setLayoutProperty(h, \"text-field\", x);\n        }\n      } else {\n        const w = Zi(y, s, this.isStyleLocalized);\n        this.setLayoutProperty(h, \"text-field\", w);\n      }\n    }\n    this.languageIsUpdated = !0;\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(t) {\n    if (!this.terrain)\n      return;\n    const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {\n      if (!this.terrain || this.terrainFlattening)\n        return;\n      const s = (performance.now() - n) / this.terrainAnimationDuration;\n      if (s < 0.99) {\n        const l = 1 - (1 - s) ** 4, u = a + l * o;\n        this.terrain.exaggeration = u, requestAnimationFrame(i);\n      } else\n        this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t, this.fire(\"terrainAnimationStop\", { terrain: this.terrain });\n      this._elevationFreeze = !1, this.triggerRepaint();\n    };\n    !this.terrainGrowing && !this.terrainFlattening && this.fire(\"terrainAnimationStart\", { terrain: this.terrain }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(t = this.terrainExaggeration) {\n    if (t < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const n = (o) => {\n      !this.terrain || o.type !== \"data\" || o.dataType !== \"source\" || !(\"source\" in o) || o.sourceId !== \"maptiler-terrain\" || o.source.type !== \"raster-dem\" || o.isSourceLoaded && (this.off(\"data\", n), this.growTerrain(t));\n    }, a = () => {\n      this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on(\"data\", n), this.addSource(J.terrainSourceId, {\n        type: \"raster-dem\",\n        url: J.terrainSourceURL\n      }), this.setTerrain({\n        source: J.terrainSourceId,\n        exaggeration: 0\n      });\n    };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = !0, this.growTerrain(t);\n      return;\n    }\n    if (this.loaded() || this.isTerrainEnabled)\n      a();\n    else {\n      const o = () => {\n        this.getTerrain() && this.getSource(J.terrainSourceId) || a();\n      };\n      this.once(\"load\", () => {\n        o();\n      }), this.once(\"moveend\", () => {\n        o();\n      });\n    }\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain)\n      return;\n    this.isTerrainEnabled = !1;\n    const t = performance.now(), n = this.terrain.exaggeration, a = () => {\n      if (!this.terrain || this.terrainGrowing)\n        return;\n      const o = (performance.now() - t) / this.terrainAnimationDuration;\n      if (this._elevationFreeze = !1, o < 0.99) {\n        const i = (1 - o) ** 4, s = n * i;\n        this.terrain.exaggeration = s, requestAnimationFrame(a);\n      } else\n        this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(J.terrainSourceId) && this.removeSource(J.terrainSourceId), this.fire(\"terrainAnimationStop\", { terrain: null });\n      this.triggerRepaint();\n    };\n    !this.terrainGrowing && !this.terrainFlattening && this.fire(\"terrainAnimationStart\", { terrain: this.terrain }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(a);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(t, n = !0) {\n    !n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  onStyleReady(t) {\n    this.isStyleLoaded() ? t() : this.once(\"styledata\", () => {\n      t();\n    });\n  }\n  async fitToIpBounds() {\n    const t = await _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geolocation.info();\n    this.fitBounds(t.country_bounds, {\n      duration: 0,\n      padding: 100\n    });\n  }\n  async centerOnIpPoint(t) {\n    const n = await _maptiler_client__WEBPACK_IMPORTED_MODULE_2__.geolocation.info();\n    this.jumpTo({\n      center: [n.longitude ?? 0, n.latitude ?? 0],\n      zoom: t || 11\n    });\n  }\n  getCameraHash() {\n    const t = new Float32Array(5), n = this.getCenter();\n    return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), js_base64__WEBPACK_IMPORTED_MODULE_4__.Base64.fromUint8Array(new Uint8Array(t.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig() {\n    return j;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return dn;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(t) {\n    return super.setTransformRequest(ta(t)), this;\n  }\n  /**\n   * Gets the {@link ProjectionSpecification}.\n   * @returns the projection specification.\n   * @example\n   * ```ts\n   * let projection = map.getProjection();\n   * ```\n   */\n  getProjection() {\n    const t = this.style.getProjection();\n    return !t === void 0 && this.style.projection ? { type: this.style.projection.name } : t;\n  }\n  /**\n   * Returns whether a globe projection is currently being used\n   */\n  isGlobeProjection() {\n    const t = this.getProjection();\n    return t ? t.type === \"globe\" : !1;\n  }\n  /**\n   * Activate the globe projection.\n   */\n  enableGlobeProjection() {\n    this.isGlobeProjection() !== !0 && (this.setProjection({ type: \"globe\" }), this.curentProjection = \"globe\");\n  }\n  /**\n   * Activate the mercator projection.\n   */\n  enableMercatorProjection() {\n    this.isGlobeProjection() !== !1 && (this.setProjection({ type: \"mercator\" }), this.curentProjection = \"mercator\");\n  }\n  setProjection(t) {\n    return this.fire(\"projection.change\", { target: this, projection: t }), super.setProjection(t);\n  }\n  /**\n   * Returns `true` is the language was ever updated, meaning changed\n   * from what is delivered in the style.\n   * Returns `false` if language in use is the language from the style\n   * and has never been changed.\n   */\n  isLanguageUpdated() {\n    return this.languageIsUpdated;\n  }\n};\nclass re {\n  constructor(e, t, n, a = {}) {\n    g(this, \"type\");\n    g(this, \"target\");\n    g(this, \"originalEvent\");\n    g(this, \"imageX\");\n    g(this, \"imageY\");\n    g(this, \"isOutOfBounds\");\n    this.type = e, this.target = t, this.originalEvent = n ?? null, Object.assign(this, a);\n  }\n}\nconst Zo = [\n  // pass nothing other than target (map / viewer) and type\n  \"idle\",\n  \"render\",\n  \"load\",\n  \"remove\",\n  \"idle\"\n  // these are fired on layers, not the map,\n  // keeping them for reference\n  // \"content\",\n  // \"visibility\",\n], Ko = [\n  \"error\"\n  // ErrorEvent\n], Xo = [\"resize\"], Yo = [\"webglcontextlost\", \"webglcontextrestored\"], Wo = [\n  \"moveend\",\n  \"movestart\",\n  \"move\",\n  \"zoomend\",\n  \"zoomstart\",\n  \"zoom\",\n  \"rotatestart\",\n  \"rotateend\",\n  \"rotate\",\n  \"dragstart\",\n  \"dragend\",\n  \"drag\",\n  \"boxzoomcancel\",\n  \"boxzoomend\",\n  \"boxzoomstart\"\n], Jo = [\"click\", \"dblclick\", \"mousedown\", \"mouseup\", \"mousemove\", \"mouseout\", \"mouseover\", \"contextmenu\", \"touchstart\", \"touchend\", \"touchmove\", \"touchcancel\"], Qo = [\"cooperativegestureprevented\"], ei = [\n  \"data\",\n  \"dataloading\",\n  \"sourcedata\",\n  \"sourcedataloading\",\n  \"dataabort\",\n  \"sourcedataabort\"\n  // this is fired on layers, not the map\n  // keeping it for reference\n  // \"metadata\",\n], lc = [\n  ...Zo,\n  ...Ko,\n  ...Xo,\n  ...Yo,\n  ...Wo,\n  ...Jo,\n  ...ei,\n  ...Qo\n], uc = [\"lngLat\", \"_defaultPrevented\"];\nfunction cc({ map: r, viewer: e, lngLatToPx: t }) {\n  lc.forEach((n) => {\n    try {\n      r.on(n, (a) => {\n        const o = n;\n        if (Jo.includes(o)) {\n          const f = a, h = f.lngLat && t(f.lngLat), m = e.getImageMetadata(), w = {\n            isOutOfBounds: m ? h[0] < 0 || h[0] > m.width || h[1] < 0 || h[1] > m.height : !0,\n            imageX: h[0],\n            imageY: h[1],\n            ...Object.fromEntries(Object.entries(a).filter(([v]) => !uc.includes(v)))\n          };\n          e.fire(new re(n, e, f.originalEvent, w));\n          return;\n        }\n        const i = n;\n        if (Wo.includes(i)) {\n          const f = a;\n          e.fire(new re(n, e, f.originalEvent, f));\n          return;\n        }\n        const s = n;\n        if (Ko.includes(s)) {\n          const f = a;\n          e.fire(new re(n, e, null, f));\n          return;\n        }\n        const l = n;\n        if (Xo.includes(l)) {\n          const f = a;\n          e.fire(new re(n, e, null, f));\n          return;\n        }\n        const u = n;\n        if (Yo.includes(u)) {\n          const f = a;\n          e.fire(new re(n, e, f.originalEvent, f));\n          return;\n        }\n        const c = n;\n        if (ei.includes(c)) {\n          const f = a;\n          e.fire(new re(n, e, null, f));\n          return;\n        }\n        const p = n;\n        if (Qo.includes(p)) {\n          const f = a;\n          e.fire(new re(n, e, null, f));\n          return;\n        }\n        const d = n;\n        if (Zo.includes(d)) {\n          e.fire(new re(n, e));\n          return;\n        }\n      });\n    } catch (a) {\n      console.error(`Error forwarding event to ImageViewer, event of type \"${n}\" is not supported`, a);\n    }\n  });\n}\nclass pc extends Error {\n  constructor(t, n, a) {\n    const o = `[${a}]: Failed to fetch ${n} at ${t.url}: ${t.status.toString()}: ${t.statusText}`;\n    super(o);\n    g(this, \"status\");\n    g(this, \"statusText\");\n    this.name = \"FetchError\", this.message = o, this.status = t.status, this.statusText = t.statusText;\n  }\n}\nconst fc = 85.051129;\nfunction dc(r, e) {\n  return new fn(e.x / r, e.y / r).toLngLat();\n}\nfunction hc(r) {\n  return Math.pow(2, r);\n}\nfunction mc(r) {\n  return Math.log(r) / Math.LN2;\n}\nfunction ti(r, e, t) {\n  return Math.min(t, Math.max(e, r));\n}\nfunction nn(r) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;\n}\nfunction an(r) {\n  return (180 + r) / 360;\n}\nfunction Ba(r, e, t) {\n  const n = t - e, a = ((r - e) % n + n) % n + e;\n  return a === e ? t : a;\n}\nfunction yc(r, e) {\n  const t = ti(e.lat, -85.051129, fc);\n  return new bi(an(e.lng) * r, nn(t) * r);\n}\nfunction gc(r) {\n  r.transform.getConstrained = function(e, t) {\n    t = ti(+t, this.minZoom, this.maxZoom);\n    const n = {\n      center: new vi(e.lng, e.lat),\n      zoom: t\n    };\n    let a = this._helper._lngRange;\n    a === null && (a = [-179.9999999999, 179.9999999999]);\n    const o = this.tileSize * hc(n.zoom);\n    let i = 0, s = o, l = 0, u = o, c = 0, p = 0;\n    const { x: d, y: f } = this.size, h = 0.5;\n    if (this._helper._latRange) {\n      const V = this._helper._latRange;\n      i = nn(V[1]) * o, s = nn(V[0]) * o, s - i < h * f && (c = h * f / (s - i));\n    }\n    a && (l = Ba(an(a[0]) * o, 0, o), u = Ba(an(a[1]) * o, 0, o), u < l && (u += o), u - l < h * d && (p = h * d / (u - l)));\n    const { x: m, y } = yc(o, e);\n    let w, v;\n    const x = Math.min(p || 0, c || 0);\n    if (x)\n      return n.zoom += mc(x), n;\n    let A = 0, E = 0;\n    const C = 1, N = 1 - (s - i) / f, ee = 1 - (u - l) / d;\n    A = Math.max(ee, C), E = Math.max(N, C);\n    const Le = 1 - A, Ee = 1 - E;\n    if (this._helper._latRange) {\n      const V = Ee * f / 2;\n      y - V < i && (v = i + V), y + V > s && (v = s - V);\n    }\n    if (a) {\n      const V = m, be = Le * d / 2;\n      V - be < l && (w = l + be), V + be > u && (w = u - be);\n    }\n    if (w !== void 0 || v !== void 0) {\n      const V = new bi(w ?? m, v ?? y);\n      n.center = dc(o, V).wrap();\n    }\n    return n;\n  };\n}\nconst vc = {\n  center: \"translate(-50%,-50%)\",\n  top: \"translate(-50%,0)\",\n  \"top-left\": \"translate(0,0)\",\n  \"top-right\": \"translate(-100%,0)\",\n  bottom: \"translate(-50%,-100%)\",\n  \"bottom-left\": \"translate(0,-100%)\",\n  \"bottom-right\": \"translate(-100%,-100%)\",\n  left: \"translate(0,-50%)\",\n  right: \"translate(-100%,-50%)\"\n};\nfunction bc(r) {\n  function e(t) {\n    if (!this._map) return;\n    const n = this._map.loaded() && !this._map.isMoving();\n    ((t == null ? void 0 : t.type) === \"terrain\" || (t == null ? void 0 : t.type) === \"render\" && !n) && this._map.once(\"render\", this._update), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));\n    let a = \"\";\n    this._rotationAlignment === \"viewport\" || this._rotationAlignment === \"auto\" ? a = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === \"map\" && (a = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);\n    let o = \"\";\n    this._pitchAlignment === \"viewport\" || this._pitchAlignment === \"auto\" ? o = \"rotateX(0deg)\" : this._pitchAlignment === \"map\" && (o = `rotateX(${this._map.getPitch()}deg)`), !this._subpixelPositioning && (!t || t.type === \"moveend\") && (this._pos = this._pos.round());\n    const i = `${vc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${a}`;\n    this._element.style.transform = i;\n  }\n  r._update = e.bind(r);\n}\nclass wc {\n  constructor({ imageViewer: e }) {\n    g(this, \"viewer\");\n    g(this, \"container\");\n    g(this, \"handleClick\", () => {\n      this.viewer.fitImageToViewport({ ease: !0 });\n    });\n    if (!e)\n      throw new Error(\"ImageViewerFitImageToBoundsControl: an instance of 'ImageViewer' is required\");\n    this.viewer = e;\n  }\n  onAdd(e) {\n    const t = document.createElement(\"button\");\n    this.container = document.createElement(\"div\"), this.container.classList.add(\"maplibregl-ctrl\", \"maplibregl-ctrl-group\"), t.classList.add(\"maplibregl-ctrl-fit-image-to-bounds\");\n    const n = document.createElement(\"span\");\n    return n.classList.add(\"maplibregl-ctrl-icon\"), t.title = \"Zoom image to viewport bounds\", t.appendChild(n), t.addEventListener(\"click\", this.handleClick), this.container.appendChild(t), this.container;\n  }\n  onRemove() {\n    this.container.remove();\n  }\n}\nconst ri = Symbol(\"MapTiler:ImageViewer:Internal:lngLatToPxInternal\"), ni = Symbol(\"MapTiler:ImageViewer:Internal:pxToLngLatInternal\"), { Evented: Sc } = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__, xc = {\n  style: {\n    version: 8,\n    sources: {},\n    layers: []\n  },\n  minPitch: 0,\n  maxPitch: 0,\n  pitch: 0,\n  bearing: 0,\n  projection: \"mercator\",\n  geolocateControl: !1,\n  navigationControl: !1,\n  projectionControl: !1,\n  hash: !1,\n  renderWorldCopies: !1,\n  terrain: !1,\n  space: !1,\n  halo: !1\n}, kc = {\n  debug: !1,\n  fitToBoundsControl: !0,\n  navigationControl: !0\n};\nvar Ka, Xa, Ya;\nclass Lc extends (Ya = Sc, Xa = ri, Ka = ni, Ya) {\n  //#region constructor\n  /**\n   * The constructor for the ImageViewer.\n   *\n   * @param {Partial<ImageViewerConstructorOptions>} imageViewerConstructorOptions - The options for the ImageViewer.\n   * @example\n   * ```ts\n   * import \"@maptiler/sdk/dist/maptiler-sdk.css\"; // import css\n   * import { ImageViewer } from \"@maptiler/sdk\"; // import the sdk\n   *\n   * const imageViewer = new ImageViewer({\n   *   container: document.getElementById(\"map\"),\n   *   imageUUID: \"01986025-ceb9-7487-9ea6-7a8637dcc1a1\",\n   *   debug: true, // show tile boundaries, padding, collision boxes etc\n   *   fitToBoundsControl: true, // show a control to fit the image to the viewport\n   *   navigationControl: true, // show a navigation control\n   *   center: [0, 0], // center in pixels\n   *   zoom: 1, // zoom level\n   *   bearing: 0, // bearing\n   * });\n   * ```\n   */\n  constructor(t) {\n    super();\n    /**\n     * The UUID of the image.\n     *\n     * @internal\n     */\n    g(this, \"imageUUID\");\n    /**\n     * Whether to enable debug mode.\n     *\n     * @internal\n     */\n    g(this, \"debug\");\n    /**\n     * The metadata of the image.\n     *\n     */\n    g(this, \"imageMetadata\");\n    /**\n     * Why not extend the Map class?\n     * Because ImageViewer technically operates in screen space and not in map space.\n     * We wrap map and perform calculations in screen space.\n     * We do not want to have to extend the Map class and give access to\n     * methods and properties that operate in LngLat space.   *\n     */\n    g(this, \"sdk\");\n    /**\n     * The options for the ImageViewer.\n     *\n     * @internal\n     */\n    g(this, \"options\");\n    /**\n     * The size of the image.\n     *\n     * @internal\n     */\n    g(this, \"imageSize\");\n    /**\n     * The padded size max.\n     *\n     * @internal\n     */\n    g(this, \"paddedSizeMax\");\n    /**\n     * The control to fit the image to the viewport.\n     */\n    g(this, \"fitToBoundsControlInstance\");\n    // this flag is used to determine if the image should be fit to the viewport\n    // when the map is resized\n    g(this, \"shouldFitImageToViewport\", !0);\n    // aliases for methods that are not exposed by the SDK\n    // but used internally (ImageMarkers)\n    g(this, Xa, this.lngLatToPx.bind(this));\n    g(this, Ka, this.pxToLngLat.bind(this));\n    if (!t.imageUUID)\n      throw new Error(\"[ImageViewer]: `imageUUID` is required\");\n    if (typeof t.container != \"string\" && !(t.container instanceof HTMLElement))\n      throw new Error(\"[ImageViewer]: `container` is required and must be a string or HTMLElement\");\n    this.options = {\n      ...kc,\n      ...t\n    };\n    const n = {\n      ...this.options,\n      ...xc\n    };\n    delete n.center, this.sdk = new Go(n), this.sdk.telemetry.registerViewerType(\"ImageViewer\");\n    const { imageUUID: a, debug: o } = t;\n    this.imageUUID = a, this.debug = o ?? !1, this.debug && (this.sdk.showTileBoundaries = this.debug, this.sdk.showPadding = this.debug, this.sdk.showCollisionBoxes = this.debug, this.sdk.repaint = this.debug), this.init();\n  }\n  /**\n   * The version of the ImageViewer / SDK.\n   */\n  get version() {\n    return this.sdk.version;\n  }\n  //#region onReadyAsync\n  /**\n   * Waits for the ImageViewer to be ready.\n   *\n   * @returns {Promise<void>}\n   */\n  async onReadyAsync() {\n    try {\n      await this.sdk.onReadyAsync(), await Promise.race([\n        new Promise((t, n) => {\n          this.once(\"imageviewerready\", (a) => {\n            t(a);\n          }), this.once(\"imagevieweriniterror\", (a) => {\n            n(a.error);\n          });\n        }),\n        new Promise((t, n) => {\n          setTimeout(() => {\n            n(new Error(\"Timeout waiting for image viewer to be ready\"));\n          }, 5e3);\n        })\n      ]);\n    } catch (t) {\n      throw t;\n    }\n  }\n  //#region init\n  /**\n   * Initializes the ImageViewer\n   *  - fetches the image metadata\n   *  - adds the image source to the sdk instance\n   *  - sets the center to the middle of the image (if center is not provided)\n   *  - monkeypatches the maplibre-gl sdk transform method to allow for overpanning and underzooming.\n   *  - sets up global event forwarding / intercepting from the map instance\n   *  - sets the center to the middle of the image (if center is not provided)\n   *\n   * @internal\n   * @returns {Promise<void>}\n   */\n  async init() {\n    var t, n, a;\n    try {\n      await this.fetchImageMetadata(), this.addImageSource(), this.options.navigationControl && this.sdk.addControl(\n        new Wa({\n          visualizePitch: !1,\n          visualizeRoll: !1\n        })\n      ), this.fitToBoundsControlInstance = new wc({ imageViewer: this }), this.options.fitToBoundsControl && this.sdk.addControl(this.fitToBoundsControlInstance), cc({\n        map: this.sdk,\n        viewer: this,\n        lngLatToPx: (u) => this.lngLatToPx(u)\n      }), gc(this.sdk);\n      const { center: o, zoom: i, bearing: s } = this.options, l = o ?? [(((t = this.imageMetadata) == null ? void 0 : t.width) ?? 0) / 2, (((n = this.imageMetadata) == null ? void 0 : n.height) ?? 0) / 2];\n      this.setCenter(l), this.setBearing(s ?? 0), this.options.zoom ? this.setZoom(i ?? ((a = this.imageMetadata) == null ? void 0 : a.maxzoom) ?? 5) : this.fitImageToViewport(), this.sdk.on(\"wheel\", () => {\n        this.shouldFitImageToViewport = !1;\n      }), this.sdk.on(\"touchstart\", () => {\n        this.shouldFitImageToViewport = !1;\n      }), this.sdk.on(\"drag\", () => {\n        this.shouldFitImageToViewport = !1;\n      }), this.sdk.on(\"resize\", () => {\n        var d, f;\n        const u = this.getCenter(), c = ((d = this.imageMetadata) == null ? void 0 : d.width) ?? 0, p = ((f = this.imageMetadata) == null ? void 0 : f.height) ?? 0;\n        this.shouldFitImageToViewport && this.fitImageToViewport(), (u[0] !== c / 2 || u[1] !== p / 2) && this.setCenter(u);\n      }), this.fire(\"imageviewerready\", new re(\"imageviewerready\", this));\n    } catch (o) {\n      this.fire(\"imagevieweriniterror\", { error: o });\n    }\n  }\n  //#region fitImageToViewport\n  /**\n   * Fits the image to the viewport.\n   *\n   * @param {Object} options - The options for the fit image to viewport.\n   * @param {boolean} options.ease - Whether to ease to the viewport bounds.\n   */\n  fitImageToViewport({ ease: t = !1 } = {}) {\n    if (!this.imageMetadata)\n      throw new Error(\"[ImageViewer]: Image metadata not found\");\n    const n = this.pxToLngLat([0, 0]), a = this.pxToLngLat([this.imageMetadata.width ?? 0, this.imageMetadata.height ?? 0]), o = this.sdk.cameraForBounds([n, a], { padding: 50 });\n    o && (t ? this.sdk.easeTo({ ...o, pitch: 0 }, null) : this.sdk.jumpTo({ ...o, pitch: 0 }, null)), this.shouldFitImageToViewport = !0;\n  }\n  //#region fetchImageMetadata\n  /**\n   * Fetches the image metadata from the API.\n   *\n   * @internal\n   * @returns {Promise<void>}\n   */\n  async fetchImageMetadata() {\n    const t = Ec(this.imageUUID), n = await fetch(t);\n    if (!n.ok)\n      throw new pc(n, \"image metadata\", \"ImageViewer\");\n    const a = await n.json();\n    this.imageMetadata = a, Object.freeze(this.imageMetadata);\n  }\n  //#region addImageSource\n  /**\n   * Adds the image source to the sdk instance.\n   *\n   * @internal\n   * @returns {void}\n   */\n  addImageSource() {\n    if (!this.imageMetadata)\n      throw this.fire(\"error\", new re(\"error\", this, null, { error: new Error(\"[ImageViewer]: Image metadata not found\") })), new Error(\"[ImageViewer]: Image metadata not found\");\n    const t = Cc(this.imageUUID), n = (s) => Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));\n    this.imageSize = [this.imageMetadata.width, this.imageMetadata.height], this.paddedSizeMax = Math.max(n(this.imageSize[0]), n(this.imageSize[1]));\n    const a = this.pxToLngLat([0, 0]), o = this.pxToLngLat(this.imageSize), i = [a.lng, o.lat, o.lng, a.lat];\n    this.sdk.addSource(\"image\", {\n      ...this.imageMetadata,\n      type: \"raster\",\n      bounds: i,\n      tiles: [t]\n    }), this.sdk.addLayer({\n      id: \"image\",\n      type: \"raster\",\n      source: \"image\"\n    });\n  }\n  //#region SDK mappings\n  /**\n   * Triggers a repaint of the ImageViewer. Same as map.triggerRepaint().\n   *\n   * @internal\n   * @returns {void}\n   */\n  triggerRepaint() {\n    this.sdk.triggerRepaint();\n  }\n  /**\n   * The scroll zoom handler.\n   *\n   * @internal\n   * @returns {ScrollZoomHandler}\n   */\n  get scrollZoom() {\n    return this.sdk.scrollZoom;\n  }\n  /**\n   * The scroll zoom handler.\n   *\n   * @internal\n   * @param {ScrollZoomHandler} value - The scroll zoom handler.\n   */\n  set scrollZoom(t) {\n    this.sdk.scrollZoom = t;\n  }\n  /**\n   * The box zoom handler.\n   *\n   * @internal\n   * @returns {BoxZoomHandler}\n   */\n  get boxZoom() {\n    return this.sdk.boxZoom;\n  }\n  /**\n   * The box zoom handler.\n   *\n   * @internal\n   * @param {BoxZoomHandler} value - The box zoom handler.\n   */\n  set boxZoom(t) {\n    this.sdk.boxZoom = t;\n  }\n  /**\n   * The drag pan handler.\n   *\n   * @internal\n   * @returns {DragPanHandler}\n   */\n  get dragPan() {\n    return this.sdk.dragPan;\n  }\n  /**\n   * The drag pan handler.\n   *\n   * @internal\n   * @param {DragPanHandler} value - The drag pan handler.\n   */\n  set dragPan(t) {\n    this.sdk.dragPan = t;\n  }\n  /**\n   * The keyboard handler.\n   *\n   * @internal\n   * @returns {KeyboardHandler}\n   */\n  get keyboard() {\n    return this.sdk.keyboard;\n  }\n  /**\n   * The keyboard handler.\n   *\n   * @internal\n   * @param {KeyboardHandler} value - The keyboard handler.\n   */\n  set keyboard(t) {\n    this.sdk.keyboard = t;\n  }\n  /**\n   * The double click zoom handler.\n   *\n   * @internal\n   * @returns {DoubleClickZoomHandler}\n   */\n  get doubleClickZoom() {\n    return this.sdk.doubleClickZoom;\n  }\n  /**\n   * The double click zoom handler.\n   *\n   * @internal\n   * @param {DoubleClickZoomHandler} value - The double click zoom handler.\n   */\n  set doubleClickZoom(t) {\n    this.sdk.doubleClickZoom = t;\n  }\n  /**\n   * The touch zoom rotate handler.\n   *\n   * @internal\n   * @returns {TwoFingersTouchZoomRotateHandler}\n   */\n  get touchZoomRotate() {\n    return this.sdk.touchZoomRotate;\n  }\n  /**\n   * The touch zoom rotate handler.\n   *\n   * @internal\n   * @param {TwoFingersTouchZoomRotateHandler} value - The touch zoom rotate handler.\n   */\n  set touchZoomRotate(t) {\n    this.sdk.touchZoomRotate = t;\n  }\n  /**\n   * The cooperative gestures handler.\n   *\n   * @internal\n   * @returns {CooperativeGesturesHandler}\n   */\n  get cooperativeGestures() {\n    return this.sdk.cooperativeGestures;\n  }\n  /**\n   * The cooperative gestures handler.\n   *\n   * @internal\n   * @param {CooperativeGesturesHandler} value - The cooperative gestures handler.\n   */\n  set cooperativeGestures(t) {\n    this.sdk.cooperativeGestures = t;\n  }\n  //#endregion SDK Mappings\n  //#region lngLatToPx\n  /**\n   * Converts a LngLat to a px coordinate, based on the image metadata.\n   *\n   * @internal\n   * @param {LngLat} lngLat - The LngLat to convert.\n   * @returns {[number, number]} The px coordinate.\n   */\n  lngLatToPx(t) {\n    if (!this.paddedSizeMax) {\n      const a = \"[ImageViewer]: Unable to convert LngLat to px, padded size max not set\";\n      throw this.fire(\"error\", new re(\"error\", this, null, { error: new Error(a) })), new Error(a);\n    }\n    const n = fn.fromLngLat(t);\n    return [n.x * this.paddedSizeMax, n.y * this.paddedSizeMax];\n  }\n  //#region pxToLngLat\n  /**\n   * Converts a px coordinate to a LngLat, based on the image metadata.\n   *\n   * @internal\n   * @param {LngLat} lngLat - The LngLat to convert.\n   * @returns {[number, number]} The px coordinate.\n   */\n  pxToLngLat(t) {\n    if (!this.paddedSizeMax) {\n      const a = \"[ImageViewer]: Unable to convert px to LngLat, padded size max not set\";\n      throw this.fire(\"error\", new re(\"error\", this, null, { error: new Error(a) })), new Error(a);\n    }\n    return new fn(t[0] / this.paddedSizeMax, t[1] / this.paddedSizeMax).toLngLat();\n  }\n  //#region getSDKInternal\n  /**\n   * Get the internal SDK instance.\n   *\n   * @returns {Map} The internal SDK instance.\n   * @internal\n   */\n  getSDKInternal() {\n    return this.sdk;\n  }\n  /**\n   * Get the canvas of the internal SDK instance.\n   *\n   * @returns {HTMLCanvasElement} The canvas of the internal SDK instance.\n   */\n  getCanvas() {\n    return this.sdk.getCanvas();\n  }\n  //#region flyTo\n  /**\n   * Fly to a given center.\n   *\n   * @param {ImageViewerFlyToOptions} options - The options for the fly to.\n   * @param {MapDataEvent} eventData - The event data.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  flyTo(t, n) {\n    const a = this.pxToLngLat(t.center);\n    return this.sdk.flyTo({ ...t, pitch: 0, center: a }, n), this;\n  }\n  //#region jumpTo\n  /**\n   * Jump to a given center.\n   *\n   * @param {ImageViewerJumpToOptions} options - The options for the jump to.\n   * @param {MapDataEvent} eventData - The event data.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  jumpTo(t, n) {\n    const a = this.pxToLngLat(t.center);\n    return this.sdk.jumpTo({ ...t, pitch: 0, center: a }, n), this;\n  }\n  //#region setZoom\n  /**\n   * Set the zoom level.\n   *\n   * @param {number} zoom - The zoom level.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  setZoom(t) {\n    return this.sdk.setZoom(t), this;\n  }\n  //#region getZoom\n  /**\n   * Get the zoom level.\n   *\n   * @returns {number} The zoom level.\n   */\n  getZoom() {\n    return this.sdk.getZoom();\n  }\n  //#region getCenter\n  /**\n   * Get the center of the ImageViewer in pixels.\n   *\n   * @internal\n   * @returns {[number, number]} The center of the ImageViewer.\n   */\n  getCenter() {\n    const t = this.sdk.getCenter();\n    return this.lngLatToPx(t);\n  }\n  //#region setCenter\n  /**\n   * Set the center of the ImageViewer in pixels.\n   *\n   * @param {number} center - The center of the ImageViewer.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  setCenter(t) {\n    return this.sdk.setCenter(this.pxToLngLat(t)), this;\n  }\n  //#region setBearing\n  /**\n   * Set the bearing of the ImageViewer in degrees.\n   *\n   * @param {number} bearing - The bearing of the ImageViewer.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  setBearing(t) {\n    return this.sdk.setBearing(t), this;\n  }\n  //#region getBearing\n  /**\n   * Get the bearing of the ImageViewer in degrees.\n   *\n   * @returns {number} The bearing of the ImageViewer.\n   */\n  getBearing() {\n    return this.sdk.getBearing();\n  }\n  //#region panBy\n  /**\n   * Pan by a given delta in pixels.\n   *\n   * @param {PointLike} delta - The delta to pan by.\n   * @param {ImageViewerEaseToOptions} options - The options for the pan.\n   * @param {any} eventData - The event data.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  panBy(t, n, a) {\n    return this.sdk.panBy(t, { ...n, pitch: 0 }, a), this;\n  }\n  //#region panTo\n  /**\n   * Pan to a given center in pixels.\n   *\n   * @param {number} center - The center to pan to.\n   * @param {ImageViewerEaseToOptions} options - The options for the pan.\n   * @param {any} eventData - The event data.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  panTo(t, n, a) {\n    return this.sdk.panTo(this.pxToLngLat(t), { ...n, pitch: 0 }, a), this;\n  }\n  //#region getImageMetadata\n  /**\n   * Get the image metadata.\n   *\n   * @returns {ImageMetadata} The image metadata.\n   */\n  getImageMetadata() {\n    return this.imageMetadata;\n  }\n  //#region getImageBounds\n  /**\n   * Get the visible bounds of the image in the viewport in imagePixels.\n   * [topLeft, bottomRight]\n   *\n   * @returns {[[number, number], [number, number]]} The visible bounds of the image.\n   */\n  getImageBounds() {\n    const n = this.sdk.getBounds().toArray().map((i) => this.lngLatToPx(vi.convert(i))), a = [n[0][0], n[1][1]], o = [n[1][0], n[0][1]];\n    return [a, o];\n  }\n  //#region fitImageBounds\n  /**\n   * Set the bounds of the image.\n   *\n   * @param {[[number, number], [number, number]]} bounds - The bounds of the image.\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  fitImageBounds([t, n]) {\n    const a = this.pxToLngLat(t), o = this.pxToLngLat(n), i = Xc.convert([a, o]);\n    return this.sdk.fitBounds(i), this;\n  }\n  //#region remove\n  /**\n   * Destroys the ImageViewer, removes the map instance and all event listeners. Useful for cleanup.\n   *\n   * @returns {ImageViewer} The ImageViewer instance.\n   */\n  remove() {\n    this.fire(\"beforeremove\", new re(\"beforeremove\", this)), this.sdk.remove(), this._listeners && Object.entries(this._listeners).forEach(([t, n]) => {\n      n.forEach((a) => {\n        this.off(t, a);\n      });\n    }), this._oneTimeListeners && Object.entries(this._oneTimeListeners).forEach(([t, n]) => {\n      n.forEach((a) => {\n        this.off(t, a);\n      });\n    });\n  }\n  pointIsWithinImageBounds(t) {\n    const n = this.getImageMetadata();\n    if (!n)\n      return !1;\n    const a = [\n      [0, 0],\n      [n.width, n.height]\n    ];\n    return t[0] >= a[0][0] && t[0] <= a[1][0] && t[1] >= a[0][1] && t[1] <= a[1][1];\n  }\n}\nfunction Ec(r) {\n  return `${ai()}/${r}/image.json?key=${j.apiKey}`;\n}\nfunction Cc(r) {\n  return `${ai()}/${r}/{z}/{x}/{y}?key=${j.apiKey}`;\n}\nfunction ai() {\n  return \"https://api.maptiler.com/images\";\n}\nconst { Evented: Ac } = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\nclass kp extends Ac {\n  constructor({ ...t }) {\n    super();\n    g(this, \"viewer\");\n    g(this, \"marker\");\n    g(this, \"position\", [0, 0]);\n    this.marker = new Mi(t);\n  }\n  /**\n   * Adds the ImageViewerMarker to an instance of ImageViewer.\n   *\n   * @param {ImageViewer} viewer - The instance of ImageViewer to add the ImageViewerMarker to.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  addTo(t) {\n    if (!(t instanceof Lc))\n      throw new Error(\"[ImageViewerMarker]: an ImageViewerMarker must be added to an instance of ImageViewer\");\n    this.viewer = t, Mc(this.marker, this, this.viewer[ri]);\n    const n = this.viewer.getSDKInternal();\n    return this.setPosition(this.position), bc(this.marker), this.marker.addTo(n), this;\n  }\n  /**\n   * Adds a class name to the ImageViewerMarker.\n   *\n   * @param {string} className - The class name to add to the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  addClassName(t) {\n    return this.marker.addClassName(t), this;\n  }\n  /**\n   * Gets the element of the ImageViewerMarker.\n   *\n   * @returns {HTMLElement} The element of the ImageViewerMarker.\n   */\n  getElement() {\n    return this.marker.getElement();\n  }\n  /**\n   * Gets the position of the ImageViewerMarker.\n   *\n   * @returns {PointLike} The position of the ImageViewerMarker.\n   * @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)\n   *\n   */\n  getPosition() {\n    return this.position;\n  }\n  /**\n   * Gets the offset of the ImageViewerMarker.\n   *\n   * @returns {PointLike} The offset of the ImageViewerMarker.\n   * @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)\n   */\n  getOffset() {\n    return this.marker.getOffset();\n  }\n  /**\n   * Gets the pitch alignment of the ImageViewerMarker.\n   *\n   * @returns {Alignment} The pitch alignment of the ImageViewerMarker.\n   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)\n   */\n  getPitchAlignment() {\n    return this.marker.getPitchAlignment();\n  }\n  /**\n   * Gets the popup of the ImageViewerMarker.\n   *\n   * @returns {Popup} The popup of the ImageViewerMarker.\n   * @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)\n   */\n  getPopup() {\n    return this.marker.getPopup();\n  }\n  /**\n   * Gets the rotation of the ImageViewerMarker.\n   *\n   * @returns {number} The rotation of the ImageViewerMarker.\n   */\n  getRotation() {\n    return this.marker.getRotation();\n  }\n  /**\n   * Gets the rotation alignment of the ImageViewerMarker.\n   *\n   * @returns {Alignment} The rotation alignment of the ImageViewerMarker.\n   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)\n   */\n  getRotationAlignment() {\n    return this.marker.getRotationAlignment();\n  }\n  /**\n   * Checks if the ImageViewerMarker is draggable.\n   *\n   * @returns {boolean} True if the ImageViewerMarker is draggable, false otherwise.\n   */\n  isDraggable() {\n    return this.marker.isDraggable();\n  }\n  /**\n   * Fires an event on the ImageViewerMarker.\n   *\n   * @param {MarkerEventTypes | Event} event - The event to fire.\n   * @param {Record<string, any>} data - The data to fire the event with.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  fire(t, n) {\n    return super.fire(t, n), this;\n  }\n  /**\n   * Removes an event listener from the ImageViewerMarker.\n   *\n   * @param {MarkerEventTypes} event - The event to remove the listener from.\n   * @param {ImageViewerMarkerEvent} listener - The listener to remove.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  off(t, n) {\n    return super.off(t, n), this;\n  }\n  /**\n   * Adds an event listener to the ImageViewerMarker.\n   *\n   * @param {MarkerEventTypes} event - The event to add the listener to.\n   * @param {ImageViewerMarkerEvent} listener - The listener to add.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  on(t, n) {\n    return super.on(t, n);\n  }\n  /**\n   * Checks if the ImageViewerMarker is within the image bounds.\n   *\n   * @returns {boolean} True if the ImageViewerMarker is within the image bounds, false otherwise.\n   */\n  isWithinImageBounds() {\n    return this.viewer.pointIsWithinImageBounds(this.position);\n  }\n  /**\n   * Removes the ImageViewerMarker from the ImageViewer and cleans up the event listeners.\n   *\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  remove() {\n    return this.marker.remove(), this.marker._listeners && Object.entries(this.marker._listeners).forEach(([t, n]) => {\n      n.forEach((a) => {\n        this.off(t, a);\n      });\n    }), this.marker._oneTimeListeners && Object.entries(this.marker._oneTimeListeners).forEach(([t, n]) => {\n      n.forEach((a) => {\n        this.off(t, a);\n      });\n    }), this;\n  }\n  /**\n   * Removes a class name from the ImageViewerMarker dom element.\n   *\n   * @param {string} className - The class name to remove from the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  removeClassName(t) {\n    return this.marker.removeClassName(t), this;\n  }\n  /**\n   * Sets the draggable state of the ImageViewerMarker.\n   *\n   * @param {boolean} draggable - The draggable state of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  setDraggable(t) {\n    return this.marker.setDraggable(t), this;\n  }\n  /**\n   * Sets the position of the ImageViewerMarker.\n   *\n   * @param {[number, number]} px - The position of the ImageViewerMarker in image pixels.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  setPosition(t) {\n    if (this.position[0] = t[0], this.position[1] = t[1], !this.viewer)\n      return this;\n    const n = this.viewer[ni](t);\n    return this.marker.setLngLat(n), this;\n  }\n  /**\n   * Sets the offset of the ImageViewerMarker.\n   *\n   * @param {PointLike} offset - The offset of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  setOffset(t) {\n    return this.marker.setOffset(t), this;\n  }\n  /**\n   * Sets the opacity of the ImageViewerMarker.\n   *\n   * @param {string} opacity - The opacity of the ImageViewerMarker.\n   * @param {string} opacityWhenCovered - The opacity of the ImageViewerMarker when covered.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  setOpacity(t, n) {\n    return this.marker.setOpacity(t, n), this;\n  }\n  /**\n   * Sets the pitch alignment of the ImageViewerMarker.\n   *\n   * @param {Alignment} pitchAlignment - The pitch alignment of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)\n   */\n  setPitchAlignment(t) {\n    return this.marker.setPitchAlignment(t), this;\n  }\n  /**\n   * Sets the popup of the ImageViewerMarker.\n   *\n   * @param {Popup} popup - The popup of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   * @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)\n   */\n  setPopup(t) {\n    return this.marker.setPopup(t), this;\n  }\n  /**\n   * Sets the rotation of the ImageViewerMarker.\n   *\n   * @param {number} rotation - The rotation of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  setRotation(t) {\n    return this.marker.setRotation(t), this;\n  }\n  /**\n   * Sets the rotation alignment of the ImageViewerMarker.\n   *\n   * @param {Alignment} rotationAlignment - The rotation alignment of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)\n   */\n  setRotationAlignment(t) {\n    return this.marker.setRotationAlignment(t), this;\n  }\n  /**\n   * Sets if subpixel positioning is enabled for the ImageViewerMarker.\n   *\n   * @param {boolean} subpixelPositioning - The subpixel positioning of the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  setSubpixelPositioning(t) {\n    return this.marker.setSubpixelPositioning(t), this;\n  }\n  /**\n   * Toggles a class name on the ImageViewerMarker dom element.\n   *\n   * @param {string} className - The class name to toggle on the ImageViewerMarker.\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  toggleClassName(t) {\n    return this.marker.toggleClassName(t), this;\n  }\n  /**\n   * Toggles the popup of the ImageViewerMarker.\n   *\n   * @returns {ImageViewerMarker} The ImageViewerMarker instance.\n   */\n  togglePopup() {\n    return this.marker.togglePopup(), this;\n  }\n}\nconst Tc = [\"dragstart\", \"drag\", \"dragend\"], _c = [\"lngLat\", \"_defaultPrevented\", \"target\"];\nclass Ic {\n  constructor(e, t, n) {\n    g(this, \"type\");\n    g(this, \"target\");\n    this.type = e, this.target = t, Object.assign(this, n);\n  }\n}\nfunction Mc(r, e, t) {\n  Tc.forEach((n) => {\n    r.on(n, (a) => {\n      var i, s;\n      if ((i = a.target) == null ? void 0 : i.getLngLat()) {\n        const l = t((s = a.target) == null ? void 0 : s.getLngLat());\n        e.setPosition(l);\n      }\n      e.fire(\n        n,\n        new Ic(n, e, {\n          ...Object.fromEntries(Object.entries(a).filter(([l]) => !_c.includes(l)))\n        })\n      );\n    });\n  });\n}\nfunction $n(r) {\n  if (typeof DOMParser < \"u\") {\n    const e = new DOMParser().parseFromString(r, \"application/xml\");\n    if (e.querySelector(\"parsererror\"))\n      throw new Error(\"The provided string is not valid XML\");\n    return e;\n  }\n  throw new Error(\"No XML parser found\");\n}\nfunction oi(r, e) {\n  if (!r.hasChildNodes())\n    return !1;\n  for (const t of Array.from(r.childNodes)) {\n    const n = t.nodeName;\n    if (typeof n == \"string\" && n.trim().toLowerCase() === e.toLowerCase())\n      return !0;\n  }\n  return !1;\n}\nfunction qa(r) {\n  if (typeof XMLSerializer < \"u\")\n    return new XMLSerializer().serializeToString(r);\n  throw new Error(\"No XML serializer found\");\n}\nfunction ii(r) {\n  const e = typeof r == \"string\" ? $n(r) : r;\n  if (!oi(e, \"gpx\"))\n    throw new Error(\"The XML document is not valid GPX\");\n  const t = H(e, \"trk\"), n = H(e, \"rte\"), a = H(e, \"wpt\"), o = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  for (const i of Array.from(t)) {\n    const s = Oc(i);\n    s && o.features.push(s);\n  }\n  for (const i of Array.from(n)) {\n    const s = $c(i);\n    s && o.features.push(s);\n  }\n  for (const i of Array.from(a))\n    o.features.push(Fc(i));\n  return o;\n}\nfunction si(r, e) {\n  let t = r;\n  if (typeof t == \"string\" && (t = $n(t)), !oi(t, \"kml\"))\n    throw new Error(\"The XML document is not valid KML\");\n  const n = {\n    type: \"FeatureCollection\",\n    features: []\n  }, a = {}, o = {}, i = {}, s = H(t, \"Placemark\"), l = H(t, \"Style\"), u = H(t, \"StyleMap\");\n  for (const c of Array.from(l)) {\n    const p = Ga(e !== void 0 ? e(c) : qa(c)).toString(16);\n    a[`#${Xe(c, \"id\")}`] = p, o[p] = c;\n  }\n  for (const c of Array.from(u)) {\n    a[`#${Xe(c, \"id\")}`] = Ga(e !== void 0 ? e(c) : qa(c)).toString(16);\n    const p = H(c, \"Pair\"), d = {};\n    for (const f of Array.from(p))\n      d[F(_(f, \"key\")) ?? \"\"] = F(_(f, \"styleUrl\"));\n    i[`#${Xe(c, \"id\")}`] = d;\n  }\n  for (const c of Array.from(s))\n    n.features = n.features.concat(zc(c, a, o, i));\n  return n;\n}\nfunction Va(r) {\n  if (r === null) return [\"#000000\", 1];\n  let e = \"\", t = 1, n = r;\n  return n.startsWith(\"#\") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? \"#000000\", t ?? 1];\n}\nfunction Pc(r) {\n  return ci(r.split(\" \"));\n}\nfunction Rc(r) {\n  let e = H(r, \"coord\");\n  const t = [], n = [];\n  e.length === 0 && (e = H(r, \"gx:coord\"));\n  for (const o of Array.from(e))\n    t.push(Pc(F(o) ?? \"\"));\n  const a = H(r, \"when\");\n  for (const o of Array.from(a)) n.push(F(o));\n  return {\n    coords: t,\n    times: n\n  };\n}\nfunction Xt(r) {\n  const e = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  let t, n, a, o, i;\n  const s = [], l = [];\n  if (_(r, \"MultiGeometry\") !== null)\n    return Xt(_(r, \"MultiGeometry\"));\n  if (_(r, \"MultiTrack\") !== null)\n    return Xt(_(r, \"MultiTrack\"));\n  if (_(r, \"gx:MultiTrack\") !== null)\n    return Xt(_(r, \"gx:MultiTrack\"));\n  for (a = 0; a < e.length; a++)\n    if (n = H(r, e[a]), n) {\n      for (o = 0; o < n.length; o++)\n        if (t = n[o], e[a] === \"Point\")\n          s.push({\n            type: \"Point\",\n            coordinates: pi(F(_(t, \"coordinates\")) ?? \"\")\n          });\n        else if (e[a] === \"LineString\")\n          s.push({\n            type: \"LineString\",\n            coordinates: Za(F(_(t, \"coordinates\")) ?? \"\")\n          });\n        else if (e[a] === \"Polygon\") {\n          const u = H(t, \"LinearRing\"), c = [];\n          for (i = 0; i < u.length; i++)\n            c.push(Za(F(_(u[i], \"coordinates\")) ?? \"\"));\n          s.push({\n            type: \"Polygon\",\n            coordinates: c\n          });\n        } else if (e[a] === \"Track\" || e[a] === \"gx:Track\") {\n          const u = Rc(t);\n          s.push({\n            type: \"LineString\",\n            coordinates: u.coords\n          }), u.times.length && l.push(u.times);\n        }\n    }\n  return { geoms: s, coordTimes: l };\n}\nfunction zc(r, e, t, n) {\n  const a = Xt(r), o = {}, i = F(_(r, \"name\")), s = F(_(r, \"address\")), l = F(_(r, \"description\")), u = _(r, \"TimeSpan\"), c = _(r, \"TimeStamp\"), p = _(r, \"ExtendedData\"), d = _(r, \"visibility\");\n  let f, h = F(_(r, \"styleUrl\")), m = _(r, \"LineStyle\"), y = _(r, \"PolyStyle\");\n  if (!a.geoms.length) return [];\n  if (i && (o.name = i), s && (o.address = s), h) {\n    h.startsWith(\"#\") || (h = `#${h}`), o.styleUrl = h, e[h] && (o.styleHash = e[h]), n[h] && (o.styleMapHash = n[h], o.styleHash = e[n[h].normal ?? \"\"]);\n    const v = t[o.styleHash ?? \"\"];\n    if (v) {\n      m || (m = _(v, \"LineStyle\")), y || (y = _(v, \"PolyStyle\"));\n      const x = _(v, \"IconStyle\");\n      if (x) {\n        const A = _(x, \"Icon\");\n        if (A) {\n          const E = F(_(A, \"href\"));\n          E && (o.icon = E);\n        }\n      }\n    }\n  }\n  if (l && (o.description = l), u) {\n    const v = F(_(u, \"begin\")), x = F(_(u, \"end\"));\n    v && x && (o.timespan = { begin: v, end: x });\n  }\n  if (c !== null && (o.timestamp = F(_(c, \"when\")) ?? (/* @__PURE__ */ new Date()).toISOString()), m !== null) {\n    const v = Va(F(_(m, \"color\"))), x = v[0], A = v[1], E = Number.parseFloat(F(_(m, \"width\")) ?? \"\");\n    x && (o.stroke = x), Number.isNaN(A) || (o[\"stroke-opacity\"] = A), Number.isNaN(E) || (o[\"stroke-width\"] = E);\n  }\n  if (y) {\n    const v = Va(F(_(y, \"color\"))), x = v[0], A = v[1], E = F(_(y, \"fill\")), C = F(_(y, \"outline\"));\n    x && (o.fill = x), Number.isNaN(A) || (o[\"fill-opacity\"] = A), E && (o[\"fill-opacity\"] = E === \"1\" ? o[\"fill-opacity\"] || 1 : 0), C && (o[\"stroke-opacity\"] = C === \"1\" ? o[\"stroke-opacity\"] || 1 : 0);\n  }\n  if (p) {\n    const v = H(p, \"Data\"), x = H(p, \"SimpleData\");\n    for (f = 0; f < v.length; f++)\n      o[v[f].getAttribute(\"name\") ?? \"\"] = F(_(v[f], \"value\")) ?? \"\";\n    for (f = 0; f < x.length; f++)\n      o[x[f].getAttribute(\"name\") ?? \"\"] = F(x[f]) ?? \"\";\n  }\n  d !== null && (o.visibility = F(d) ?? \"\"), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);\n  const w = {\n    type: \"Feature\",\n    geometry: a.geoms.length === 1 ? a.geoms[0] : {\n      type: \"GeometryCollection\",\n      geometries: a.geoms\n    },\n    properties: o\n  };\n  return Xe(r, \"id\") && (w.id = Xe(r, \"id\") ?? void 0), [w];\n}\nfunction li(r, e) {\n  const t = H(r, e), n = [], a = [];\n  let o = [];\n  const i = t.length;\n  if (!(i < 2)) {\n    for (let s = 0; s < i; s++) {\n      const l = fi(t[s]);\n      n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));\n    }\n    return {\n      line: n,\n      times: a,\n      heartRates: o\n    };\n  }\n}\nfunction Oc(r) {\n  const e = H(r, \"trkseg\"), t = [], n = [], a = [];\n  let o;\n  for (let s = 0; s < e.length; s++)\n    if (o = li(e[s], \"trkpt\"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {\n      if (!a.length)\n        for (let l = 0; l < s; l++)\n          a.push(new Array(t[l].length).fill(null));\n      o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));\n    }\n  if (t.length === 0) return;\n  const i = {\n    ...Fn(r),\n    ...ui(_(r, \"extensions\"))\n  };\n  return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {\n    type: \"Feature\",\n    properties: i,\n    geometry: {\n      type: \"LineString\",\n      coordinates: t[0]\n    }\n  } : {\n    type: \"Feature\",\n    properties: i,\n    geometry: {\n      type: \"MultiLineString\",\n      coordinates: t\n    }\n  };\n}\nfunction $c(r) {\n  const e = li(r, \"rtept\");\n  return e === void 0 ? void 0 : {\n    type: \"Feature\",\n    properties: {\n      ...Fn(r),\n      ...ui(_(r, \"extensions\"))\n    },\n    geometry: {\n      type: \"LineString\",\n      coordinates: e.line\n    }\n  };\n}\nfunction Fc(r) {\n  return {\n    type: \"Feature\",\n    properties: { ...Fn(r), ...on(r, [\"sym\"]) },\n    geometry: {\n      type: \"Point\",\n      coordinates: fi(r).coordinates\n    }\n  };\n}\nfunction ui(r) {\n  const e = {};\n  if (r) {\n    const t = _(r, \"line\");\n    if (t) {\n      const n = F(_(t, \"color\")), a = Number.parseFloat(F(_(t, \"opacity\")) ?? \"0\"), o = Number.parseFloat(F(_(t, \"width\")) ?? \"0\");\n      n && (e.stroke = n), Number.isNaN(a) || (e[\"stroke-opacity\"] = a), Number.isNaN(o) || (e[\"stroke-width\"] = o * 96 / 25.4);\n    }\n  }\n  return e;\n}\nfunction Fn(r) {\n  const e = on(r, [\"name\", \"cmt\", \"desc\", \"type\", \"time\", \"keywords\"]), t = H(r, \"link\");\n  if (t.length !== 0) {\n    e.links = [];\n    for (const n of Array.from(t)) {\n      const a = {\n        href: Xe(n, \"href\"),\n        ...on(n, [\"text\", \"type\"])\n      };\n      e.links.push(a);\n    }\n  }\n  return e;\n}\nfunction Ga(r) {\n  let e = 0;\n  if (!r || !r.length) return e;\n  for (let t = 0; t < r.length; t++)\n    e = (e << 5) - e + r.charCodeAt(t) | 0;\n  return e;\n}\nfunction H(r, e) {\n  return r.getElementsByTagName(e);\n}\nfunction Xe(r, e) {\n  return r.getAttribute(e);\n}\nfunction Ha(r, e) {\n  return Number.parseFloat(Xe(r, e) ?? \"0\");\n}\nfunction _(r, e) {\n  const t = H(r, e);\n  return t.length ? t[0] : null;\n}\nfunction Nc(r) {\n  return r.normalize && r.normalize(), r;\n}\nfunction ci(r) {\n  return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);\n}\nfunction F(r) {\n  return r && Nc(r), r && r.textContent;\n}\nfunction on(r, e) {\n  const t = {};\n  let n, a;\n  for (a = 0; a < e.length; a++)\n    n = _(r, e[a]), n && (t[e[a]] = F(n) ?? \"\");\n  return t;\n}\nfunction pi(r) {\n  return ci(r.replace(/\\s*/g, \"\").split(\",\"));\n}\nfunction Za(r) {\n  const e = r.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/), t = [];\n  for (const n of e) t.push(pi(n));\n  return t;\n}\nfunction fi(r) {\n  const e = [Ha(r, \"lon\"), Ha(r, \"lat\")], t = _(r, \"ele\"), n = _(r, \"gpxtpx:hr\") || _(r, \"hr\"), a = _(r, \"time\");\n  let o;\n  return t && (o = Number.parseFloat(F(t) ?? \"0\"), Number.isNaN(o) || e.push(o)), {\n    coordinates: e,\n    time: a ? F(a) : null,\n    heartRate: n !== null ? Number.parseFloat(F(n) ?? \"0\") : null\n  };\n}\nfunction jc(r) {\n  let e = r;\n  try {\n    typeof e == \"string\" && (e = $n(e));\n  } catch {\n    return null;\n  }\n  try {\n    return ii(e);\n  } catch {\n  }\n  try {\n    return si(e);\n  } catch {\n  }\n  return null;\n}\nasync function Dc(r, e = {}) {\n  const t = e.download ?? !1, n = await Uc(r);\n  if (t) {\n    const a = e.filename ?? \"maptiler_screenshot.png\", o = document.createElement(\"a\");\n    o.style.display = \"none\", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {\n      document.body.removeChild(o), URL.revokeObjectURL(o.href);\n    }, 0);\n  }\n  return n;\n}\nfunction Uc(r) {\n  return new Promise((e, t) => {\n    r.redraw(), r.once(\"idle\", () => {\n      r.getCanvas().toBlob((n) => {\n        if (!n) {\n          t(Error(\"Screenshot could not be created.\"));\n          return;\n        }\n        e(n);\n      }, \"image/png\");\n    });\n  });\n}\nconst sn = [\n  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n  [\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n  [\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n  [\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n  [\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n  [\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n  [\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n  [\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n  [\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n  [\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"]\n];\nfunction kr() {\n  return sn[~~(Math.random() * sn.length)][~~(Math.random() * 4)];\n}\nfunction Pt() {\n  return `maptiler_source_${Qa()}`;\n}\nfunction Rt() {\n  return `maptiler_layer_${Qa()}`;\n}\nfunction ln(r, e) {\n  if (e <= r[0].zoom)\n    return r[0].value;\n  if (e >= r[r.length - 1].zoom)\n    return r[r.length - 1].value;\n  for (let t = 0; t < r.length - 1; t += 1)\n    if (e >= r[t].zoom && e < r[t + 1].zoom) {\n      const n = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / n;\n      return a * r[t + 1].value + (1 - a) * r[t].value;\n    }\n  return 0;\n}\nfunction je(r) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap((e) => [e.zoom, e.value])];\n}\nfunction O(r) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap((e) => [e.zoom, e.value])];\n}\nfunction di(r, e) {\n  if (typeof e == \"number\" && typeof r == \"number\")\n    return 2 * e + r;\n  if (typeof e == \"number\" && Array.isArray(r))\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap((t) => [t.zoom, 2 * e + t.value])];\n  if (typeof r == \"number\" && Array.isArray(e))\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...e.flatMap((t) => [t.zoom, 2 * t.value + r])];\n  if (Array.isArray(r) && Array.isArray(e)) {\n    const t = Array.from(/* @__PURE__ */ new Set([...r.map((n) => n.zoom), ...e.map((n) => n.zoom)])).sort((n, a) => n < a ? -1 : 1);\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...t.flatMap((n) => [n, 2 * ln(e, n) + ln(r, n)])];\n  }\n  return 0;\n}\nfunction hi(r, e) {\n  return [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((t) => [t.propertyValue, t.value])];\n}\nfunction Nn(r) {\n  const e = r.trimStart(), t = `${e}${\" \".repeat(r.length - e.length)}`, n = Array.from(t);\n  if (!n.every((s) => s === \" \" || s === \"_\"))\n    throw new Error(\"A dash pattern must be composed only of whitespace and underscore characters.\");\n  if (!(n.some((s) => s === \"_\") && n.some((s) => s === \" \")))\n    throw new Error(\"A dash pattern must contain at least one underscore and one whitespace character\");\n  const i = [1];\n  for (let s = 1; s < n.length; s += 1) {\n    const l = n[s - 1], u = n[s];\n    l === u ? i[i.length - 1] += 1 : i.push(1);\n  }\n  return i;\n}\nfunction un(r, e) {\n  return [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((t) => [t.value, t.color])];\n}\nfunction cn(r, e, t = !0) {\n  return t ? [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.025])],\n    2,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.05])],\n    4,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.1])],\n    8,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.25])],\n    16,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius])]\n  ] : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius])];\n}\nfunction mi(r, e, t = !0) {\n  return t ? [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.025])],\n    2,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.05])],\n    4,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.1])],\n    8,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.25])],\n    16,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value])]\n  ] : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value])];\n}\nfunction pn(r, e) {\n  return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", e],\n    ...r.getRawColorStops().flatMap((t) => {\n      const n = t.value, a = t.color;\n      return [n, a.length === 4 ? a[3] / 255 : 1];\n    })\n  ];\n}\nfunction yi(r, e = 10) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"heatmap-density\"],\n    ...Array.from({ length: e + 1 }, (t, n) => {\n      const a = n / e;\n      return [a, r.getColorHex(a)];\n    }).flat()\n  ];\n}\nfunction Gt(r) {\n  const e = r.toString(16);\n  return e.length === 1 ? `0${e}` : e;\n}\nfunction Bc(r) {\n  return `#${Gt(r[0])}${Gt(r[1])}${Gt(r[2])}${r.length === 4 ? Gt(r[3]) : \"\"}`;\n}\nclass T extends Array {\n  constructor(t = {}) {\n    super();\n    g(this, \"min\", 0);\n    g(this, \"max\", 1);\n    \"min\" in t && (this.min = t.min), \"max\" in t && (this.max = t.max), \"stops\" in t && this.setStops(t.stops, { clone: !1 });\n  }\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(t) {\n    return new T({\n      stops: t.map((n) => ({\n        value: n[0],\n        color: n[1]\n      }))\n    });\n  }\n  setStops(t, n = { clone: !0 }) {\n    const a = n.clone ? this.clone() : this;\n    a.length = 0;\n    let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n    for (let s = 0; s < t.length; s += 1)\n      o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({\n        value: t[s].value,\n        color: t[s].color.slice()\n        // we want to make sure we do a deep copy and not a reference\n      });\n    return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;\n  }\n  scale(t, n, a = { clone: !0 }) {\n    const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];\n    for (let p = 0; p < this.length; p += 1) {\n      const h = (this[p].value - i) / l * u + t;\n      o ? c.push({\n        value: h,\n        color: this[p].color.slice()\n      }) : this[p].value = h;\n    }\n    return o ? new T({ stops: c }) : this;\n  }\n  // for some reason, I had to reimplement this\n  at(t) {\n    return t < 0 ? this[this.length + t] : this[t];\n  }\n  clone() {\n    return new T({ stops: this.getRawColorStops() });\n  }\n  getRawColorStops() {\n    const t = [];\n    for (let n = 0; n < this.length; n += 1)\n      t.push({ value: this[n].value, color: this[n].color });\n    return t;\n  }\n  reverse(t = { clone: !0 }) {\n    const n = t.clone ? this.clone() : this;\n    for (let a = 0; a < ~~(n.length / 2); a += 1) {\n      const o = n[a].color;\n      n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;\n    }\n    return n;\n  }\n  getBounds() {\n    return { min: this.min, max: this.max };\n  }\n  getColor(t, n = { smooth: !0 }) {\n    if (t <= this[0].value)\n      return this[0].color;\n    if (t >= this.at(-1).value)\n      return this.at(-1).color;\n    for (let a = 0; a < this.length - 1; a += 1) {\n      if (t > this[a + 1].value)\n        continue;\n      const o = this[a].color;\n      if (!n.smooth)\n        return o.slice();\n      const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);\n      return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));\n    }\n    return [0, 0, 0];\n  }\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(t, n = {\n    smooth: !0,\n    withAlpha: !1\n  }) {\n    return Bc(this.getColor(t, n));\n  }\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(t, n = { smooth: !0 }) {\n    const a = this.getBounds();\n    return this.getColor(a.min + t * (a.max - a.min), n);\n  }\n  getCanvasStrip(t = {\n    horizontal: !0,\n    size: 512,\n    smooth: !0\n  }) {\n    const n = document.createElement(\"canvas\");\n    n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;\n    const a = n.getContext(\"2d\");\n    if (!a) throw new Error(\"Canvs context is missing\");\n    const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;\n    for (let d = 0; d < s; d += 1) {\n      const f = this.getColor(l + d * p, {\n        smooth: t.smooth\n      });\n      i[d * 4] = f[0], i[d * 4 + 1] = f[1], i[d * 4 + 2] = f[2], i[d * 4 + 3] = f.length > 3 ? f[3] : 255;\n    }\n    return a.putImageData(o, 0, 0), n;\n  }\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(t, n = 15) {\n    const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);\n    let s;\n    if (t === \"ease-in-square\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = d ** 2, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-out-square\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 1 - (1 - d) ** 2, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-out-sqrt\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = d ** 0.5, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-in-sqrt\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 1 - (1 - d) ** 0.5, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-out-exp\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 1 - 2 ** (-10 * d), h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-in-exp\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 2 ** (10 * d - 10), h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else\n      throw new Error(\"Invalid ressampling method.\");\n    return new T({ stops: s }).scale(a.min, a.max);\n  }\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart() {\n    const t = this.getRawColorStops();\n    t.unshift({\n      value: t[0].value,\n      color: t[0].color.slice()\n    }), t[1].value += 1e-3;\n    for (const n of t)\n      n.color.length === 3 && n.color.push(255);\n    return t[0].color[3] = 0, new T({ stops: t });\n  }\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart() {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\nconst gi = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0, 0] },\n      { value: 1, color: [0, 0, 0, 0] }\n    ]\n  }),\n  GRAY: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new T({\n    stops: [\n      { value: 0, color: [0, 0, 131] },\n      { value: 0.125, color: [0, 60, 170] },\n      { value: 0.375, color: [5, 255, 255] },\n      { value: 0.625, color: [255, 255, 0] },\n      { value: 0.875, color: [250, 0, 0] },\n      { value: 1, color: [128, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new T({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 0.169, color: [253, 255, 2] },\n      { value: 0.173, color: [247, 255, 2] },\n      { value: 0.337, color: [0, 252, 4] },\n      { value: 0.341, color: [0, 252, 10] },\n      { value: 0.506, color: [1, 249, 255] },\n      { value: 0.671, color: [2, 0, 253] },\n      { value: 0.675, color: [8, 0, 253] },\n      { value: 0.839, color: [255, 0, 251] },\n      { value: 0.843, color: [255, 0, 245] },\n      { value: 1, color: [255, 0, 6] }\n    ]\n  }),\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.3, color: [230, 0, 0] },\n      { value: 0.6, color: [255, 210, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new T({\n    stops: [\n      { value: 0, color: [255, 0, 255] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new T({\n    stops: [\n      { value: 0, color: [0, 128, 102] },\n      { value: 1, color: [255, 255, 102] }\n    ]\n  }),\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new T({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new T({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [0, 255, 128] }\n    ]\n  }),\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.376, color: [84, 84, 116] },\n      { value: 0.753, color: [169, 200, 200] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.804, color: [255, 160, 102] },\n      { value: 1, color: [255, 199, 127] }\n    ]\n  }),\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new T({\n    stops: [\n      { value: 0, color: [8, 29, 88] },\n      { value: 0.125, color: [37, 52, 148] },\n      { value: 0.25, color: [34, 94, 168] },\n      { value: 0.375, color: [29, 145, 192] },\n      { value: 0.5, color: [65, 182, 196] },\n      { value: 0.625, color: [127, 205, 187] },\n      { value: 0.75, color: [199, 233, 180] },\n      { value: 0.875, color: [237, 248, 217] },\n      { value: 1, color: [255, 255, 217] }\n    ]\n  }),\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new T({\n    stops: [\n      { value: 0, color: [0, 68, 27] },\n      { value: 0.125, color: [0, 109, 44] },\n      { value: 0.25, color: [35, 139, 69] },\n      { value: 0.375, color: [65, 171, 93] },\n      { value: 0.5, color: [116, 196, 118] },\n      { value: 0.625, color: [161, 217, 155] },\n      { value: 0.75, color: [199, 233, 192] },\n      { value: 0.875, color: [229, 245, 224] },\n      { value: 1, color: [247, 252, 245] }\n    ]\n  }),\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new T({\n    stops: [\n      { value: 0, color: [128, 0, 38] },\n      { value: 0.125, color: [189, 0, 38] },\n      { value: 0.25, color: [227, 26, 28] },\n      { value: 0.375, color: [252, 78, 42] },\n      { value: 0.5, color: [253, 141, 60] },\n      { value: 0.625, color: [254, 178, 76] },\n      { value: 0.75, color: [254, 217, 118] },\n      { value: 0.875, color: [255, 237, 160] },\n      { value: 1, color: [255, 255, 204] }\n    ]\n  }),\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new T({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new T({\n    stops: [\n      { value: 0, color: [5, 10, 172] },\n      { value: 0.35, color: [106, 137, 247] },\n      { value: 0.5, color: [190, 190, 190] },\n      { value: 0.6, color: [220, 170, 132] },\n      { value: 0.7, color: [230, 145, 90] },\n      { value: 1, color: [178, 10, 28] }\n    ]\n  }),\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new T({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 0.1, color: [51, 153, 255] },\n      { value: 0.2, color: [102, 204, 255] },\n      { value: 0.3, color: [153, 204, 255] },\n      { value: 0.4, color: [204, 204, 255] },\n      { value: 0.5, color: [255, 255, 255] },\n      { value: 0.6, color: [255, 204, 255] },\n      { value: 0.7, color: [255, 153, 255] },\n      { value: 0.8, color: [255, 102, 204] },\n      { value: 0.9, color: [255, 102, 102] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new T({\n    stops: [\n      { value: 0, color: [150, 0, 90] },\n      { value: 0.125, color: [0, 0, 200] },\n      { value: 0.25, color: [0, 25, 255] },\n      { value: 0.375, color: [0, 152, 255] },\n      { value: 0.5, color: [44, 255, 150] },\n      { value: 0.625, color: [151, 255, 0] },\n      { value: 0.75, color: [255, 234, 0] },\n      { value: 0.875, color: [255, 111, 0] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new T({\n    stops: [\n      { value: 0, color: [12, 51, 131] },\n      { value: 0.25, color: [10, 136, 186] },\n      { value: 0.5, color: [242, 211, 56] },\n      { value: 0.75, color: [242, 143, 56] },\n      { value: 1, color: [217, 30, 30] }\n    ]\n  }),\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.2, color: [230, 0, 0] },\n      { value: 0.4, color: [230, 210, 0] },\n      { value: 0.7, color: [255, 255, 255] },\n      { value: 1, color: [160, 200, 255] }\n    ]\n  }),\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new T({\n    stops: [\n      { value: 0, color: [0, 0, 130] },\n      { value: 0.1, color: [0, 180, 180] },\n      { value: 0.2, color: [40, 210, 40] },\n      { value: 0.4, color: [230, 230, 50] },\n      { value: 0.6, color: [120, 70, 20] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.15, color: [30, 0, 100] },\n      { value: 0.4, color: [120, 0, 100] },\n      { value: 0.6, color: [160, 90, 0] },\n      { value: 0.8, color: [230, 200, 0] },\n      { value: 1, color: [255, 250, 220] }\n    ]\n  }),\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new T({\n    stops: [\n      { value: 0, color: [68, 1, 84] },\n      { value: 0.13, color: [71, 44, 122] },\n      { value: 0.25, color: [59, 81, 139] },\n      { value: 0.38, color: [44, 113, 142] },\n      { value: 0.5, color: [33, 144, 141] },\n      { value: 0.63, color: [39, 173, 129] },\n      { value: 0.75, color: [92, 200, 99] },\n      { value: 0.88, color: [170, 220, 50] },\n      { value: 1, color: [253, 231, 37] }\n    ]\n  }),\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new T({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [31, 12, 72] },\n      { value: 0.25, color: [85, 15, 109] },\n      { value: 0.38, color: [136, 34, 106] },\n      { value: 0.5, color: [186, 54, 85] },\n      { value: 0.63, color: [227, 89, 51] },\n      { value: 0.75, color: [249, 140, 10] },\n      { value: 0.88, color: [249, 201, 50] },\n      { value: 1, color: [252, 255, 164] }\n    ]\n  }),\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new T({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [28, 16, 68] },\n      { value: 0.25, color: [79, 18, 123] },\n      { value: 0.38, color: [129, 37, 129] },\n      { value: 0.5, color: [181, 54, 122] },\n      { value: 0.63, color: [229, 80, 100] },\n      { value: 0.75, color: [251, 135, 97] },\n      { value: 0.88, color: [254, 194, 135] },\n      { value: 1, color: [252, 253, 191] }\n    ]\n  }),\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new T({\n    stops: [\n      { value: 0, color: [13, 8, 135] },\n      { value: 0.13, color: [75, 3, 161] },\n      { value: 0.25, color: [125, 3, 168] },\n      { value: 0.38, color: [168, 34, 150] },\n      { value: 0.5, color: [203, 70, 121] },\n      { value: 0.63, color: [229, 107, 93] },\n      { value: 0.75, color: [248, 148, 65] },\n      { value: 0.88, color: [253, 195, 40] },\n      { value: 1, color: [240, 249, 33] }\n    ]\n  }),\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new T({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [172, 0, 187] },\n      { value: 0.25, color: [219, 0, 170] },\n      { value: 0.38, color: [255, 0, 130] },\n      { value: 0.5, color: [255, 63, 74] },\n      { value: 0.63, color: [255, 123, 0] },\n      { value: 0.75, color: [234, 176, 0] },\n      { value: 0.88, color: [190, 228, 0] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new T({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [116, 0, 218] },\n      { value: 0.25, color: [98, 74, 237] },\n      { value: 0.38, color: [68, 146, 231] },\n      { value: 0.5, color: [0, 204, 197] },\n      { value: 0.63, color: [0, 247, 146] },\n      { value: 0.75, color: [0, 255, 88] },\n      { value: 0.88, color: [40, 255, 8] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new T({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.1, color: [199, 0, 180] },\n      { value: 0.2, color: [255, 0, 121] },\n      { value: 0.3, color: [255, 108, 0] },\n      { value: 0.4, color: [222, 194, 0] },\n      { value: 0.5, color: [150, 255, 0] },\n      { value: 0.6, color: [0, 255, 55] },\n      { value: 0.7, color: [0, 246, 150] },\n      { value: 0.8, color: [50, 167, 222] },\n      { value: 0.9, color: [103, 51, 235] },\n      { value: 1, color: [124, 0, 186] }\n    ]\n  }),\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new T({\n    stops: [\n      { value: 0, color: [40, 26, 44] },\n      { value: 0.13, color: [59, 49, 90] },\n      { value: 0.25, color: [64, 76, 139] },\n      { value: 0.38, color: [63, 110, 151] },\n      { value: 0.5, color: [72, 142, 158] },\n      { value: 0.63, color: [85, 174, 163] },\n      { value: 0.75, color: [120, 206, 163] },\n      { value: 0.88, color: [187, 230, 172] },\n      { value: 1, color: [253, 254, 204] }\n    ]\n  }),\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new T({\n    stops: [\n      { value: 0, color: [47, 15, 62] },\n      { value: 0.13, color: [87, 23, 86] },\n      { value: 0.25, color: [130, 28, 99] },\n      { value: 0.38, color: [171, 41, 96] },\n      { value: 0.5, color: [206, 67, 86] },\n      { value: 0.63, color: [230, 106, 84] },\n      { value: 0.75, color: [242, 149, 103] },\n      { value: 0.88, color: [249, 193, 135] },\n      { value: 1, color: [254, 237, 176] }\n    ]\n  }),\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new T({\n    stops: [\n      { value: 0, color: [18, 36, 20] },\n      { value: 0.13, color: [25, 63, 41] },\n      { value: 0.25, color: [24, 91, 59] },\n      { value: 0.38, color: [13, 119, 72] },\n      { value: 0.5, color: [18, 148, 80] },\n      { value: 0.63, color: [80, 173, 89] },\n      { value: 0.75, color: [132, 196, 122] },\n      { value: 0.88, color: [175, 221, 162] },\n      { value: 1, color: [215, 249, 208] }\n    ]\n  }),\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new T({\n    stops: [\n      { value: 0, color: [54, 14, 36] },\n      { value: 0.13, color: [89, 23, 80] },\n      { value: 0.25, color: [110, 45, 132] },\n      { value: 0.38, color: [120, 77, 178] },\n      { value: 0.5, color: [120, 113, 213] },\n      { value: 0.63, color: [115, 151, 228] },\n      { value: 0.75, color: [134, 185, 227] },\n      { value: 0.88, color: [177, 214, 227] },\n      { value: 1, color: [230, 241, 241] }\n    ]\n  }),\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new T({\n    stops: [\n      { value: 0, color: [30, 4, 110] },\n      { value: 0.13, color: [47, 14, 176] },\n      { value: 0.25, color: [41, 45, 236] },\n      { value: 0.38, color: [25, 99, 212] },\n      { value: 0.5, color: [68, 131, 200] },\n      { value: 0.63, color: [114, 156, 197] },\n      { value: 0.75, color: [157, 181, 203] },\n      { value: 0.88, color: [200, 208, 216] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new T({\n    stops: [\n      { value: 0, color: [60, 9, 18] },\n      { value: 0.13, color: [100, 17, 27] },\n      { value: 0.25, color: [142, 20, 29] },\n      { value: 0.38, color: [177, 43, 27] },\n      { value: 0.5, color: [192, 87, 63] },\n      { value: 0.63, color: [205, 125, 105] },\n      { value: 0.75, color: [216, 162, 148] },\n      { value: 0.88, color: [227, 199, 193] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new T({\n    stops: [\n      { value: 0, color: [64, 5, 5] },\n      { value: 0.13, color: [106, 6, 15] },\n      { value: 0.25, color: [144, 26, 7] },\n      { value: 0.38, color: [168, 64, 3] },\n      { value: 0.5, color: [188, 100, 4] },\n      { value: 0.63, color: [206, 136, 11] },\n      { value: 0.75, color: [220, 174, 25] },\n      { value: 0.88, color: [231, 215, 44] },\n      { value: 1, color: [248, 254, 105] }\n    ]\n  }),\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new T({\n    stops: [\n      { value: 0, color: [51, 20, 24] },\n      { value: 0.13, color: [90, 32, 35] },\n      { value: 0.25, color: [129, 44, 34] },\n      { value: 0.38, color: [159, 68, 25] },\n      { value: 0.5, color: [182, 99, 19] },\n      { value: 0.63, color: [199, 134, 22] },\n      { value: 0.75, color: [212, 171, 35] },\n      { value: 0.88, color: [221, 210, 54] },\n      { value: 1, color: [225, 253, 75] }\n    ]\n  }),\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new T({\n    stops: [\n      { value: 0, color: [145, 105, 18] },\n      { value: 0.13, color: [184, 71, 38] },\n      { value: 0.25, color: [186, 58, 115] },\n      { value: 0.38, color: [160, 71, 185] },\n      { value: 0.5, color: [110, 97, 218] },\n      { value: 0.63, color: [50, 123, 164] },\n      { value: 0.75, color: [31, 131, 110] },\n      { value: 0.88, color: [77, 129, 34] },\n      { value: 1, color: [145, 105, 18] }\n    ]\n  }),\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new T({\n    stops: [\n      { value: 0, color: [42, 24, 108] },\n      { value: 0.13, color: [33, 50, 162] },\n      { value: 0.25, color: [15, 90, 145] },\n      { value: 0.38, color: [40, 118, 137] },\n      { value: 0.5, color: [59, 146, 135] },\n      { value: 0.63, color: [79, 175, 126] },\n      { value: 0.75, color: [120, 203, 104] },\n      { value: 0.88, color: [193, 221, 100] },\n      { value: 1, color: [253, 239, 154] }\n    ]\n  }),\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new T({\n    stops: [\n      { value: 0, color: [4, 35, 51] },\n      { value: 0.13, color: [23, 51, 122] },\n      { value: 0.25, color: [85, 59, 157] },\n      { value: 0.38, color: [129, 79, 143] },\n      { value: 0.5, color: [175, 95, 130] },\n      { value: 0.63, color: [222, 112, 101] },\n      { value: 0.75, color: [249, 146, 66] },\n      { value: 0.88, color: [249, 196, 65] },\n      { value: 1, color: [232, 250, 91] }\n    ]\n  }),\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new T({\n    stops: [\n      { value: 0, color: [34, 31, 27] },\n      { value: 0.13, color: [65, 50, 41] },\n      { value: 0.25, color: [98, 69, 52] },\n      { value: 0.38, color: [131, 89, 57] },\n      { value: 0.5, color: [161, 112, 59] },\n      { value: 0.63, color: [185, 140, 66] },\n      { value: 0.75, color: [202, 174, 88] },\n      { value: 0.88, color: [216, 209, 126] },\n      { value: 1, color: [233, 246, 171] }\n    ]\n  }),\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new T({\n    stops: [\n      { value: 0, color: [17, 32, 64] },\n      { value: 0.13, color: [35, 52, 116] },\n      { value: 0.25, color: [29, 81, 156] },\n      { value: 0.38, color: [31, 113, 162] },\n      { value: 0.5, color: [50, 144, 169] },\n      { value: 0.63, color: [87, 173, 176] },\n      { value: 0.75, color: [149, 196, 189] },\n      { value: 0.88, color: [203, 221, 211] },\n      { value: 1, color: [254, 251, 230] }\n    ]\n  }),\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new T({\n    stops: [\n      { value: 0, color: [23, 35, 19] },\n      { value: 0.13, color: [24, 64, 38] },\n      { value: 0.25, color: [11, 95, 45] },\n      { value: 0.38, color: [39, 123, 35] },\n      { value: 0.5, color: [95, 146, 12] },\n      { value: 0.63, color: [152, 165, 18] },\n      { value: 0.75, color: [201, 186, 69] },\n      { value: 0.88, color: [233, 216, 137] },\n      { value: 1, color: [255, 253, 205] }\n    ]\n  }),\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new T({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.07, color: [22, 5, 59] },\n      { value: 0.13, color: [60, 4, 105] },\n      { value: 0.2, color: [109, 1, 135] },\n      { value: 0.27, color: [161, 0, 147] },\n      { value: 0.33, color: [210, 2, 142] },\n      { value: 0.4, color: [251, 11, 123] },\n      { value: 0.47, color: [255, 29, 97] },\n      { value: 0.53, color: [255, 54, 69] },\n      { value: 0.6, color: [255, 85, 46] },\n      { value: 0.67, color: [255, 120, 34] },\n      { value: 0.73, color: [255, 157, 37] },\n      { value: 0.8, color: [241, 191, 57] },\n      { value: 0.87, color: [224, 220, 93] },\n      { value: 0.93, color: [218, 241, 142] },\n      { value: 1, color: [227, 253, 198] }\n    ]\n  }),\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new T({\n    stops: [\n      { value: 0, color: [0, 32, 77, 255] },\n      { value: 0.125, color: [5, 54, 110, 255] },\n      { value: 0.25, color: [65, 77, 108, 255] },\n      { value: 0.375, color: [97, 100, 111, 255] },\n      { value: 0.5, color: [125, 124, 121, 255] },\n      { value: 0.625, color: [156, 149, 120, 255] },\n      { value: 0.75, color: [190, 175, 111, 255] },\n      { value: 0.875, color: [225, 204, 94, 255] },\n      { value: 1, color: [255, 235, 70, 255] }\n    ]\n  }),\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new T({\n    stops: [\n      { value: 0, color: [48, 18, 59, 255] },\n      { value: 0.125, color: [70, 107, 227, 255] },\n      { value: 0.25, color: [40, 187, 236, 255] },\n      { value: 0.375, color: [49, 242, 153, 255] },\n      { value: 0.5, color: [162, 252, 60, 255] },\n      { value: 0.625, color: [237, 208, 58, 255] },\n      { value: 0.75, color: [251, 128, 34, 255] },\n      { value: 0.875, color: [210, 49, 5, 255] },\n      { value: 1, color: [122, 4, 3, 255] }\n    ]\n  }),\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new T({\n    stops: [\n      { value: 0, color: [250, 235, 221, 0] },\n      { value: 0.133, color: [250, 235, 221, 255] },\n      { value: 0.266, color: [246, 170, 130, 255] },\n      { value: 0.4, color: [240, 96, 67, 255] },\n      { value: 0.533, color: [203, 27, 79, 255] },\n      { value: 0.666, color: [132, 30, 90, 255] },\n      { value: 0.8, color: [63, 27, 68, 255] },\n      { value: 1, color: [3, 5, 26, 255] }\n    ]\n  }),\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new T({\n    stops: [\n      { value: 0, color: [11, 4, 5, 255] },\n      { value: 0.125, color: [43, 28, 53, 255] },\n      { value: 0.25, color: [62, 53, 107, 255] },\n      { value: 0.375, color: [59, 86, 152, 255] },\n      { value: 0.5, color: [53, 123, 162, 255] },\n      { value: 0.625, color: [53, 158, 170, 255] },\n      { value: 0.75, color: [73, 193, 173, 255] },\n      { value: 0.875, color: [150, 221, 181, 255] },\n      { value: 1, color: [222, 245, 229, 255] }\n    ]\n  })\n};\nasync function qc(r, e, t = {}) {\n  var a, o;\n  if (!e.sourceId && !e.data)\n    throw new Error(\"Creating a polyline layer requires an existing .sourceId or a valid .data property\");\n  let n = e.data;\n  if (typeof n == \"string\") {\n    if (ir(n))\n      n = `https://api.maptiler.com/data/${e.data}/features.json?key=${j.apiKey}`;\n    else if (((a = n.split(\".\").pop()) == null ? void 0 : a.toLowerCase().trim()) === \"gpx\") {\n      const s = await (await fetch(n, t)).text();\n      n = ii(s);\n    } else if (((o = n.split(\".\").pop()) == null ? void 0 : o.toLowerCase().trim()) === \"kml\") {\n      const s = await (await fetch(n, t)).text();\n      n = si(s);\n    } else {\n      const i = Vi(n) ?? jc(n);\n      i && (n = i);\n    }\n    if (!n)\n      throw new Error(\"Polyline data was provided as string but is incompatible with valid formats.\");\n  }\n  return Vc(r, {\n    ...e,\n    data: n\n  });\n}\nfunction Vc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = {\n    polylineLayerId: n,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: t\n  };\n  e.data && !r.getSource(t) && r.addSource(t, {\n    type: \"geojson\",\n    data: e.data\n  });\n  const o = e.lineWidth ?? 3, i = e.lineColor ?? kr(), s = e.lineOpacity ?? 1, l = e.lineBlur ?? 0, u = e.lineGapWidth ?? 0;\n  let c = e.lineDashArray ?? null;\n  const p = e.outlineWidth ?? 1, d = e.outlineColor ?? \"#FFFFFF\", f = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0;\n  if (typeof c == \"string\" && (c = Nn(c)), e.outline === !0) {\n    const m = `${n}_outline`;\n    a.polylineOutlineLayerId = m, r.addLayer(\n      {\n        id: m,\n        type: \"line\",\n        source: t,\n        layout: {\n          \"line-join\": e.lineJoin ?? \"round\",\n          \"line-cap\": e.lineCap ?? \"round\"\n        },\n        minzoom: e.minzoom ?? 0,\n        maxzoom: e.maxzoom ?? 23,\n        paint: {\n          \"line-opacity\": typeof f == \"number\" ? f : O(f),\n          \"line-color\": typeof d == \"string\" ? d : je(d),\n          \"line-width\": di(o, p),\n          \"line-blur\": typeof h == \"number\" ? h : O(h)\n        }\n      },\n      e.beforeId\n    );\n  }\n  return r.addLayer(\n    {\n      id: n,\n      type: \"line\",\n      source: t,\n      layout: {\n        \"line-join\": e.lineJoin ?? \"round\",\n        \"line-cap\": e.lineCap ?? \"round\"\n      },\n      minzoom: e.minzoom ?? 0,\n      maxzoom: e.maxzoom ?? 23,\n      paint: {\n        \"line-opacity\": typeof s == \"number\" ? s : O(s),\n        \"line-color\": typeof i == \"string\" ? i : je(i),\n        \"line-width\": typeof o == \"number\" ? o : O(o),\n        \"line-blur\": typeof l == \"number\" ? l : O(l),\n        \"line-gap-width\": typeof u == \"number\" ? u : O(u),\n        // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n        // results in no showing the line while it should have the same behavior\n        // of not adding the property \"line-dasharray\" as all.\n        // As a workaround, we are inlining the addition of the prop with a conditional\n        // which is less readable.\n        ...c && { \"line-dasharray\": c }\n      }\n    },\n    e.beforeId\n  ), a;\n}\nfunction Gc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = {\n    polygonLayerId: n,\n    polygonOutlineLayerId: e.outline ? `${n}_outline` : \"\",\n    polygonSourceId: t\n  };\n  if (e.data && !r.getSource(t)) {\n    let m = e.data;\n    typeof m == \"string\" && ir(m) && (m = `https://api.maptiler.com/data/${m}/features.json?key=${j.apiKey}`), r.addSource(t, {\n      type: \"geojson\",\n      data: m\n    });\n  }\n  let o = e.outlineDashArray ?? null;\n  const i = e.outlineWidth ?? 1, s = e.outlineColor ?? \"#FFFFFF\", l = e.outlineOpacity ?? 1, u = e.outlineBlur ?? 0, c = e.fillColor ?? kr(), p = e.fillOpacity ?? 1, d = e.outlinePosition ?? \"center\", f = e.pattern ?? null;\n  typeof o == \"string\" && (o = Nn(o));\n  const h = (m = null) => {\n    if (r.addLayer(\n      {\n        id: n,\n        type: \"fill\",\n        source: t,\n        minzoom: e.minzoom ?? 0,\n        maxzoom: e.maxzoom ?? 23,\n        paint: {\n          \"fill-color\": typeof c == \"string\" ? c : je(c),\n          \"fill-opacity\": typeof p == \"number\" ? p : O(p),\n          // Adding a pattern if provided\n          ...m && { \"fill-pattern\": m }\n        }\n      },\n      e.beforeId\n    ), e.outline === !0) {\n      let y;\n      d === \"inside\" ? typeof i == \"number\" ? y = 0.5 * i : y = O(\n        i.map(({ zoom: w, value: v }) => ({\n          zoom: w,\n          value: 0.5 * v\n        }))\n      ) : d === \"outside\" ? typeof i == \"number\" ? y = -0.5 * i : y = O(\n        i.map((w) => ({\n          zoom: w.zoom,\n          value: -0.5 * w.value\n        }))\n      ) : y = 0, r.addLayer(\n        {\n          id: a.polygonOutlineLayerId,\n          type: \"line\",\n          source: t,\n          layout: {\n            \"line-join\": e.outlineJoin ?? \"round\",\n            \"line-cap\": e.outlineCap ?? \"butt\"\n          },\n          minzoom: e.minzoom ?? 0,\n          maxzoom: e.maxzoom ?? 23,\n          paint: {\n            \"line-opacity\": typeof l == \"number\" ? l : O(l),\n            \"line-color\": typeof s == \"string\" ? s : je(s),\n            \"line-width\": typeof i == \"number\" ? i : O(i),\n            \"line-blur\": typeof u == \"number\" ? u : O(u),\n            \"line-offset\": y,\n            // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n            // results in no showing the line while it should have the same behavior\n            // of not adding the property \"line-dasharray\" as all.\n            // As a workaround, we are inlining the addition of the prop with a conditional\n            // which is less readable.\n            ...o && {\n              \"line-dasharray\": o\n            }\n          }\n        },\n        e.beforeId\n      );\n    }\n  };\n  return f ? r.hasImage(f) ? h(f) : r.loadImage(f).then((m) => {\n    r.addImage(f, m.data), h(f);\n  }).catch((m) => {\n    console.error(\"Could not load the pattern image.\", m.message), h();\n  }) : h(), a;\n}\nfunction Hc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.minPointRadius ?? 10, n = e.maxPointRadius ?? 50, a = e.cluster ?? !1, o = 20, i = Array.isArray(e.pointColor) ? e.pointColor : gi.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample(\"ease-out-square\"), s = i.getBounds(), l = e.sourceId ?? Pt(), u = e.layerId ?? Rt(), c = e.showLabel ?? a, p = e.alignOnViewport ?? !0, d = e.outline ?? !1, f = e.outlineOpacity ?? 1, h = e.outlineWidth ?? 1, m = e.outlineColor ?? \"#FFFFFF\";\n  let y;\n  const w = e.zoomCompensation ?? !0, v = e.minzoom ?? 0, x = e.maxzoom ?? 23;\n  typeof e.pointOpacity == \"number\" ? y = e.pointOpacity : Array.isArray(e.pointOpacity) ? y = O(e.pointOpacity) : e.cluster ? y = pn(i, \"point_count\") : e.property ? y = pn(i, e.property) : y = O([\n    { zoom: v, value: 0 },\n    { zoom: v + 0.25, value: 1 },\n    { zoom: x - 0.25, value: 1 },\n    { zoom: x, value: 0 }\n  ]);\n  const A = {\n    pointLayerId: u,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: l\n  };\n  if (e.data && !r.getSource(l)) {\n    let E = e.data;\n    typeof E == \"string\" && ir(E) && (E = `https://api.maptiler.com/data/${E}/features.json?key=${j.apiKey}`), r.addSource(l, {\n      type: \"geojson\",\n      data: E,\n      cluster: a\n    });\n  }\n  if (a) {\n    A.clusterLayerId = `${u}_cluster`;\n    const E = Array.from({ length: o }, (C, N) => {\n      const ee = s.min + N * (s.max - s.min) / (o - 1);\n      return {\n        value: ee,\n        pointRadius: t + (n - t) * (N / (o - 1)) ** 0.5,\n        color: i.getColorHex(ee)\n      };\n    });\n    r.addLayer(\n      {\n        id: A.clusterLayerId,\n        type: \"circle\",\n        source: l,\n        filter: [\"has\", \"point_count\"],\n        paint: {\n          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-color\": typeof e.pointColor == \"string\" ? e.pointColor : un(E, \"point_count\"),\n          \"circle-radius\": typeof e.pointRadius == \"number\" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : cn(E, \"point_count\", !1),\n          \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-opacity\": y,\n          ...d && {\n            \"circle-stroke-opacity\": typeof f == \"number\" ? f : O(f),\n            \"circle-stroke-width\": typeof h == \"number\" ? h : O(h),\n            \"circle-stroke-color\": typeof m == \"string\" ? m : je(m)\n          }\n        },\n        minzoom: v,\n        maxzoom: x\n      },\n      e.beforeId\n    ), r.addLayer(\n      {\n        id: A.pointLayerId,\n        type: \"circle\",\n        source: l,\n        filter: [\"!\", [\"has\", \"point_count\"]],\n        paint: {\n          \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n          \"circle-color\": typeof e.pointColor == \"string\" ? e.pointColor : i.getColorHex(i.getBounds().min),\n          \"circle-radius\": typeof e.pointRadius == \"number\" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : E[0].pointRadius * 0.75,\n          \"circle-opacity\": y,\n          ...d && {\n            \"circle-stroke-opacity\": typeof f == \"number\" ? f : O(f),\n            \"circle-stroke-width\": typeof h == \"number\" ? h : O(h),\n            \"circle-stroke-color\": typeof m == \"string\" ? m : je(m)\n          }\n        },\n        minzoom: v,\n        maxzoom: x\n      },\n      e.beforeId\n    );\n  } else {\n    let E = typeof e.pointColor == \"string\" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : kr(), C = typeof e.pointRadius == \"number\" ? w ? O([\n      { zoom: 0, value: e.pointRadius * 0.025 },\n      { zoom: 2, value: e.pointRadius * 0.05 },\n      { zoom: 4, value: e.pointRadius * 0.1 },\n      { zoom: 8, value: e.pointRadius * 0.25 },\n      { zoom: 16, value: e.pointRadius * 1 }\n    ]) : e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : w ? O([\n      { zoom: 0, value: t * 0.05 },\n      { zoom: 2, value: t * 0.1 },\n      { zoom: 4, value: t * 0.2 },\n      { zoom: 8, value: t * 0.5 },\n      { zoom: 16, value: t * 1 }\n    ]) : t;\n    if (e.property && Array.isArray(e.pointColor)) {\n      const N = Array.from({ length: o }, (ee, Le) => {\n        const Ee = s.min + Le * (s.max - s.min) / (o - 1);\n        return {\n          value: Ee,\n          pointRadius: typeof e.pointRadius == \"number\" ? e.pointRadius : t + (n - t) * (Le / (o - 1)) ** 0.5,\n          color: typeof e.pointColor == \"string\" ? e.pointColor : i.getColorHex(Ee)\n        };\n      });\n      E = un(N, e.property), C = cn(N, e.property, w);\n    }\n    r.addLayer(\n      {\n        id: A.pointLayerId,\n        type: \"circle\",\n        source: l,\n        layout: {\n          // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n          \"circle-sort-key\": e.property ? [\"/\", 1, [\"get\", e.property]] : 0\n        },\n        paint: {\n          \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-color\": E,\n          \"circle-opacity\": y,\n          \"circle-radius\": C,\n          ...d && {\n            \"circle-stroke-opacity\": typeof f == \"number\" ? f : O(f),\n            \"circle-stroke-width\": typeof h == \"number\" ? h : O(h),\n            \"circle-stroke-color\": typeof m == \"string\" ? m : je(m)\n          }\n        },\n        minzoom: v,\n        maxzoom: x\n      },\n      e.beforeId\n    );\n  }\n  if (c !== !1 && (e.cluster || e.property)) {\n    A.labelLayerId = `${u}_label`;\n    const E = e.labelColor ?? \"#fff\", C = e.labelSize ?? 12;\n    r.addLayer(\n      {\n        id: A.labelLayerId,\n        type: \"symbol\",\n        source: l,\n        filter: [\"has\", e.cluster ? \"point_count\" : e.property],\n        layout: {\n          \"text-field\": e.cluster ? \"{point_count_abbreviated}\" : `{${e.property}}`,\n          \"text-font\": [\"Noto Sans Regular\"],\n          \"text-size\": C,\n          \"text-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"symbol-sort-key\": [\"/\", 1, [\"get\", e.cluster ? \"point_count\" : e.property]]\n          // so that the largest value goes on top\n        },\n        paint: {\n          \"text-color\": E,\n          \"text-opacity\": y\n        },\n        minzoom: v,\n        maxzoom: x\n      },\n      e.beforeId\n    );\n  }\n  return A;\n}\nfunction Zc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? Pt(), n = e.layerId ?? Rt(), a = e.minzoom ?? 0, o = e.maxzoom ?? 23, i = e.zoomCompensation ?? !0, s = e.opacity ?? [\n    { zoom: a, value: 0 },\n    { zoom: a + 0.25, value: 1 },\n    { zoom: o - 0.25, value: 1 },\n    { zoom: o, value: 0 }\n  ];\n  let l = Array.isArray(e.colorRamp) ? e.colorRamp : gi.TURBO.transparentStart();\n  const u = l.getBounds();\n  (u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());\n  const c = e.intensity ?? [\n    { zoom: 0, value: 0.01 },\n    { zoom: 4, value: 0.2 },\n    { zoom: 16, value: 1 }\n  ], p = e.property ?? null, d = e.weight ?? 1;\n  let f = 1;\n  p ? typeof d == \"number\" ? (f = d, typeof e.weight == \"number\" && console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\")) : Array.isArray(d) ? f = hi(d, p) : console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\") : typeof d == \"number\" ? f = d : Array.isArray(d) && console.warn(\"The options `.propertyValueWeights` can only be used when `.property` is provided.\");\n  const h = [\n    { zoom: 0, value: 50 * 0.025 },\n    { zoom: 2, value: 50 * 0.05 },\n    { zoom: 4, value: 50 * 0.1 },\n    { zoom: 8, value: 50 * 0.25 },\n    { zoom: 16, value: 50 }\n  ], m = e.radius ?? (i ? h : 10);\n  let y = 1;\n  typeof m == \"number\" ? y = m : Array.isArray(m) && \"zoom\" in m[0] ? y = O(m) : p && Array.isArray(m) && \"propertyValue\" in m[0] ? y = mi(m, p, i) : !p && Array.isArray(m) && \"propertyValue\" in m[0] ? (y = O(h), console.warn(\"The option `.radius` can only be property-driven if the option `.property` is provided.\")) : y = O(h);\n  const w = {\n    heatmapLayerId: n,\n    heatmapSourceId: t\n  };\n  if (e.data && !r.getSource(t)) {\n    let v = e.data;\n    typeof v == \"string\" && ir(v) && (v = `https://api.maptiler.com/data/${v}/features.json?key=${j.apiKey}`), r.addSource(t, {\n      type: \"geojson\",\n      data: v\n    });\n  }\n  return r.addLayer(\n    {\n      id: n,\n      type: \"heatmap\",\n      source: t,\n      minzoom: a,\n      maxzoom: o,\n      paint: {\n        \"heatmap-weight\": f,\n        \"heatmap-intensity\": typeof c == \"number\" ? c : O(c),\n        \"heatmap-color\": yi(l),\n        \"heatmap-radius\": y,\n        \"heatmap-opacity\": typeof s == \"number\" ? s : O(s)\n      }\n    },\n    e.beforeId\n  ), w;\n}\nconst Lp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  addHeatmap: Zc,\n  addPoint: Hc,\n  addPolygon: Gc,\n  addPolyline: qc,\n  colorDrivenByProperty: un,\n  colorPalettes: sn,\n  computeRampedOutlineWidth: di,\n  dashArrayMaker: Nn,\n  generateRandomLayerName: Rt,\n  generateRandomSourceName: Pt,\n  getRandomColor: kr,\n  heatmapIntensityFromColorRamp: yi,\n  lerpZoomNumberValues: ln,\n  opacityDrivenByProperty: pn,\n  paintColorOptionsToPaintSpec: je,\n  radiusDrivenByProperty: cn,\n  radiusDrivenByPropertyHeatmap: mi,\n  rampedOptionsToLayerPaintSpec: O,\n  rampedPropertyValueWeight: hi,\n  takeScreenshot: Dc\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Kc() {\n  return \"3.9.0\";\n}\nconst Ep = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map, Cp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker, Ap = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup, Tp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Style, _p = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CanvasSource, Ip = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeoJSONSource, Mp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ImageSource, Pp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterTileSource, Rp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterDEMTileSource, zp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VectorTileSource, Op = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VideoSource, $p = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl, Fp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeolocateControl, Np = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl, jp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LogoControl, Dp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScaleControl, Up = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.FullscreenControl, Bp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TerrainControl, qp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.BoxZoomHandler, Vp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScrollZoomHandler, Gp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CooperativeGesturesHandler, Hp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.KeyboardHandler, Zp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TwoFingersTouchPitchHandler, Kp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapWheelEvent, Xp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapTouchEvent, Yp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapMouseEvent, Wp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.config, Jp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.getVersion, {\n  setRTLTextPlugin: Qp,\n  getRTLTextPluginStatus: ef,\n  LngLat: vi,\n  LngLatBounds: Xc,\n  MercatorCoordinate: fn,\n  Evented: tf,\n  AJAXError: rf,\n  prewarm: nf,\n  clearPrewarmedResources: af,\n  Hash: of,\n  Point: bi,\n  EdgeInsets: sf,\n  DragRotateHandler: lf,\n  DragPanHandler: uf,\n  TwoFingersTouchZoomRotateHandler: cf,\n  DoubleClickZoomHandler: pf,\n  TwoFingersTouchZoomHandler: ff,\n  TwoFingersTouchRotateHandler: df,\n  getWorkerCount: hf,\n  setWorkerCount: mf,\n  getMaxParallelImageRequests: yf,\n  setMaxParallelImageRequests: gf,\n  getWorkerUrl: vf,\n  setWorkerUrl: bf,\n  addSourceType: wf,\n  importScriptInWorkers: Sf,\n  addProtocol: xf,\n  removeProtocol: kf\n} = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\n\n//# sourceMappingURL=maptiler-sdk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL3Nkay9kaXN0L21hcHRpbGVyLXNkay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNBO0FBQzRCO0FBQ2E7QUFDakI7QUFDK1A7QUFDc1c7QUFDN2xCO0FBQ2hDLHVCQUF1QiwrQ0FBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBTztBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0REFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLDBCQUEwQjtBQUMxQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrQkFBa0I7QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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Q0EsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYyxRQUFRLGdCQUFnQixRQUFRLGdCQUFnQixRQUFRLGlCQUFpQixTQUFTLGVBQWUsU0FBUyw4QkFBOEIsU0FBUyxnQkFBZ0IsUUFBUSxlQUFlLFNBQVMsZUFBZSxTQUFTLGtCQUFrQixTQUFTLG1CQUFtQixTQUFTLGlCQUFpQixTQUFTLG9CQUFvQixTQUFTLHFCQUFxQixTQUFTLHVCQUF1QixTQUFTO0FBQ2hhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUUsSUFBSSxJQUFJLHNEQUFzRCxFQUFFO0FBQy9HLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNLFlBQVksTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJLFVBQVUsRUFBRSxVQUFVLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRSw0Q0FBNEMsVUFBVTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLDRDQUE0QyxVQUFVO0FBQzdGO0FBQ0EsZ0RBQWdELFVBQVUsU0FBUyxVQUFVO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFLDJEQUEyRCxPQUFPLElBQUksT0FBTztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxvQkFBb0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkVBQTJFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQSxnS0FBZ0ssV0FBVztBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxTQUFTO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUUsZUFBZSxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0NBQWdDLG9CQUFvQixTQUFTLFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLEdBQUcsRUFBRTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLE9BQU87QUFDekc7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFlBQVksNkJBQTZCO0FBQ3pDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsOEJBQThCO0FBQ3pDLGVBQWUsa0NBQWtDO0FBQ2pELGNBQWMsaUNBQWlDO0FBQy9DLGVBQWUsa0NBQWtDO0FBQ2pELFdBQVcsc0NBQXNDO0FBQ2pELGFBQWEsNENBQTRDO0FBQ3pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyx3RkFBd0YsVUFBVSwyQ0FBMkMsVUFBVTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCw2Q0FBNkMsRUFBRSxVQUFVLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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QTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLHdDQUFDO0FBb0pIO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBwbGllci1kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL3Nkay9kaXN0L21hcHRpbGVyLXNkay5tanM/MDdiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU2kgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgSG4gPSAocikgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3Iocik7XG59O1xudmFyIHhpID0gKHIsIGUsIHQpID0+IGUgaW4gciA/IFNpKHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdDtcbnZhciBnID0gKHIsIGUsIHQpID0+IHhpKHIsIHR5cGVvZiBlICE9IFwic3ltYm9sXCIgPyBlICsgXCJcIiA6IGUsIHQpLCBMciA9IChyLCBlLCB0KSA9PiBlLmhhcyhyKSB8fCBIbihcIkNhbm5vdCBcIiArIHQpO1xudmFyIGsgPSAociwgZSwgdCkgPT4gKExyKHIsIGUsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIHQgPyB0LmNhbGwocikgOiBlLmdldChyKSksIFogPSAociwgZSwgdCkgPT4gZS5oYXMocikgPyBIbihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBlIGluc3RhbmNlb2YgV2Vha1NldCA/IGUuYWRkKHIpIDogZS5zZXQociwgdCksIEsgPSAociwgZSwgdCwgbikgPT4gKExyKHIsIGUsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgbiA/IG4uY2FsbChyLCB0KSA6IGUuc2V0KHIsIHQpLCB0KSwgWCA9IChyLCBlLCB0KSA9PiAoTHIociwgZSwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIHQpO1xuaW1wb3J0IEwgZnJvbSBcIm1hcGxpYnJlLWdsXCI7XG5pbXBvcnQgeyBCYXNlNjQgYXMga2kgfSBmcm9tIFwianMtYmFzZTY0XCI7XG5pbXBvcnQgTGkgZnJvbSBcImV2ZW50c1wiO1xuaW1wb3J0IHsgTGFuZ3VhZ2UgYXMgRWksIGdldExhbmd1YWdlSW5mb0Zyb21Db2RlIGFzIFpuLCBjb25maWcgYXMgRXIsIE1hcFN0eWxlIGFzIGh0LCBtYXBTdHlsZVByZXNldExpc3QgYXMgQ3IsIGV4cGFuZE1hcFN0eWxlIGFzIENpLCBNYXBTdHlsZVZhcmlhbnQgYXMgQWksIFJlZmVyZW5jZU1hcFN0eWxlIGFzIFRpLCB0b0xhbmd1YWdlSW5mbyBhcyBLbiwgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUZsYWcgYXMgX2ksIGdlb2xvY2F0aW9uIGFzIFhuIH0gZnJvbSBcIkBtYXB0aWxlci9jbGllbnRcIjtcbmltcG9ydCB7IE1hcFN0eWxlIGFzIENmLCBNYXBTdHlsZVZhcmlhbnQgYXMgQWYsIFJlZmVyZW5jZU1hcFN0eWxlIGFzIFRmLCBTZXJ2aWNlRXJyb3IgYXMgX2YsIGFyZVNhbWVMYW5ndWFnZXMgYXMgSWYsIGJ1ZmZlclRvUGl4ZWxEYXRhQnJvd3NlciBhcyBNZiwgY2FuUGFyc2VQaXhlbERhdGEgYXMgUGYsIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlIGFzIFJmLCBjb29yZGluYXRlcyBhcyB6ZiwgZGF0YSBhcyBPZiwgZWxldmF0aW9uIGFzICRmLCBleHBhbmRNYXBTdHlsZSBhcyBGZiwgZ2VvY29kaW5nIGFzIE5mLCBnZW9sb2NhdGlvbiBhcyBqZiwgZ2V0QXV0b0xhbmd1YWdlIGFzIERmLCBnZXRCdWZmZXJUb1BpeGVsRGF0YVBhcnNlciBhcyBVZiwgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUNvZGUgYXMgQmYsIGdldExhbmd1YWdlSW5mb0Zyb21GbGFnIGFzIHFmLCBnZXRMYW5ndWFnZUluZm9Gcm9tS2V5IGFzIFZmLCBnZXRUaWxlQ2FjaGUgYXMgR2YsIGlzTGFuZ3VhZ2VJbmZvIGFzIEhmLCBtYXBTdHlsZVByZXNldExpc3QgYXMgWmYsIG1hdGggYXMgS2YsIG1pc2MgYXMgWGYsIHN0YXRpY01hcHMgYXMgWWYsIHN0eWxlVG9TdHlsZSBhcyBXZiwgdG9MYW5ndWFnZUluZm8gYXMgSmYgfSBmcm9tIFwiQG1hcHRpbGVyL2NsaWVudFwiO1xuaW1wb3J0IHsgdjQgYXMgSWkgfSBmcm9tIFwidXVpZFwiO1xubGV0IE1pID0gY2xhc3MgZXh0ZW5kcyBMLk1hcmtlciB7XG4gIGFkZFRvKGUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkVG8oZSk7XG4gIH1cbn07XG5jbGFzcyBucCBleHRlbmRzIEwuUG9wdXAge1xuICBhZGRUbyhlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmFkZFRvKGUpO1xuICB9XG59XG5jbGFzcyBhcCBleHRlbmRzIEwuU3R5bGUge1xuICBjb25zdHJ1Y3RvcihlLCB0ID0ge30pIHtcbiAgICBzdXBlcihlLCB0KTtcbiAgfVxufVxuY2xhc3Mgb3AgZXh0ZW5kcyBMLkNhbnZhc1NvdXJjZSB7XG4gIG9uQWRkKGUpIHtcbiAgICBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgaXAgZXh0ZW5kcyBMLkdlb0pTT05Tb3VyY2Uge1xuICBvbkFkZChlKSB7XG4gICAgc3VwZXIub25BZGQoZSk7XG4gIH1cbn1cbmNsYXNzIHNwIGV4dGVuZHMgTC5JbWFnZVNvdXJjZSB7XG4gIG9uQWRkKGUpIHtcbiAgICBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgbHAgZXh0ZW5kcyBMLlJhc3RlclRpbGVTb3VyY2Uge1xuICBvbkFkZChlKSB7XG4gICAgc3VwZXIub25BZGQoZSk7XG4gIH1cbn1cbmNsYXNzIHVwIGV4dGVuZHMgTC5SYXN0ZXJERU1UaWxlU291cmNlIHtcbiAgb25BZGQoZSkge1xuICAgIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBjcCBleHRlbmRzIEwuVmVjdG9yVGlsZVNvdXJjZSB7XG4gIG9uQWRkKGUpIHtcbiAgICBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgcHAgZXh0ZW5kcyBMLlZpZGVvU291cmNlIHtcbiAgb25BZGQoZSkge1xuICAgIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBXYSBleHRlbmRzIEwuTmF2aWdhdGlvbkNvbnRyb2wge1xuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBQaSBleHRlbmRzIEwuR2VvbG9jYXRlQ29udHJvbCB7XG4gIG9uQWRkKGUpIHtcbiAgICByZXR1cm4gc3VwZXIub25BZGQoZSk7XG4gIH1cbn1cbmNsYXNzIGZwIGV4dGVuZHMgTC5BdHRyaWJ1dGlvbkNvbnRyb2wge1xuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBSaSBleHRlbmRzIEwuTG9nb0NvbnRyb2wge1xuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyB6aSBleHRlbmRzIEwuU2NhbGVDb250cm9sIHtcbiAgb25BZGQoZSkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgT2kgZXh0ZW5kcyBMLkZ1bGxzY3JlZW5Db250cm9sIHtcbiAgb25BZGQoZSkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgZHAgZXh0ZW5kcyBMLlRlcnJhaW5Db250cm9sIHtcbiAgb25BZGQoZSkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgaHAgZXh0ZW5kcyBMLkJveFpvb21IYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpO1xuICB9XG59XG5jbGFzcyBtcCBleHRlbmRzIEwuU2Nyb2xsWm9vbUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCk7XG4gIH1cbn1cbmNsYXNzIHlwIGV4dGVuZHMgTC5Db29wZXJhdGl2ZUdlc3R1cmVzSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KTtcbiAgfVxufVxuY2xhc3MgZ3AgZXh0ZW5kcyBMLktleWJvYXJkSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgfVxufVxuY2xhc3MgdnAgZXh0ZW5kcyBMLlR3b0ZpbmdlcnNUb3VjaFBpdGNoSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgfVxufVxuY2xhc3MgYnAgZXh0ZW5kcyBMLk1hcFdoZWVsRXZlbnQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgc3VwZXIoZSwgdCwgbik7XG4gIH1cbn1cbmNsYXNzIHdwIGV4dGVuZHMgTC5NYXBUb3VjaEV2ZW50IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHN1cGVyKGUsIHQsIG4pO1xuICB9XG59XG5jbGFzcyBTcCBleHRlbmRzIEwuTWFwTW91c2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEgPSB7fSkge1xuICAgIHN1cGVyKGUsIHQsIG4sIGEpO1xuICB9XG59XG5jb25zdCB6ID0ge1xuICAvKipcbiAgICogTGFuZ3VhZ2UgbW9kZSB0byBkaXNwbGF5IGxhYmVscyBpbiBib3RoIHRoZSBsb2NhbCBsYW5ndWFnZSBhbmQgdGhlIGxhbmd1YWdlIG9mIHRoZSB2aXNpdG9yJ3MgZGV2aWNlLCBjb25jYXRlbmF0ZWQuXG4gICAqIE5vdGUgdGhhdCBpZiB0aG9zZSB0d28gbGFuZ3VhZ2VzIGFyZSB0aGUgc2FtZSwgbGFiZWxzIHdvbid0IGJlIGR1cGxpY2F0ZWQuXG4gICAqL1xuICBWSVNJVE9SOiB7XG4gICAgY29kZTogbnVsbCxcbiAgICBmbGFnOiBcInZpc2l0b3JcIixcbiAgICBuYW1lOiBcIlZpc2l0b3JcIixcbiAgICBsYXRpbjogITAsXG4gICAgaXNNb2RlOiAhMCxcbiAgICBnZW9jb2Rpbmc6ICExXG4gIH0sXG4gIC8qKlxuICAgKiBMYW5ndWFnZSBtb2RlIHRvIGRpc3BsYXkgbGFiZWxzIGluIGJvdGggdGhlIGxvY2FsIGxhbmd1YWdlIGFuZCBFbmdsaXNoLCBjb25jYXRlbmF0ZWQuXG4gICAqIE5vdGUgdGhhdCBpZiB0aG9zZSB0d28gbGFuZ3VhZ2VzIGFyZSB0aGUgc2FtZSwgbGFiZWxzIHdvbid0IGJlIGR1cGxpY2F0ZWQuXG4gICAqL1xuICBWSVNJVE9SX0VOR0xJU0g6IHtcbiAgICBjb2RlOiBudWxsLFxuICAgIGZsYWc6IFwidmlzaXRvcl9lblwiLFxuICAgIG5hbWU6IFwiVmlzaXRvciBFbmdsaXNoXCIsXG4gICAgbGF0aW46ICEwLFxuICAgIGlzTW9kZTogITAsXG4gICAgZ2VvY29kaW5nOiAhMVxuICB9LFxuICAvKipcbiAgICogTGFuZ3VhZ2UgbW9kZSB0byBkaXNwbGF5IGxhYmVscyBpbiBhIGxhbmd1YWdlIGVuZm9yY2VkIGluIHRoZSBzdHlsZS5cbiAgICovXG4gIFNUWUxFOiB7XG4gICAgY29kZTogbnVsbCxcbiAgICBmbGFnOiBcInN0eWxlXCIsXG4gICAgbmFtZTogXCJTdHlsZVwiLFxuICAgIGxhdGluOiAhMSxcbiAgICBpc01vZGU6ICEwLFxuICAgIGdlb2NvZGluZzogITFcbiAgfSxcbiAgLyoqXG4gICAqIExhbmd1YWdlIG1vZGUgdG8gZGlzcGxheSBsYWJlbHMgaW4gYSBsYW5ndWFnZSBlbmZvcmNlZCBpbiB0aGUgc3R5bGUuIFRoZSBsYW5ndWFnZSBjYW5ub3QgYmUgZnVydGhlciBtb2RpZmllZC5cbiAgICovXG4gIFNUWUxFX0xPQ0s6IHtcbiAgICBjb2RlOiBudWxsLFxuICAgIGZsYWc6IFwic3R5bGVfbG9ja1wiLFxuICAgIG5hbWU6IFwiU3R5bGUgTG9ja1wiLFxuICAgIGxhdGluOiAhMSxcbiAgICBpc01vZGU6ICEwLFxuICAgIGdlb2NvZGluZzogITFcbiAgfSxcbiAgLi4uRWlcbn07XG5mdW5jdGlvbiBZbigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPiBcInVcIikge1xuICAgIGNvbnN0IGUgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnNwbGl0KFwiLVwiKVswXSwgdCA9IFpuKGUpO1xuICAgIHJldHVybiB0IHx8IHouRU5HTElTSDtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG5hdmlnYXRvci5sYW5ndWFnZXMubWFwKChlKSA9PiBlLnNwbGl0KFwiLVwiKVswXSkpKS5tYXAoKGUpID0+IFpuKGUpKS5maWx0ZXIoKGUpID0+IGUpWzBdID8/IHouTE9DQUw7XG59XG5jb25zdCBKID0ge1xuICBtYXB0aWxlckxvZ29VUkw6IFwiaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL3Jlc291cmNlcy9sb2dvLnN2Z1wiLFxuICBtYXB0aWxlclVSTDogXCJodHRwczovL3d3dy5tYXB0aWxlci5jb20vXCIsXG4gIG1hcHRpbGVyQXBpSG9zdDogXCJhcGkubWFwdGlsZXIuY29tXCIsXG4gIHRlbGVtZXRyeVVSTDogXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vbWV0cmljc1wiLFxuICBydGxQbHVnaW5VUkw6IFwiaHR0cHM6Ly9jZG4ubWFwdGlsZXIuY29tL21hcGJveC1nbC1ydGwtdGV4dC92MC4yLjMvbWFwYm94LWdsLXJ0bC10ZXh0Lm1pbi5qc1wiLFxuICBwcmltYXJ5TGFuZ3VhZ2U6IHouU1RZTEUsXG4gIHNlY29uZGFyeUxhbmd1YWdlOiB6LkxPQ0FMLFxuICB0ZXJyYWluU291cmNlVVJMOiBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS90aWxlcy90ZXJyYWluLXJnYi12Mi90aWxlcy5qc29uXCIsXG4gIHRlcnJhaW5Tb3VyY2VJZDogXCJtYXB0aWxlci10ZXJyYWluXCJcbn07XG5PYmplY3QuZnJlZXplKEopO1xuY29uc3QgZG4gPSBJaSgpO1xuY2xhc3MgJGkgZXh0ZW5kcyBMaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbGFuZ3VhZ2UuIEJ5IGRlZmF1bHQsIHRoZSBsYW5ndWFnZSBvZiB0aGUgd2ViIGJyb3dzZXIgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnKHRoaXMsIFwicHJpbWFyeUxhbmd1YWdlXCIsIEoucHJpbWFyeUxhbmd1YWdlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kYXJ5IGxhbmd1YWdlLCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgZGVmaW5lZCBpbiB0aGUgbWFwIHN0eWxlLlxuICAgICAqIFRoaXMgc2V0dGluZ3MgaXMgaGlnaGx5IGRlcGVuZGFudCBvbiB0aGUgc3R5bGUgY29tcGF0aWJpbGl0eSBhbmQgbWF5IG5vdCB3b3JrIGluIG1vc3QgY2FzZXMuXG4gICAgICovXG4gICAgZyh0aGlzLCBcInNlY29uZGFyeUxhbmd1YWdlXCIpO1xuICAgIC8qKlxuICAgICAqIFNldHRpbmcgb24gd2hldGhlciBvZiBub3QgdGhlIFNESyBydW5zIHdpdGggYSBzZXNzaW9uIGxvZ2ljLlxuICAgICAqIEEgXCJzZXNzaW9uXCIgaXMgc3RhcnRlZCBhdCB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIFNESyBhbmQgZmluaXNoZWQgd2hlbiB0aGUgYnJvd3NlclxuICAgICAqIHBhZ2UgaXMgYmVpbmcgcmVmcmVzaGVkLlxuICAgICAqIFdoZW4gYHNlc3Npb25gIGlzIGVuYWJsZWQgKGRlZmF1bHQ6IHRydWUpLCB0aGUgZXh0cmEgVVJMIHBhcmFtIGBtdHNpZGAgaXMgYWRkZWQgdG8gcXVlcmllc1xuICAgICAqIG9uIHRoZSBNYXBUaWxlciBDbG91ZCBBUEkuIFRoaXMgYWxsb3dzIE1hcFRpbGVyIHRvIGVuYWJsZSBcInNlc3Npb24gYmFzZWQgYmlsbGluZ1wiLlxuICAgICAqL1xuICAgIGcodGhpcywgXCJzZXNzaW9uXCIsICEwKTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGNsaWVudC1zaWRlIGNhY2hpbmcgb2YgcmVxdWVzdHMgZm9yIHRpbGVzIGFuZCBmb250cy5cbiAgICAgKiBUaGUgY2FjaGVkIHJlcXVlc3RzIHBlcnNpc3QgbXVsdGlwbGUgYnJvd3NlciBzZXNzaW9ucyBhbmQgd2lsbCBiZSByZXVzZWQgd2hlbiBwb3NzaWJsZS5cbiAgICAgKiBXb3JrcyBvbmx5IGZvciByZXF1ZXN0cyB0byB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJIHdoZW4gc2Vzc2lvbnMgYXJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgZyh0aGlzLCBcImNhY2hpbmdcIiwgITApO1xuICAgIC8qKlxuICAgICAqIFRlbGVtZXRyeSBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgYnV0IGNhbiBiZSBvcHRlZC1vdXQgYnkgc2V0dGluZyB0aGlzIHZhbHVlIHRvIGBmYWxzZWAuXG4gICAgICogVGhlIHRlbGVtZXRyeSBpcyB2ZXJ5IHZhbHVhYmxlIHRvIHRoZSB0ZWFtIGF0IE1hcFRpbGVyIGJlY2F1c2UgaXQgc2hhcmVzIGluZm9ybWF0aW9uXG4gICAgICogYWJvdXQgd2hlcmUgdG8gYWRkIHRoZSBleHRyYSBlZmZvcnQuIEl0IGFsc28gaGVscHMgc3BvdHRpbmcgc29tZSBpbmNvbXBhdGliaWxpdHkgaXNzdWVzXG4gICAgICogdGhhdCBtYXkgYXJpc2UgYmV0d2VlbiB0aGUgU0RLIGFuZCBhIHNwZWNpZmljIHZlcnNpb24gb2YgYSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBJdCBjb25zaXN0cyBpbiBzZW5kaW5nIG1ldHJpY3MgYWJvdXQgdXNhZ2Ugb2YgdGhlIGZvbGxvd2luZyBmZWF0dXJlczpcbiAgICAgKiAtIFNESyB2ZXJzaW9uIFtzdHJpbmddXG4gICAgICogLSBBUEkga2V5IFtzdHJpbmddXG4gICAgICogLSBNYXBUaWxlciBzZXNpb24gSUQgKGlmIG9wdGVkLWluKSBbc3RyaW5nXVxuICAgICAqIC0gaWYgdGlsZSBjYWNoaW5nIGlzIGVuYWJsZWQgW2Jvb2xlYW5dXG4gICAgICogLSBpZiBsYW5ndWFnZSBzcGVjaWZpZWQgYXQgaW5pdGlhbGl6YXRpb24gW2Jvb2xlYW5dXG4gICAgICogLSBpZiB0ZXJyYWluIGlzIGFjdGl2YXRlZCBhdCBpbml0aWFsaXphdGlvbiBbYm9vbGVhbl1cbiAgICAgKiAtIGlmIGdsb2JlIHByb2plY3Rpb24gaXMgYWN0aXZhdGVkIGF0IGluaXRpYWxpemF0aW9uIFtib29sZWFuXVxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24sIGVhY2ggb2ZmaWNpYWwgbW9kdWxlIHdpbGwgYmUgYWRkZWQgdG8gYSBsaXN0LCBhbG9uZ3NpZGUgaXRzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIGcodGhpcywgXCJ0ZWxlbWV0cnlcIiwgITApO1xuICAgIC8qKlxuICAgICAqIFVuaXQgdG8gYmUgdXNlZFxuICAgICAqL1xuICAgIGcodGhpcywgXCJfdW5pdFwiLCBcIm1ldHJpY1wiKTtcbiAgICAvKipcbiAgICAgKiBNYXBUaWxlciBDbG91ZCBBUEkga2V5XG4gICAgICovXG4gICAgZyh0aGlzLCBcIl9hcGlLZXlcIiwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdW5pdCBzeXN0ZW1cbiAgICovXG4gIHNldCB1bml0KHQpIHtcbiAgICB0aGlzLl91bml0ID0gdCwgdGhpcy5lbWl0KFwidW5pdFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB1bml0IHN5c3RlbVxuICAgKi9cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJIGtleVxuICAgKi9cbiAgc2V0IGFwaUtleSh0KSB7XG4gICAgdGhpcy5fYXBpS2V5ID0gdCwgRXIuYXBpS2V5ID0gdCwgdGhpcy5lbWl0KFwiYXBpS2V5XCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIENsb3VkIEFQSSBrZXlcbiAgICovXG4gIGdldCBhcGlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwaUtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgdGhlIGN1c3RvbSBmZXRjaCBmdW5jdGlvbiB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG9uZVxuICAgKi9cbiAgc2V0IGZldGNoKHQpIHtcbiAgICBFci5mZXRjaCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmV0Y2ggZnVjbnRpb25cbiAgICovXG4gIGdldCBmZXRjaCgpIHtcbiAgICByZXR1cm4gRXIuZmV0Y2g7XG4gIH1cbn1cbmNvbnN0IGogPSBuZXcgJGkoKTtcbmNsYXNzIFduIGV4dGVuZHMgUmkge1xuICBjb25zdHJ1Y3Rvcih0ID0ge30pIHtcbiAgICBzdXBlcih0KTtcbiAgICBnKHRoaXMsIFwibG9nb1VSTFwiLCBcIlwiKTtcbiAgICBnKHRoaXMsIFwibGlua1VSTFwiLCBcIlwiKTtcbiAgICB0aGlzLmxvZ29VUkwgPSB0LmxvZ29VUkwgPz8gSi5tYXB0aWxlckxvZ29VUkwsIHRoaXMubGlua1VSTCA9IHQubGlua1VSTCA/PyBKLm1hcHRpbGVyVVJMO1xuICB9XG4gIG9uQWRkKHQpIHtcbiAgICB0aGlzLl9tYXAgPSB0LCB0aGlzLl9jb21wYWN0ID0gdGhpcy5vcHRpb25zLmNvbXBhY3QgPz8gITEsIHRoaXMuX2NvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLl9jb250YWluZXIuY2xhc3NOYW1lID0gXCJtYXBsaWJyZWdsLWN0cmxcIjtcbiAgICBjb25zdCBuID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIHJldHVybiBuLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcIm5vLXJlcGVhdFwiLCBuLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiLCBuLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIG4uc3R5bGUuaGVpZ2h0ID0gXCIyM3B4XCIsIG4uc3R5bGUubWFyZ2luID0gXCIwIDAgLTRweCAtNHB4XCIsIG4uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCBuLnN0eWxlLndpZHRoID0gXCI4OHB4XCIsIG4uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke3RoaXMubG9nb1VSTH0pYCwgbi5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IFwiMTAwcHggMzBweFwiLCBuLnN0eWxlLndpZHRoID0gXCIxMDBweFwiLCBuLnN0eWxlLmhlaWdodCA9IFwiMzBweFwiLCBuLnRhcmdldCA9IFwiX2JsYW5rXCIsIG4ucmVsID0gXCJub29wZW5lclwiLCBuLmhyZWYgPSB0aGlzLmxpbmtVUkwsIG4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk1hcFRpbGVyIGxvZ29cIiksIG4uc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXJcIiksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChuKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMuX21hcC5vbihcInJlc2l6ZVwiLCB0aGlzLl91cGRhdGVDb21wYWN0KSwgdGhpcy5fdXBkYXRlQ29tcGFjdCgpLCB0aGlzLl9jb250YWluZXI7XG4gIH1cbn1cbmNvbnN0IFZyID0gXCJsb2NhbGNhY2hlX3NvdXJjZVwiLCBHciA9IFwibG9jYWxjYWNoZVwiLCBGaSA9IFwibWFwdGlsZXJfc2RrXCIsIE5pID0gMWUzLCBqaSA9IDEwMCwgSHIgPSB0eXBlb2YgY2FjaGVzIDwgXCJ1XCIsIHsgYWRkUHJvdG9jb2w6IEpuIH0gPSBMO1xuZnVuY3Rpb24gRGkociwgZSkge1xuICBpZiAoSHIgJiYgai5jYWNoaW5nICYmIGouc2Vzc2lvbiAmJiByLmhvc3QgPT09IEoubWFwdGlsZXJBcGlIb3N0KSB7XG4gICAgaWYgKGUgPT09IFwiU291cmNlXCIgJiYgci5ocmVmLmluY2x1ZGVzKFwidGlsZXMuanNvblwiKSlcbiAgICAgIHJldHVybiByLmhyZWYucmVwbGFjZShcImh0dHBzOi8vXCIsIGAke1ZyfTovL2ApO1xuICAgIGlmIChlID09PSBcIlRpbGVcIiB8fCBlID09PSBcIkdseXBoc1wiKVxuICAgICAgcmV0dXJuIHIuaHJlZi5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgYCR7R3J9Oi8vYCk7XG4gIH1cbiAgcmV0dXJuIHIuaHJlZjtcbn1cbmxldCBBcjtcbmFzeW5jIGZ1bmN0aW9uIEphKCkge1xuICByZXR1cm4gQXIgfHwgKEFyID0gYXdhaXQgY2FjaGVzLm9wZW4oRmkpKSwgQXI7XG59XG5sZXQgUW4gPSAwO1xuYXN5bmMgZnVuY3Rpb24gVWkoKSB7XG4gIGNvbnN0IHIgPSBhd2FpdCBKYSgpLCBlID0gYXdhaXQgci5rZXlzKCksIHQgPSBlLnNsaWNlKDAsIE1hdGgubWF4KGUubGVuZ3RoIC0gTmksIDApKTtcbiAgZm9yIChjb25zdCBuIG9mIHQpXG4gICAgci5kZWxldGUobik7XG59XG5mdW5jdGlvbiBCaSgpIHtcbiAgSm4oXG4gICAgVnIsXG4gICAgYXN5bmMgKHIsIGUpID0+IHtcbiAgICAgIGlmICghci51cmwpIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgIHIudXJsID0gci51cmwucmVwbGFjZShgJHtWcn06Ly9gLCBcImh0dHBzOi8vXCIpO1xuICAgICAgY29uc3QgdCA9IHI7XG4gICAgICB0LnNpZ25hbCA9IGUuc2lnbmFsO1xuICAgICAgY29uc3QgbiA9IGF3YWl0IGZldGNoKHIudXJsLCB0KSwgYSA9IGF3YWl0IG4uanNvbigpO1xuICAgICAgcmV0dXJuIGEudGlsZXMgJiYgYS50aWxlcy5sZW5ndGggPiAwICYmIChhLnRpbGVzWzBdICs9IGAmbGFzdC1tb2RpZmllZD0ke24uaGVhZGVycy5nZXQoXCJMYXN0LU1vZGlmaWVkXCIpfWApLCB7XG4gICAgICAgIGRhdGE6IGEsXG4gICAgICAgIGNhY2hlQ29udHJvbDogbi5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIiksXG4gICAgICAgIGV4cGlyZXM6IG4uaGVhZGVycy5nZXQoXCJFeHBpcmVzXCIpXG4gICAgICB9O1xuICAgIH1cbiAgKSwgSm4oR3IsIGFzeW5jIChyLCBlKSA9PiB7XG4gICAgaWYgKCFyLnVybCkgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgIHIudXJsID0gci51cmwucmVwbGFjZShgJHtHcn06Ly9gLCBcImh0dHBzOi8vXCIpO1xuICAgIGNvbnN0IHQgPSBuZXcgVVJMKHIudXJsKSwgbiA9IG5ldyBVUkwodCk7XG4gICAgbi5zZWFyY2hQYXJhbXMuZGVsZXRlKFwibXRzaWRcIiksIG4uc2VhcmNoUGFyYW1zLmRlbGV0ZShcImtleVwiKTtcbiAgICBjb25zdCBhID0gbi50b1N0cmluZygpLCBvID0gbmV3IFVSTCh0KTtcbiAgICBvLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJsYXN0LW1vZGlmaWVkXCIpO1xuICAgIGNvbnN0IGkgPSBvLnRvU3RyaW5nKCksIHMgPSBhc3luYyAoZCkgPT4gKHtcbiAgICAgIGRhdGE6IGF3YWl0IGQuYXJyYXlCdWZmZXIoKSxcbiAgICAgIGNhY2hlQ29udHJvbDogZC5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIiksXG4gICAgICBleHBpcmVzOiBkLmhlYWRlcnMuZ2V0KFwiRXhwaXJlc1wiKVxuICAgIH0pLCBsID0gYXdhaXQgSmEoKSwgdSA9IGF3YWl0IGwubWF0Y2goYSk7XG4gICAgaWYgKHUpXG4gICAgICByZXR1cm4gcyh1KTtcbiAgICBjb25zdCBjID0gcjtcbiAgICBjLnNpZ25hbCA9IGUuc2lnbmFsO1xuICAgIGNvbnN0IHAgPSBhd2FpdCBmZXRjaChpLCBjKTtcbiAgICByZXR1cm4gcC5zdGF0dXMgPj0gMjAwICYmIHAuc3RhdHVzIDwgMzAwICYmIChsLnB1dChhLCBwLmNsb25lKCkpLmNhdGNoKCgpID0+IHtcbiAgICB9KSwgKytRbiA+IGppICYmIChVaSgpLCBRbiA9IDApKSwgcyhwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBxaShyLCBlKSB7XG4gIGZvciAoY29uc3QgdCBvZiByKVxuICAgIHR5cGVvZiBlW3RdID09IFwiZnVuY3Rpb25cIiAmJiAoZVt0XSA9IGVbdF0uYmluZChlKSk7XG59XG5mdW5jdGlvbiBlYShyLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB0ID0gbmV3IFVSTChyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHQuaG9zdCA9PT0gSi5tYXB0aWxlckFwaUhvc3QgJiYgKHQuc2VhcmNoUGFyYW1zLmhhcyhcImtleVwiKSB8fCB0LnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJrZXlcIiwgai5hcGlLZXkpLCBqLnNlc3Npb24gJiYgdC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibXRzaWRcIiwgZG4pKSwge1xuICAgIHVybDogRGkodCwgZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHRhKHIpIHtcbiAgcmV0dXJuIChlLCB0KSA9PiB7XG4gICAgaWYgKHIgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbiA9IHIoZSwgdCksIGEgPSBlYSgobiA9PSBudWxsID8gdm9pZCAwIDogbi51cmwpID8/IFwiXCIsIHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubixcbiAgICAgICAgLi4uYVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGVhKGUsIHQpO1xuICB9O1xufVxuZnVuY3Rpb24gUWEoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG5mdW5jdGlvbiBpcihyKSB7XG4gIHJldHVybiAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvZ2kudGVzdChyKTtcbn1cbmZ1bmN0aW9uIFZpKHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyKTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBHaSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIndlYmdsMlwiKSA/IG51bGwgOiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA8IFwidVwiID8gXCJHcmFwaGljIHJlbmRlcmluZyB3aXRoIFdlYkdMMiBoYXMgYmVlbiBkaXNhYmxlZCBvciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgZ3JhcGhpYyBjYXJkLiBUaGUgbWFwIGNhbm5vdCBiZSBkaXNwbGF5ZWQuXCIgOiBcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGdyYXBoaWMgcmVuZGVyaW5nIHdpdGggV2ViR0wyLiBUaGUgbWFwIGNhbm5vdCBiZSBkaXNwbGF5ZWQuXCI7XG59XG5mdW5jdGlvbiBIaShyKSB7XG4gIGNvbnN0IGUgPSBHaSgpO1xuICBpZiAoIWUpIHJldHVybjtcbiAgbGV0IHQgPSBudWxsO1xuICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKSA6IHIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAodCA9IHIpLCAhdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgTWFwIGNvbnRhaW5lciBtdXN0IGJlIHByb3ZpZGVkLlwiKTtcbiAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHRocm93IG4uaW5uZXJIVE1MID0gZSwgbi5jbGFzc0xpc3QuYWRkKFwid2ViZ2wtd2FybmluZy1kaXZcIiksIHQuYXBwZW5kQ2hpbGQobiksIG5ldyBFcnJvcihlKTtcbn1cbmZ1bmN0aW9uIHhwKHIpIHtcbiAgY29uc3QgZSA9IFwiVGhlIFdlYkdMIGNvbnRleHQgd2FzIGxvc3QuXCIsIHQgPSByLmdldENvbnRhaW5lcigpLCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbi5pbm5lckhUTUwgPSBlLCBuLmNsYXNzTGlzdC5hZGQoXCJ3ZWJnbC13YXJuaW5nLWRpdlwiKSwgdC5hcHBlbmRDaGlsZChuKTtcbn1cbmZ1bmN0aW9uIHJhKHIsIGUpIHtcbiAgcmV0dXJuICEoIUFycmF5LmlzQXJyYXkocikgfHwgci5sZW5ndGggIT09IDIgfHwgclswXSAhPT0gXCJnZXRcIiB8fCB0eXBlb2YgclsxXSAhPSBcInN0cmluZ1wiIHx8IGUgJiYgIXJbMV0uc3RhcnRzV2l0aChcIm5hbWU6XCIpIHx8ICFlICYmIHJbMV0gIT09IFwibmFtZVwiKTtcbn1cbmZ1bmN0aW9uIFppKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHN0cnVjdHVyZWRDbG9uZShyKSwgYSA9IChvKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvICE9IFwic3RyaW5nXCIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHJhKG9baV0sIHQpID8gb1tpXSA9IHN0cnVjdHVyZWRDbG9uZShlKSA6IGEob1tpXSk7XG4gIH07XG4gIHJldHVybiByYShuLCB0KSA/IGUgOiAoYShuKSwgbik7XG59XG5mdW5jdGlvbiBLaShyLCBlKSB7XG4gIGNvbnN0IHQgPSBlID8gL1xce25hbWU6XFxTK1xcfS8gOiAvXFx7bmFtZVxcfS87XG4gIHJldHVybiB7XG4gICAgY29udGFpbnM6IHQudGVzdChyKSxcbiAgICBleGFjdE1hdGNoOiBuZXcgUmVnRXhwKGBeJHt0LnNvdXJjZX0kYCkudGVzdChyKVxuICB9O1xufVxuZnVuY3Rpb24gWGkociwgZSwgdCkge1xuICBjb25zdCBuID0gdCA/IC9cXHtuYW1lOlxcUytcXH0vIDogL1xce25hbWVcXH0vLCBhID0gci5zcGxpdChuKTtcbiAgcmV0dXJuIFtcImNvbmNhdFwiLCAuLi5hLmZsYXRNYXAoKHMsIGwpID0+IGwgPT09IGEubGVuZ3RoIC0gMSA/IFtzXSA6IFtzLCBlXSldO1xufVxuZnVuY3Rpb24gWWkocikge1xuICB2YXIgbjtcbiAgY29uc3QgZSA9IC9cXHtuYW1lKD86Oig/PGxhbmd1YWdlPlxcUyspKT9cXH0vZywgdCA9IFtdO1xuICBmb3IgKDsgOyApIHtcbiAgICBjb25zdCBhID0gZS5leGVjKHIpO1xuICAgIGlmICghYSkgYnJlYWs7XG4gICAgY29uc3QgbyA9ICgobiA9IGEuZ3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogbi5sYW5ndWFnZSkgPz8gbnVsbDtcbiAgICB0LnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBXaShyKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShyKSB8fCByLmxlbmd0aCAhPT0gMiB8fCByWzBdICE9PSBcImdldFwiIHx8IHR5cGVvZiByWzFdICE9IFwic3RyaW5nXCIgPyBudWxsIDogclsxXS50cmltKCkgPT09IFwibmFtZVwiID8ge1xuICAgIGlzTGFuZ3VhZ2U6ICEwLFxuICAgIGxvY2FsaXphdGlvbjogbnVsbFxuICB9IDogclsxXS50cmltKCkuc3RhcnRzV2l0aChcIm5hbWU6XCIpID8ge1xuICAgIGlzTGFuZ3VhZ2U6ICEwLFxuICAgIGxvY2FsaXphdGlvbjogclsxXS50cmltKCkuc3BsaXQoXCI6XCIpLnBvcCgpXG4gIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gSmkocikge1xuICBjb25zdCBlID0gW10sIHQgPSBzdHJ1Y3R1cmVkQ2xvbmUociksIG4gPSAoYSkgPT4ge1xuICAgIGlmICh0eXBlb2YgYSAhPSBcInN0cmluZ1wiKVxuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBhLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgIGNvbnN0IGkgPSBXaShhW29dKTtcbiAgICAgICAgaSA/IGUucHVzaChpLmxvY2FsaXphdGlvbikgOiBuKGFbb10pO1xuICAgICAgfVxuICB9O1xuICByZXR1cm4gbihbdF0pLCBlO1xufVxuZnVuY3Rpb24gUWkociwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIGZvciAoY29uc3QgbyBvZiByKSB7XG4gICAgaWYgKG8udHlwZSAhPT0gXCJzeW1ib2xcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGkgPSBvLCB7IGlkOiBzLCBsYXlvdXQ6IGwgfSA9IGk7XG4gICAgaWYgKCFsIHx8ICEoXCJ0ZXh0LWZpZWxkXCIgaW4gbCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB1ID0gZS5nZXRMYXlvdXRQcm9wZXJ0eShzLCBcInRleHQtZmllbGRcIik7XG4gICAgaWYgKHUpXG4gICAgICBpZiAodHlwZW9mIHUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBjID0gWWkodSk7XG4gICAgICAgIHQucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGMgPSBKaSh1KTtcbiAgICAgICAgdC5wdXNoKGMpO1xuICAgICAgfVxuICB9XG4gIGNvbnN0IG4gPSB0LmZsYXQoKSwgYSA9IHtcbiAgICB1bmxvY2FsaXplZDogMCxcbiAgICBsb2NhbGl6ZWQ6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgbyBvZiBuKVxuICAgIG8gPT09IG51bGwgPyBhLnVubG9jYWxpemVkICs9IDEgOiAobyBpbiBhLmxvY2FsaXplZCB8fCAoYS5sb2NhbGl6ZWRbb10gPSAwKSwgYS5sb2NhbGl6ZWRbb10gKz0gMSk7XG4gIHJldHVybiBhO1xufVxudmFyIGVzID0gOCwgdHMgPSB7XG4gIHZlcnNpb246IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiBbXG4gICAgICA4XG4gICAgXVxuICB9LFxuICBuYW1lOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICBtZXRhZGF0YToge1xuICAgIHR5cGU6IFwiKlwiXG4gIH0sXG4gIGNlbnRlcjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIlxuICB9LFxuICBjZW50ZXJBbHRpdHVkZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgfSxcbiAgem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgfSxcbiAgYmVhcmluZzoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB1bml0czogXCJkZWdyZWVzXCJcbiAgfSxcbiAgcGl0Y2g6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiXG4gIH0sXG4gIHJvbGw6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiXG4gIH0sXG4gIHN0YXRlOiB7XG4gICAgdHlwZTogXCJzdGF0ZVwiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0sXG4gIGxpZ2h0OiB7XG4gICAgdHlwZTogXCJsaWdodFwiXG4gIH0sXG4gIHNreToge1xuICAgIHR5cGU6IFwic2t5XCJcbiAgfSxcbiAgcHJvamVjdGlvbjoge1xuICAgIHR5cGU6IFwicHJvamVjdGlvblwiXG4gIH0sXG4gIHRlcnJhaW46IHtcbiAgICB0eXBlOiBcInRlcnJhaW5cIlxuICB9LFxuICBzb3VyY2VzOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwic291cmNlc1wiXG4gIH0sXG4gIHNwcml0ZToge1xuICAgIHR5cGU6IFwic3ByaXRlXCJcbiAgfSxcbiAgZ2x5cGhzOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICB0cmFuc2l0aW9uOiB7XG4gICAgdHlwZTogXCJ0cmFuc2l0aW9uXCJcbiAgfSxcbiAgbGF5ZXJzOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJsYXllclwiXG4gIH1cbn0sIHJzID0ge1xuICBcIipcIjoge1xuICAgIHR5cGU6IFwic291cmNlXCJcbiAgfVxufSwgbnMgPSBbXG4gIFwic291cmNlX3ZlY3RvclwiLFxuICBcInNvdXJjZV9yYXN0ZXJcIixcbiAgXCJzb3VyY2VfcmFzdGVyX2RlbVwiLFxuICBcInNvdXJjZV9nZW9qc29uXCIsXG4gIFwic291cmNlX3ZpZGVvXCIsXG4gIFwic291cmNlX2ltYWdlXCJcbl0sIGFzID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmVjdG9yOiB7fVxuICAgIH1cbiAgfSxcbiAgdXJsOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICB0aWxlczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICB9LFxuICBib3VuZHM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIC0xODAsXG4gICAgICAtODUuMDUxMTI5LFxuICAgICAgMTgwLFxuICAgICAgODUuMDUxMTI5XG4gICAgXVxuICB9LFxuICBzY2hlbWU6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHh5ejoge30sXG4gICAgICB0bXM6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInh5elwiXG4gIH0sXG4gIG1pbnpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMjJcbiAgfSxcbiAgYXR0cmlidXRpb246IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIHByb21vdGVJZDoge1xuICAgIHR5cGU6IFwicHJvbW90ZUlkXCJcbiAgfSxcbiAgdm9sYXRpbGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LFxuICBcIipcIjoge1xuICAgIHR5cGU6IFwiKlwiXG4gIH1cbn0sIG9zID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgcmFzdGVyOiB7fVxuICAgIH1cbiAgfSxcbiAgdXJsOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICB0aWxlczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICB9LFxuICBib3VuZHM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIC0xODAsXG4gICAgICAtODUuMDUxMTI5LFxuICAgICAgMTgwLFxuICAgICAgODUuMDUxMTI5XG4gICAgXVxuICB9LFxuICBtaW56b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sXG4gIG1heHpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDIyXG4gIH0sXG4gIHRpbGVTaXplOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiA1MTIsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCJcbiAgfSxcbiAgc2NoZW1lOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB4eXo6IHt9LFxuICAgICAgdG1zOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJ4eXpcIlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgdm9sYXRpbGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LFxuICBcIipcIjoge1xuICAgIHR5cGU6IFwiKlwiXG4gIH1cbn0sIGlzID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgXCJyYXN0ZXItZGVtXCI6IHt9XG4gICAgfVxuICB9LFxuICB1cmw6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIHRpbGVzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgZGVmYXVsdDogW1xuICAgICAgLTE4MCxcbiAgICAgIC04NS4wNTExMjksXG4gICAgICAxODAsXG4gICAgICA4NS4wNTExMjlcbiAgICBdXG4gIH0sXG4gIG1pbnpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMjJcbiAgfSxcbiAgdGlsZVNpemU6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDUxMixcbiAgICB1bml0czogXCJwaXhlbHNcIlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgZW5jb2Rpbmc6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHRlcnJhcml1bToge30sXG4gICAgICBtYXBib3g6IHt9LFxuICAgICAgY3VzdG9tOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJtYXBib3hcIlxuICB9LFxuICByZWRGYWN0b3I6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDFcbiAgfSxcbiAgYmx1ZUZhY3Rvcjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMVxuICB9LFxuICBncmVlbkZhY3Rvcjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMVxuICB9LFxuICBiYXNlU2hpZnQ6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSxcbiAgdm9sYXRpbGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LFxuICBcIipcIjoge1xuICAgIHR5cGU6IFwiKlwiXG4gIH1cbn0sIHNzID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgZ2VvanNvbjoge31cbiAgICB9XG4gIH0sXG4gIGRhdGE6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCIqXCJcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMThcbiAgfSxcbiAgYXR0cmlidXRpb246IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIGJ1ZmZlcjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMTI4LFxuICAgIG1heGltdW06IDUxMixcbiAgICBtaW5pbXVtOiAwXG4gIH0sXG4gIGZpbHRlcjoge1xuICAgIHR5cGU6IFwiKlwiXG4gIH0sXG4gIHRvbGVyYW5jZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMC4zNzVcbiAgfSxcbiAgY2x1c3Rlcjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sXG4gIGNsdXN0ZXJSYWRpdXM6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDUwLFxuICAgIG1pbmltdW06IDBcbiAgfSxcbiAgY2x1c3Rlck1heFpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiXG4gIH0sXG4gIGNsdXN0ZXJNaW5Qb2ludHM6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiXG4gIH0sXG4gIGNsdXN0ZXJQcm9wZXJ0aWVzOiB7XG4gICAgdHlwZTogXCIqXCJcbiAgfSxcbiAgbGluZU1ldHJpY3M6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LFxuICBnZW5lcmF0ZUlkOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSxcbiAgcHJvbW90ZUlkOiB7XG4gICAgdHlwZTogXCJwcm9tb3RlSWRcIlxuICB9XG59LCBscyA9IHtcbiAgdHlwZToge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpZGVvOiB7fVxuICAgIH1cbiAgfSxcbiAgdXJsczoge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCJcbiAgfSxcbiAgY29vcmRpbmF0ZXM6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGxlbmd0aDogNCxcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgbGVuZ3RoOiAyLFxuICAgICAgdmFsdWU6IFwibnVtYmVyXCJcbiAgICB9XG4gIH1cbn0sIHVzID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgaW1hZ2U6IHt9XG4gICAgfVxuICB9LFxuICB1cmw6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICBjb29yZGluYXRlczoge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBsZW5ndGg6IDIsXG4gICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgIH1cbiAgfVxufSwgY3MgPSB7XG4gIGlkOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICByZXF1aXJlZDogITBcbiAgfSxcbiAgdHlwZToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgZmlsbDoge30sXG4gICAgICBsaW5lOiB7fSxcbiAgICAgIHN5bWJvbDoge30sXG4gICAgICBjaXJjbGU6IHt9LFxuICAgICAgaGVhdG1hcDoge30sXG4gICAgICBcImZpbGwtZXh0cnVzaW9uXCI6IHt9LFxuICAgICAgcmFzdGVyOiB7fSxcbiAgICAgIGhpbGxzaGFkZToge30sXG4gICAgICBcImNvbG9yLXJlbGllZlwiOiB7fSxcbiAgICAgIGJhY2tncm91bmQ6IHt9XG4gICAgfSxcbiAgICByZXF1aXJlZDogITBcbiAgfSxcbiAgbWV0YWRhdGE6IHtcbiAgICB0eXBlOiBcIipcIlxuICB9LFxuICBzb3VyY2U6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIFwic291cmNlLWxheWVyXCI6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIG1pbnpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMjRcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAyNFxuICB9LFxuICBmaWx0ZXI6IHtcbiAgICB0eXBlOiBcImZpbHRlclwiXG4gIH0sXG4gIGxheW91dDoge1xuICAgIHR5cGU6IFwibGF5b3V0XCJcbiAgfSxcbiAgcGFpbnQ6IHtcbiAgICB0eXBlOiBcInBhaW50XCJcbiAgfVxufSwgcHMgPSBbXG4gIFwibGF5b3V0X2ZpbGxcIixcbiAgXCJsYXlvdXRfbGluZVwiLFxuICBcImxheW91dF9jaXJjbGVcIixcbiAgXCJsYXlvdXRfaGVhdG1hcFwiLFxuICBcImxheW91dF9maWxsLWV4dHJ1c2lvblwiLFxuICBcImxheW91dF9zeW1ib2xcIixcbiAgXCJsYXlvdXRfcmFzdGVyXCIsXG4gIFwibGF5b3V0X2hpbGxzaGFkZVwiLFxuICBcImxheW91dF9jb2xvci1yZWxpZWZcIixcbiAgXCJsYXlvdXRfYmFja2dyb3VuZFwiXG5dLCBmcyA9IHtcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge30sXG4gICAgICBub25lOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59LCBkcyA9IHtcbiAgXCJmaWxsLXNvcnQta2V5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIGhzID0ge1xuICBcImNpcmNsZS1zb3J0LWtleVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge30sXG4gICAgICBub25lOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59LCBtcyA9IHtcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge30sXG4gICAgICBub25lOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59LCB5cyA9IHtcbiAgXCJsaW5lLWNhcFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBidXR0OiB7fSxcbiAgICAgIHJvdW5kOiB7fSxcbiAgICAgIHNxdWFyZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwiYnV0dFwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJsaW5lLWpvaW5cIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgYmV2ZWw6IHt9LFxuICAgICAgcm91bmQ6IHt9LFxuICAgICAgbWl0ZXI6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm1pdGVyXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1taXRlci1saW1pdFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAyLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwibGluZS1qb2luXCI6IFwibWl0ZXJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtcm91bmQtbGltaXRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMS4wNSxcbiAgICByZXF1aXJlczogW1xuICAgICAge1xuICAgICAgICBcImxpbmUtam9pblwiOiBcInJvdW5kXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJsaW5lLXNvcnQta2V5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIGdzID0ge1xuICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgcG9pbnQ6IHt9LFxuICAgICAgbGluZToge30sXG4gICAgICBcImxpbmUtY2VudGVyXCI6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInBvaW50XCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInN5bWJvbC1zcGFjaW5nXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDI1MCxcbiAgICBtaW5pbXVtOiAxLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInN5bWJvbC1zb3J0LWtleVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJzeW1ib2wtei1vcmRlclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBhdXRvOiB7fSxcbiAgICAgIFwidmlld3BvcnQteVwiOiB7fSxcbiAgICAgIHNvdXJjZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwiYXV0b1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIixcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwiaWNvbi1vdmVybGFwXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLW92ZXJsYXBcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbmV2ZXI6IHt9LFxuICAgICAgYWx3YXlzOiB7fSxcbiAgICAgIGNvb3BlcmF0aXZlOiB7fVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge30sXG4gICAgICBhdXRvOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1zaXplXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJmYWN0b3Igb2YgdGhlIG9yaWdpbmFsIGljb24gc2l6ZVwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi10ZXh0LWZpdFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBub25lOiB7fSxcbiAgICAgIHdpZHRoOiB7fSxcbiAgICAgIGhlaWdodDoge30sXG4gICAgICBib3RoOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJub25lXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0sXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICB7XG4gICAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiBbXG4gICAgICAgICAgXCJib3RoXCIsXG4gICAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICAgIFwiaGVpZ2h0XCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24taW1hZ2VcIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRva2VuczogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1yb3RhdGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgIHR5cGU6IFwicGFkZGluZ1wiLFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIDJcbiAgICBdLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIixcbiAgICAgIHtcbiAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgIFwibGluZS1jZW50ZXJcIlxuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMCxcbiAgICAgIDBcbiAgICBdLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgY2VudGVyOiB7fSxcbiAgICAgIGxlZnQ6IHt9LFxuICAgICAgcmlnaHQ6IHt9LFxuICAgICAgdG9wOiB7fSxcbiAgICAgIGJvdHRvbToge30sXG4gICAgICBcInRvcC1sZWZ0XCI6IHt9LFxuICAgICAgXCJ0b3AtcmlnaHRcIjoge30sXG4gICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgXCJib3R0b20tcmlnaHRcIjoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9LFxuICAgICAgYXV0bzoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwiYXV0b1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge30sXG4gICAgICBhdXRvOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgIFwidmlld3BvcnQtZ2x5cGhcIjoge30sXG4gICAgICBhdXRvOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1maWVsZFwiOiB7XG4gICAgdHlwZTogXCJmb3JtYXR0ZWRcIixcbiAgICBkZWZhdWx0OiBcIlwiLFxuICAgIHRva2VuczogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1mb250XCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgXCJPcGVuIFNhbnMgUmVndWxhclwiLFxuICAgICAgXCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIlxuICAgIF0sXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LXNpemVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMTYsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEuMixcbiAgICB1bml0czogXCJlbXNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWp1c3RpZnlcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgYXV0bzoge30sXG4gICAgICBsZWZ0OiB7fSxcbiAgICAgIGNlbnRlcjoge30sXG4gICAgICByaWdodDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfVxuICB9LFxuICBcInRleHQtdmFyaWFibGUtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgY2VudGVyOiB7fSxcbiAgICAgIGxlZnQ6IHt9LFxuICAgICAgcmlnaHQ6IHt9LFxuICAgICAgdG9wOiB7fSxcbiAgICAgIGJvdHRvbToge30sXG4gICAgICBcInRvcC1sZWZ0XCI6IHt9LFxuICAgICAgXCJ0b3AtcmlnaHRcIjoge30sXG4gICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgXCJib3R0b20tcmlnaHRcIjoge31cbiAgICB9LFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcbiAgICAgICAgICBcInBvaW50XCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtdmFyaWFibGUtYW5jaG9yLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJ2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb25cIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICB7XG4gICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG4gICAgICAgICAgXCJwb2ludFwiXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGNlbnRlcjoge30sXG4gICAgICBsZWZ0OiB7fSxcbiAgICAgIHJpZ2h0OiB7fSxcbiAgICAgIHRvcDoge30sXG4gICAgICBib3R0b206IHt9LFxuICAgICAgXCJ0b3AtbGVmdFwiOiB7fSxcbiAgICAgIFwidG9wLXJpZ2h0XCI6IHt9LFxuICAgICAgXCJib3R0b20tbGVmdFwiOiB7fSxcbiAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcImNlbnRlclwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwidGV4dC12YXJpYWJsZS1hbmNob3JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1tYXgtYW5nbGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogNDUsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcbiAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICBcImxpbmUtY2VudGVyXCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtd3JpdGluZy1tb2RlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgaG9yaXpvbnRhbDoge30sXG4gICAgICB2ZXJ0aWNhbDoge31cbiAgICB9LFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcbiAgICAgICAgICBcInBvaW50XCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtcm90YXRlXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgcGVyaW9kOiAzNjAsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1wYWRkaW5nXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDIsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWtlZXAtdXByaWdodFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAge1xuICAgICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG4gICAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgICAgXCJsaW5lLWNlbnRlclwiXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBub25lOiB7fSxcbiAgICAgIHVwcGVyY2FzZToge30sXG4gICAgICBsb3dlcmNhc2U6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm5vbmVcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtb2Zmc2V0XCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIDAsXG4gICAgICAwXG4gICAgXSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcInRleHQtcmFkaWFsLW9mZnNldFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwidGV4dC1vdmVybGFwXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LW92ZXJsYXBcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbmV2ZXI6IHt9LFxuICAgICAgYWx3YXlzOiB7fSxcbiAgICAgIGNvb3BlcmF0aXZlOiB7fVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIHZzID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIGJzID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIHdzID0ge1xuICB0eXBlOiBcImFycmF5XCIsXG4gIHZhbHVlOiBcIipcIlxufSwgU3MgPSB7XG4gIHR5cGU6IFwiZW51bVwiLFxuICB2YWx1ZXM6IHtcbiAgICBcIj09XCI6IHt9LFxuICAgIFwiIT1cIjoge30sXG4gICAgXCI+XCI6IHt9LFxuICAgIFwiPj1cIjoge30sXG4gICAgXCI8XCI6IHt9LFxuICAgIFwiPD1cIjoge30sXG4gICAgaW46IHt9LFxuICAgIFwiIWluXCI6IHt9LFxuICAgIGFsbDoge30sXG4gICAgYW55OiB7fSxcbiAgICBub25lOiB7fSxcbiAgICBoYXM6IHt9LFxuICAgIFwiIWhhc1wiOiB7fVxuICB9XG59LCB4cyA9IHtcbiAgdHlwZTogXCJlbnVtXCIsXG4gIHZhbHVlczoge1xuICAgIFBvaW50OiB7fSxcbiAgICBMaW5lU3RyaW5nOiB7fSxcbiAgICBQb2x5Z29uOiB7fVxuICB9XG59LCBrcyA9IHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBtaW5pbXVtOiAwLFxuICBtYXhpbXVtOiAyNCxcbiAgdmFsdWU6IFtcbiAgICBcIm51bWJlclwiLFxuICAgIFwiY29sb3JcIlxuICBdLFxuICBsZW5ndGg6IDJcbn0sIExzID0ge1xuICB0eXBlOiBcImFycmF5XCIsXG4gIHZhbHVlOiBcIipcIixcbiAgbWluaW11bTogMVxufSwgRXMgPSB7XG4gIGFuY2hvcjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIGRlZmF1bHQ6IFwidmlld3BvcnRcIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge31cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgcG9zaXRpb246IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMS4xNSxcbiAgICAgIDIxMCxcbiAgICAgIDMwXG4gICAgXSxcbiAgICBsZW5ndGg6IDMsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfVxuICB9LFxuICBjb2xvcjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgZGVmYXVsdDogXCIjZmZmZmZmXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH0sXG4gIGludGVuc2l0eToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IDAuNSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH1cbn0sIENzID0ge1xuICBcInNreS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBkZWZhdWx0OiBcIiM4OEM2RkNcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogITBcbiAgfSxcbiAgXCJob3Jpem9uLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IFwiI2ZmZmZmZlwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAhMFxuICB9LFxuICBcImZvZy1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBkZWZhdWx0OiBcIiNmZmZmZmZcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogITBcbiAgfSxcbiAgXCJmb2ctZ3JvdW5kLWJsZW5kXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBkZWZhdWx0OiAwLjUsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAhMFxuICB9LFxuICBcImhvcml6b24tZm9nLWJsZW5kXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBkZWZhdWx0OiAwLjgsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAhMFxuICB9LFxuICBcInNreS1ob3Jpem9uLWJsZW5kXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBkZWZhdWx0OiAwLjgsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAhMFxuICB9LFxuICBcImF0bW9zcGhlcmUtYmxlbmRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IDAuOCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH1cbn0sIEFzID0ge1xuICBzb3VyY2U6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHJlcXVpcmVkOiAhMFxuICB9LFxuICBleGFnZ2VyYXRpb246IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIG1pbmltdW06IDAsXG4gICAgZGVmYXVsdDogMVxuICB9XG59LCBUcyA9IHtcbiAgdHlwZToge1xuICAgIHR5cGU6IFwicHJvamVjdGlvbkRlZmluaXRpb25cIixcbiAgICBkZWZhdWx0OiBcIm1lcmNhdG9yXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIHRyYW5zaXRpb246ICExLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfVxuICB9XG59LCBfcyA9IFtcbiAgXCJwYWludF9maWxsXCIsXG4gIFwicGFpbnRfbGluZVwiLFxuICBcInBhaW50X2NpcmNsZVwiLFxuICBcInBhaW50X2hlYXRtYXBcIixcbiAgXCJwYWludF9maWxsLWV4dHJ1c2lvblwiLFxuICBcInBhaW50X3N5bWJvbFwiLFxuICBcInBhaW50X3Jhc3RlclwiLFxuICBcInBhaW50X2hpbGxzaGFkZVwiLFxuICBcInBhaW50X2NvbG9yLXJlbGllZlwiLFxuICBcInBhaW50X2JhY2tncm91bmRcIlxuXSwgSXMgPSB7XG4gIFwiZmlsbC1hbnRpYWxpYXNcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImZpbGwtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAge1xuICAgICAgICBcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcImZpbGwtYW50aWFsaWFzXCI6ICEwXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMCxcbiAgICAgIDBcbiAgICBdLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJmaWxsLXRyYW5zbGF0ZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiZmlsbC1wYXR0ZXJuXCI6IHtcbiAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgfVxufSwgTXMgPSB7XG4gIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLXRyYW5zbGF0ZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBkZWZhdWx0OiBbXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0sXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImxpbmUtdHJhbnNsYXRlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1nYXAtd2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWJsdXJcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWRhc2hhcnJheVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwibGluZSB3aWR0aHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAge1xuICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkXCJcbiAgfSxcbiAgXCJsaW5lLXBhdHRlcm5cIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtZ3JhZGllbnRcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICByZXF1aXJlczogW1xuICAgICAge1xuICAgICAgICBcIiFcIjogXCJsaW5lLWRhc2hhcnJheVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc291cmNlOiBcImdlb2pzb25cIixcbiAgICAgICAgaGFzOiB7XG4gICAgICAgICAgbGluZU1ldHJpY3M6ICEwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwibGluZS1wcm9ncmVzc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb2xvci1yYW1wXCJcbiAgfVxufSwgUHMgPSB7XG4gIFwiY2lyY2xlLXJhZGl1c1wiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiA1LFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLXRyYW5zbGF0ZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBkZWZhdWx0OiBbXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0sXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJ2aWV3cG9ydFwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9XG59LCBScyA9IHtcbiAgXCJoZWF0bWFwLXJhZGl1c1wiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAzMCxcbiAgICBtaW5pbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJoZWF0bWFwLXdlaWdodFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImhlYXRtYXAtaW50ZW5zaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGVhdG1hcC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICAgIFtcbiAgICAgICAgXCJsaW5lYXJcIlxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgXCJoZWF0bWFwLWRlbnNpdHlcIlxuICAgICAgXSxcbiAgICAgIDAsXG4gICAgICBcInJnYmEoMCwgMCwgMjU1LCAwKVwiLFxuICAgICAgMC4xLFxuICAgICAgXCJyb3lhbGJsdWVcIixcbiAgICAgIDAuMyxcbiAgICAgIFwiY3lhblwiLFxuICAgICAgMC41LFxuICAgICAgXCJsaW1lXCIsXG4gICAgICAwLjcsXG4gICAgICBcInllbGxvd1wiLFxuICAgICAgMSxcbiAgICAgIFwicmVkXCJcbiAgICBdLFxuICAgIHRyYW5zaXRpb246ICExLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiaGVhdG1hcC1kZW5zaXR5XCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuICB9LFxuICBcImhlYXRtYXAtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn0sIHpzID0ge1xuICBcImljb24tb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWhhbG8tYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMCxcbiAgICAgIDBcbiAgICBdLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIixcbiAgICAgIFwiaWNvbi10cmFuc2xhdGVcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgb3ZlcnJpZGFibGU6ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtaGFsby1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRlZmF1bHQ6IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtaGFsby13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1oYWxvLWJsdXJcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIDAsXG4gICAgICAwXG4gICAgXSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICBcInRleHQtdHJhbnNsYXRlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufSwgT3MgPSB7XG4gIFwicmFzdGVyLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1odWUtcm90YXRlXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgcGVyaW9kOiAzNjAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLXNhdHVyYXRpb25cIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAtMSxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAtMSxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItcmVzYW1wbGluZ1wiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBsaW5lYXI6IHt9LFxuICAgICAgbmVhcmVzdDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibGluZWFyXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDMwMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICExLFxuICAgIHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufSwgJHMgPSB7XG4gIFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1kaXJlY3Rpb25cIjoge1xuICAgIHR5cGU6IFwibnVtYmVyQXJyYXlcIixcbiAgICBkZWZhdWx0OiAzMzUsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAzNTksXG4gICAgdHJhbnNpdGlvbjogITEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYWx0aXR1ZGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyQXJyYXlcIixcbiAgICBkZWZhdWx0OiA0NSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDkwLFxuICAgIHRyYW5zaXRpb246ICExLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpZXdwb3J0XCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1leGFnZ2VyYXRpb25cIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMC41LFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvckFycmF5XCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JBcnJheVwiLFxuICAgIGRlZmF1bHQ6IFwiI0ZGRkZGRlwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1tZXRob2RcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgc3RhbmRhcmQ6IHt9LFxuICAgICAgYmFzaWM6IHt9LFxuICAgICAgY29tYmluZWQ6IHt9LFxuICAgICAgaWdvcjoge30sXG4gICAgICBtdWx0aWRpcmVjdGlvbmFsOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJzdGFuZGFyZFwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufSwgRnMgPSB7XG4gIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcbiAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWRcIlxuICB9LFxuICBcImJhY2tncm91bmQtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn0sIE5zID0ge1xuICBkdXJhdGlvbjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMzAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCJcbiAgfSxcbiAgZGVsYXk6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIlxuICB9XG59LCBqcyA9IHtcbiAgXCIqXCI6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH1cbn0sIERzID0ge1xuICAkdmVyc2lvbjogZXMsXG4gICRyb290OiB0cyxcbiAgc291cmNlczogcnMsXG4gIHNvdXJjZTogbnMsXG4gIHNvdXJjZV92ZWN0b3I6IGFzLFxuICBzb3VyY2VfcmFzdGVyOiBvcyxcbiAgc291cmNlX3Jhc3Rlcl9kZW06IGlzLFxuICBzb3VyY2VfZ2VvanNvbjogc3MsXG4gIHNvdXJjZV92aWRlbzogbHMsXG4gIHNvdXJjZV9pbWFnZTogdXMsXG4gIGxheWVyOiBjcyxcbiAgbGF5b3V0OiBwcyxcbiAgbGF5b3V0X2JhY2tncm91bmQ6IGZzLFxuICBsYXlvdXRfZmlsbDogZHMsXG4gIGxheW91dF9jaXJjbGU6IGhzLFxuICBsYXlvdXRfaGVhdG1hcDogbXMsXG4gIFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCI6IHtcbiAgICB2aXNpYmlsaXR5OiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgbm9uZToge31cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICB9XG4gIH0sXG4gIGxheW91dF9saW5lOiB5cyxcbiAgbGF5b3V0X3N5bWJvbDogZ3MsXG4gIGxheW91dF9yYXN0ZXI6IHZzLFxuICBsYXlvdXRfaGlsbHNoYWRlOiBicyxcbiAgXCJsYXlvdXRfY29sb3ItcmVsaWVmXCI6IHtcbiAgICB2aXNpYmlsaXR5OiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgbm9uZToge31cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICB9XG4gIH0sXG4gIGZpbHRlcjogd3MsXG4gIGZpbHRlcl9vcGVyYXRvcjogU3MsXG4gIGdlb21ldHJ5X3R5cGU6IHhzLFxuICBmdW5jdGlvbjoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHR5cGU6IFwiZXhwcmVzc2lvblwiXG4gICAgfSxcbiAgICBzdG9wczoge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgdmFsdWU6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBiYXNlOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZGVmYXVsdDogXCIkem9vbVwiXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICBpZGVudGl0eToge30sXG4gICAgICAgIGV4cG9uZW50aWFsOiB7fSxcbiAgICAgICAgaW50ZXJ2YWw6IHt9LFxuICAgICAgICBjYXRlZ29yaWNhbDoge31cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBcImV4cG9uZW50aWFsXCJcbiAgICB9LFxuICAgIGNvbG9yU3BhY2U6IHtcbiAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIHJnYjoge30sXG4gICAgICAgIGxhYjoge30sXG4gICAgICAgIGhjbDoge31cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBcInJnYlwiXG4gICAgfSxcbiAgICBkZWZhdWx0OiB7XG4gICAgICB0eXBlOiBcIipcIixcbiAgICAgIHJlcXVpcmVkOiAhMVxuICAgIH1cbiAgfSxcbiAgZnVuY3Rpb25fc3RvcDoga3MsXG4gIGV4cHJlc3Npb246IExzLFxuICBsaWdodDogRXMsXG4gIHNreTogQ3MsXG4gIHRlcnJhaW46IEFzLFxuICBwcm9qZWN0aW9uOiBUcyxcbiAgcGFpbnQ6IF9zLFxuICBwYWludF9maWxsOiBJcyxcbiAgXCJwYWludF9maWxsLWV4dHJ1c2lvblwiOiB7XG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCI6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tY29sb3JcIjoge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgIHJlcXVpcmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcIiFcIjogXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiLFxuICAgICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgIGxlbmd0aDogMixcbiAgICAgIGRlZmF1bHQ6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICBcInpvb21cIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgIHJlcXVpcmVzOiBbXG4gICAgICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCJcbiAgICAgIF0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICBcInpvb21cIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIjoge1xuICAgICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiLFxuICAgICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICB1bml0czogXCJtZXRlcnNcIixcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tYmFzZVwiOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICB1bml0czogXCJtZXRlcnNcIixcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgcmVxdWlyZXM6IFtcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIlxuICAgICAgXSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiLFxuICAgICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCI6IHtcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogITAsXG4gICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9XG4gIH0sXG4gIHBhaW50X2xpbmU6IE1zLFxuICBwYWludF9jaXJjbGU6IFBzLFxuICBwYWludF9oZWF0bWFwOiBScyxcbiAgcGFpbnRfc3ltYm9sOiB6cyxcbiAgcGFpbnRfcmFzdGVyOiBPcyxcbiAgcGFpbnRfaGlsbHNoYWRlOiAkcyxcbiAgXCJwYWludF9jb2xvci1yZWxpZWZcIjoge1xuICAgIFwiY29sb3ItcmVsaWVmLW9wYWNpdHlcIjoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgIH0sXG4gICAgXCJjb2xvci1yZWxpZWYtY29sb3JcIjoge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICBcImVsZXZhdGlvblwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb2xvci1yYW1wXCJcbiAgICB9XG4gIH0sXG4gIHBhaW50X2JhY2tncm91bmQ6IEZzLFxuICB0cmFuc2l0aW9uOiBOcyxcbiAgXCJwcm9wZXJ0eS10eXBlXCI6IHtcbiAgICBcImRhdGEtZHJpdmVuXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgfSxcbiAgICBcImNyb3NzLWZhZGVkXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgfSxcbiAgICBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgfSxcbiAgICBcImNvbG9yLXJhbXBcIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICB9LFxuICAgIFwiZGF0YS1jb25zdGFudFwiOiB7XG4gICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIlxuICAgIH0sXG4gICAgY29uc3RhbnQ6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgfVxuICB9LFxuICBwcm9tb3RlSWQ6IGpzXG59O1xuY2xhc3MgYiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAoZSA/IGAke2V9OiBgIDogXCJcIikgKyBuLCBhICYmICh0aGlzLmlkZW50aWZpZXIgPSBhKSwgdCAhPSBudWxsICYmIHQuX19saW5lX18gJiYgKHRoaXMubGluZSA9IHQuX19saW5lX18pO1xuICB9XG59XG5mdW5jdGlvbiBZdChyLCAuLi5lKSB7XG4gIGZvciAoY29uc3QgdCBvZiBlKVxuICAgIGZvciAoY29uc3QgbiBpbiB0KVxuICAgICAgcltuXSA9IHRbbl07XG4gIHJldHVybiByO1xufVxuY2xhc3Mgd2UgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5tZXNzYWdlID0gdCwgdGhpcy5rZXkgPSBlO1xuICB9XG59XG5jbGFzcyBobiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSBbXSkge1xuICAgIHRoaXMucGFyZW50ID0gZSwgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIGZvciAoY29uc3QgW24sIGFdIG9mIHQpXG4gICAgICB0aGlzLmJpbmRpbmdzW25dID0gYTtcbiAgfVxuICBjb25jYXQoZSkge1xuICAgIHJldHVybiBuZXcgaG4odGhpcywgZSk7XG4gIH1cbiAgZ2V0KGUpIHtcbiAgICBpZiAodGhpcy5iaW5kaW5nc1tlXSlcbiAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW2VdO1xuICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQoZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2V9IG5vdCBmb3VuZCBpbiBzY29wZS5gKTtcbiAgfVxuICBoYXMoZSkge1xuICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW2VdID8gITAgOiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmhhcyhlKSA6ICExO1xuICB9XG59XG5jb25zdCBzciA9IHsga2luZDogXCJudWxsXCIgfSwgUyA9IHsga2luZDogXCJudW1iZXJcIiB9LCBQID0geyBraW5kOiBcInN0cmluZ1wiIH0sIE0gPSB7IGtpbmQ6IFwiYm9vbGVhblwiIH0sIFNlID0geyBraW5kOiBcImNvbG9yXCIgfSwgbHIgPSB7IGtpbmQ6IFwicHJvamVjdGlvbkRlZmluaXRpb25cIiB9LCBWZSA9IHsga2luZDogXCJvYmplY3RcIiB9LCBJID0geyBraW5kOiBcInZhbHVlXCIgfSwgVXMgPSB7IGtpbmQ6IFwiZXJyb3JcIiB9LCB1ciA9IHsga2luZDogXCJjb2xsYXRvclwiIH0sIGNyID0geyBraW5kOiBcImZvcm1hdHRlZFwiIH0sIHByID0geyBraW5kOiBcInBhZGRpbmdcIiB9LCB2dCA9IHsga2luZDogXCJjb2xvckFycmF5XCIgfSwgZnIgPSB7IGtpbmQ6IFwibnVtYmVyQXJyYXlcIiB9LCBfdCA9IHsga2luZDogXCJyZXNvbHZlZEltYWdlXCIgfSwgZHIgPSB7IGtpbmQ6IFwidmFyaWFibGVBbmNob3JPZmZzZXRDb2xsZWN0aW9uXCIgfTtcbmZ1bmN0aW9uIG5lKHIsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcImFycmF5XCIsXG4gICAgaXRlbVR5cGU6IHIsXG4gICAgTjogZVxuICB9O1xufVxuZnVuY3Rpb24gRChyKSB7XG4gIGlmIChyLmtpbmQgPT09IFwiYXJyYXlcIikge1xuICAgIGNvbnN0IGUgPSBEKHIuaXRlbVR5cGUpO1xuICAgIHJldHVybiB0eXBlb2Ygci5OID09IFwibnVtYmVyXCIgPyBgYXJyYXk8JHtlfSwgJHtyLk59PmAgOiByLml0ZW1UeXBlLmtpbmQgPT09IFwidmFsdWVcIiA/IFwiYXJyYXlcIiA6IGBhcnJheTwke2V9PmA7XG4gIH0gZWxzZVxuICAgIHJldHVybiByLmtpbmQ7XG59XG5jb25zdCBCcyA9IFtcbiAgc3IsXG4gIFMsXG4gIFAsXG4gIE0sXG4gIFNlLFxuICBscixcbiAgY3IsXG4gIFZlLFxuICBuZShJKSxcbiAgcHIsXG4gIGZyLFxuICB2dCxcbiAgX3QsXG4gIGRyXG5dO1xuZnVuY3Rpb24gYnQociwgZSkge1xuICBpZiAoZS5raW5kID09PSBcImVycm9yXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChyLmtpbmQgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChlLmtpbmQgPT09IFwiYXJyYXlcIiAmJiAoZS5OID09PSAwICYmIGUuaXRlbVR5cGUua2luZCA9PT0gXCJ2YWx1ZVwiIHx8ICFidChyLml0ZW1UeXBlLCBlLml0ZW1UeXBlKSkgJiYgKHR5cGVvZiByLk4gIT0gXCJudW1iZXJcIiB8fCByLk4gPT09IGUuTikpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoci5raW5kID09PSBlLmtpbmQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoci5raW5kID09PSBcInZhbHVlXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdCBvZiBCcylcbiAgICAgICAgaWYgKCFidCh0LCBlKSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBFeHBlY3RlZCAke0Qocil9IGJ1dCBmb3VuZCAke0QoZSl9IGluc3RlYWQuYDtcbn1cbmZ1bmN0aW9uIG1uKHIsIGUpIHtcbiAgcmV0dXJuIGUuc29tZSgodCkgPT4gdC5raW5kID09PSByLmtpbmQpO1xufVxuZnVuY3Rpb24gR2UociwgZSkge1xuICByZXR1cm4gZS5zb21lKCh0KSA9PiB0ID09PSBcIm51bGxcIiA/IHIgPT09IG51bGwgOiB0ID09PSBcImFycmF5XCIgPyBBcnJheS5pc0FycmF5KHIpIDogdCA9PT0gXCJvYmplY3RcIiA/IHIgJiYgIUFycmF5LmlzQXJyYXkocikgJiYgdHlwZW9mIHIgPT0gXCJvYmplY3RcIiA6IHQgPT09IHR5cGVvZiByKTtcbn1cbmZ1bmN0aW9uIEllKHIsIGUpIHtcbiAgcmV0dXJuIHIua2luZCA9PT0gXCJhcnJheVwiICYmIGUua2luZCA9PT0gXCJhcnJheVwiID8gci5pdGVtVHlwZS5raW5kID09PSBlLml0ZW1UeXBlLmtpbmQgJiYgdHlwZW9mIHIuTiA9PSBcIm51bWJlclwiIDogci5raW5kID09PSBlLmtpbmQ7XG59XG5jb25zdCBlbyA9IDAuOTY0MjIsIHRvID0gMSwgcm8gPSAwLjgyNTIxLCBubyA9IDQgLyAyOSwgcnQgPSA2IC8gMjksIGFvID0gMyAqIHJ0ICogcnQsIHFzID0gcnQgKiBydCAqIHJ0LCBWcyA9IE1hdGguUEkgLyAxODAsIEdzID0gMTgwIC8gTWF0aC5QSTtcbmZ1bmN0aW9uIG9vKHIpIHtcbiAgcmV0dXJuIHIgPSByICUgMzYwLCByIDwgMCAmJiAociArPSAzNjApLCByO1xufVxuZnVuY3Rpb24gaW8oW3IsIGUsIHQsIG5dKSB7XG4gIHIgPSBUcihyKSwgZSA9IFRyKGUpLCB0ID0gVHIodCk7XG4gIGxldCBhLCBvO1xuICBjb25zdCBpID0gX3IoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBlICsgMC4wNjA2MTY5ICogdCkgLyB0byk7XG4gIHIgPT09IGUgJiYgZSA9PT0gdCA/IGEgPSBvID0gaSA6IChhID0gX3IoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBlICsgMC4xNDMwODA0ICogdCkgLyBlbyksIG8gPSBfcigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGUgKyAwLjcxNDE3MzMgKiB0KSAvIHJvKSk7XG4gIGNvbnN0IHMgPSAxMTYgKiBpIC0gMTY7XG4gIHJldHVybiBbcyA8IDAgPyAwIDogcywgNTAwICogKGEgLSBpKSwgMjAwICogKGkgLSBvKSwgbl07XG59XG5mdW5jdGlvbiBUcihyKSB7XG4gIHJldHVybiByIDw9IDAuMDQwNDUgPyByIC8gMTIuOTIgOiBNYXRoLnBvdygociArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuZnVuY3Rpb24gX3Iocikge1xuICByZXR1cm4gciA+IHFzID8gTWF0aC5wb3cociwgMSAvIDMpIDogciAvIGFvICsgbm87XG59XG5mdW5jdGlvbiBzbyhbciwgZSwgdCwgbl0pIHtcbiAgbGV0IGEgPSAociArIDE2KSAvIDExNiwgbyA9IGlzTmFOKGUpID8gYSA6IGEgKyBlIC8gNTAwLCBpID0gaXNOYU4odCkgPyBhIDogYSAtIHQgLyAyMDA7XG4gIHJldHVybiBhID0gdG8gKiBNcihhKSwgbyA9IGVvICogTXIobyksIGkgPSBybyAqIE1yKGkpLCBbXG4gICAgSXIoMy4xMzM4NTYxICogbyAtIDEuNjE2ODY2NyAqIGEgLSAwLjQ5MDYxNDYgKiBpKSxcbiAgICAvLyBENTAgLT4gc1JHQlxuICAgIElyKC0wLjk3ODc2ODQgKiBvICsgMS45MTYxNDE1ICogYSArIDAuMDMzNDU0ICogaSksXG4gICAgSXIoMC4wNzE5NDUzICogbyAtIDAuMjI4OTkxNCAqIGEgKyAxLjQwNTI0MjcgKiBpKSxcbiAgICBuXG4gIF07XG59XG5mdW5jdGlvbiBJcihyKSB7XG4gIHJldHVybiByID0gciA8PSAzMDRlLTUgPyAxMi45MiAqIHIgOiAxLjA1NSAqIE1hdGgucG93KHIsIDEgLyAyLjQpIC0gMC4wNTUsIHIgPCAwID8gMCA6IHIgPiAxID8gMSA6IHI7XG59XG5mdW5jdGlvbiBNcihyKSB7XG4gIHJldHVybiByID4gcnQgPyByICogciAqIHIgOiBhbyAqIChyIC0gbm8pO1xufVxuZnVuY3Rpb24gSHMocikge1xuICBjb25zdCBbZSwgdCwgbiwgYV0gPSBpbyhyKSwgbyA9IE1hdGguc3FydCh0ICogdCArIG4gKiBuKTtcbiAgcmV0dXJuIFtNYXRoLnJvdW5kKG8gKiAxZTQpID8gb28oTWF0aC5hdGFuMihuLCB0KSAqIEdzKSA6IE5hTiwgbywgZSwgYV07XG59XG5mdW5jdGlvbiBacyhbciwgZSwgdCwgbl0pIHtcbiAgcmV0dXJuIHIgPSBpc05hTihyKSA/IDAgOiByICogVnMsIHNvKFt0LCBNYXRoLmNvcyhyKSAqIGUsIE1hdGguc2luKHIpICogZSwgbl0pO1xufVxuZnVuY3Rpb24gS3MoW3IsIGUsIHQsIG5dKSB7XG4gIHIgPSBvbyhyKSwgZSAvPSAxMDAsIHQgLz0gMTAwO1xuICBmdW5jdGlvbiBhKG8pIHtcbiAgICBjb25zdCBpID0gKG8gKyByIC8gMzApICUgMTIsIHMgPSBlICogTWF0aC5taW4odCwgMSAtIHQpO1xuICAgIHJldHVybiB0IC0gcyAqIE1hdGgubWF4KC0xLCBNYXRoLm1pbihpIC0gMywgOSAtIGksIDEpKTtcbiAgfVxuICByZXR1cm4gW2EoMCksIGEoOCksIGEoNCksIG5dO1xufVxuY29uc3QgWHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCB0KTtcbn07XG5mdW5jdGlvbiBtdChyLCBlKSB7XG4gIHJldHVybiBYcyhyLCBlKSA/IHJbZV0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBZcyhyKSB7XG4gIGlmIChyID0gci50b0xvd2VyQ2FzZSgpLnRyaW0oKSwgciA9PT0gXCJ0cmFuc3BhcmVudFwiKVxuICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gIGNvbnN0IGUgPSBtdChXcywgcik7XG4gIGlmIChlKSB7XG4gICAgY29uc3QgW2EsIG8sIGldID0gZTtcbiAgICByZXR1cm4gW2EgLyAyNTUsIG8gLyAyNTUsIGkgLyAyNTUsIDFdO1xuICB9XG4gIGlmIChyLnN0YXJ0c1dpdGgoXCIjXCIpICYmIC9eIyg/OlswLTlhLWZdezMsNH18WzAtOWEtZl17Nn18WzAtOWEtZl17OH0pJC8udGVzdChyKSkge1xuICAgIGNvbnN0IG8gPSByLmxlbmd0aCA8IDYgPyAxIDogMjtcbiAgICBsZXQgaSA9IDE7XG4gICAgcmV0dXJuIFtcbiAgICAgIFV0KHIuc2xpY2UoaSwgaSArPSBvKSksXG4gICAgICBVdChyLnNsaWNlKGksIGkgKz0gbykpLFxuICAgICAgVXQoci5zbGljZShpLCBpICs9IG8pKSxcbiAgICAgIFV0KHIuc2xpY2UoaSwgaSArIG8pIHx8IFwiZmZcIilcbiAgICBdO1xuICB9XG4gIGlmIChyLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcbiAgICBjb25zdCBhID0gL15yZ2JhP1xcKFxccyooW1xcZGUuKy1dKykoJSk/KD86XFxzK3xcXHMqKCwpXFxzKikoW1xcZGUuKy1dKykoJSk/KD86XFxzK3xcXHMqKCwpXFxzKikoW1xcZGUuKy1dKykoJSk/KD86XFxzKihbLFxcL10pXFxzKihbXFxkZS4rLV0rKSglKT8pP1xccypcXCkkLywgbyA9IHIubWF0Y2goYSk7XG4gICAgaWYgKG8pIHtcbiAgICAgIGNvbnN0IFtcbiAgICAgICAgaSxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgcyxcbiAgICAgICAgLy8gPG51bWVyaWM+XG4gICAgICAgIGwsXG4gICAgICAgIC8vICUgICAgICAgICAob3B0aW9uYWwpXG4gICAgICAgIHUsXG4gICAgICAgIC8vICwgICAgICAgICAob3B0aW9uYWwpXG4gICAgICAgIGMsXG4gICAgICAgIC8vIDxudW1lcmljPlxuICAgICAgICBwLFxuICAgICAgICAvLyAlICAgICAgICAgKG9wdGlvbmFsKVxuICAgICAgICBkLFxuICAgICAgICAvLyAsICAgICAgICAgKG9wdGlvbmFsKVxuICAgICAgICBmLFxuICAgICAgICAvLyA8bnVtZXJpYz5cbiAgICAgICAgaCxcbiAgICAgICAgLy8gJSAgICAgICAgIChvcHRpb25hbClcbiAgICAgICAgbSxcbiAgICAgICAgLy8gLHwvICAgICAgIChvcHRpb25hbClcbiAgICAgICAgeSxcbiAgICAgICAgLy8gPG51bWVyaWM+IChvcHRpb25hbClcbiAgICAgICAgd1xuICAgICAgICAvLyAlICAgICAgICAgKG9wdGlvbmFsKVxuICAgICAgXSA9IG8sIHYgPSBbdSB8fCBcIiBcIiwgZCB8fCBcIiBcIiwgbV0uam9pbihcIlwiKTtcbiAgICAgIGlmICh2ID09PSBcIiAgXCIgfHwgdiA9PT0gXCIgIC9cIiB8fCB2ID09PSBcIiwsXCIgfHwgdiA9PT0gXCIsLCxcIikge1xuICAgICAgICBjb25zdCB4ID0gW2wsIHAsIGhdLmpvaW4oXCJcIiksIEEgPSB4ID09PSBcIiUlJVwiID8gMTAwIDogeCA9PT0gXCJcIiA/IDI1NSA6IDA7XG4gICAgICAgIGlmIChBKSB7XG4gICAgICAgICAgY29uc3QgRSA9IFtcbiAgICAgICAgICAgIGV0KCtzIC8gQSwgMCwgMSksXG4gICAgICAgICAgICBldCgrYyAvIEEsIDAsIDEpLFxuICAgICAgICAgICAgZXQoK2YgLyBBLCAwLCAxKSxcbiAgICAgICAgICAgIHkgPyBuYSgreSwgdykgOiAxXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoYWEoRSkpXG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCB0ID0gL15oc2xhP1xcKFxccyooW1xcZGUuKy1dKykoPzpkZWcpPyg/Olxccyt8XFxzKigsKVxccyopKFtcXGRlListXSspJSg/Olxccyt8XFxzKigsKVxccyopKFtcXGRlListXSspJSg/OlxccyooWyxcXC9dKVxccyooW1xcZGUuKy1dKykoJSk/KT9cXHMqXFwpJC8sIG4gPSByLm1hdGNoKHQpO1xuICBpZiAobikge1xuICAgIGNvbnN0IFtcbiAgICAgIGEsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgbyxcbiAgICAgIC8vIDxudW1lcmljPlxuICAgICAgaSxcbiAgICAgIC8vICwgICAgICAgICAob3B0aW9uYWwpXG4gICAgICBzLFxuICAgICAgLy8gPG51bWVyaWM+XG4gICAgICBsLFxuICAgICAgLy8gLCAgICAgICAgIChvcHRpb25hbClcbiAgICAgIHUsXG4gICAgICAvLyA8bnVtZXJpYz5cbiAgICAgIGMsXG4gICAgICAvLyAsfC8gICAgICAgKG9wdGlvbmFsKVxuICAgICAgcCxcbiAgICAgIC8vIDxudW1lcmljPiAob3B0aW9uYWwpXG4gICAgICBkXG4gICAgICAvLyAlICAgICAgICAgKG9wdGlvbmFsKVxuICAgIF0gPSBuLCBmID0gW2kgfHwgXCIgXCIsIGwgfHwgXCIgXCIsIGNdLmpvaW4oXCJcIik7XG4gICAgaWYgKGYgPT09IFwiICBcIiB8fCBmID09PSBcIiAgL1wiIHx8IGYgPT09IFwiLCxcIiB8fCBmID09PSBcIiwsLFwiKSB7XG4gICAgICBjb25zdCBoID0gW1xuICAgICAgICArbyxcbiAgICAgICAgZXQoK3MsIDAsIDEwMCksXG4gICAgICAgIGV0KCt1LCAwLCAxMDApLFxuICAgICAgICBwID8gbmEoK3AsIGQpIDogMVxuICAgICAgXTtcbiAgICAgIGlmIChhYShoKSlcbiAgICAgICAgcmV0dXJuIEtzKGgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gVXQocikge1xuICByZXR1cm4gcGFyc2VJbnQoci5wYWRFbmQoMiwgciksIDE2KSAvIDI1NTtcbn1cbmZ1bmN0aW9uIG5hKHIsIGUpIHtcbiAgcmV0dXJuIGV0KGUgPyByIC8gMTAwIDogciwgMCwgMSk7XG59XG5mdW5jdGlvbiBldChyLCBlLCB0KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChlLCByKSwgdCk7XG59XG5mdW5jdGlvbiBhYShyKSB7XG4gIHJldHVybiAhci5zb21lKE51bWJlci5pc05hTik7XG59XG5jb25zdCBXcyA9IHtcbiAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gIGxpbWU6IFswLCAyNTUsIDBdLFxuICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59O1xuZnVuY3Rpb24gTmUociwgZSwgdCkge1xuICByZXR1cm4gciArIHQgKiAoZSAtIHIpO1xufVxuZnVuY3Rpb24gb3QociwgZSwgdCkge1xuICByZXR1cm4gci5tYXAoKG4sIGEpID0+IE5lKG4sIGVbYV0sIHQpKTtcbn1cbmNsYXNzICQge1xuICAvKipcbiAgICogQHBhcmFtIHIgUmVkIGNvbXBvbmVudCBwcmVtdWx0aXBsaWVkIGJ5IGBhbHBoYWAgMC4uMVxuICAgKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQgcHJlbXVsdGlwbGllZCBieSBgYWxwaGFgIDAuLjFcbiAgICogQHBhcmFtIGIgQmx1ZSBjb21wb25lbnQgcHJlbXVsdGlwbGllZCBieSBgYWxwaGFgIDAuLjFcbiAgICogQHBhcmFtIFthbHBoYT0xXSBBbHBoYSBjb21wb25lbnQgMC4uMVxuICAgKiBAcGFyYW0gW3ByZW11bHRpcGxpZWQ9dHJ1ZV0gV2hldGhlciB0aGUgYHJgLCBgZ2AgYW5kIGBiYCB2YWx1ZXMgaGF2ZSBhbHJlYWR5XG4gICAqIGJlZW4gbXVsdGlwbGllZCBieSBhbHBoYS4gSWYgYHRydWVgIG5vdGhpbmcgaGFwcGVucyBpZiBgZmFsc2VgIHRoZW4gdGhleSB3aWxsXG4gICAqIGJlIG11bHRpcGxpZWQgYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEgPSAxLCBvID0gITApIHtcbiAgICB0aGlzLnIgPSBlLCB0aGlzLmcgPSB0LCB0aGlzLmIgPSBuLCB0aGlzLmEgPSBhLCBvIHx8ICh0aGlzLnIgKj0gYSwgdGhpcy5nICo9IGEsIHRoaXMuYiAqPSBhLCBhIHx8IHRoaXMub3ZlcndyaXRlR2V0dGVyKFwicmdiXCIsIFtlLCB0LCBuLCBhXSkpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgQ1NTIGNvbG9yIHN0cmluZ3MgYW5kIGNvbnZlcnRzIGNvbG9ycyB0byBzUkdCIGNvbG9yIHNwYWNlIGlmIG5lZWRlZC5cbiAgICogT2ZmaWNpYWxseSBzdXBwb3J0ZWQgY29sb3IgZm9ybWF0czpcbiAgICogLSBrZXl3b3JkLCBlLmcuICdhcXVhbWFyaW5lJyBvciAnc3RlZWxibHVlJ1xuICAgKiAtIGhleCAod2l0aCAzLCA0LCA2IG9yIDggZGlnaXRzKSwgZS5nLiAnI2YwZicgb3IgJyNlOWJlYmVhOSdcbiAgICogLSByZ2IgYW5kIHJnYmEsIGUuZy4gJ3JnYigwLDI0MCwxMjApJyBvciAncmdiYSgwJSw5NCUsNDclLDAuMSknIG9yICdyZ2IoMCAyNDAgMTIwIC8gLjMpJ1xuICAgKiAtIGhzbCBhbmQgaHNsYSwgZS5nLiAnaHNsKDAsMCUsODMlKScgb3IgJ2hzbGEoMCwwJSw4MyUsLjUpJyBvciAnaHNsKDAgMCUgODMlIC8gMjAlKSdcbiAgICpcbiAgICogQHBhcmFtIGlucHV0IENTUyBjb2xvciBzdHJpbmcgdG8gcGFyc2UuXG4gICAqIEByZXR1cm5zIEEgYENvbG9yYCBpbnN0YW5jZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIGNvbG9yIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBwYXJzZShlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiAkKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IFlzKGUpO1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuIG5ldyAkKC4uLnQsICExKTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbiBjb2xvciBpbnRlcnBvbGF0aW9uIGFuZCBieSAndG8tcmdiYScgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMgR2llbiBjb2xvciwgd2l0aCByZXZlcnNlZCBhbHBoYSBibGVuZGluZywgaW4gc1JHQiBjb2xvciBzcGFjZS5cbiAgICovXG4gIGdldCByZ2IoKSB7XG4gICAgY29uc3QgeyByOiBlLCBnOiB0LCBiOiBuLCBhIH0gPSB0aGlzLCBvID0gYSB8fCAxIC8gMDtcbiAgICByZXR1cm4gdGhpcy5vdmVyd3JpdGVHZXR0ZXIoXCJyZ2JcIiwgW2UgLyBvLCB0IC8gbywgbiAvIG8sIGFdKTtcbiAgfVxuICAvKipcbiAgICogVXNlZCBpbiBjb2xvciBpbnRlcnBvbGF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBHaWVuIGNvbG9yLCB3aXRoIHJldmVyc2VkIGFscGhhIGJsZW5kaW5nLCBpbiBIQ0wgY29sb3Igc3BhY2UuXG4gICAqL1xuICBnZXQgaGNsKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJ3cml0ZUdldHRlcihcImhjbFwiLCBIcyh0aGlzLnJnYikpO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGluIGNvbG9yIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIEdpZW4gY29sb3IsIHdpdGggcmV2ZXJzZWQgYWxwaGEgYmxlbmRpbmcsIGluIExBQiBjb2xvciBzcGFjZS5cbiAgICovXG4gIGdldCBsYWIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcndyaXRlR2V0dGVyKFwibGFiXCIsIGlvKHRoaXMucmdiKSk7XG4gIH1cbiAgLyoqXG4gICAqIExhenkgZ2V0dGVyIHBhdHRlcm4uIFdoZW4gZ2V0dGVyIGlzIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgbGF6eSB2YWx1ZVxuICAgKiBpcyBjYWxjdWxhdGVkIGFuZCB0aGVuIG92ZXJ3cml0ZXMgZ2V0dGVyIGZ1bmN0aW9uIGluIGdpdmVuIG9iamVjdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGU6XG4gICAqIGNvbnN0IHJlZENvbG9yID0gQ29sb3IucGFyc2UoJ3JlZCcpO1xuICAgKiBsZXQgeCA9IHJlZENvbG9yLmhjbDsgLy8gdGhpcyB3aWxsIGludm9rZSBgZ2V0IGhjbCgpYCwgd2hpY2ggd2lsbCBjYWxjdWxhdGVcbiAgICogLy8gdGhlIHZhbHVlIG9mIHJlZCBpbiBIQ0wgc3BhY2UgYW5kIGludm9rZSB0aGlzIGBvdmVyd3JpdGVHZXR0ZXJgIGZ1bmN0aW9uXG4gICAqIC8vIHdoaWNoIGluIHR1cm4gd2lsbCBzZXQgYSBmaWVsZCB3aXRoIGEga2V5ICdoY2wnIGluIHRoZSBgcmVkQ29sb3JgIG9iamVjdC5cbiAgICogLy8gSW4gb3RoZXIgd29yZHMgaXQgd2lsbCBvdmVycmlkZSBgZ2V0IGhjbCgpYCBmcm9tIGl0cyBgQ29sb3JgIHByb3RvdHlwZVxuICAgKiAvLyB3aXRoIGl0cyBvd24gcHJvcGVydHk6IGhjbCA9IFtjYWxjdWxhdGVkIHJlZCB2YWx1ZSBpbiBoY2xdLlxuICAgKiBsZXQgeSA9IHJlZENvbG9yLmhjbDsgLy8gbmV4dCBjYWxsIHdpbGwgbm8gbG9uZ2VyIGludm9rZSBnZXR0ZXIgYnV0IHNpbXBseVxuICAgKiAvLyByZXR1cm4gdGhlIHByZXZpb3VzbHkgY2FsY3VsYXRlZCB2YWx1ZVxuICAgKiB4ID09PSB5OyAvLyB0cnVlIC0gYHhgIGlzIGV4YWN0bHkgdGhlIHNhbWUgb2JqZWN0IGFzIGB5YFxuICAgKlxuICAgKiBAcGFyYW0gZ2V0dGVyS2V5IEdldHRlciBrZXlcbiAgICogQHBhcmFtIGxhenlWYWx1ZSBMYXppbHkgY2FsY3VsYXRlZCB2YWx1ZSB0byBiZSBtZW1vaXplZCBieSBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvdmVyd3JpdGVHZXR0ZXIoZSwgdCkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZSwgeyB2YWx1ZTogdCB9KSwgdDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSAndG8tc3RyaW5nJyBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBTZXJpYWxpemVkIGNvbG9yIGluIGZvcm1hdCBgcmdiYShyLGcsYixhKWBcbiAgICogd2hlcmUgcixnLGIgYXJlIG51bWJlcnMgd2l0aGluIDAuLjI1NSBhbmQgYWxwaGEgaXMgbnVtYmVyIHdpdGhpbiAxLi4wXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBwdXJwbGUgPSBuZXcgQ29sb3IucGFyc2UoJ3B1cnBsZScpO1xuICAgKiBwdXJwbGUudG9TdHJpbmc7IC8vID0gXCJyZ2JhKDEyOCwwLDEyOCwxKVwiXG4gICAqIHZhciB0cmFuc2x1Y2VudEdyZWVuID0gbmV3IENvbG9yLnBhcnNlKCdyZ2JhKDI2LCAyMDcsIDI2LCAuNzMpJyk7XG4gICAqIHRyYW5zbHVjZW50R3JlZW4udG9TdHJpbmcoKTsgLy8gPSBcInJnYmEoMjYsMjA3LDI2LDAuNzMpXCJcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IFtlLCB0LCBuLCBhXSA9IHRoaXMucmdiO1xuICAgIHJldHVybiBgcmdiYSgke1tlLCB0LCBuXS5tYXAoKG8pID0+IE1hdGgucm91bmQobyAqIDI1NSkpLmpvaW4oXCIsXCIpfSwke2F9KWA7XG4gIH1cbiAgc3RhdGljIGludGVycG9sYXRlKGUsIHQsIG4sIGEgPSBcInJnYlwiKSB7XG4gICAgc3dpdGNoIChhKSB7XG4gICAgICBjYXNlIFwicmdiXCI6IHtcbiAgICAgICAgY29uc3QgW28sIGksIHMsIGxdID0gb3QoZS5yZ2IsIHQucmdiLCBuKTtcbiAgICAgICAgcmV0dXJuIG5ldyAkKG8sIGksIHMsIGwsICExKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJoY2xcIjoge1xuICAgICAgICBjb25zdCBbbywgaSwgcywgbF0gPSBlLmhjbCwgW3UsIGMsIHAsIGRdID0gdC5oY2w7XG4gICAgICAgIGxldCBmLCBoO1xuICAgICAgICBpZiAoIWlzTmFOKG8pICYmICFpc05hTih1KSkge1xuICAgICAgICAgIGxldCB4ID0gdSAtIG87XG4gICAgICAgICAgdSA+IG8gJiYgeCA+IDE4MCA/IHggLT0gMzYwIDogdSA8IG8gJiYgbyAtIHUgPiAxODAgJiYgKHggKz0gMzYwKSwgZiA9IG8gKyBuICogeDtcbiAgICAgICAgfSBlbHNlIGlzTmFOKG8pID8gaXNOYU4odSkgPyBmID0gTmFOIDogKGYgPSB1LCAocyA9PT0gMSB8fCBzID09PSAwKSAmJiAoaCA9IGMpKSA6IChmID0gbywgKHAgPT09IDEgfHwgcCA9PT0gMCkgJiYgKGggPSBpKSk7XG4gICAgICAgIGNvbnN0IFttLCB5LCB3LCB2XSA9IFpzKFtcbiAgICAgICAgICBmLFxuICAgICAgICAgIGggPz8gTmUoaSwgYywgbiksXG4gICAgICAgICAgTmUocywgcCwgbiksXG4gICAgICAgICAgTmUobCwgZCwgbilcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBuZXcgJChtLCB5LCB3LCB2LCAhMSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGFiXCI6IHtcbiAgICAgICAgY29uc3QgW28sIGksIHMsIGxdID0gc28ob3QoZS5sYWIsIHQubGFiLCBuKSk7XG4gICAgICAgIHJldHVybiBuZXcgJChvLCBpLCBzLCBsLCAhMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4kLmJsYWNrID0gbmV3ICQoMCwgMCwgMCwgMSk7XG4kLndoaXRlID0gbmV3ICQoMSwgMSwgMSwgMSk7XG4kLnRyYW5zcGFyZW50ID0gbmV3ICQoMCwgMCwgMCwgMCk7XG4kLnJlZCA9IG5ldyAkKDEsIDAsIDAsIDEpO1xuY2xhc3MgeW4ge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgZSA/IHRoaXMuc2Vuc2l0aXZpdHkgPSB0ID8gXCJ2YXJpYW50XCIgOiBcImNhc2VcIiA6IHRoaXMuc2Vuc2l0aXZpdHkgPSB0ID8gXCJhY2NlbnRcIiA6IFwiYmFzZVwiLCB0aGlzLmxvY2FsZSA9IG4sIHRoaXMuY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10sIHsgc2Vuc2l0aXZpdHk6IHRoaXMuc2Vuc2l0aXZpdHksIHVzYWdlOiBcInNlYXJjaFwiIH0pO1xuICB9XG4gIGNvbXBhcmUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhdG9yLmNvbXBhcmUoZSwgdCk7XG4gIH1cbiAgcmVzb2x2ZWRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xuICB9XG59XG5jb25zdCBKcyA9IFtcImJvdHRvbVwiLCBcImNlbnRlclwiLCBcInRvcFwiXTtcbmNsYXNzIFpyIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSwgbywgaSkge1xuICAgIHRoaXMudGV4dCA9IGUsIHRoaXMuaW1hZ2UgPSB0LCB0aGlzLnNjYWxlID0gbiwgdGhpcy5mb250U3RhY2sgPSBhLCB0aGlzLnRleHRDb2xvciA9IG8sIHRoaXMudmVydGljYWxBbGlnbiA9IGk7XG4gIH1cbn1cbmNsYXNzIEFlIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuc2VjdGlvbnMgPSBlO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKGUpIHtcbiAgICByZXR1cm4gbmV3IEFlKFtuZXcgWnIoZSwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCldKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCA/ICEwIDogIXRoaXMuc2VjdGlvbnMuc29tZSgoZSkgPT4gZS50ZXh0Lmxlbmd0aCAhPT0gMCB8fCBlLmltYWdlICYmIGUuaW1hZ2UubmFtZS5sZW5ndGggIT09IDApO1xuICB9XG4gIHN0YXRpYyBmYWN0b3J5KGUpIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEFlID8gZSA6IEFlLmZyb21TdHJpbmcoZSk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwID8gXCJcIiA6IHRoaXMuc2VjdGlvbnMubWFwKChlKSA9PiBlLnRleHQpLmpvaW4oXCJcIik7XG4gIH1cbn1cbmNsYXNzIGllIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudmFsdWVzID0gZS5zbGljZSgpO1xuICB9XG4gIC8qKlxuICAgKiBOdW1lcmljIHBhZGRpbmcgdmFsdWVzXG4gICAqIEBwYXJhbSBpbnB1dCBBIHBhZGRpbmcgdmFsdWVcbiAgICogQHJldHVybnMgQSBgUGFkZGluZ2AgaW5zdGFuY2UsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCBwYWRkaW5nIHZhbHVlLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIGllKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gbmV3IGllKFtlLCBlLCBlLCBlXSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkgJiYgIShlLmxlbmd0aCA8IDEgfHwgZS5sZW5ndGggPiA0KSkge1xuICAgICAgZm9yIChjb25zdCB0IG9mIGUpXG4gICAgICAgIGlmICh0eXBlb2YgdCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGUgPSBbZVswXSwgZVswXSwgZVswXSwgZVswXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBlID0gW2VbMF0sIGVbMV0sIGVbMF0sIGVbMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZSA9IFtlWzBdLCBlWzFdLCBlWzJdLCBlWzFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgaWUoZSk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGludGVycG9sYXRlKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gbmV3IGllKG90KGUudmFsdWVzLCB0LnZhbHVlcywgbikpO1xuICB9XG59XG5jbGFzcyBzZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnZhbHVlcyA9IGUuc2xpY2UoKTtcbiAgfVxuICAvKipcbiAgICogTnVtZXJpYyBOdW1iZXJBcnJheSB2YWx1ZXNcbiAgICogQHBhcmFtIGlucHV0IEEgTnVtYmVyQXJyYXkgdmFsdWVcbiAgICogQHJldHVybnMgQSBgTnVtYmVyQXJyYXlgIGluc3RhbmNlLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgTnVtYmVyQXJyYXkgdmFsdWUuXG4gICAqL1xuICBzdGF0aWMgcGFyc2UoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2Ygc2UpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBuZXcgc2UoW2VdKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZm9yIChjb25zdCB0IG9mIGUpXG4gICAgICAgIGlmICh0eXBlb2YgdCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIHJldHVybiBuZXcgc2UoZSk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGludGVycG9sYXRlKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gbmV3IHNlKG90KGUudmFsdWVzLCB0LnZhbHVlcywgbikpO1xuICB9XG59XG5jbGFzcyBRIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudmFsdWVzID0gZS5zbGljZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDb2xvckFycmF5IHZhbHVlc1xuICAgKiBAcGFyYW0gaW5wdXQgQSBDb2xvckFycmF5IHZhbHVlXG4gICAqIEByZXR1cm5zIEEgYENvbG9yQXJyYXlgIGluc3RhbmNlLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgQ29sb3JBcnJheSB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBwYXJzZShlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBRKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IG4gPSAkLnBhcnNlKGUpO1xuICAgICAgcmV0dXJuIG4gPyBuZXcgUShbbl0pIDogdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBlKSB7XG4gICAgICBpZiAodHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYSA9ICQucGFyc2Uobik7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHQucHVzaChhKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBRKHQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGludGVycG9sYXRlKGUsIHQsIG4sIGEgPSBcInJnYlwiKSB7XG4gICAgY29uc3QgbyA9IFtdO1xuICAgIGlmIChlLnZhbHVlcy5sZW5ndGggIT0gdC52YWx1ZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2xvckFycmF5OiBBcnJheXMgaGF2ZSBtaXNtYXRjaGVkIGxlbmd0aCAoJHtlLnZhbHVlcy5sZW5ndGh9IHZzLiAke3QudmFsdWVzLmxlbmd0aH0pLCBjYW5ub3QgaW50ZXJwb2xhdGUuYCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLnZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgIG8ucHVzaCgkLmludGVycG9sYXRlKGUudmFsdWVzW2ldLCB0LnZhbHVlc1tpXSwgbiwgYSkpO1xuICAgIHJldHVybiBuZXcgUShvKTtcbiAgfVxufVxuY2xhc3MgVSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9XG59XG5jb25zdCBRcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImNlbnRlclwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcInRvcC1sZWZ0XCIsIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgXCJib3R0b20tcmlnaHRcIl0pO1xuY2xhc3MgeWUge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBlLnNsaWNlKCk7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIHllKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKCEoIUFycmF5LmlzQXJyYXkoZSkgfHwgZS5sZW5ndGggPCAxIHx8IGUubGVuZ3RoICUgMiAhPT0gMCkpIHtcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMikge1xuICAgICAgICBjb25zdCBuID0gZVt0XSwgYSA9IGVbdCArIDFdO1xuICAgICAgICBpZiAodHlwZW9mIG4gIT0gXCJzdHJpbmdcIiB8fCAhUXMuaGFzKG4pIHx8ICFBcnJheS5pc0FycmF5KGEpIHx8IGEubGVuZ3RoICE9PSAyIHx8IHR5cGVvZiBhWzBdICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGFbMV0gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHllKGUpO1xuICAgIH1cbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZXMpO1xuICB9XG4gIHN0YXRpYyBpbnRlcnBvbGF0ZShlLCB0LCBuKSB7XG4gICAgY29uc3QgYSA9IGUudmFsdWVzLCBvID0gdC52YWx1ZXM7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBvLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBVKGBDYW5ub3QgaW50ZXJwb2xhdGUgdmFsdWVzIG9mIGRpZmZlcmVudCBsZW5ndGguIGZyb206ICR7ZS50b1N0cmluZygpfSwgdG86ICR7dC50b1N0cmluZygpfWApO1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IGEubGVuZ3RoOyBzICs9IDIpIHtcbiAgICAgIGlmIChhW3NdICE9PSBvW3NdKVxuICAgICAgICB0aHJvdyBuZXcgVShgQ2Fubm90IGludGVycG9sYXRlIHZhbHVlcyBjb250YWluaW5nIG1pc21hdGNoZWQgYW5jaG9ycy4gZnJvbVske3N9XTogJHthW3NdfSwgdG9bJHtzfV06ICR7b1tzXX1gKTtcbiAgICAgIGkucHVzaChhW3NdKTtcbiAgICAgIGNvbnN0IFtsLCB1XSA9IGFbcyArIDFdLCBbYywgcF0gPSBvW3MgKyAxXTtcbiAgICAgIGkucHVzaChbTmUobCwgYywgbiksIE5lKHUsIHAsIG4pXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgeWUoaSk7XG4gIH1cbn1cbmNsYXNzIERlIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMubmFtZSA9IGUubmFtZSwgdGhpcy5hdmFpbGFibGUgPSBlLmF2YWlsYWJsZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKGUpIHtcbiAgICByZXR1cm4gZSA/IG5ldyBEZSh7IG5hbWU6IGUsIGF2YWlsYWJsZTogITEgfSkgOiBudWxsO1xuICB9XG59XG5jbGFzcyBkZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLnRvID0gdCwgdGhpcy50cmFuc2l0aW9uID0gbjtcbiAgfVxuICBzdGF0aWMgaW50ZXJwb2xhdGUoZSwgdCwgbikge1xuICAgIHJldHVybiBuZXcgZGUoZSwgdCwgbik7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIGRlKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkgJiYgZS5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVbMF0gPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZVsxXSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlWzJdID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gbmV3IGRlKGVbMF0sIGVbMV0sIGVbMl0pO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBlLmZyb20gPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZS50byA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlLnRyYW5zaXRpb24gPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBuZXcgZGUoZS5mcm9tLCBlLnRvLCBlLnRyYW5zaXRpb24pO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIG5ldyBkZShlLCBlLCAxKTtcbiAgfVxufVxuZnVuY3Rpb24gbG8ociwgZSwgdCwgbikge1xuICByZXR1cm4gdHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiByID49IDAgJiYgciA8PSAyNTUgJiYgdHlwZW9mIGUgPT0gXCJudW1iZXJcIiAmJiBlID49IDAgJiYgZSA8PSAyNTUgJiYgdHlwZW9mIHQgPT0gXCJudW1iZXJcIiAmJiB0ID49IDAgJiYgdCA8PSAyNTUgPyB0eXBlb2YgbiA+IFwidVwiIHx8IHR5cGVvZiBuID09IFwibnVtYmVyXCIgJiYgbiA+PSAwICYmIG4gPD0gMSA/IG51bGwgOiBgSW52YWxpZCByZ2JhIHZhbHVlIFske1tyLCBlLCB0LCBuXS5qb2luKFwiLCBcIil9XTogJ2EnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLmAgOiBgSW52YWxpZCByZ2JhIHZhbHVlIFskeyh0eXBlb2YgbiA9PSBcIm51bWJlclwiID8gW3IsIGUsIHQsIG5dIDogW3IsIGUsIHRdKS5qb2luKFwiLCBcIil9XTogJ3InLCAnZycsIGFuZCAnYicgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS5gO1xufVxuZnVuY3Rpb24gd3Qocikge1xuICBpZiAociA9PT0gbnVsbCB8fCB0eXBlb2YgciA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiByID09IFwibnVtYmVyXCIgfHwgciBpbnN0YW5jZW9mIGRlIHx8IHIgaW5zdGFuY2VvZiAkIHx8IHIgaW5zdGFuY2VvZiB5biB8fCByIGluc3RhbmNlb2YgQWUgfHwgciBpbnN0YW5jZW9mIGllIHx8IHIgaW5zdGFuY2VvZiBzZSB8fCByIGluc3RhbmNlb2YgUSB8fCByIGluc3RhbmNlb2YgeWUgfHwgciBpbnN0YW5jZW9mIERlKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgcilcbiAgICAgIGlmICghd3QoZSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJvYmplY3RcIikge1xuICAgIGZvciAoY29uc3QgZSBpbiByKVxuICAgICAgaWYgKCF3dChyW2VdKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcShyKSB7XG4gIGlmIChyID09PSBudWxsKVxuICAgIHJldHVybiBzcjtcbiAgaWYgKHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIFA7XG4gIGlmICh0eXBlb2YgciA9PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gTTtcbiAgaWYgKHR5cGVvZiByID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIFM7XG4gIGlmIChyIGluc3RhbmNlb2YgJClcbiAgICByZXR1cm4gU2U7XG4gIGlmIChyIGluc3RhbmNlb2YgZGUpXG4gICAgcmV0dXJuIGxyO1xuICBpZiAociBpbnN0YW5jZW9mIHluKVxuICAgIHJldHVybiB1cjtcbiAgaWYgKHIgaW5zdGFuY2VvZiBBZSlcbiAgICByZXR1cm4gY3I7XG4gIGlmIChyIGluc3RhbmNlb2YgaWUpXG4gICAgcmV0dXJuIHByO1xuICBpZiAociBpbnN0YW5jZW9mIHNlKVxuICAgIHJldHVybiBmcjtcbiAgaWYgKHIgaW5zdGFuY2VvZiBRKVxuICAgIHJldHVybiB2dDtcbiAgaWYgKHIgaW5zdGFuY2VvZiB5ZSlcbiAgICByZXR1cm4gZHI7XG4gIGlmIChyIGluc3RhbmNlb2YgRGUpXG4gICAgcmV0dXJuIF90O1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkge1xuICAgIGNvbnN0IGUgPSByLmxlbmd0aDtcbiAgICBsZXQgdDtcbiAgICBmb3IgKGNvbnN0IG4gb2Ygcikge1xuICAgICAgY29uc3QgYSA9IHEobik7XG4gICAgICBpZiAoIXQpXG4gICAgICAgIHQgPSBhO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0ID09PSBhKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0ID0gSTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZSh0IHx8IEksIGUpO1xuICB9IGVsc2VcbiAgICByZXR1cm4gVmU7XG59XG5mdW5jdGlvbiB5dChyKSB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgcjtcbiAgcmV0dXJuIHIgPT09IG51bGwgPyBcIlwiIDogZSA9PT0gXCJzdHJpbmdcIiB8fCBlID09PSBcIm51bWJlclwiIHx8IGUgPT09IFwiYm9vbGVhblwiID8gU3RyaW5nKHIpIDogciBpbnN0YW5jZW9mICQgfHwgciBpbnN0YW5jZW9mIGRlIHx8IHIgaW5zdGFuY2VvZiBBZSB8fCByIGluc3RhbmNlb2YgaWUgfHwgciBpbnN0YW5jZW9mIHNlIHx8IHIgaW5zdGFuY2VvZiBRIHx8IHIgaW5zdGFuY2VvZiB5ZSB8fCByIGluc3RhbmNlb2YgRGUgPyByLnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeShyKTtcbn1cbmNsYXNzIGl0IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMudmFsdWUgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYCdsaXRlcmFsJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgaWYgKCF3dChlWzFdKSlcbiAgICAgIHJldHVybiB0LmVycm9yKFwiaW52YWxpZCB2YWx1ZVwiKTtcbiAgICBjb25zdCBuID0gZVsxXTtcbiAgICBsZXQgYSA9IHEobik7XG4gICAgY29uc3QgbyA9IHQuZXhwZWN0ZWRUeXBlO1xuICAgIHJldHVybiBhLmtpbmQgPT09IFwiYXJyYXlcIiAmJiBhLk4gPT09IDAgJiYgbyAmJiBvLmtpbmQgPT09IFwiYXJyYXlcIiAmJiAodHlwZW9mIG8uTiAhPSBcIm51bWJlclwiIHx8IG8uTiA9PT0gMCkgJiYgKGEgPSBvKSwgbmV3IGl0KGEsIG4pO1xuICB9XG4gIGV2YWx1YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIGVhY2hDaGlsZCgpIHtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxuY29uc3QgQnQgPSB7XG4gIHN0cmluZzogUCxcbiAgbnVtYmVyOiBTLFxuICBib29sZWFuOiBNLFxuICBvYmplY3Q6IFZlXG59O1xuY2xhc3MgaGUge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy5hcmdzID0gdDtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgbGV0IG4gPSAxLCBhO1xuICAgIGNvbnN0IG8gPSBlWzBdO1xuICAgIGlmIChvID09PSBcImFycmF5XCIpIHtcbiAgICAgIGxldCBzO1xuICAgICAgaWYgKGUubGVuZ3RoID4gMikge1xuICAgICAgICBjb25zdCB1ID0gZVsxXTtcbiAgICAgICAgaWYgKHR5cGVvZiB1ICE9IFwic3RyaW5nXCIgfHwgISh1IGluIEJ0KSB8fCB1ID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybiB0LmVycm9yKCdUaGUgaXRlbSB0eXBlIGFyZ3VtZW50IG9mIFwiYXJyYXlcIiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIG51bWJlciwgYm9vbGVhbicsIDEpO1xuICAgICAgICBzID0gQnRbdV0sIG4rKztcbiAgICAgIH0gZWxzZVxuICAgICAgICBzID0gSTtcbiAgICAgIGxldCBsO1xuICAgICAgaWYgKGUubGVuZ3RoID4gMykge1xuICAgICAgICBpZiAoZVsyXSAhPT0gbnVsbCAmJiAodHlwZW9mIGVbMl0gIT0gXCJudW1iZXJcIiB8fCBlWzJdIDwgMCB8fCBlWzJdICE9PSBNYXRoLmZsb29yKGVbMl0pKSlcbiAgICAgICAgICByZXR1cm4gdC5lcnJvcignVGhlIGxlbmd0aCBhcmd1bWVudCB0byBcImFycmF5XCIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGl0ZXJhbCcsIDIpO1xuICAgICAgICBsID0gZVsyXSwgbisrO1xuICAgICAgfVxuICAgICAgYSA9IG5lKHMsIGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIUJ0W29dKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGVzIGRvZXNuJ3QgY29udGFpbiBuYW1lID0gJHtvfWApO1xuICAgICAgYSA9IEJ0W29dO1xuICAgIH1cbiAgICBjb25zdCBpID0gW107XG4gICAgZm9yICg7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICBjb25zdCBzID0gdC5wYXJzZShlW25dLCBuLCBJKTtcbiAgICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgaGUoYSwgaSk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5hcmdzLmxlbmd0aDsgdCsrKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5hcmdzW3RdLmV2YWx1YXRlKGUpO1xuICAgICAgaWYgKGJ0KHRoaXMudHlwZSwgcShuKSkpIHtcbiAgICAgICAgaWYgKHQgPT09IHRoaXMuYXJncy5sZW5ndGggLSAxKVxuICAgICAgICAgIHRocm93IG5ldyBVKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlICR7RCh0aGlzLnR5cGUpfSwgYnV0IGZvdW5kICR7RChxKG4pKX0gaW5zdGVhZC5gKTtcbiAgICAgIH0gZWxzZSByZXR1cm4gbjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChlKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoKGUpID0+IGUub3V0cHV0RGVmaW5lZCgpKTtcbiAgfVxufVxuY29uc3Qgb2EgPSB7XG4gIFwidG8tYm9vbGVhblwiOiBNLFxuICBcInRvLWNvbG9yXCI6IFNlLFxuICBcInRvLW51bWJlclwiOiBTLFxuICBcInRvLXN0cmluZ1wiOiBQXG59O1xuY2xhc3MgJGUge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy5hcmdzID0gdDtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgY29uc3QgbiA9IGVbMF07XG4gICAgaWYgKCFvYVtuXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgJHtufSBhcyBpdCBpcyBub3QgcGFydCBvZiB0aGUga25vd24gdHlwZXNgKTtcbiAgICBpZiAoKG4gPT09IFwidG8tYm9vbGVhblwiIHx8IG4gPT09IFwidG8tc3RyaW5nXCIpICYmIGUubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBvbmUgYXJndW1lbnQuXCIpO1xuICAgIGNvbnN0IGEgPSBvYVtuXSwgbyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcyA9IHQucGFyc2UoZVtpXSwgaSwgSSk7XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgby5wdXNoKHMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3ICRlKGEsIG8pO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZS5raW5kKSB7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICByZXR1cm4gISF0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoZSk7XG4gICAgICBjYXNlIFwiY29sb3JcIjoge1xuICAgICAgICBsZXQgdCwgbjtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgIGlmICh0ID0gYS5ldmFsdWF0ZShlKSwgbiA9IG51bGwsIHQgaW5zdGFuY2VvZiAkKVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBlLnBhcnNlQ29sb3IodCk7XG4gICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHQpICYmICh0Lmxlbmd0aCA8IDMgfHwgdC5sZW5ndGggPiA0ID8gbiA9IGBJbnZhbGlkIHJnYmEgdmFsdWUgJHtKU09OLnN0cmluZ2lmeSh0KX06IGV4cGVjdGVkIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIHRocmVlIG9yIGZvdXIgbnVtZXJpYyB2YWx1ZXMuYCA6IG4gPSBsbyh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdKSwgIW4pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyAkKHRbMF0gLyAyNTUsIHRbMV0gLyAyNTUsIHRbMl0gLyAyNTUsIHRbM10pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBVKG4gfHwgYENvdWxkIG5vdCBwYXJzZSBjb2xvciBmcm9tIHZhbHVlICcke3R5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogSlNPTi5zdHJpbmdpZnkodCl9J2ApO1xuICAgICAgfVxuICAgICAgY2FzZSBcInBhZGRpbmdcIjoge1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgIHQgPSBuLmV2YWx1YXRlKGUpO1xuICAgICAgICAgIGNvbnN0IGEgPSBpZS5wYXJzZSh0KTtcbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBVKGBDb3VsZCBub3QgcGFyc2UgcGFkZGluZyBmcm9tIHZhbHVlICcke3R5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogSlNPTi5zdHJpbmdpZnkodCl9J2ApO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm51bWJlckFycmF5XCI6IHtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmFyZ3MpIHtcbiAgICAgICAgICB0ID0gbi5ldmFsdWF0ZShlKTtcbiAgICAgICAgICBjb25zdCBhID0gc2UucGFyc2UodCk7XG4gICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVShgQ291bGQgbm90IHBhcnNlIG51bWJlckFycmF5IGZyb20gdmFsdWUgJyR7dHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiBKU09OLnN0cmluZ2lmeSh0KX0nYCk7XG4gICAgICB9XG4gICAgICBjYXNlIFwiY29sb3JBcnJheVwiOiB7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hcmdzKSB7XG4gICAgICAgICAgdCA9IG4uZXZhbHVhdGUoZSk7XG4gICAgICAgICAgY29uc3QgYSA9IFEucGFyc2UodCk7XG4gICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVShgQ291bGQgbm90IHBhcnNlIGNvbG9yQXJyYXkgZnJvbSB2YWx1ZSAnJHt0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IEpTT04uc3RyaW5naWZ5KHQpfSdgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb25cIjoge1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgIHQgPSBuLmV2YWx1YXRlKGUpO1xuICAgICAgICAgIGNvbnN0IGEgPSB5ZS5wYXJzZSh0KTtcbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBVKGBDb3VsZCBub3QgcGFyc2UgdmFyaWFibGVBbmNob3JPZmZzZXRDb2xsZWN0aW9uIGZyb20gdmFsdWUgJyR7dHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiBKU09OLnN0cmluZ2lmeSh0KX0nYCk7XG4gICAgICB9XG4gICAgICBjYXNlIFwibnVtYmVyXCI6IHtcbiAgICAgICAgbGV0IHQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hcmdzKSB7XG4gICAgICAgICAgaWYgKHQgPSBuLmV2YWx1YXRlKGUpLCB0ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgYSA9IE51bWJlcih0KTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGEpKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFUoYENvdWxkIG5vdCBjb252ZXJ0ICR7SlNPTi5zdHJpbmdpZnkodCl9IHRvIG51bWJlci5gKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJmb3JtYXR0ZWRcIjpcbiAgICAgICAgcmV0dXJuIEFlLmZyb21TdHJpbmcoeXQodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGUpKSk7XG4gICAgICBjYXNlIFwicmVzb2x2ZWRJbWFnZVwiOlxuICAgICAgICByZXR1cm4gRGUuZnJvbVN0cmluZyh5dCh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoZSkpKTtcbiAgICAgIGNhc2UgXCJwcm9qZWN0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5hcmdzWzBdLmV2YWx1YXRlKGUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHl0KHRoaXMuYXJnc1swXS5ldmFsdWF0ZShlKSk7XG4gICAgfVxuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goZSk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KChlKSA9PiBlLm91dHB1dERlZmluZWQoKSk7XG4gIH1cbn1cbmNvbnN0IGVsID0gW1wiVW5rbm93blwiLCBcIlBvaW50XCIsIFwiTGluZVN0cmluZ1wiLCBcIlBvbHlnb25cIl07XG5jbGFzcyB1byB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ2xvYmFscyA9IG51bGwsIHRoaXMuZmVhdHVyZSA9IG51bGwsIHRoaXMuZmVhdHVyZVN0YXRlID0gbnVsbCwgdGhpcy5mb3JtYXR0ZWRTZWN0aW9uID0gbnVsbCwgdGhpcy5fcGFyc2VDb2xvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5hdmFpbGFibGVJbWFnZXMgPSBudWxsLCB0aGlzLmNhbm9uaWNhbCA9IG51bGw7XG4gIH1cbiAgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiBcImlkXCIgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmlkIDogbnVsbDtcbiAgfVxuICBnZW9tZXRyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSA/IHR5cGVvZiB0aGlzLmZlYXR1cmUudHlwZSA9PSBcIm51bWJlclwiID8gZWxbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsO1xuICB9XG4gIGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgXCJnZW9tZXRyeVwiIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5nZW9tZXRyeSA6IG51bGw7XG4gIH1cbiAgY2Fub25pY2FsSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsO1xuICB9XG4gIHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgfVxuICBwYXJzZUNvbG9yKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMuX3BhcnNlQ29sb3JDYWNoZS5nZXQoZSk7XG4gICAgcmV0dXJuIHQgfHwgKHQgPSAkLnBhcnNlKGUpLCB0aGlzLl9wYXJzZUNvbG9yQ2FjaGUuc2V0KGUsIHQpKSwgdDtcbiAgfVxufVxuY2xhc3MgaHIge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuID0gW10sIGEsIG8gPSBuZXcgaG4oKSwgaSA9IFtdKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IGUsIHRoaXMucGF0aCA9IG4sIHRoaXMua2V5ID0gbi5tYXAoKHMpID0+IGBbJHtzfV1gKS5qb2luKFwiXCIpLCB0aGlzLnNjb3BlID0gbywgdGhpcy5lcnJvcnMgPSBpLCB0aGlzLmV4cGVjdGVkVHlwZSA9IGEsIHRoaXMuX2lzQ29uc3RhbnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gZXhwciB0aGUgSlNPTiBleHByZXNzaW9uIHRvIHBhcnNlXG4gICAqIEBwYXJhbSBpbmRleCB0aGUgb3B0aW9uYWwgYXJndW1lbnQgaW5kZXggaWYgdGhpcyBleHByZXNzaW9uIGlzIGFuIGFyZ3VtZW50IG9mIGEgcGFyZW50IGV4cHJlc3Npb24gdGhhdCdzIGJlaW5nIHBhcnNlZFxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5vbWl0VHlwZUFubm90YXRpb25zIHNldCB0cnVlIHRvIG9taXQgaW5mZXJyZWQgdHlwZSBhbm5vdGF0aW9ucy4gIENhbGxlciBiZXdhcmU6IHdpdGggdGhpcyBvcHRpb24gc2V0LCB0aGUgcGFyc2VkIGV4cHJlc3Npb24ncyB0eXBlIHdpbGwgTk9UIHNhdGlzZnkgYGV4cGVjdGVkVHlwZWAgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgd3JhcHBlZCBpbiBhbiBpbmZlcnJlZCBhbm5vdGF0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGFyc2UoZSwgdCwgbiwgYSwgbyA9IHt9KSB7XG4gICAgcmV0dXJuIHQgPyB0aGlzLmNvbmNhdCh0LCBuLCBhKS5fcGFyc2UoZSwgbykgOiB0aGlzLl9wYXJzZShlLCBvKTtcbiAgfVxuICBfcGFyc2UoZSwgdCkge1xuICAgIChlID09PSBudWxsIHx8IHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGUgPT0gXCJudW1iZXJcIikgJiYgKGUgPSBbXCJsaXRlcmFsXCIsIGVdKTtcbiAgICBmdW5jdGlvbiBuKGEsIG8sIGkpIHtcbiAgICAgIHJldHVybiBpID09PSBcImFzc2VydFwiID8gbmV3IGhlKG8sIFthXSkgOiBpID09PSBcImNvZXJjZVwiID8gbmV3ICRlKG8sIFthXSkgOiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFtdXS4nKTtcbiAgICAgIGNvbnN0IGEgPSBlWzBdO1xuICAgICAgaWYgKHR5cGVvZiBhICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKGBFeHByZXNzaW9uIG5hbWUgbXVzdCBiZSBhIHN0cmluZywgYnV0IGZvdW5kICR7dHlwZW9mIGF9IGluc3RlYWQuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uYCwgMCksIG51bGw7XG4gICAgICBjb25zdCBvID0gdGhpcy5yZWdpc3RyeVthXTtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGxldCBpID0gby5wYXJzZShlLCB0aGlzKTtcbiAgICAgICAgaWYgKCFpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5leHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICBjb25zdCBzID0gdGhpcy5leHBlY3RlZFR5cGUsIGwgPSBpLnR5cGU7XG4gICAgICAgICAgaWYgKChzLmtpbmQgPT09IFwic3RyaW5nXCIgfHwgcy5raW5kID09PSBcIm51bWJlclwiIHx8IHMua2luZCA9PT0gXCJib29sZWFuXCIgfHwgcy5raW5kID09PSBcIm9iamVjdFwiIHx8IHMua2luZCA9PT0gXCJhcnJheVwiKSAmJiBsLmtpbmQgPT09IFwidmFsdWVcIilcbiAgICAgICAgICAgIGkgPSBuKGksIHMsIHQudHlwZUFubm90YXRpb24gfHwgXCJhc3NlcnRcIik7XG4gICAgICAgICAgZWxzZSBpZiAocy5raW5kID09PSBcInByb2plY3Rpb25EZWZpbml0aW9uXCIgJiYgW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0uaW5jbHVkZXMobC5raW5kKSB8fCBbXCJjb2xvclwiLCBcImZvcm1hdHRlZFwiLCBcInJlc29sdmVkSW1hZ2VcIl0uaW5jbHVkZXMocy5raW5kKSAmJiBbXCJ2YWx1ZVwiLCBcInN0cmluZ1wiXS5pbmNsdWRlcyhsLmtpbmQpIHx8IFtcInBhZGRpbmdcIiwgXCJudW1iZXJBcnJheVwiXS5pbmNsdWRlcyhzLmtpbmQpICYmIFtcInZhbHVlXCIsIFwibnVtYmVyXCIsIFwiYXJyYXlcIl0uaW5jbHVkZXMobC5raW5kKSB8fCBzLmtpbmQgPT09IFwiY29sb3JBcnJheVwiICYmIFtcInZhbHVlXCIsIFwic3RyaW5nXCIsIFwiYXJyYXlcIl0uaW5jbHVkZXMobC5raW5kKSB8fCBzLmtpbmQgPT09IFwidmFyaWFibGVBbmNob3JPZmZzZXRDb2xsZWN0aW9uXCIgJiYgW1widmFsdWVcIiwgXCJhcnJheVwiXS5pbmNsdWRlcyhsLmtpbmQpKVxuICAgICAgICAgICAgaSA9IG4oaSwgcywgdC50eXBlQW5ub3RhdGlvbiB8fCBcImNvZXJjZVwiKTtcbiAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoZWNrU3VidHlwZShzLCBsKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGkgaW5zdGFuY2VvZiBpdCkgJiYgaS50eXBlLmtpbmQgIT09IFwicmVzb2x2ZWRJbWFnZVwiICYmIHRoaXMuX2lzQ29uc3RhbnQoaSkpIHtcbiAgICAgICAgICBjb25zdCBzID0gbmV3IHVvKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGkgPSBuZXcgaXQoaS50eXBlLCBpLmV2YWx1YXRlKHMpKTtcbiAgICAgICAgICB9IGNhdGNoIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihsLm1lc3NhZ2UpLCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVycm9yKGBVbmtub3duIGV4cHJlc3Npb24gXCIke2F9XCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uYCwgMCk7XG4gICAgfSBlbHNlIHJldHVybiB0eXBlb2YgZSA+IFwidVwiID8gdGhpcy5lcnJvcihcIid1bmRlZmluZWQnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuXCIpIDogdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IHRoaXMuZXJyb3IoJ0JhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1wibGl0ZXJhbFwiLCB7Li4ufV0gaW5zdGVhZC4nKSA6IHRoaXMuZXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgZm91bmQgJHt0eXBlb2YgZX0gaW5zdGVhZC5gKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBjb250ZXh0IHN1aXRhYmxlIGZvciBwYXJzaW5nIHRoZSBzdWJleHByZXNzaW9uIGF0XG4gICAqIGluZGV4IGBpbmRleGAsIG9wdGlvbmFsbHkgYXBwZW5kaW5nIHRvICdsZXQnIGJpbmRpbmcgbWFwLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYGVycm9yc2AgcHJvcGVydHksIGludGVuZGVkIGZvciBjb2xsZWN0aW5nIGVycm9ycyB3aGlsZVxuICAgKiBwYXJzaW5nLCBpcyBjb3BpZWQgYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGNsb25lZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbmNhdChlLCB0LCBuKSB7XG4gICAgY29uc3QgYSA9IHR5cGVvZiBlID09IFwibnVtYmVyXCIgPyB0aGlzLnBhdGguY29uY2F0KGUpIDogdGhpcy5wYXRoLCBvID0gbiA/IHRoaXMuc2NvcGUuY29uY2F0KG4pIDogdGhpcy5zY29wZTtcbiAgICByZXR1cm4gbmV3IGhyKHRoaXMucmVnaXN0cnksIHRoaXMuX2lzQ29uc3RhbnQsIGEsIHQgfHwgbnVsbCwgbywgdGhpcy5lcnJvcnMpO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIGEgcGFyc2luZyAob3IgdHlwZSBjaGVja2luZykgZXJyb3IgaW50byB0aGUgYHRoaXMuZXJyb3JzYFxuICAgKiBAcGFyYW0gZXJyb3IgVGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIGtleXMgT3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGF0IGEgY2hpbGRcbiAgICogb2YgdGhlIGN1cnJlbnQgZXhwcmVzc2lvbiBhdCBgdGhpcy5rZXlgLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXJyb3IoZSwgLi4udCkge1xuICAgIGNvbnN0IG4gPSBgJHt0aGlzLmtleX0ke3QubWFwKChhKSA9PiBgWyR7YX1dYCkuam9pbihcIlwiKX1gO1xuICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IHdlKG4sIGUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBudWxsIGlmIGB0YCBpcyBhIHN1YnR5cGUgb2YgYGV4cGVjdGVkYDsgb3RoZXJ3aXNlIHJldHVybnMgYW5cbiAgICogZXJyb3IgbWVzc2FnZSBhbmQgYWxzbyBwdXNoZXMgaXQgdG8gYHRoaXMuZXJyb3JzYC5cbiAgICogQHBhcmFtIGV4cGVjdGVkIFRoZSBleHBlY3RlZCB0eXBlXG4gICAqIEBwYXJhbSB0IFRoZSBhY3R1YWwgdHlwZVxuICAgKiBAcmV0dXJucyBudWxsIGlmIGB0YCBpcyBhIHN1YnR5cGUgb2YgYGV4cGVjdGVkYDsgb3RoZXJ3aXNlIHJldHVybnMgYW4gZXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgY2hlY2tTdWJ0eXBlKGUsIHQpIHtcbiAgICBjb25zdCBuID0gYnQoZSwgdCk7XG4gICAgcmV0dXJuIG4gJiYgdGhpcy5lcnJvcihuKSwgbjtcbiAgfVxufVxuY2xhc3MgbXIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gdC50eXBlLCB0aGlzLmJpbmRpbmdzID0gW10uY29uY2F0KGUpLCB0aGlzLnJlc3VsdCA9IHQ7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5ldmFsdWF0ZShlKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLmJpbmRpbmdzKVxuICAgICAgZSh0WzFdKTtcbiAgICBlKHRoaXMucmVzdWx0KTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8IDQpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBjb25zdCBuID0gW107XG4gICAgZm9yIChsZXQgbyA9IDE7IG8gPCBlLmxlbmd0aCAtIDE7IG8gKz0gMikge1xuICAgICAgY29uc3QgaSA9IGVbb107XG4gICAgICBpZiAodHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kICR7dHlwZW9mIGl9IGluc3RlYWQuYCwgbyk7XG4gICAgICBpZiAoL1teYS16QS1aMC05X10vLnRlc3QoaSkpXG4gICAgICAgIHJldHVybiB0LmVycm9yKFwiVmFyaWFibGUgbmFtZXMgbXVzdCBjb250YWluIG9ubHkgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3IgJ18nLlwiLCBvKTtcbiAgICAgIGNvbnN0IHMgPSB0LnBhcnNlKGVbbyArIDFdLCBvICsgMSk7XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbi5wdXNoKFtpLCBzXSk7XG4gICAgfVxuICAgIGNvbnN0IGEgPSB0LnBhcnNlKGVbZS5sZW5ndGggLSAxXSwgZS5sZW5ndGggLSAxLCB0LmV4cGVjdGVkVHlwZSwgbik7XG4gICAgcmV0dXJuIGEgPyBuZXcgbXIobiwgYSkgOiBudWxsO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0Lm91dHB1dERlZmluZWQoKTtcbiAgfVxufVxuY2xhc3MgeXIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gdC50eXBlLCB0aGlzLm5hbWUgPSBlLCB0aGlzLmJvdW5kRXhwcmVzc2lvbiA9IHQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGVbMV0gIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0LmVycm9yKFwiJ3ZhcicgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBzdHJpbmcgbGl0ZXJhbCBhcmd1bWVudC5cIik7XG4gICAgY29uc3QgbiA9IGVbMV07XG4gICAgcmV0dXJuIHQuc2NvcGUuaGFzKG4pID8gbmV3IHlyKG4sIHQuc2NvcGUuZ2V0KG4pKSA6IHQuZXJyb3IoYFVua25vd24gdmFyaWFibGUgXCIke259XCIuIE1ha2Ugc3VyZSBcIiR7bn1cIiBoYXMgYmVlbiBib3VuZCBpbiBhbiBlbmNsb3NpbmcgXCJsZXRcIiBleHByZXNzaW9uIGJlZm9yZSB1c2luZyBpdC5gLCAxKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRFeHByZXNzaW9uLmV2YWx1YXRlKGUpO1xuICB9XG4gIGVhY2hDaGlsZCgpIHtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuY2xhc3MgZ24ge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy5pbmRleCA9IHQsIHRoaXMuaW5wdXQgPSBuO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAzKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSwgUyksIGEgPSB0LnBhcnNlKGVbMl0sIDIsIG5lKHQuZXhwZWN0ZWRUeXBlIHx8IEkpKTtcbiAgICBpZiAoIW4gfHwgIWEpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBvID0gYS50eXBlO1xuICAgIHJldHVybiBuZXcgZ24oby5pdGVtVHlwZSwgbiwgYSk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmluZGV4LmV2YWx1YXRlKGUpLCBuID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShlKTtcbiAgICBpZiAodCA8IDApXG4gICAgICB0aHJvdyBuZXcgVShgQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJHt0fSA8IDAuYCk7XG4gICAgaWYgKHQgPj0gbi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgVShgQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogJHt0fSA+ICR7bi5sZW5ndGggLSAxfS5gKTtcbiAgICBpZiAodCAhPT0gTWF0aC5mbG9vcih0KSlcbiAgICAgIHRocm93IG5ldyBVKGBBcnJheSBpbmRleCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBmb3VuZCAke3R9IGluc3RlYWQuYCk7XG4gICAgcmV0dXJuIG5bdF07XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMuaW5kZXgpLCBlKHRoaXMuaW5wdXQpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyB2biB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSBNLCB0aGlzLm5lZWRsZSA9IGUsIHRoaXMuaGF5c3RhY2sgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAzKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSwgSSksIGEgPSB0LnBhcnNlKGVbMl0sIDIsIEkpO1xuICAgIHJldHVybiAhbiB8fCAhYSA/IG51bGwgOiBtbihuLnR5cGUsIFtNLCBQLCBTLCBzciwgSV0pID8gbmV3IHZuKG4sIGEpIDogdC5lcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJHtEKG4udHlwZSl9IGluc3RlYWRgKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubmVlZGxlLmV2YWx1YXRlKGUpLCBuID0gdGhpcy5oYXlzdGFjay5ldmFsdWF0ZShlKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKCFHZSh0LCBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwibnVsbFwiXSkpXG4gICAgICB0aHJvdyBuZXcgVShgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJHtEKHEodCkpfSBpbnN0ZWFkLmApO1xuICAgIGlmICghR2UobiwgW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0pKVxuICAgICAgdGhyb3cgbmV3IFUoYEV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICR7RChxKG4pKX0gaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gbi5pbmRleE9mKHQpID49IDA7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMubmVlZGxlKSwgZSh0aGlzLmhheXN0YWNrKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxuY2xhc3MgV3Qge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgdGhpcy50eXBlID0gUywgdGhpcy5uZWVkbGUgPSBlLCB0aGlzLmhheXN0YWNrID0gdCwgdGhpcy5mcm9tSW5kZXggPSBuO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDw9IDIgfHwgZS5sZW5ndGggPj0gNSlcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCAzIG9yIDQgYXJndW1lbnRzLCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSwgSSksIGEgPSB0LnBhcnNlKGVbMl0sIDIsIEkpO1xuICAgIGlmICghbiB8fCAhYSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICghbW4obi50eXBlLCBbTSwgUCwgUywgc3IsIEldKSlcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAke0Qobi50eXBlKX0gaW5zdGVhZGApO1xuICAgIGlmIChlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3QgbyA9IHQucGFyc2UoZVszXSwgMywgUyk7XG4gICAgICByZXR1cm4gbyA/IG5ldyBXdChuLCBhLCBvKSA6IG51bGw7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gbmV3IFd0KG4sIGEpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUoZSksIG4gPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGUpO1xuICAgIGlmICghR2UodCwgW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcIm51bGxcIl0pKVxuICAgICAgdGhyb3cgbmV3IFUoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICR7RChxKHQpKX0gaW5zdGVhZC5gKTtcbiAgICBsZXQgYTtcbiAgICBpZiAodGhpcy5mcm9tSW5kZXggJiYgKGEgPSB0aGlzLmZyb21JbmRleC5ldmFsdWF0ZShlKSksIEdlKG4sIFtcInN0cmluZ1wiXSkpIHtcbiAgICAgIGNvbnN0IG8gPSBuLmluZGV4T2YodCwgYSk7XG4gICAgICByZXR1cm4gbyA9PT0gLTEgPyAtMSA6IFsuLi5uLnNsaWNlKDAsIG8pXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChHZShuLCBbXCJhcnJheVwiXSkpXG4gICAgICAgIHJldHVybiBuLmluZGV4T2YodCwgYSk7XG4gICAgICB0aHJvdyBuZXcgVShgRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHtEKHEobikpfSBpbnN0ZWFkLmApO1xuICAgIH1cbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5uZWVkbGUpLCBlKHRoaXMuaGF5c3RhY2spLCB0aGlzLmZyb21JbmRleCAmJiBlKHRoaXMuZnJvbUluZGV4KTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuY2xhc3MgYm4ge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgdGhpcy5pbnB1dFR5cGUgPSBlLCB0aGlzLnR5cGUgPSB0LCB0aGlzLmlucHV0ID0gbiwgdGhpcy5jYXNlcyA9IGEsIHRoaXMub3V0cHV0cyA9IG8sIHRoaXMub3RoZXJ3aXNlID0gaTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8IDUpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5ICR7ZS5sZW5ndGggLSAxfS5gKTtcbiAgICBpZiAoZS5sZW5ndGggJSAyICE9PSAxKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgIGxldCBuLCBhO1xuICAgIHQuZXhwZWN0ZWRUeXBlICYmIHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09IFwidmFsdWVcIiAmJiAoYSA9IHQuZXhwZWN0ZWRUeXBlKTtcbiAgICBjb25zdCBvID0ge30sIGkgPSBbXTtcbiAgICBmb3IgKGxldCB1ID0gMjsgdSA8IGUubGVuZ3RoIC0gMTsgdSArPSAyKSB7XG4gICAgICBsZXQgYyA9IGVbdV07XG4gICAgICBjb25zdCBwID0gZVt1ICsgMV07XG4gICAgICBBcnJheS5pc0FycmF5KGMpIHx8IChjID0gW2NdKTtcbiAgICAgIGNvbnN0IGQgPSB0LmNvbmNhdCh1KTtcbiAgICAgIGlmIChjLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYnJhbmNoIGxhYmVsLlwiKTtcbiAgICAgIGZvciAoY29uc3QgaCBvZiBjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaCAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBoICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIGQuZXJyb3IoXCJCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLlwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoID09IFwibnVtYmVyXCIgJiYgTWF0aC5hYnMoaCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICByZXR1cm4gZC5lcnJvcihgQnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXJzIG5vIGxhcmdlciB0aGFuICR7TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ9LmApO1xuICAgICAgICBpZiAodHlwZW9mIGggPT0gXCJudW1iZXJcIiAmJiBNYXRoLmZsb29yKGgpICE9PSBoKVxuICAgICAgICAgIHJldHVybiBkLmVycm9yKFwiTnVtZXJpYyBicmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlciB2YWx1ZXMuXCIpO1xuICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgbiA9IHEoaCk7XG4gICAgICAgIGVsc2UgaWYgKGQuY2hlY2tTdWJ0eXBlKG4sIHEoaCkpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG9bU3RyaW5nKGgpXSA8IFwidVwiKVxuICAgICAgICAgIHJldHVybiBkLmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIHVuaXF1ZS5cIik7XG4gICAgICAgIG9bU3RyaW5nKGgpXSA9IGkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29uc3QgZiA9IHQucGFyc2UocCwgdSwgYSk7XG4gICAgICBpZiAoIWYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgYSA9IGEgfHwgZi50eXBlLCBpLnB1c2goZik7XG4gICAgfVxuICAgIGNvbnN0IHMgPSB0LnBhcnNlKGVbMV0sIDEsIEkpO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGwgPSB0LnBhcnNlKGVbZS5sZW5ndGggLSAxXSwgZS5sZW5ndGggLSAxLCBhKTtcbiAgICByZXR1cm4gIWwgfHwgcy50eXBlLmtpbmQgIT09IFwidmFsdWVcIiAmJiB0LmNvbmNhdCgxKS5jaGVja1N1YnR5cGUobiwgcy50eXBlKSA/IG51bGwgOiBuZXcgYm4obiwgYSwgcywgbywgaSwgbCk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGUpO1xuICAgIHJldHVybiAocSh0KSA9PT0gdGhpcy5pbnB1dFR5cGUgJiYgdGhpcy5vdXRwdXRzW3RoaXMuY2FzZXNbdF1dIHx8IHRoaXMub3RoZXJ3aXNlKS5ldmFsdWF0ZShlKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5pbnB1dCksIHRoaXMub3V0cHV0cy5mb3JFYWNoKGUpLCBlKHRoaXMub3RoZXJ3aXNlKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoKGUpID0+IGUub3V0cHV0RGVmaW5lZCgpKSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gIH1cbn1cbmNsYXNzIHduIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMuYnJhbmNoZXMgPSB0LCB0aGlzLm90aGVyd2lzZSA9IG47XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggPCA0KVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSAke2UubGVuZ3RoIC0gMX0uYCk7XG4gICAgaWYgKGUubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgIGxldCBuO1xuICAgIHQuZXhwZWN0ZWRUeXBlICYmIHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09IFwidmFsdWVcIiAmJiAobiA9IHQuZXhwZWN0ZWRUeXBlKTtcbiAgICBjb25zdCBhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBlLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgY29uc3QgcyA9IHQucGFyc2UoZVtpXSwgaSwgTSk7XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbCA9IHQucGFyc2UoZVtpICsgMV0sIGkgKyAxLCBuKTtcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBhLnB1c2goW3MsIGxdKSwgbiA9IG4gfHwgbC50eXBlO1xuICAgIH1cbiAgICBjb25zdCBvID0gdC5wYXJzZShlW2UubGVuZ3RoIC0gMV0sIGUubGVuZ3RoIC0gMSwgbik7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaW5mZXIgb3V0cHV0IHR5cGVcIik7XG4gICAgcmV0dXJuIG5ldyB3bihuLCBhLCBvKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgZm9yIChjb25zdCBbdCwgbl0gb2YgdGhpcy5icmFuY2hlcylcbiAgICAgIGlmICh0LmV2YWx1YXRlKGUpKVxuICAgICAgICByZXR1cm4gbi5ldmFsdWF0ZShlKTtcbiAgICByZXR1cm4gdGhpcy5vdGhlcndpc2UuZXZhbHVhdGUoZSk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBmb3IgKGNvbnN0IFt0LCBuXSBvZiB0aGlzLmJyYW5jaGVzKVxuICAgICAgZSh0KSwgZShuKTtcbiAgICBlKHRoaXMub3RoZXJ3aXNlKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmJyYW5jaGVzLmV2ZXJ5KChbZSwgdF0pID0+IHQub3V0cHV0RGVmaW5lZCgpKSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gIH1cbn1cbmNsYXNzIEp0IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSkge1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMuaW5wdXQgPSB0LCB0aGlzLmJlZ2luSW5kZXggPSBuLCB0aGlzLmVuZEluZGV4ID0gYTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8PSAyIHx8IGUubGVuZ3RoID49IDUpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kICR7ZS5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuICAgIGNvbnN0IG4gPSB0LnBhcnNlKGVbMV0sIDEsIEkpLCBhID0gdC5wYXJzZShlWzJdLCAyLCBTKTtcbiAgICBpZiAoIW4gfHwgIWEpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIW1uKG4udHlwZSwgW25lKEkpLCBQLCBJXSkpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAke0Qobi50eXBlKX0gaW5zdGVhZGApO1xuICAgIGlmIChlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3QgbyA9IHQucGFyc2UoZVszXSwgMywgUyk7XG4gICAgICByZXR1cm4gbyA/IG5ldyBKdChuLnR5cGUsIG4sIGEsIG8pIDogbnVsbDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBuZXcgSnQobi50eXBlLCBuLCBhKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoZSksIG4gPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUoZSk7XG4gICAgbGV0IGE7XG4gICAgaWYgKHRoaXMuZW5kSW5kZXggJiYgKGEgPSB0aGlzLmVuZEluZGV4LmV2YWx1YXRlKGUpKSwgR2UodCwgW1wic3RyaW5nXCJdKSlcbiAgICAgIHJldHVybiBbLi4udF0uc2xpY2UobiwgYSkuam9pbihcIlwiKTtcbiAgICBpZiAoR2UodCwgW1wiYXJyYXlcIl0pKVxuICAgICAgcmV0dXJuIHQuc2xpY2UobiwgYSk7XG4gICAgdGhyb3cgbmV3IFUoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHtEKHEodCkpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLmlucHV0KSwgZSh0aGlzLmJlZ2luSW5kZXgpLCB0aGlzLmVuZEluZGV4ICYmIGUodGhpcy5lbmRJbmRleCk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvKHIsIGUpIHtcbiAgY29uc3QgdCA9IHIubGVuZ3RoIC0gMTtcbiAgbGV0IG4gPSAwLCBhID0gdCwgbyA9IDAsIGksIHM7XG4gIGZvciAoOyBuIDw9IGE7IClcbiAgICBpZiAobyA9IE1hdGguZmxvb3IoKG4gKyBhKSAvIDIpLCBpID0gcltvXSwgcyA9IHJbbyArIDFdLCBpIDw9IGUpIHtcbiAgICAgIGlmIChvID09PSB0IHx8IGUgPCBzKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIG4gPSBvICsgMTtcbiAgICB9IGVsc2UgaWYgKGkgPiBlKVxuICAgICAgYSA9IG8gLSAxO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBVKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyLlwiKTtcbiAgcmV0dXJuIDA7XG59XG5jbGFzcyBnciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLmlucHV0ID0gdCwgdGhpcy5sYWJlbHMgPSBbXSwgdGhpcy5vdXRwdXRzID0gW107XG4gICAgZm9yIChjb25zdCBbYSwgb10gb2YgbilcbiAgICAgIHRoaXMubGFiZWxzLnB1c2goYSksIHRoaXMub3V0cHV0cy5wdXNoKG8pO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIC0gMSA8IDQpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5ICR7ZS5sZW5ndGggLSAxfS5gKTtcbiAgICBpZiAoKGUubGVuZ3RoIC0gMSkgJSAyICE9PSAwKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgIGNvbnN0IG4gPSB0LnBhcnNlKGVbMV0sIDEsIFMpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBsZXQgbyA9IG51bGw7XG4gICAgdC5leHBlY3RlZFR5cGUgJiYgdC5leHBlY3RlZFR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIChvID0gdC5leHBlY3RlZFR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgcyA9IGkgPT09IDEgPyAtMSAvIDAgOiBlW2ldLCBsID0gZVtpICsgMV0sIHUgPSBpLCBjID0gaSArIDE7XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgdSk7XG4gICAgICBpZiAoYS5sZW5ndGggJiYgYVthLmxlbmd0aCAtIDFdWzBdID49IHMpXG4gICAgICAgIHJldHVybiB0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwic3RlcFwiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIHUpO1xuICAgICAgY29uc3QgcCA9IHQucGFyc2UobCwgYywgbyk7XG4gICAgICBpZiAoIXApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbyA9IG8gfHwgcC50eXBlLCBhLnB1c2goW3MsIHBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBncihvLCBuLCBhKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubGFiZWxzLCBuID0gdGhpcy5vdXRwdXRzO1xuICAgIGlmICh0Lmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBuWzBdLmV2YWx1YXRlKGUpO1xuICAgIGNvbnN0IGEgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGUpO1xuICAgIGlmIChhIDw9IHRbMF0pXG4gICAgICByZXR1cm4gblswXS5ldmFsdWF0ZShlKTtcbiAgICBjb25zdCBvID0gdC5sZW5ndGg7XG4gICAgaWYgKGEgPj0gdFtvIC0gMV0pXG4gICAgICByZXR1cm4gbltvIC0gMV0uZXZhbHVhdGUoZSk7XG4gICAgY29uc3QgaSA9IGNvKHQsIGEpO1xuICAgIHJldHVybiBuW2ldLmV2YWx1YXRlKGUpO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLmlucHV0KTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5vdXRwdXRzKVxuICAgICAgZSh0KTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoKGUpID0+IGUub3V0cHV0RGVmaW5lZCgpKTtcbiAgfVxufVxuZnVuY3Rpb24gdGwocikge1xuICByZXR1cm4gciAmJiByLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIFwiZGVmYXVsdFwiKSA/IHIuZGVmYXVsdCA6IHI7XG59XG52YXIgUHIsIGlhO1xuZnVuY3Rpb24gcmwoKSB7XG4gIGlmIChpYSkgcmV0dXJuIFByO1xuICBpYSA9IDEsIFByID0gcjtcbiAgZnVuY3Rpb24gcihlLCB0LCBuLCBhKSB7XG4gICAgdGhpcy5jeCA9IDMgKiBlLCB0aGlzLmJ4ID0gMyAqIChuIC0gZSkgLSB0aGlzLmN4LCB0aGlzLmF4ID0gMSAtIHRoaXMuY3ggLSB0aGlzLmJ4LCB0aGlzLmN5ID0gMyAqIHQsIHRoaXMuYnkgPSAzICogKGEgLSB0KSAtIHRoaXMuY3ksIHRoaXMuYXkgPSAxIC0gdGhpcy5jeSAtIHRoaXMuYnksIHRoaXMucDF4ID0gZSwgdGhpcy5wMXkgPSB0LCB0aGlzLnAyeCA9IG4sIHRoaXMucDJ5ID0gYTtcbiAgfVxuICByZXR1cm4gci5wcm90b3R5cGUgPSB7XG4gICAgc2FtcGxlQ3VydmVYOiBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gKCh0aGlzLmF4ICogZSArIHRoaXMuYngpICogZSArIHRoaXMuY3gpICogZTtcbiAgICB9LFxuICAgIHNhbXBsZUN1cnZlWTogZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuICgodGhpcy5heSAqIGUgKyB0aGlzLmJ5KSAqIGUgKyB0aGlzLmN5KSAqIGU7XG4gICAgfSxcbiAgICBzYW1wbGVDdXJ2ZURlcml2YXRpdmVYOiBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gKDMgKiB0aGlzLmF4ICogZSArIDIgKiB0aGlzLmJ4KSAqIGUgKyB0aGlzLmN4O1xuICAgIH0sXG4gICAgc29sdmVDdXJ2ZVg6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSAxZS02KSwgZSA8IDApIHJldHVybiAwO1xuICAgICAgaWYgKGUgPiAxKSByZXR1cm4gMTtcbiAgICAgIGZvciAodmFyIG4gPSBlLCBhID0gMDsgYSA8IDg7IGErKykge1xuICAgICAgICB2YXIgbyA9IHRoaXMuc2FtcGxlQ3VydmVYKG4pIC0gZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKG8pIDwgdCkgcmV0dXJuIG47XG4gICAgICAgIHZhciBpID0gdGhpcy5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYKG4pO1xuICAgICAgICBpZiAoTWF0aC5hYnMoaSkgPCAxZS02KSBicmVhaztcbiAgICAgICAgbiA9IG4gLSBvIC8gaTtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gMCwgbCA9IDE7XG4gICAgICBmb3IgKG4gPSBlLCBhID0gMDsgYSA8IDIwICYmIChvID0gdGhpcy5zYW1wbGVDdXJ2ZVgobiksICEoTWF0aC5hYnMobyAtIGUpIDwgdCkpOyBhKyspXG4gICAgICAgIGUgPiBvID8gcyA9IG4gOiBsID0gbiwgbiA9IChsIC0gcykgKiAwLjUgKyBzO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcbiAgICBzb2x2ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgoZSwgdCkpO1xuICAgIH1cbiAgfSwgUHI7XG59XG52YXIgbmwgPSBybCgpLCBhbCA9IC8qIEBfX1BVUkVfXyAqLyB0bChubCk7XG5jbGFzcyB4ZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEsIG8pIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLm9wZXJhdG9yID0gdCwgdGhpcy5pbnRlcnBvbGF0aW9uID0gbiwgdGhpcy5pbnB1dCA9IGEsIHRoaXMubGFiZWxzID0gW10sIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2ksIHNdIG9mIG8pXG4gICAgICB0aGlzLmxhYmVscy5wdXNoKGkpLCB0aGlzLm91dHB1dHMucHVzaChzKTtcbiAgfVxuICBzdGF0aWMgaW50ZXJwb2xhdGlvbkZhY3RvcihlLCB0LCBuLCBhKSB7XG4gICAgbGV0IG8gPSAwO1xuICAgIGlmIChlLm5hbWUgPT09IFwiZXhwb25lbnRpYWxcIilcbiAgICAgIG8gPSBScih0LCBlLmJhc2UsIG4sIGEpO1xuICAgIGVsc2UgaWYgKGUubmFtZSA9PT0gXCJsaW5lYXJcIilcbiAgICAgIG8gPSBScih0LCAxLCBuLCBhKTtcbiAgICBlbHNlIGlmIChlLm5hbWUgPT09IFwiY3ViaWMtYmV6aWVyXCIpIHtcbiAgICAgIGNvbnN0IGkgPSBlLmNvbnRyb2xQb2ludHM7XG4gICAgICBvID0gbmV3IGFsKGlbMF0sIGlbMV0sIGlbMl0sIGlbM10pLnNvbHZlKFJyKHQsIDEsIG4sIGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBsZXQgW24sIGEsIG8sIC4uLmldID0gZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgYS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGFuIGludGVycG9sYXRpb24gdHlwZSBleHByZXNzaW9uLlwiLCAxKTtcbiAgICBpZiAoYVswXSA9PT0gXCJsaW5lYXJcIilcbiAgICAgIGEgPSB7IG5hbWU6IFwibGluZWFyXCIgfTtcbiAgICBlbHNlIGlmIChhWzBdID09PSBcImV4cG9uZW50aWFsXCIpIHtcbiAgICAgIGNvbnN0IHUgPSBhWzFdO1xuICAgICAgaWYgKHR5cGVvZiB1ICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS5cIiwgMSwgMSk7XG4gICAgICBhID0ge1xuICAgICAgICBuYW1lOiBcImV4cG9uZW50aWFsXCIsXG4gICAgICAgIGJhc2U6IHVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChhWzBdID09PSBcImN1YmljLWJlemllclwiKSB7XG4gICAgICBjb25zdCB1ID0gYS5zbGljZSgxKTtcbiAgICAgIGlmICh1Lmxlbmd0aCAhPT0gNCB8fCB1LnNvbWUoKGMpID0+IHR5cGVvZiBjICE9IFwibnVtYmVyXCIgfHwgYyA8IDAgfHwgYyA+IDEpKVxuICAgICAgICByZXR1cm4gdC5lcnJvcihcIkN1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLlwiLCAxKTtcbiAgICAgIGEgPSB7XG4gICAgICAgIG5hbWU6IFwiY3ViaWMtYmV6aWVyXCIsXG4gICAgICAgIGNvbnRyb2xQb2ludHM6IHVcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gdC5lcnJvcihgVW5rbm93biBpbnRlcnBvbGF0aW9uIHR5cGUgJHtTdHJpbmcoYVswXSl9YCwgMSwgMCk7XG4gICAgaWYgKGUubGVuZ3RoIC0gMSA8IDQpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5ICR7ZS5sZW5ndGggLSAxfS5gKTtcbiAgICBpZiAoKGUubGVuZ3RoIC0gMSkgJSAyICE9PSAwKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgIGlmIChvID0gdC5wYXJzZShvLCAyLCBTKSwgIW8pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBzID0gW107XG4gICAgbGV0IGwgPSBudWxsO1xuICAgIChuID09PSBcImludGVycG9sYXRlLWhjbFwiIHx8IG4gPT09IFwiaW50ZXJwb2xhdGUtbGFiXCIpICYmIHQuZXhwZWN0ZWRUeXBlICE9IHZ0ID8gbCA9IFNlIDogdC5leHBlY3RlZFR5cGUgJiYgdC5leHBlY3RlZFR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIChsID0gdC5leHBlY3RlZFR5cGUpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgaS5sZW5ndGg7IHUgKz0gMikge1xuICAgICAgY29uc3QgYyA9IGlbdV0sIHAgPSBpW3UgKyAxXSwgZCA9IHUgKyAzLCBmID0gdSArIDQ7XG4gICAgICBpZiAodHlwZW9mIGMgIT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGQpO1xuICAgICAgaWYgKHMubGVuZ3RoICYmIHNbcy5sZW5ndGggLSAxXVswXSA+PSBjKVxuICAgICAgICByZXR1cm4gdC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgZCk7XG4gICAgICBjb25zdCBoID0gdC5wYXJzZShwLCBmLCBsKTtcbiAgICAgIGlmICghaClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBsID0gbCB8fCBoLnR5cGUsIHMucHVzaChbYywgaF0pO1xuICAgIH1cbiAgICByZXR1cm4gIUllKGwsIFMpICYmICFJZShsLCBscikgJiYgIUllKGwsIFNlKSAmJiAhSWUobCwgcHIpICYmICFJZShsLCBmcikgJiYgIUllKGwsIHZ0KSAmJiAhSWUobCwgZHIpICYmICFJZShsLCBuZShTKSkgPyB0LmVycm9yKGBUeXBlICR7RChsKX0gaXMgbm90IGludGVycG9sYXRhYmxlLmApIDogbmV3IHhlKGwsIG4sIGEsIG8sIHMpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5sYWJlbHMsIG4gPSB0aGlzLm91dHB1dHM7XG4gICAgaWYgKHQubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIG5bMF0uZXZhbHVhdGUoZSk7XG4gICAgY29uc3QgYSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoZSk7XG4gICAgaWYgKGEgPD0gdFswXSlcbiAgICAgIHJldHVybiBuWzBdLmV2YWx1YXRlKGUpO1xuICAgIGNvbnN0IG8gPSB0Lmxlbmd0aDtcbiAgICBpZiAoYSA+PSB0W28gLSAxXSlcbiAgICAgIHJldHVybiBuW28gLSAxXS5ldmFsdWF0ZShlKTtcbiAgICBjb25zdCBpID0gY28odCwgYSksIHMgPSB0W2ldLCBsID0gdFtpICsgMV0sIHUgPSB4ZS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvbiwgYSwgcywgbCksIGMgPSBuW2ldLmV2YWx1YXRlKGUpLCBwID0gbltpICsgMV0uZXZhbHVhdGUoZSk7XG4gICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiaW50ZXJwb2xhdGVcIjpcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBOZShjLCBwLCB1KTtcbiAgICAgICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgICAgIHJldHVybiAkLmludGVycG9sYXRlKGMsIHAsIHUpO1xuICAgICAgICAgIGNhc2UgXCJwYWRkaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gaWUuaW50ZXJwb2xhdGUoYywgcCwgdSk7XG4gICAgICAgICAgY2FzZSBcImNvbG9yQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBRLmludGVycG9sYXRlKGMsIHAsIHUpO1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIHNlLmludGVycG9sYXRlKGMsIHAsIHUpO1xuICAgICAgICAgIGNhc2UgXCJ2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiB5ZS5pbnRlcnBvbGF0ZShjLCBwLCB1KTtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBvdChjLCBwLCB1KTtcbiAgICAgICAgICBjYXNlIFwicHJvamVjdGlvbkRlZmluaXRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBkZS5pbnRlcnBvbGF0ZShjLCBwLCB1KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImludGVycG9sYXRlLWhjbFwiOlxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgICAgICByZXR1cm4gJC5pbnRlcnBvbGF0ZShjLCBwLCB1LCBcImhjbFwiKTtcbiAgICAgICAgICBjYXNlIFwiY29sb3JBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIFEuaW50ZXJwb2xhdGUoYywgcCwgdSwgXCJoY2xcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJpbnRlcnBvbGF0ZS1sYWJcIjpcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICAgICAgcmV0dXJuICQuaW50ZXJwb2xhdGUoYywgcCwgdSwgXCJsYWJcIik7XG4gICAgICAgICAgY2FzZSBcImNvbG9yQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBRLmludGVycG9sYXRlKGMsIHAsIHUsIFwibGFiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLmlucHV0KTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5vdXRwdXRzKVxuICAgICAgZSh0KTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoKGUpID0+IGUub3V0cHV0RGVmaW5lZCgpKTtcbiAgfVxufVxuZnVuY3Rpb24gUnIociwgZSwgdCwgbikge1xuICBjb25zdCBhID0gbiAtIHQsIG8gPSByIC0gdDtcbiAgcmV0dXJuIGEgPT09IDAgPyAwIDogZSA9PT0gMSA/IG8gLyBhIDogKE1hdGgucG93KGUsIG8pIC0gMSkgLyAoTWF0aC5wb3coZSwgYSkgLSAxKTtcbn1cbiQuaW50ZXJwb2xhdGUsIGllLmludGVycG9sYXRlLCBzZS5pbnRlcnBvbGF0ZSwgUS5pbnRlcnBvbGF0ZSwgeWUuaW50ZXJwb2xhdGU7XG5jbGFzcyBTdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLmFyZ3MgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICBsZXQgbiA9IG51bGw7XG4gICAgY29uc3QgYSA9IHQuZXhwZWN0ZWRUeXBlO1xuICAgIGEgJiYgYS5raW5kICE9PSBcInZhbHVlXCIgJiYgKG4gPSBhKTtcbiAgICBjb25zdCBvID0gW107XG4gICAgZm9yIChjb25zdCBzIG9mIGUuc2xpY2UoMSkpIHtcbiAgICAgIGNvbnN0IGwgPSB0LnBhcnNlKHMsIDEgKyBvLmxlbmd0aCwgbiwgdm9pZCAwLCB7IHR5cGVBbm5vdGF0aW9uOiBcIm9taXRcIiB9KTtcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBuID0gbiB8fCBsLnR5cGUsIG8ucHVzaChsKTtcbiAgICB9XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGVcIik7XG4gICAgcmV0dXJuIGEgJiYgby5zb21lKChzKSA9PiBidChhLCBzLnR5cGUpKSA/IG5ldyBTdChJLCBvKSA6IG5ldyBTdChuLCBvKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgbGV0IHQgPSBudWxsLCBuID0gMCwgYTtcbiAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5hcmdzKVxuICAgICAgaWYgKG4rKywgdCA9IG8uZXZhbHVhdGUoZSksIHQgJiYgdCBpbnN0YW5jZW9mIERlICYmICF0LmF2YWlsYWJsZSAmJiAoYSB8fCAoYSA9IHQubmFtZSksIHQgPSBudWxsLCBuID09PSB0aGlzLmFyZ3MubGVuZ3RoICYmICh0ID0gYSkpLCB0ICE9PSBudWxsKVxuICAgICAgICBicmVhaztcbiAgICByZXR1cm4gdDtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIHRoaXMuYXJncy5mb3JFYWNoKGUpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeSgoZSkgPT4gZS5vdXRwdXREZWZpbmVkKCkpO1xuICB9XG59XG5mdW5jdGlvbiBzYShyLCBlKSB7XG4gIHJldHVybiByID09PSBcIj09XCIgfHwgciA9PT0gXCIhPVwiID8gZS5raW5kID09PSBcImJvb2xlYW5cIiB8fCBlLmtpbmQgPT09IFwic3RyaW5nXCIgfHwgZS5raW5kID09PSBcIm51bWJlclwiIHx8IGUua2luZCA9PT0gXCJudWxsXCIgfHwgZS5raW5kID09PSBcInZhbHVlXCIgOiBlLmtpbmQgPT09IFwic3RyaW5nXCIgfHwgZS5raW5kID09PSBcIm51bWJlclwiIHx8IGUua2luZCA9PT0gXCJ2YWx1ZVwiO1xufVxuZnVuY3Rpb24gb2wociwgZSwgdCkge1xuICByZXR1cm4gZSA9PT0gdDtcbn1cbmZ1bmN0aW9uIGlsKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGUgIT09IHQ7XG59XG5mdW5jdGlvbiBzbChyLCBlLCB0KSB7XG4gIHJldHVybiBlIDwgdDtcbn1cbmZ1bmN0aW9uIGxsKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGUgPiB0O1xufVxuZnVuY3Rpb24gdWwociwgZSwgdCkge1xuICByZXR1cm4gZSA8PSB0O1xufVxuZnVuY3Rpb24gY2wociwgZSwgdCkge1xuICByZXR1cm4gZSA+PSB0O1xufVxuZnVuY3Rpb24gcG8ociwgZSwgdCwgbikge1xuICByZXR1cm4gbi5jb21wYXJlKGUsIHQpID09PSAwO1xufVxuZnVuY3Rpb24gcGwociwgZSwgdCwgbikge1xuICByZXR1cm4gIXBvKHIsIGUsIHQsIG4pO1xufVxuZnVuY3Rpb24gZmwociwgZSwgdCwgbikge1xuICByZXR1cm4gbi5jb21wYXJlKGUsIHQpIDwgMDtcbn1cbmZ1bmN0aW9uIGRsKHIsIGUsIHQsIG4pIHtcbiAgcmV0dXJuIG4uY29tcGFyZShlLCB0KSA+IDA7XG59XG5mdW5jdGlvbiBobChyLCBlLCB0LCBuKSB7XG4gIHJldHVybiBuLmNvbXBhcmUoZSwgdCkgPD0gMDtcbn1cbmZ1bmN0aW9uIG1sKHIsIGUsIHQsIG4pIHtcbiAgcmV0dXJuIG4uY29tcGFyZShlLCB0KSA+PSAwO1xufVxuZnVuY3Rpb24gbHQociwgZSwgdCkge1xuICBjb25zdCBuID0gciAhPT0gXCI9PVwiICYmIHIgIT09IFwiIT1cIjtcbiAgcmV0dXJuIGNsYXNzIGZvIHtcbiAgICBjb25zdHJ1Y3RvcihvLCBpLCBzKSB7XG4gICAgICB0aGlzLnR5cGUgPSBNLCB0aGlzLmxocyA9IG8sIHRoaXMucmhzID0gaSwgdGhpcy5jb2xsYXRvciA9IHMsIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gby50eXBlLmtpbmQgPT09IFwidmFsdWVcIiB8fCBpLnR5cGUua2luZCA9PT0gXCJ2YWx1ZVwiO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UobywgaSkge1xuICAgICAgaWYgKG8ubGVuZ3RoICE9PSAzICYmIG8ubGVuZ3RoICE9PSA0KVxuICAgICAgICByZXR1cm4gaS5lcnJvcihcIkV4cGVjdGVkIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXCIpO1xuICAgICAgY29uc3QgcyA9IG9bMF07XG4gICAgICBsZXQgbCA9IGkucGFyc2Uob1sxXSwgMSwgSSk7XG4gICAgICBpZiAoIWwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKCFzYShzLCBsLnR5cGUpKVxuICAgICAgICByZXR1cm4gaS5jb25jYXQoMSkuZXJyb3IoYFwiJHtzfVwiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICcke0QobC50eXBlKX0nLmApO1xuICAgICAgbGV0IHUgPSBpLnBhcnNlKG9bMl0sIDIsIEkpO1xuICAgICAgaWYgKCF1KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICghc2EocywgdS50eXBlKSlcbiAgICAgICAgcmV0dXJuIGkuY29uY2F0KDIpLmVycm9yKGBcIiR7c31cIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAnJHtEKHUudHlwZSl9Jy5gKTtcbiAgICAgIGlmIChsLnR5cGUua2luZCAhPT0gdS50eXBlLmtpbmQgJiYgbC50eXBlLmtpbmQgIT09IFwidmFsdWVcIiAmJiB1LnR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiKVxuICAgICAgICByZXR1cm4gaS5lcnJvcihgQ2Fubm90IGNvbXBhcmUgdHlwZXMgJyR7RChsLnR5cGUpfScgYW5kICcke0QodS50eXBlKX0nLmApO1xuICAgICAgbiAmJiAobC50eXBlLmtpbmQgPT09IFwidmFsdWVcIiAmJiB1LnR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiID8gbCA9IG5ldyBoZSh1LnR5cGUsIFtsXSkgOiBsLnR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIHUudHlwZS5raW5kID09PSBcInZhbHVlXCIgJiYgKHUgPSBuZXcgaGUobC50eXBlLCBbdV0pKSk7XG4gICAgICBsZXQgYyA9IG51bGw7XG4gICAgICBpZiAoby5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgaWYgKGwudHlwZS5raW5kICE9PSBcInN0cmluZ1wiICYmIHUudHlwZS5raW5kICE9PSBcInN0cmluZ1wiICYmIGwudHlwZS5raW5kICE9PSBcInZhbHVlXCIgJiYgdS50eXBlLmtpbmQgIT09IFwidmFsdWVcIilcbiAgICAgICAgICByZXR1cm4gaS5lcnJvcihcIkNhbm5vdCB1c2UgY29sbGF0b3IgdG8gY29tcGFyZSBub24tc3RyaW5nIHR5cGVzLlwiKTtcbiAgICAgICAgaWYgKGMgPSBpLnBhcnNlKG9bM10sIDMsIHVyKSwgIWMpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGZvKGwsIHUsIGMpO1xuICAgIH1cbiAgICBldmFsdWF0ZShvKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5saHMuZXZhbHVhdGUobyksIHMgPSB0aGlzLnJocy5ldmFsdWF0ZShvKTtcbiAgICAgIGlmIChuICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGwgPSBxKGkpLCB1ID0gcShzKTtcbiAgICAgICAgaWYgKGwua2luZCAhPT0gdS5raW5kIHx8ICEobC5raW5kID09PSBcInN0cmluZ1wiIHx8IGwua2luZCA9PT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgdGhyb3cgbmV3IFUoYEV4cGVjdGVkIGFyZ3VtZW50cyBmb3IgXCIke3J9XCIgdG8gYmUgKHN0cmluZywgc3RyaW5nKSBvciAobnVtYmVyLCBudW1iZXIpLCBidXQgZm91bmQgKCR7bC5raW5kfSwgJHt1LmtpbmR9KSBpbnN0ZWFkLmApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29sbGF0b3IgJiYgIW4gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgY29uc3QgbCA9IHEoaSksIHUgPSBxKHMpO1xuICAgICAgICBpZiAobC5raW5kICE9PSBcInN0cmluZ1wiIHx8IHUua2luZCAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gZShvLCBpLCBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yID8gdChvLCBpLCBzLCB0aGlzLmNvbGxhdG9yLmV2YWx1YXRlKG8pKSA6IGUobywgaSwgcyk7XG4gICAgfVxuICAgIGVhY2hDaGlsZChvKSB7XG4gICAgICBvKHRoaXMubGhzKSwgbyh0aGlzLnJocyksIHRoaXMuY29sbGF0b3IgJiYgbyh0aGlzLmNvbGxhdG9yKTtcbiAgICB9XG4gICAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH07XG59XG5jb25zdCB5bCA9IGx0KFwiPT1cIiwgb2wsIHBvKSwgZ2wgPSBsdChcIiE9XCIsIGlsLCBwbCksIHZsID0gbHQoXCI8XCIsIHNsLCBmbCksIGJsID0gbHQoXCI+XCIsIGxsLCBkbCksIHdsID0gbHQoXCI8PVwiLCB1bCwgaGwpLCBTbCA9IGx0KFwiPj1cIiwgY2wsIG1sKTtcbmNsYXNzIHZyIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHRoaXMudHlwZSA9IHVyLCB0aGlzLmxvY2FsZSA9IG4sIHRoaXMuY2FzZVNlbnNpdGl2ZSA9IGUsIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlID0gdDtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgb25lIGFyZ3VtZW50LlwiKTtcbiAgICBjb25zdCBuID0gZVsxXTtcbiAgICBpZiAodHlwZW9mIG4gIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG4pKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJDb2xsYXRvciBvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICBjb25zdCBhID0gdC5wYXJzZShuW1wiY2FzZS1zZW5zaXRpdmVcIl0gPT09IHZvaWQgMCA/ICExIDogbltcImNhc2Utc2Vuc2l0aXZlXCJdLCAxLCBNKTtcbiAgICBpZiAoIWEpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBvID0gdC5wYXJzZShuW1wiZGlhY3JpdGljLXNlbnNpdGl2ZVwiXSA9PT0gdm9pZCAwID8gITEgOiBuW1wiZGlhY3JpdGljLXNlbnNpdGl2ZVwiXSwgMSwgTSk7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGkgPSBudWxsO1xuICAgIHJldHVybiBuLmxvY2FsZSAmJiAoaSA9IHQucGFyc2Uobi5sb2NhbGUsIDEsIFApLCAhaSkgPyBudWxsIDogbmV3IHZyKGEsIG8sIGkpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICByZXR1cm4gbmV3IHluKHRoaXMuY2FzZVNlbnNpdGl2ZS5ldmFsdWF0ZShlKSwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUuZXZhbHVhdGUoZSksIHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoZSkgOiBudWxsKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5jYXNlU2Vuc2l0aXZlKSwgZSh0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSksIHRoaXMubG9jYWxlICYmIGUodGhpcy5sb2NhbGUpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyBTbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEsIG8pIHtcbiAgICB0aGlzLnR5cGUgPSBQLCB0aGlzLm51bWJlciA9IGUsIHRoaXMubG9jYWxlID0gdCwgdGhpcy5jdXJyZW5jeSA9IG4sIHRoaXMubWluRnJhY3Rpb25EaWdpdHMgPSBhLCB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID0gbztcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMylcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cy5cIik7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSwgUyk7XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYSA9IGVbMl07XG4gICAgaWYgKHR5cGVvZiBhICE9IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShhKSlcbiAgICAgIHJldHVybiB0LmVycm9yKFwiTnVtYmVyRm9ybWF0IG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgIGxldCBvID0gbnVsbDtcbiAgICBpZiAoYS5sb2NhbGUgJiYgKG8gPSB0LnBhcnNlKGEubG9jYWxlLCAxLCBQKSwgIW8pKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGkgPSBudWxsO1xuICAgIGlmIChhLmN1cnJlbmN5ICYmIChpID0gdC5wYXJzZShhLmN1cnJlbmN5LCAxLCBQKSwgIWkpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHMgPSBudWxsO1xuICAgIGlmIChhW1wibWluLWZyYWN0aW9uLWRpZ2l0c1wiXSAmJiAocyA9IHQucGFyc2UoYVtcIm1pbi1mcmFjdGlvbi1kaWdpdHNcIl0sIDEsIFMpLCAhcykpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbCA9IG51bGw7XG4gICAgcmV0dXJuIGFbXCJtYXgtZnJhY3Rpb24tZGlnaXRzXCJdICYmIChsID0gdC5wYXJzZShhW1wibWF4LWZyYWN0aW9uLWRpZ2l0c1wiXSwgMSwgUyksICFsKSA/IG51bGwgOiBuZXcgU24obiwgbywgaSwgcywgbCk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShlKSA6IFtdLCB7XG4gICAgICBzdHlsZTogdGhpcy5jdXJyZW5jeSA/IFwiY3VycmVuY3lcIiA6IFwiZGVjaW1hbFwiLFxuICAgICAgY3VycmVuY3k6IHRoaXMuY3VycmVuY3kgPyB0aGlzLmN1cnJlbmN5LmV2YWx1YXRlKGUpIDogdm9pZCAwLFxuICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID8gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShlKSA6IHZvaWQgMCxcbiAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUoZSkgOiB2b2lkIDBcbiAgICB9KS5mb3JtYXQodGhpcy5udW1iZXIuZXZhbHVhdGUoZSkpO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLm51bWJlciksIHRoaXMubG9jYWxlICYmIGUodGhpcy5sb2NhbGUpLCB0aGlzLmN1cnJlbmN5ICYmIGUodGhpcy5jdXJyZW5jeSksIHRoaXMubWluRnJhY3Rpb25EaWdpdHMgJiYgZSh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSwgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyAmJiBlKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyB4biB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnR5cGUgPSBjciwgdGhpcy5zZWN0aW9ucyA9IGU7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgIGNvbnN0IG4gPSBlWzFdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShuKSAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi5cIik7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIGxldCBvID0gITE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGNvbnN0IHMgPSBlW2ldO1xuICAgICAgaWYgKG8gJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzKSkge1xuICAgICAgICBvID0gITE7XG4gICAgICAgIGxldCBsID0gbnVsbDtcbiAgICAgICAgaWYgKHNbXCJmb250LXNjYWxlXCJdICYmIChsID0gdC5wYXJzZShzW1wiZm9udC1zY2FsZVwiXSwgMSwgUyksICFsKSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHUgPSBudWxsO1xuICAgICAgICBpZiAoc1tcInRleHQtZm9udFwiXSAmJiAodSA9IHQucGFyc2Uoc1tcInRleHQtZm9udFwiXSwgMSwgbmUoUCkpLCAhdSkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgICAgaWYgKHNbXCJ0ZXh0LWNvbG9yXCJdICYmIChjID0gdC5wYXJzZShzW1widGV4dC1jb2xvclwiXSwgMSwgU2UpLCAhYykpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBwID0gbnVsbDtcbiAgICAgICAgaWYgKHNbXCJ2ZXJ0aWNhbC1hbGlnblwiXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc1tcInZlcnRpY2FsLWFsaWduXCJdID09IFwic3RyaW5nXCIgJiYgIUpzLmluY2x1ZGVzKHNbXCJ2ZXJ0aWNhbC1hbGlnblwiXSkpXG4gICAgICAgICAgICByZXR1cm4gdC5lcnJvcihgJ3ZlcnRpY2FsLWFsaWduJyBtdXN0IGJlIG9uZSBvZjogJ2JvdHRvbScsICdjZW50ZXInLCAndG9wJyBidXQgZm91bmQgJyR7c1tcInZlcnRpY2FsLWFsaWduXCJdfScgaW5zdGVhZC5gKTtcbiAgICAgICAgICBpZiAocCA9IHQucGFyc2Uoc1tcInZlcnRpY2FsLWFsaWduXCJdLCAxLCBQKSwgIXApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gYVthLmxlbmd0aCAtIDFdO1xuICAgICAgICBkLnNjYWxlID0gbCwgZC5mb250ID0gdSwgZC50ZXh0Q29sb3IgPSBjLCBkLnZlcnRpY2FsQWxpZ24gPSBwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbCA9IHQucGFyc2UoZVtpXSwgMSwgSSk7XG4gICAgICAgIGlmICghbClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgdSA9IGwudHlwZS5raW5kO1xuICAgICAgICBpZiAodSAhPT0gXCJzdHJpbmdcIiAmJiB1ICE9PSBcInZhbHVlXCIgJiYgdSAhPT0gXCJudWxsXCIgJiYgdSAhPT0gXCJyZXNvbHZlZEltYWdlXCIpXG4gICAgICAgICAgcmV0dXJuIHQuZXJyb3IoXCJGb3JtYXR0ZWQgdGV4dCB0eXBlIG11c3QgYmUgJ3N0cmluZycsICd2YWx1ZScsICdpbWFnZScgb3IgJ251bGwnLlwiKTtcbiAgICAgICAgbyA9ICEwLCBhLnB1c2goeyBjb250ZW50OiBsLCBzY2FsZTogbnVsbCwgZm9udDogbnVsbCwgdGV4dENvbG9yOiBudWxsLCB2ZXJ0aWNhbEFsaWduOiBudWxsIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IHhuKGEpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gKG4pID0+IHtcbiAgICAgIGNvbnN0IGEgPSBuLmNvbnRlbnQuZXZhbHVhdGUoZSk7XG4gICAgICByZXR1cm4gcShhKSA9PT0gX3QgPyBuZXcgWnIoXCJcIiwgYSwgbnVsbCwgbnVsbCwgbnVsbCwgbi52ZXJ0aWNhbEFsaWduID8gbi52ZXJ0aWNhbEFsaWduLmV2YWx1YXRlKGUpIDogbnVsbCkgOiBuZXcgWnIoeXQoYSksIG51bGwsIG4uc2NhbGUgPyBuLnNjYWxlLmV2YWx1YXRlKGUpIDogbnVsbCwgbi5mb250ID8gbi5mb250LmV2YWx1YXRlKGUpLmpvaW4oXCIsXCIpIDogbnVsbCwgbi50ZXh0Q29sb3IgPyBuLnRleHRDb2xvci5ldmFsdWF0ZShlKSA6IG51bGwsIG4udmVydGljYWxBbGlnbiA/IG4udmVydGljYWxBbGlnbi5ldmFsdWF0ZShlKSA6IG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBBZSh0aGlzLnNlY3Rpb25zLm1hcCh0KSk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5zZWN0aW9ucylcbiAgICAgIGUodC5jb250ZW50KSwgdC5zY2FsZSAmJiBlKHQuc2NhbGUpLCB0LmZvbnQgJiYgZSh0LmZvbnQpLCB0LnRleHRDb2xvciAmJiBlKHQudGV4dENvbG9yKSwgdC52ZXJ0aWNhbEFsaWduICYmIGUodC52ZXJ0aWNhbEFsaWduKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuY2xhc3Mga24ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy50eXBlID0gX3QsIHRoaXMuaW5wdXQgPSBlO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICBjb25zdCBuID0gdC5wYXJzZShlWzFdLCAxLCBQKTtcbiAgICByZXR1cm4gbiA/IG5ldyBrbihuKSA6IHQuZXJyb3IoXCJObyBpbWFnZSBuYW1lIHByb3ZpZGVkLlwiKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoZSksIG4gPSBEZS5mcm9tU3RyaW5nKHQpO1xuICAgIHJldHVybiBuICYmIGUuYXZhaWxhYmxlSW1hZ2VzICYmIChuLmF2YWlsYWJsZSA9IGUuYXZhaWxhYmxlSW1hZ2VzLmluZGV4T2YodCkgPiAtMSksIG47XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMuaW5wdXQpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyBMbiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnR5cGUgPSBTLCB0aGlzLmlucHV0ID0gZTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSk7XG4gICAgcmV0dXJuIG4gPyBuLnR5cGUua2luZCAhPT0gXCJhcnJheVwiICYmIG4udHlwZS5raW5kICE9PSBcInN0cmluZ1wiICYmIG4udHlwZS5raW5kICE9PSBcInZhbHVlXCIgPyB0LmVycm9yKGBFeHBlY3RlZCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kICR7RChuLnR5cGUpfSBpbnN0ZWFkLmApIDogbmV3IExuKG4pIDogbnVsbDtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoZSk7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gWy4uLnRdLmxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICAgIHJldHVybiB0Lmxlbmd0aDtcbiAgICB0aHJvdyBuZXcgVShgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCAke0QocSh0KSl9IGluc3RlYWQuYCk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMuaW5wdXQpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBrZSA9IDgxOTI7XG5mdW5jdGlvbiB4bChyLCBlKSB7XG4gIGNvbnN0IHQgPSBrbChyWzBdKSwgbiA9IEVsKHJbMV0pLCBhID0gTWF0aC5wb3coMiwgZS56KTtcbiAgcmV0dXJuIFtNYXRoLnJvdW5kKHQgKiBhICoga2UpLCBNYXRoLnJvdW5kKG4gKiBhICoga2UpXTtcbn1cbmZ1bmN0aW9uIEVuKHIsIGUpIHtcbiAgY29uc3QgdCA9IE1hdGgucG93KDIsIGUueiksIG4gPSAoclswXSAvIGtlICsgZS54KSAvIHQsIGEgPSAoclsxXSAvIGtlICsgZS55KSAvIHQ7XG4gIHJldHVybiBbTGwobiksIENsKGEpXTtcbn1cbmZ1bmN0aW9uIGtsKHIpIHtcbiAgcmV0dXJuICgxODAgKyByKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIExsKHIpIHtcbiAgcmV0dXJuIHIgKiAzNjAgLSAxODA7XG59XG5mdW5jdGlvbiBFbChyKSB7XG4gIHJldHVybiAoMTgwIC0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgciAqIE1hdGguUEkgLyAzNjApKSkgLyAzNjA7XG59XG5mdW5jdGlvbiBDbChyKSB7XG4gIHJldHVybiAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKCgxODAgLSByICogMzYwKSAqIE1hdGguUEkgLyAxODApKSAtIDkwO1xufVxuZnVuY3Rpb24gSXQociwgZSkge1xuICByWzBdID0gTWF0aC5taW4oclswXSwgZVswXSksIHJbMV0gPSBNYXRoLm1pbihyWzFdLCBlWzFdKSwgclsyXSA9IE1hdGgubWF4KHJbMl0sIGVbMF0pLCByWzNdID0gTWF0aC5tYXgoclszXSwgZVsxXSk7XG59XG5mdW5jdGlvbiB4dChyLCBlKSB7XG4gIHJldHVybiAhKHJbMF0gPD0gZVswXSB8fCByWzJdID49IGVbMl0gfHwgclsxXSA8PSBlWzFdIHx8IHJbM10gPj0gZVszXSk7XG59XG5mdW5jdGlvbiBBbChyLCBlLCB0KSB7XG4gIHJldHVybiBlWzFdID4gclsxXSAhPSB0WzFdID4gclsxXSAmJiByWzBdIDwgKHRbMF0gLSBlWzBdKSAqIChyWzFdIC0gZVsxXSkgLyAodFsxXSAtIGVbMV0pICsgZVswXTtcbn1cbmZ1bmN0aW9uIFRsKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHJbMF0gLSBlWzBdLCBhID0gclsxXSAtIGVbMV0sIG8gPSByWzBdIC0gdFswXSwgaSA9IHJbMV0gLSB0WzFdO1xuICByZXR1cm4gbiAqIGkgLSBvICogYSA9PT0gMCAmJiBuICogbyA8PSAwICYmIGEgKiBpIDw9IDA7XG59XG5mdW5jdGlvbiBicihyLCBlLCB0LCBuKSB7XG4gIGNvbnN0IGEgPSBbZVswXSAtIHJbMF0sIGVbMV0gLSByWzFdXSwgbyA9IFtuWzBdIC0gdFswXSwgblsxXSAtIHRbMV1dO1xuICByZXR1cm4gUGwobywgYSkgPT09IDAgPyAhMSA6ICEhKGxhKHIsIGUsIHQsIG4pICYmIGxhKHQsIG4sIHIsIGUpKTtcbn1cbmZ1bmN0aW9uIF9sKHIsIGUsIHQpIHtcbiAgZm9yIChjb25zdCBuIG9mIHQpXG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBuLmxlbmd0aCAtIDE7ICsrYSlcbiAgICAgIGlmIChicihyLCBlLCBuW2FdLCBuW2EgKyAxXSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gdXQociwgZSwgdCA9ICExKSB7XG4gIGxldCBuID0gITE7XG4gIGZvciAoY29uc3QgYSBvZiBlKVxuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgYS5sZW5ndGggLSAxOyBvKyspIHtcbiAgICAgIGlmIChUbChyLCBhW29dLCBhW28gKyAxXSkpXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgQWwociwgYVtvXSwgYVtvICsgMV0pICYmIChuID0gIW4pO1xuICAgIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJbChyLCBlKSB7XG4gIGZvciAoY29uc3QgdCBvZiBlKVxuICAgIGlmICh1dChyLCB0KSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gaG8ociwgZSkge1xuICBmb3IgKGNvbnN0IHQgb2YgcilcbiAgICBpZiAoIXV0KHQsIGUpKVxuICAgICAgcmV0dXJuICExO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IHIubGVuZ3RoIC0gMTsgKyt0KVxuICAgIGlmIChfbChyW3RdLCByW3QgKyAxXSwgZSkpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIE1sKHIsIGUpIHtcbiAgZm9yIChjb25zdCB0IG9mIGUpXG4gICAgaWYgKGhvKHIsIHQpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBQbChyLCBlKSB7XG4gIHJldHVybiByWzBdICogZVsxXSAtIHJbMV0gKiBlWzBdO1xufVxuZnVuY3Rpb24gbGEociwgZSwgdCwgbikge1xuICBjb25zdCBhID0gclswXSAtIHRbMF0sIG8gPSByWzFdIC0gdFsxXSwgaSA9IGVbMF0gLSB0WzBdLCBzID0gZVsxXSAtIHRbMV0sIGwgPSBuWzBdIC0gdFswXSwgdSA9IG5bMV0gLSB0WzFdLCBjID0gYSAqIHUgLSBsICogbywgcCA9IGkgKiB1IC0gbCAqIHM7XG4gIHJldHVybiBjID4gMCAmJiBwIDwgMCB8fCBjIDwgMCAmJiBwID4gMDtcbn1cbmZ1bmN0aW9uIENuKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHIubGVuZ3RoOyBhKyspIHtcbiAgICBjb25zdCBvID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByW2FdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzID0geGwoclthXVtpXSwgdCk7XG4gICAgICBJdChlLCBzKSwgby5wdXNoKHMpO1xuICAgIH1cbiAgICBuLnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBtbyhyLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgZm9yIChsZXQgYSA9IDA7IGEgPCByLmxlbmd0aDsgYSsrKSB7XG4gICAgY29uc3QgbyA9IENuKHJbYV0sIGUsIHQpO1xuICAgIG4ucHVzaChvKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHlvKHIsIGUsIHQsIG4pIHtcbiAgaWYgKHJbMF0gPCB0WzBdIHx8IHJbMF0gPiB0WzJdKSB7XG4gICAgY29uc3QgYSA9IG4gKiAwLjU7XG4gICAgbGV0IG8gPSByWzBdIC0gdFswXSA+IGEgPyAtbiA6IHRbMF0gLSByWzBdID4gYSA/IG4gOiAwO1xuICAgIG8gPT09IDAgJiYgKG8gPSByWzBdIC0gdFsyXSA+IGEgPyAtbiA6IHRbMl0gLSByWzBdID4gYSA/IG4gOiAwKSwgclswXSArPSBvO1xuICB9XG4gIEl0KGUsIHIpO1xufVxuZnVuY3Rpb24gUmwocikge1xuICByWzBdID0gclsxXSA9IDEgLyAwLCByWzJdID0gclszXSA9IC0xIC8gMDtcbn1cbmZ1bmN0aW9uIHVhKHIsIGUsIHQsIG4pIHtcbiAgY29uc3QgYSA9IE1hdGgucG93KDIsIG4ueikgKiBrZSwgbyA9IFtuLnggKiBrZSwgbi55ICoga2VdLCBpID0gW107XG4gIGZvciAoY29uc3QgcyBvZiByKVxuICAgIGZvciAoY29uc3QgbCBvZiBzKSB7XG4gICAgICBjb25zdCB1ID0gW2wueCArIG9bMF0sIGwueSArIG9bMV1dO1xuICAgICAgeW8odSwgZSwgdCwgYSksIGkucHVzaCh1KTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gY2EociwgZSwgdCwgbikge1xuICBjb25zdCBhID0gTWF0aC5wb3coMiwgbi56KSAqIGtlLCBvID0gW24ueCAqIGtlLCBuLnkgKiBrZV0sIGkgPSBbXTtcbiAgZm9yIChjb25zdCBzIG9mIHIpIHtcbiAgICBjb25zdCBsID0gW107XG4gICAgZm9yIChjb25zdCB1IG9mIHMpIHtcbiAgICAgIGNvbnN0IGMgPSBbdS54ICsgb1swXSwgdS55ICsgb1sxXV07XG4gICAgICBJdChlLCBjKSwgbC5wdXNoKGMpO1xuICAgIH1cbiAgICBpLnB1c2gobCk7XG4gIH1cbiAgaWYgKGVbMl0gLSBlWzBdIDw9IGEgLyAyKSB7XG4gICAgUmwoZSk7XG4gICAgZm9yIChjb25zdCBzIG9mIGkpXG4gICAgICBmb3IgKGNvbnN0IGwgb2YgcylcbiAgICAgICAgeW8obCwgZSwgdCwgYSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB6bChyLCBlKSB7XG4gIGNvbnN0IHQgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sIG4gPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sIGEgPSByLmNhbm9uaWNhbElEKCk7XG4gIGlmIChlLnR5cGUgPT09IFwiUG9seWdvblwiKSB7XG4gICAgY29uc3QgbyA9IENuKGUuY29vcmRpbmF0ZXMsIG4sIGEpLCBpID0gdWEoci5nZW9tZXRyeSgpLCB0LCBuLCBhKTtcbiAgICBpZiAoIXh0KHQsIG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoY29uc3QgcyBvZiBpKVxuICAgICAgaWYgKCF1dChzLCBvKSlcbiAgICAgICAgcmV0dXJuICExO1xuICB9XG4gIGlmIChlLnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIHtcbiAgICBjb25zdCBvID0gbW8oZS5jb29yZGluYXRlcywgbiwgYSksIGkgPSB1YShyLmdlb21ldHJ5KCksIHQsIG4sIGEpO1xuICAgIGlmICgheHQodCwgbikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yIChjb25zdCBzIG9mIGkpXG4gICAgICBpZiAoIUlsKHMsIG8pKVxuICAgICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gT2wociwgZSkge1xuICBjb25zdCB0ID0gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdLCBuID0gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdLCBhID0gci5jYW5vbmljYWxJRCgpO1xuICBpZiAoZS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgIGNvbnN0IG8gPSBDbihlLmNvb3JkaW5hdGVzLCBuLCBhKSwgaSA9IGNhKHIuZ2VvbWV0cnkoKSwgdCwgbiwgYSk7XG4gICAgaWYgKCF4dCh0LCBuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgaSlcbiAgICAgIGlmICghaG8ocywgbykpXG4gICAgICAgIHJldHVybiAhMTtcbiAgfVxuICBpZiAoZS50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSB7XG4gICAgY29uc3QgbyA9IG1vKGUuY29vcmRpbmF0ZXMsIG4sIGEpLCBpID0gY2Eoci5nZW9tZXRyeSgpLCB0LCBuLCBhKTtcbiAgICBpZiAoIXh0KHQsIG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoY29uc3QgcyBvZiBpKVxuICAgICAgaWYgKCFNbChzLCBvKSlcbiAgICAgICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmNsYXNzIEhlIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMudHlwZSA9IE0sIHRoaXMuZ2VvanNvbiA9IGUsIHRoaXMuZ2VvbWV0cmllcyA9IHQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihgJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICR7ZS5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuICAgIGlmICh3dChlWzFdKSkge1xuICAgICAgY29uc3QgbiA9IGVbMV07XG4gICAgICBpZiAobi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG8gb2Ygbi5mZWF0dXJlcykge1xuICAgICAgICAgIGNvbnN0IHsgdHlwZTogaSwgY29vcmRpbmF0ZXM6IHMgfSA9IG8uZ2VvbWV0cnk7XG4gICAgICAgICAgaSA9PT0gXCJQb2x5Z29uXCIgJiYgYS5wdXNoKHMpLCBpID09PSBcIk11bHRpUG9seWdvblwiICYmIGEucHVzaCguLi5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gbmV3IEhlKG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG4udHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICAgICAgY29uc3QgYSA9IG4uZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgaWYgKGEgPT09IFwiUG9seWdvblwiIHx8IGEgPT09IFwiTXVsdGlQb2x5Z29uXCIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBIZShuLCBuLmdlb21ldHJ5KTtcbiAgICAgIH0gZWxzZSBpZiAobi50eXBlID09PSBcIlBvbHlnb25cIiB8fCBuLnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpXG4gICAgICAgIHJldHVybiBuZXcgSGUobiwgbik7XG4gICAgfVxuICAgIHJldHVybiB0LmVycm9yKFwiJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyB2YWxpZCBnZW9qc29uIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvbHlnb24gZ2VvbWV0cnkgdHlwZS5cIik7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGlmIChlLmdlb21ldHJ5KCkgIT0gbnVsbCAmJiBlLmNhbm9uaWNhbElEKCkgIT0gbnVsbCkge1xuICAgICAgaWYgKGUuZ2VvbWV0cnlUeXBlKCkgPT09IFwiUG9pbnRcIilcbiAgICAgICAgcmV0dXJuIHpsKGUsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICBpZiAoZS5nZW9tZXRyeVR5cGUoKSA9PT0gXCJMaW5lU3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBPbChlLCB0aGlzLmdlb21ldHJpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZWFjaENoaWxkKCkge1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jbGFzcyBnbyB7XG4gIGNvbnN0cnVjdG9yKGUgPSBbXSwgdCA9IChuLCBhKSA9PiBuIDwgYSA/IC0xIDogbiA+IGEgPyAxIDogMCkge1xuICAgIGlmICh0aGlzLmRhdGEgPSBlLCB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGgsIHRoaXMuY29tcGFyZSA9IHQsIHRoaXMubGVuZ3RoID4gMClcbiAgICAgIGZvciAobGV0IG4gPSAodGhpcy5sZW5ndGggPj4gMSkgLSAxOyBuID49IDA7IG4tLSkgdGhpcy5fZG93bihuKTtcbiAgfVxuICBwdXNoKGUpIHtcbiAgICB0aGlzLmRhdGEucHVzaChlKSwgdGhpcy5fdXAodGhpcy5sZW5ndGgrKyk7XG4gIH1cbiAgcG9wKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLmRhdGFbMF0sIHQgPSB0aGlzLmRhdGEucG9wKCk7XG4gICAgcmV0dXJuIC0tdGhpcy5sZW5ndGggPiAwICYmICh0aGlzLmRhdGFbMF0gPSB0LCB0aGlzLl9kb3duKDApKSwgZTtcbiAgfVxuICBwZWVrKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gIH1cbiAgX3VwKGUpIHtcbiAgICBjb25zdCB7IGRhdGE6IHQsIGNvbXBhcmU6IG4gfSA9IHRoaXMsIGEgPSB0W2VdO1xuICAgIGZvciAoOyBlID4gMDsgKSB7XG4gICAgICBjb25zdCBvID0gZSAtIDEgPj4gMSwgaSA9IHRbb107XG4gICAgICBpZiAobihhLCBpKSA+PSAwKSBicmVhaztcbiAgICAgIHRbZV0gPSBpLCBlID0gbztcbiAgICB9XG4gICAgdFtlXSA9IGE7XG4gIH1cbiAgX2Rvd24oZSkge1xuICAgIGNvbnN0IHsgZGF0YTogdCwgY29tcGFyZTogbiB9ID0gdGhpcywgYSA9IHRoaXMubGVuZ3RoID4+IDEsIG8gPSB0W2VdO1xuICAgIGZvciAoOyBlIDwgYTsgKSB7XG4gICAgICBsZXQgaSA9IChlIDw8IDEpICsgMTtcbiAgICAgIGNvbnN0IHMgPSBpICsgMTtcbiAgICAgIGlmIChzIDwgdGhpcy5sZW5ndGggJiYgbih0W3NdLCB0W2ldKSA8IDAgJiYgKGkgPSBzKSwgbih0W2ldLCBvKSA+PSAwKSBicmVhaztcbiAgICAgIHRbZV0gPSB0W2ldLCBlID0gaTtcbiAgICB9XG4gICAgdFtlXSA9IG87XG4gIH1cbn1cbmZ1bmN0aW9uICRsKHIsIGUpIHtcbiAgaWYgKHIubGVuZ3RoIDw9IDEpXG4gICAgcmV0dXJuIFtyXTtcbiAgY29uc3QgbiA9IFtdO1xuICBsZXQgYSwgbztcbiAgZm9yIChjb25zdCBpIG9mIHIpIHtcbiAgICBjb25zdCBzID0gRmwoaSk7XG4gICAgcyAhPT0gMCAmJiAoaS5hcmVhID0gTWF0aC5hYnMocyksIG8gPT09IHZvaWQgMCAmJiAobyA9IHMgPCAwKSwgbyA9PT0gcyA8IDAgPyAoYSAmJiBuLnB1c2goYSksIGEgPSBbaV0pIDogYS5wdXNoKGkpKTtcbiAgfVxuICByZXR1cm4gYSAmJiBuLnB1c2goYSksIG47XG59XG5mdW5jdGlvbiBGbChyKSB7XG4gIGxldCBlID0gMDtcbiAgZm9yIChsZXQgdCA9IDAsIG4gPSByLmxlbmd0aCwgYSA9IG4gLSAxLCBvLCBpOyB0IDwgbjsgYSA9IHQrKylcbiAgICBvID0gclt0XSwgaSA9IHJbYV0sIGUgKz0gKGkueCAtIG8ueCkgKiAoby55ICsgaS55KTtcbiAgcmV0dXJuIGU7XG59XG5jb25zdCBObCA9IDYzNzguMTM3LCBwYSA9IDEgLyAyOTguMjU3MjIzNTYzLCBmYSA9IHBhICogKDIgLSBwYSksIGRhID0gTWF0aC5QSSAvIDE4MDtcbmNsYXNzIEFuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGNvbnN0IHQgPSBkYSAqIE5sICogMWUzLCBuID0gTWF0aC5jb3MoZSAqIGRhKSwgYSA9IDEgLyAoMSAtIGZhICogKDEgLSBuICogbikpLCBvID0gTWF0aC5zcXJ0KGEpO1xuICAgIHRoaXMua3ggPSB0ICogbyAqIG4sIHRoaXMua3kgPSB0ICogbyAqIGEgKiAoMSAtIGZhKTtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gdHdvIHBvaW50cyBvZiB0aGUgZm9ybSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHJldHVybnMgdGhlIGRpc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gYSAtIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgKiBAcGFyYW0gYiAtIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgKiBAcmV0dXJucyBkaXN0YW5jZVxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkaXN0YW5jZSA9IHJ1bGVyLmRpc3RhbmNlKFszMC41LCA1MC41XSwgWzMwLjUxLCA1MC40OV0pO1xuICAgKiAvLz1kaXN0YW5jZVxuICAgKi9cbiAgZGlzdGFuY2UoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLndyYXAoZVswXSAtIHRbMF0pICogdGhpcy5reCwgYSA9IChlWzFdIC0gdFsxXSkgKiB0aGlzLmt5O1xuICAgIHJldHVybiBNYXRoLnNxcnQobiAqIG4gKyBhICogYSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIHtwb2ludCwgaW5kZXgsIHR9LCB3aGVyZSBwb2ludCBpcyBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lXG4gICAqIGZyb20gdGhlIGdpdmVuIHBvaW50LCBpbmRleCBpcyB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQgd2l0aCB0aGUgY2xvc2VzdCBwb2ludCxcbiAgICogYW5kIHQgaXMgYSBwYXJhbWV0ZXIgZnJvbSAwIHRvIDEgdGhhdCBpbmRpY2F0ZXMgd2hlcmUgdGhlIGNsb3Nlc3QgcG9pbnQgaXMgb24gdGhhdCBzZWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gbGluZSAtIGFuIGFycmF5IG9mIHBvaW50cyB0aGF0IGZvcm0gdGhlIGxpbmVcbiAgICogQHBhcmFtIHAgLSBwb2ludCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgICogQHJldHVybnMgdGhlIG5lYXJlc3QgcG9pbnQsIGl0cyBpbmRleCBpbiB0aGUgYXJyYXkgYW5kIHRoZSBwcm9wb3J0aW9uIGFsb25nIHRoZSBsaW5lXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHBvaW50ID0gcnVsZXIucG9pbnRPbkxpbmUobGluZSwgWy02Ny4wNCwgNTAuNV0pLnBvaW50O1xuICAgKiAvLz1wb2ludFxuICAgKi9cbiAgcG9pbnRPbkxpbmUoZSwgdCkge1xuICAgIGxldCBuID0gMSAvIDAsIGEsIG8sIGksIHM7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCBlLmxlbmd0aCAtIDE7IGwrKykge1xuICAgICAgbGV0IHUgPSBlW2xdWzBdLCBjID0gZVtsXVsxXSwgcCA9IHRoaXMud3JhcChlW2wgKyAxXVswXSAtIHUpICogdGhpcy5reCwgZCA9IChlW2wgKyAxXVsxXSAtIGMpICogdGhpcy5reSwgZiA9IDA7XG4gICAgICAocCAhPT0gMCB8fCBkICE9PSAwKSAmJiAoZiA9ICh0aGlzLndyYXAodFswXSAtIHUpICogdGhpcy5reCAqIHAgKyAodFsxXSAtIGMpICogdGhpcy5reSAqIGQpIC8gKHAgKiBwICsgZCAqIGQpLCBmID4gMSA/ICh1ID0gZVtsICsgMV1bMF0sIGMgPSBlW2wgKyAxXVsxXSkgOiBmID4gMCAmJiAodSArPSBwIC8gdGhpcy5reCAqIGYsIGMgKz0gZCAvIHRoaXMua3kgKiBmKSksIHAgPSB0aGlzLndyYXAodFswXSAtIHUpICogdGhpcy5reCwgZCA9ICh0WzFdIC0gYykgKiB0aGlzLmt5O1xuICAgICAgY29uc3QgaCA9IHAgKiBwICsgZCAqIGQ7XG4gICAgICBoIDwgbiAmJiAobiA9IGgsIGEgPSB1LCBvID0gYywgaSA9IGwsIHMgPSBmKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbYSwgb10sXG4gICAgICBpbmRleDogaSxcbiAgICAgIHQ6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHMpKVxuICAgIH07XG4gIH1cbiAgd3JhcChlKSB7XG4gICAgZm9yICg7IGUgPCAtMTgwOyApXG4gICAgICBlICs9IDM2MDtcbiAgICBmb3IgKDsgZSA+IDE4MDsgKVxuICAgICAgZSAtPSAzNjA7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cbmNvbnN0IEtyID0gMTAwLCBYciA9IDUwO1xuZnVuY3Rpb24gdm8ociwgZSkge1xuICByZXR1cm4gZVswXSAtIHJbMF07XG59XG5mdW5jdGlvbiBRdChyKSB7XG4gIHJldHVybiByWzFdIC0gclswXSArIDE7XG59XG5mdW5jdGlvbiBfZShyLCBlKSB7XG4gIHJldHVybiByWzFdID49IHJbMF0gJiYgclsxXSA8IGU7XG59XG5mdW5jdGlvbiBZcihyLCBlKSB7XG4gIGlmIChyWzBdID4gclsxXSlcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICBjb25zdCB0ID0gUXQocik7XG4gIGlmIChlKSB7XG4gICAgaWYgKHQgPT09IDIpXG4gICAgICByZXR1cm4gW3IsIG51bGxdO1xuICAgIGNvbnN0IGEgPSBNYXRoLmZsb29yKHQgLyAyKTtcbiAgICByZXR1cm4gW1xuICAgICAgW3JbMF0sIHJbMF0gKyBhXSxcbiAgICAgIFtyWzBdICsgYSwgclsxXV1cbiAgICBdO1xuICB9XG4gIGlmICh0ID09PSAxKVxuICAgIHJldHVybiBbciwgbnVsbF07XG4gIGNvbnN0IG4gPSBNYXRoLmZsb29yKHQgLyAyKSAtIDE7XG4gIHJldHVybiBbXG4gICAgW3JbMF0sIHJbMF0gKyBuXSxcbiAgICBbclswXSArIG4gKyAxLCByWzFdXVxuICBdO1xufVxuZnVuY3Rpb24gV3IociwgZSkge1xuICBpZiAoIV9lKGUsIHIubGVuZ3RoKSlcbiAgICByZXR1cm4gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdO1xuICBjb25zdCB0ID0gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdO1xuICBmb3IgKGxldCBuID0gZVswXTsgbiA8PSBlWzFdOyArK24pXG4gICAgSXQodCwgcltuXSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gSnIocikge1xuICBjb25zdCBlID0gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdO1xuICBmb3IgKGNvbnN0IHQgb2YgcilcbiAgICBmb3IgKGNvbnN0IG4gb2YgdClcbiAgICAgIEl0KGUsIG4pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGhhKHIpIHtcbiAgcmV0dXJuIHJbMF0gIT09IC0xIC8gMCAmJiByWzFdICE9PSAtMSAvIDAgJiYgclsyXSAhPT0gMSAvIDAgJiYgclszXSAhPT0gMSAvIDA7XG59XG5mdW5jdGlvbiBUbihyLCBlLCB0KSB7XG4gIGlmICghaGEocikgfHwgIWhhKGUpKVxuICAgIHJldHVybiBOYU47XG4gIGxldCBuID0gMCwgYSA9IDA7XG4gIHJldHVybiByWzJdIDwgZVswXSAmJiAobiA9IGVbMF0gLSByWzJdKSwgclswXSA+IGVbMl0gJiYgKG4gPSByWzBdIC0gZVsyXSksIHJbMV0gPiBlWzNdICYmIChhID0gclsxXSAtIGVbM10pLCByWzNdIDwgZVsxXSAmJiAoYSA9IGVbMV0gLSByWzNdKSwgdC5kaXN0YW5jZShbMCwgMF0sIFtuLCBhXSk7XG59XG5mdW5jdGlvbiBxZShyLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSB0LnBvaW50T25MaW5lKGUsIHIpO1xuICByZXR1cm4gdC5kaXN0YW5jZShyLCBuLnBvaW50KTtcbn1cbmZ1bmN0aW9uIF9uKHIsIGUsIHQsIG4sIGEpIHtcbiAgY29uc3QgbyA9IE1hdGgubWluKHFlKHIsIFt0LCBuXSwgYSksIHFlKGUsIFt0LCBuXSwgYSkpLCBpID0gTWF0aC5taW4ocWUodCwgW3IsIGVdLCBhKSwgcWUobiwgW3IsIGVdLCBhKSk7XG4gIHJldHVybiBNYXRoLm1pbihvLCBpKTtcbn1cbmZ1bmN0aW9uIGpsKHIsIGUsIHQsIG4sIGEpIHtcbiAgaWYgKCEoX2UoZSwgci5sZW5ndGgpICYmIF9lKG4sIHQubGVuZ3RoKSkpXG4gICAgcmV0dXJuIDEgLyAwO1xuICBsZXQgaSA9IDEgLyAwO1xuICBmb3IgKGxldCBzID0gZVswXTsgcyA8IGVbMV07ICsrcykge1xuICAgIGNvbnN0IGwgPSByW3NdLCB1ID0gcltzICsgMV07XG4gICAgZm9yIChsZXQgYyA9IG5bMF07IGMgPCBuWzFdOyArK2MpIHtcbiAgICAgIGNvbnN0IHAgPSB0W2NdLCBkID0gdFtjICsgMV07XG4gICAgICBpZiAoYnIobCwgdSwgcCwgZCkpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgaSA9IE1hdGgubWluKGksIF9uKGwsIHUsIHAsIGQsIGEpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBEbChyLCBlLCB0LCBuLCBhKSB7XG4gIGlmICghKF9lKGUsIHIubGVuZ3RoKSAmJiBfZShuLCB0Lmxlbmd0aCkpKVxuICAgIHJldHVybiBOYU47XG4gIGxldCBpID0gMSAvIDA7XG4gIGZvciAobGV0IHMgPSBlWzBdOyBzIDw9IGVbMV07ICsrcylcbiAgICBmb3IgKGxldCBsID0gblswXTsgbCA8PSBuWzFdOyArK2wpXG4gICAgICBpZiAoaSA9IE1hdGgubWluKGksIGEuZGlzdGFuY2UocltzXSwgdFtsXSkpLCBpID09PSAwKVxuICAgICAgICByZXR1cm4gaTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBVbChyLCBlLCB0KSB7XG4gIGlmICh1dChyLCBlLCAhMCkpXG4gICAgcmV0dXJuIDA7XG4gIGxldCBuID0gMSAvIDA7XG4gIGZvciAoY29uc3QgYSBvZiBlKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhW2EubGVuZ3RoIC0gMV07XG4gICAgaWYgKG8gIT09IGkgJiYgKG4gPSBNYXRoLm1pbihuLCBxZShyLCBbaSwgb10sIHQpKSwgbiA9PT0gMCkpXG4gICAgICByZXR1cm4gbjtcbiAgICBjb25zdCBzID0gdC5wb2ludE9uTGluZShhLCByKTtcbiAgICBpZiAobiA9IE1hdGgubWluKG4sIHQuZGlzdGFuY2Uociwgcy5wb2ludCkpLCBuID09PSAwKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBCbChyLCBlLCB0LCBuKSB7XG4gIGlmICghX2UoZSwgci5sZW5ndGgpKVxuICAgIHJldHVybiBOYU47XG4gIGZvciAobGV0IG8gPSBlWzBdOyBvIDw9IGVbMV07ICsrbylcbiAgICBpZiAodXQocltvXSwgdCwgITApKVxuICAgICAgcmV0dXJuIDA7XG4gIGxldCBhID0gMSAvIDA7XG4gIGZvciAobGV0IG8gPSBlWzBdOyBvIDwgZVsxXTsgKytvKSB7XG4gICAgY29uc3QgaSA9IHJbb10sIHMgPSByW28gKyAxXTtcbiAgICBmb3IgKGNvbnN0IGwgb2YgdClcbiAgICAgIGZvciAobGV0IHUgPSAwLCBjID0gbC5sZW5ndGgsIHAgPSBjIC0gMTsgdSA8IGM7IHAgPSB1KyspIHtcbiAgICAgICAgY29uc3QgZCA9IGxbcF0sIGYgPSBsW3VdO1xuICAgICAgICBpZiAoYnIoaSwgcywgZCwgZikpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGEgPSBNYXRoLm1pbihhLCBfbihpLCBzLCBkLCBmLCBuKSk7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBtYShyLCBlKSB7XG4gIGZvciAoY29uc3QgdCBvZiByKVxuICAgIGZvciAoY29uc3QgbiBvZiB0KVxuICAgICAgaWYgKHV0KG4sIGUsICEwKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBxbChyLCBlLCB0LCBuID0gMSAvIDApIHtcbiAgY29uc3QgYSA9IEpyKHIpLCBvID0gSnIoZSk7XG4gIGlmIChuICE9PSAxIC8gMCAmJiBUbihhLCBvLCB0KSA+PSBuKVxuICAgIHJldHVybiBuO1xuICBpZiAoeHQoYSwgbykpIHtcbiAgICBpZiAobWEociwgZSkpXG4gICAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChtYShlLCByKSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IGkgPSAxIC8gMDtcbiAgZm9yIChjb25zdCBzIG9mIHIpXG4gICAgZm9yIChsZXQgbCA9IDAsIHUgPSBzLmxlbmd0aCwgYyA9IHUgLSAxOyBsIDwgdTsgYyA9IGwrKykge1xuICAgICAgY29uc3QgcCA9IHNbY10sIGQgPSBzW2xdO1xuICAgICAgZm9yIChjb25zdCBmIG9mIGUpXG4gICAgICAgIGZvciAobGV0IGggPSAwLCBtID0gZi5sZW5ndGgsIHkgPSBtIC0gMTsgaCA8IG07IHkgPSBoKyspIHtcbiAgICAgICAgICBjb25zdCB3ID0gZlt5XSwgdiA9IGZbaF07XG4gICAgICAgICAgaWYgKGJyKHAsIGQsIHcsIHYpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgaSA9IE1hdGgubWluKGksIF9uKHAsIGQsIHcsIHYsIHQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB5YShyLCBlLCB0LCBuLCBhLCBvKSB7XG4gIGlmICghbylcbiAgICByZXR1cm47XG4gIGNvbnN0IGkgPSBUbihXcihuLCBvKSwgYSwgdCk7XG4gIGkgPCBlICYmIHIucHVzaChbaSwgbywgWzAsIDBdXSk7XG59XG5mdW5jdGlvbiBxdChyLCBlLCB0LCBuLCBhLCBvLCBpKSB7XG4gIGlmICghbyB8fCAhaSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSBUbihXcihuLCBvKSwgV3IoYSwgaSksIHQpO1xuICBzIDwgZSAmJiByLnB1c2goW3MsIG8sIGldKTtcbn1cbmZ1bmN0aW9uIGVyKHIsIGUsIHQsIG4sIGEgPSAxIC8gMCkge1xuICBsZXQgbyA9IE1hdGgubWluKG4uZGlzdGFuY2UoclswXSwgdFswXVswXSksIGEpO1xuICBpZiAobyA9PT0gMClcbiAgICByZXR1cm4gbztcbiAgY29uc3QgaSA9IG5ldyBnbyhbWzAsIFswLCByLmxlbmd0aCAtIDFdLCBbMCwgMF1dXSwgdm8pLCBzID0gSnIodCk7XG4gIGZvciAoOyBpLmxlbmd0aCA+IDA7ICkge1xuICAgIGNvbnN0IGwgPSBpLnBvcCgpO1xuICAgIGlmIChsWzBdID49IG8pXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB1ID0gbFsxXSwgYyA9IGUgPyBYciA6IEtyO1xuICAgIGlmIChRdCh1KSA8PSBjKSB7XG4gICAgICBpZiAoIV9lKHUsIHIubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IHAgPSBCbChyLCB1LCB0LCBuKTtcbiAgICAgICAgaWYgKGlzTmFOKHApIHx8IHAgPT09IDApXG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIG8gPSBNYXRoLm1pbihvLCBwKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBmb3IgKGxldCBwID0gdVswXTsgcCA8PSB1WzFdOyArK3ApIHtcbiAgICAgICAgICBjb25zdCBkID0gVWwocltwXSwgdCwgbik7XG4gICAgICAgICAgaWYgKG8gPSBNYXRoLm1pbihvLCBkKSwgbyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHAgPSBZcih1LCBlKTtcbiAgICAgIHlhKGksIG8sIG4sIHIsIHMsIHBbMF0pLCB5YShpLCBvLCBuLCByLCBzLCBwWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiB0cihyLCBlLCB0LCBuLCBhLCBvID0gMSAvIDApIHtcbiAgbGV0IGkgPSBNYXRoLm1pbihvLCBhLmRpc3RhbmNlKHJbMF0sIHRbMF0pKTtcbiAgaWYgKGkgPT09IDApXG4gICAgcmV0dXJuIGk7XG4gIGNvbnN0IHMgPSBuZXcgZ28oW1swLCBbMCwgci5sZW5ndGggLSAxXSwgWzAsIHQubGVuZ3RoIC0gMV1dXSwgdm8pO1xuICBmb3IgKDsgcy5sZW5ndGggPiAwOyApIHtcbiAgICBjb25zdCBsID0gcy5wb3AoKTtcbiAgICBpZiAobFswXSA+PSBpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgdSA9IGxbMV0sIGMgPSBsWzJdLCBwID0gZSA/IFhyIDogS3IsIGQgPSBuID8gWHIgOiBLcjtcbiAgICBpZiAoUXQodSkgPD0gcCAmJiBRdChjKSA8PSBkKSB7XG4gICAgICBpZiAoIV9lKHUsIHIubGVuZ3RoKSAmJiBfZShjLCB0Lmxlbmd0aCkpXG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICBsZXQgZjtcbiAgICAgIGlmIChlICYmIG4pXG4gICAgICAgIGYgPSBqbChyLCB1LCB0LCBjLCBhKSwgaSA9IE1hdGgubWluKGksIGYpO1xuICAgICAgZWxzZSBpZiAoZSAmJiAhbikge1xuICAgICAgICBjb25zdCBoID0gci5zbGljZSh1WzBdLCB1WzFdICsgMSk7XG4gICAgICAgIGZvciAobGV0IG0gPSBjWzBdOyBtIDw9IGNbMV07ICsrbSlcbiAgICAgICAgICBpZiAoZiA9IHFlKHRbbV0sIGgsIGEpLCBpID0gTWF0aC5taW4oaSwgZiksIGkgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0gZWxzZSBpZiAoIWUgJiYgbikge1xuICAgICAgICBjb25zdCBoID0gdC5zbGljZShjWzBdLCBjWzFdICsgMSk7XG4gICAgICAgIGZvciAobGV0IG0gPSB1WzBdOyBtIDw9IHVbMV07ICsrbSlcbiAgICAgICAgICBpZiAoZiA9IHFlKHJbbV0sIGgsIGEpLCBpID0gTWF0aC5taW4oaSwgZiksIGkgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBmID0gRGwociwgdSwgdCwgYywgYSksIGkgPSBNYXRoLm1pbihpLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZiA9IFlyKHUsIGUpLCBoID0gWXIoYywgbik7XG4gICAgICBxdChzLCBpLCBhLCByLCB0LCBmWzBdLCBoWzBdKSwgcXQocywgaSwgYSwgciwgdCwgZlswXSwgaFsxXSksIHF0KHMsIGksIGEsIHIsIHQsIGZbMV0sIGhbMF0pLCBxdChzLCBpLCBhLCByLCB0LCBmWzFdLCBoWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBWbChyLCBlKSB7XG4gIGNvbnN0IHQgPSByLmdlb21ldHJ5KCksIG4gPSB0LmZsYXQoKS5tYXAoKGkpID0+IEVuKFtpLngsIGkueV0sIHIuY2Fub25pY2FsKSk7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gTmFOO1xuICBjb25zdCBhID0gbmV3IEFuKG5bMF1bMV0pO1xuICBsZXQgbyA9IDEgLyAwO1xuICBmb3IgKGNvbnN0IGkgb2YgZSkge1xuICAgIHN3aXRjaCAoaS50eXBlKSB7XG4gICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIHRyKG4sICExLCBbaS5jb29yZGluYXRlc10sICExLCBhLCBvKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIHRyKG4sICExLCBpLmNvb3JkaW5hdGVzLCAhMCwgYSwgbykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIG8gPSBNYXRoLm1pbihvLCBlcihuLCAhMSwgaS5jb29yZGluYXRlcywgYSwgbykpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKG8gPT09IDApXG4gICAgICByZXR1cm4gbztcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEdsKHIsIGUpIHtcbiAgY29uc3QgdCA9IHIuZ2VvbWV0cnkoKSwgbiA9IHQuZmxhdCgpLm1hcCgoaSkgPT4gRW4oW2kueCwgaS55XSwgci5jYW5vbmljYWwpKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBOYU47XG4gIGNvbnN0IGEgPSBuZXcgQW4oblswXVsxXSk7XG4gIGxldCBvID0gMSAvIDA7XG4gIGZvciAoY29uc3QgaSBvZiBlKSB7XG4gICAgc3dpdGNoIChpLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICBvID0gTWF0aC5taW4obywgdHIobiwgITAsIFtpLmNvb3JkaW5hdGVzXSwgITEsIGEsIG8pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICBvID0gTWF0aC5taW4obywgdHIobiwgITAsIGkuY29vcmRpbmF0ZXMsICEwLCBhLCBvKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIGVyKG4sICEwLCBpLmNvb3JkaW5hdGVzLCBhLCBvKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobyA9PT0gMClcbiAgICAgIHJldHVybiBvO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gSGwociwgZSkge1xuICBjb25zdCB0ID0gci5nZW9tZXRyeSgpO1xuICBpZiAodC5sZW5ndGggPT09IDAgfHwgdFswXS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIE5hTjtcbiAgY29uc3QgbiA9ICRsKHQpLm1hcCgoaSkgPT4gaS5tYXAoKHMpID0+IHMubWFwKChsKSA9PiBFbihbbC54LCBsLnldLCByLmNhbm9uaWNhbCkpKSksIGEgPSBuZXcgQW4oblswXVswXVswXVsxXSk7XG4gIGxldCBvID0gMSAvIDA7XG4gIGZvciAoY29uc3QgaSBvZiBlKVxuICAgIGZvciAoY29uc3QgcyBvZiBuKSB7XG4gICAgICBzd2l0Y2ggKGkudHlwZSkge1xuICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICBvID0gTWF0aC5taW4obywgZXIoW2kuY29vcmRpbmF0ZXNdLCAhMSwgcywgYSwgbykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgIG8gPSBNYXRoLm1pbihvLCBlcihpLmNvb3JkaW5hdGVzLCAhMCwgcywgYSwgbykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICAgIG8gPSBNYXRoLm1pbihvLCBxbChzLCBpLmNvb3JkaW5hdGVzLCBhLCBvKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobyA9PT0gMClcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIHpyKHIpIHtcbiAgcmV0dXJuIHIudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIiA/IHIuY29vcmRpbmF0ZXMubWFwKChlKSA9PiAoe1xuICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgIGNvb3JkaW5hdGVzOiBlXG4gIH0pKSA6IHIudHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIiA/IHIuY29vcmRpbmF0ZXMubWFwKChlKSA9PiAoe1xuICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgIGNvb3JkaW5hdGVzOiBlXG4gIH0pKSA6IHIudHlwZSA9PT0gXCJNdWx0aVBvaW50XCIgPyByLmNvb3JkaW5hdGVzLm1hcCgoZSkgPT4gKHtcbiAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgY29vcmRpbmF0ZXM6IGVcbiAgfSkpIDogW3JdO1xufVxuY2xhc3MgWmUge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gUywgdGhpcy5nZW9qc29uID0gZSwgdGhpcy5nZW9tZXRyaWVzID0gdDtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybiB0LmVycm9yKGAnZGlzdGFuY2UnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBpZiAod3QoZVsxXSkpIHtcbiAgICAgIGNvbnN0IG4gPSBlWzFdO1xuICAgICAgaWYgKG4udHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKVxuICAgICAgICByZXR1cm4gbmV3IFplKG4sIG4uZmVhdHVyZXMubWFwKChhKSA9PiB6cihhLmdlb21ldHJ5KSkuZmxhdCgpKTtcbiAgICAgIGlmIChuLnR5cGUgPT09IFwiRmVhdHVyZVwiKVxuICAgICAgICByZXR1cm4gbmV3IFplKG4sIHpyKG4uZ2VvbWV0cnkpKTtcbiAgICAgIGlmIChcInR5cGVcIiBpbiBuICYmIFwiY29vcmRpbmF0ZXNcIiBpbiBuKVxuICAgICAgICByZXR1cm4gbmV3IFplKG4sIHpyKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHQuZXJyb3IoXCInZGlzdGFuY2UnIGV4cHJlc3Npb24gcmVxdWlyZXMgdmFsaWQgZ2VvanNvbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2x5Z29uIGdlb21ldHJ5IHR5cGUuXCIpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBpZiAoZS5nZW9tZXRyeSgpICE9IG51bGwgJiYgZS5jYW5vbmljYWxJRCgpICE9IG51bGwpIHtcbiAgICAgIGlmIChlLmdlb21ldHJ5VHlwZSgpID09PSBcIlBvaW50XCIpXG4gICAgICAgIHJldHVybiBWbChlLCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgaWYgKGUuZ2VvbWV0cnlUeXBlKCkgPT09IFwiTGluZVN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gR2woZSwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgIGlmIChlLmdlb21ldHJ5VHlwZSgpID09PSBcIlBvbHlnb25cIilcbiAgICAgICAgcmV0dXJuIEhsKGUsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgfVxuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZWFjaENoaWxkKCkge1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jbGFzcyBNdCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnR5cGUgPSBJLCB0aGlzLmtleSA9IGU7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgMSBhcmd1bWVudCwgYnV0IGZvdW5kICR7ZS5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuICAgIGNvbnN0IG4gPSBlWzFdO1xuICAgIHJldHVybiBuID09IG51bGwgPyB0LmVycm9yKFwiR2xvYmFsIHN0YXRlIHByb3BlcnR5IG11c3QgYmUgZGVmaW5lZC5cIikgOiB0eXBlb2YgbiAhPSBcInN0cmluZ1wiID8gdC5lcnJvcihgR2xvYmFsIHN0YXRlIHByb3BlcnR5IG11c3QgYmUgc3RyaW5nLCBidXQgZm91bmQgJHt0eXBlb2YgZVsxXX0gaW5zdGVhZC5gKSA6IG5ldyBNdChuKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3QgbiA9ICh0ID0gZS5nbG9iYWxzKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0Lmdsb2JhbFN0YXRlO1xuICAgIHJldHVybiAhbiB8fCBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDAgPyBudWxsIDogbXQobiwgdGhpcy5rZXkpO1xuICB9XG4gIGVhY2hDaGlsZCgpIHtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgSW4gPSB7XG4gIC8vIHNwZWNpYWwgZm9ybXNcbiAgXCI9PVwiOiB5bCxcbiAgXCIhPVwiOiBnbCxcbiAgXCI+XCI6IGJsLFxuICBcIjxcIjogdmwsXG4gIFwiPj1cIjogU2wsXG4gIFwiPD1cIjogd2wsXG4gIGFycmF5OiBoZSxcbiAgYXQ6IGduLFxuICBib29sZWFuOiBoZSxcbiAgY2FzZTogd24sXG4gIGNvYWxlc2NlOiBTdCxcbiAgY29sbGF0b3I6IHZyLFxuICBmb3JtYXQ6IHhuLFxuICBpbWFnZToga24sXG4gIGluOiB2bixcbiAgXCJpbmRleC1vZlwiOiBXdCxcbiAgaW50ZXJwb2xhdGU6IHhlLFxuICBcImludGVycG9sYXRlLWhjbFwiOiB4ZSxcbiAgXCJpbnRlcnBvbGF0ZS1sYWJcIjogeGUsXG4gIGxlbmd0aDogTG4sXG4gIGxldDogbXIsXG4gIGxpdGVyYWw6IGl0LFxuICBtYXRjaDogYm4sXG4gIG51bWJlcjogaGUsXG4gIFwibnVtYmVyLWZvcm1hdFwiOiBTbixcbiAgb2JqZWN0OiBoZSxcbiAgc2xpY2U6IEp0LFxuICBzdGVwOiBncixcbiAgc3RyaW5nOiBoZSxcbiAgXCJ0by1ib29sZWFuXCI6ICRlLFxuICBcInRvLWNvbG9yXCI6ICRlLFxuICBcInRvLW51bWJlclwiOiAkZSxcbiAgXCJ0by1zdHJpbmdcIjogJGUsXG4gIHZhcjogeXIsXG4gIHdpdGhpbjogSGUsXG4gIGRpc3RhbmNlOiBaZSxcbiAgXCJnbG9iYWwtc3RhdGVcIjogTXRcbn07XG5jbGFzcyBtZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEpIHtcbiAgICB0aGlzLm5hbWUgPSBlLCB0aGlzLnR5cGUgPSB0LCB0aGlzLl9ldmFsdWF0ZSA9IG4sIHRoaXMuYXJncyA9IGE7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZShlLCB0aGlzLmFyZ3MpO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goZSk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBjb25zdCBuID0gZVswXSwgYSA9IG1lLmRlZmluaXRpb25zW25dO1xuICAgIGlmICghYSlcbiAgICAgIHJldHVybiB0LmVycm9yKGBVbmtub3duIGV4cHJlc3Npb24gXCIke259XCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uYCwgMCk7XG4gICAgY29uc3QgbyA9IEFycmF5LmlzQXJyYXkoYSkgPyBhWzBdIDogYS50eXBlLCBpID0gQXJyYXkuaXNBcnJheShhKSA/IFtbYVsxXSwgYVsyXV1dIDogYS5vdmVybG9hZHMsIHMgPSBpLmZpbHRlcigoW3VdKSA9PiAhQXJyYXkuaXNBcnJheSh1KSB8fCAvLyB2YXJhZ3NcbiAgICB1Lmxlbmd0aCA9PT0gZS5sZW5ndGggLSAxKTtcbiAgICBsZXQgbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBbdSwgY10gb2Ygcykge1xuICAgICAgbCA9IG5ldyBocih0LnJlZ2lzdHJ5LCByciwgdC5wYXRoLCBudWxsLCB0LnNjb3BlKTtcbiAgICAgIGNvbnN0IHAgPSBbXTtcbiAgICAgIGxldCBkID0gITE7XG4gICAgICBmb3IgKGxldCBmID0gMTsgZiA8IGUubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgY29uc3QgaCA9IGVbZl0sIG0gPSBBcnJheS5pc0FycmF5KHUpID8gdVtmIC0gMV0gOiB1LnR5cGUsIHkgPSBsLnBhcnNlKGgsIDEgKyBwLmxlbmd0aCwgbSk7XG4gICAgICAgIGlmICgheSkge1xuICAgICAgICAgIGQgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwLnB1c2goeSk7XG4gICAgICB9XG4gICAgICBpZiAoIWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodSkgJiYgdS5sZW5ndGggIT09IHAubGVuZ3RoKSB7XG4gICAgICAgICAgbC5lcnJvcihgRXhwZWN0ZWQgJHt1Lmxlbmd0aH0gYXJndW1lbnRzLCBidXQgZm91bmQgJHtwLmxlbmd0aH0gaW5zdGVhZC5gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IHAubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICBjb25zdCBoID0gQXJyYXkuaXNBcnJheSh1KSA/IHVbZl0gOiB1LnR5cGUsIG0gPSBwW2ZdO1xuICAgICAgICAgIGwuY29uY2F0KGYgKyAxKS5jaGVja1N1YnR5cGUoaCwgbS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobC5lcnJvcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiBuZXcgbWUobiwgbywgYywgcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzLmxlbmd0aCA9PT0gMSlcbiAgICAgIHQuZXJyb3JzLnB1c2goLi4ubC5lcnJvcnMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYyA9IChzLmxlbmd0aCA/IHMgOiBpKS5tYXAoKFtkXSkgPT4gS2woZCkpLmpvaW4oXCIgfCBcIiksIHAgPSBbXTtcbiAgICAgIGZvciAobGV0IGQgPSAxOyBkIDwgZS5sZW5ndGg7IGQrKykge1xuICAgICAgICBjb25zdCBmID0gdC5wYXJzZShlW2RdLCAxICsgcC5sZW5ndGgpO1xuICAgICAgICBpZiAoIWYpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHAucHVzaChEKGYudHlwZSkpO1xuICAgICAgfVxuICAgICAgdC5lcnJvcihgRXhwZWN0ZWQgYXJndW1lbnRzIG9mIHR5cGUgJHtjfSwgYnV0IGZvdW5kICgke3Auam9pbihcIiwgXCIpfSkgaW5zdGVhZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIHJlZ2lzdGVyKGUsIHQpIHtcbiAgICBtZS5kZWZpbml0aW9ucyA9IHQ7XG4gICAgZm9yIChjb25zdCBuIGluIHQpXG4gICAgICBlW25dID0gbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdhKHIsIFtlLCB0LCBuLCBhXSkge1xuICBlID0gZS5ldmFsdWF0ZShyKSwgdCA9IHQuZXZhbHVhdGUociksIG4gPSBuLmV2YWx1YXRlKHIpO1xuICBjb25zdCBvID0gYSA/IGEuZXZhbHVhdGUocikgOiAxLCBpID0gbG8oZSwgdCwgbiwgbyk7XG4gIGlmIChpKVxuICAgIHRocm93IG5ldyBVKGkpO1xuICByZXR1cm4gbmV3ICQoZSAvIDI1NSwgdCAvIDI1NSwgbiAvIDI1NSwgbywgITEpO1xufVxuZnVuY3Rpb24gdmEociwgZSkge1xuICByZXR1cm4gciBpbiBlO1xufVxuZnVuY3Rpb24gT3IociwgZSkge1xuICBjb25zdCB0ID0gZVtyXTtcbiAgcmV0dXJuIHR5cGVvZiB0ID4gXCJ1XCIgPyBudWxsIDogdDtcbn1cbmZ1bmN0aW9uIFpsKHIsIGUsIHQsIG4pIHtcbiAgZm9yICg7IHQgPD0gbjsgKSB7XG4gICAgY29uc3QgYSA9IHQgKyBuID4+IDE7XG4gICAgaWYgKGVbYV0gPT09IHIpXG4gICAgICByZXR1cm4gITA7XG4gICAgZVthXSA+IHIgPyBuID0gYSAtIDEgOiB0ID0gYSArIDE7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gVWUocikge1xuICByZXR1cm4geyB0eXBlOiByIH07XG59XG5tZS5yZWdpc3RlcihJbiwge1xuICBlcnJvcjogW1xuICAgIFVzLFxuICAgIFtQXSxcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgVShlLmV2YWx1YXRlKHIpKTtcbiAgICB9XG4gIF0sXG4gIHR5cGVvZjogW1xuICAgIFAsXG4gICAgW0ldLFxuICAgIChyLCBbZV0pID0+IEQocShlLmV2YWx1YXRlKHIpKSlcbiAgXSxcbiAgXCJ0by1yZ2JhXCI6IFtcbiAgICBuZShTLCA0KSxcbiAgICBbU2VdLFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIGNvbnN0IFt0LCBuLCBhLCBvXSA9IGUuZXZhbHVhdGUocikucmdiO1xuICAgICAgcmV0dXJuIFt0ICogMjU1LCBuICogMjU1LCBhICogMjU1LCBvXTtcbiAgICB9XG4gIF0sXG4gIHJnYjogW1xuICAgIFNlLFxuICAgIFtTLCBTLCBTXSxcbiAgICBnYVxuICBdLFxuICByZ2JhOiBbXG4gICAgU2UsXG4gICAgW1MsIFMsIFMsIFNdLFxuICAgIGdhXG4gIF0sXG4gIGhhczoge1xuICAgIHR5cGU6IE0sXG4gICAgb3ZlcmxvYWRzOiBbXG4gICAgICBbXG4gICAgICAgIFtQXSxcbiAgICAgICAgKHIsIFtlXSkgPT4gdmEoZS5ldmFsdWF0ZShyKSwgci5wcm9wZXJ0aWVzKCkpXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbUCwgVmVdLFxuICAgICAgICAociwgW2UsIHRdKSA9PiB2YShlLmV2YWx1YXRlKHIpLCB0LmV2YWx1YXRlKHIpKVxuICAgICAgXVxuICAgIF1cbiAgfSxcbiAgZ2V0OiB7XG4gICAgdHlwZTogSSxcbiAgICBvdmVybG9hZHM6IFtcbiAgICAgIFtcbiAgICAgICAgW1BdLFxuICAgICAgICAociwgW2VdKSA9PiBPcihlLmV2YWx1YXRlKHIpLCByLnByb3BlcnRpZXMoKSlcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFtQLCBWZV0sXG4gICAgICAgIChyLCBbZSwgdF0pID0+IE9yKGUuZXZhbHVhdGUociksIHQuZXZhbHVhdGUocikpXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBcImZlYXR1cmUtc3RhdGVcIjogW1xuICAgIEksXG4gICAgW1BdLFxuICAgIChyLCBbZV0pID0+IE9yKGUuZXZhbHVhdGUociksIHIuZmVhdHVyZVN0YXRlIHx8IHt9KVxuICBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgVmUsXG4gICAgW10sXG4gICAgKHIpID0+IHIucHJvcGVydGllcygpXG4gIF0sXG4gIFwiZ2VvbWV0cnktdHlwZVwiOiBbXG4gICAgUCxcbiAgICBbXSxcbiAgICAocikgPT4gci5nZW9tZXRyeVR5cGUoKVxuICBdLFxuICBpZDogW1xuICAgIEksXG4gICAgW10sXG4gICAgKHIpID0+IHIuaWQoKVxuICBdLFxuICB6b29tOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAocikgPT4gci5nbG9iYWxzLnpvb21cbiAgXSxcbiAgXCJoZWF0bWFwLWRlbnNpdHlcIjogW1xuICAgIFMsXG4gICAgW10sXG4gICAgKHIpID0+IHIuZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwXG4gIF0sXG4gIGVsZXZhdGlvbjogW1xuICAgIFMsXG4gICAgW10sXG4gICAgKHIpID0+IHIuZ2xvYmFscy5lbGV2YXRpb24gfHwgMFxuICBdLFxuICBcImxpbmUtcHJvZ3Jlc3NcIjogW1xuICAgIFMsXG4gICAgW10sXG4gICAgKHIpID0+IHIuZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMFxuICBdLFxuICBhY2N1bXVsYXRlZDogW1xuICAgIEksXG4gICAgW10sXG4gICAgKHIpID0+IHIuZ2xvYmFscy5hY2N1bXVsYXRlZCA9PT0gdm9pZCAwID8gbnVsbCA6IHIuZ2xvYmFscy5hY2N1bXVsYXRlZFxuICBdLFxuICBcIitcIjogW1xuICAgIFMsXG4gICAgVWUoUyksXG4gICAgKHIsIGUpID0+IHtcbiAgICAgIGxldCB0ID0gMDtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBlKVxuICAgICAgICB0ICs9IG4uZXZhbHVhdGUocik7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gIF0sXG4gIFwiKlwiOiBbXG4gICAgUyxcbiAgICBVZShTKSxcbiAgICAociwgZSkgPT4ge1xuICAgICAgbGV0IHQgPSAxO1xuICAgICAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgICAgIHQgKj0gbi5ldmFsdWF0ZShyKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgXSxcbiAgXCItXCI6IHtcbiAgICB0eXBlOiBTLFxuICAgIG92ZXJsb2FkczogW1xuICAgICAgW1xuICAgICAgICBbUywgU10sXG4gICAgICAgIChyLCBbZSwgdF0pID0+IGUuZXZhbHVhdGUocikgLSB0LmV2YWx1YXRlKHIpXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbU10sXG4gICAgICAgIChyLCBbZV0pID0+IC1lLmV2YWx1YXRlKHIpXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBcIi9cIjogW1xuICAgIFMsXG4gICAgW1MsIFNdLFxuICAgIChyLCBbZSwgdF0pID0+IGUuZXZhbHVhdGUocikgLyB0LmV2YWx1YXRlKHIpXG4gIF0sXG4gIFwiJVwiOiBbXG4gICAgUyxcbiAgICBbUywgU10sXG4gICAgKHIsIFtlLCB0XSkgPT4gZS5ldmFsdWF0ZShyKSAlIHQuZXZhbHVhdGUocilcbiAgXSxcbiAgbG4yOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAoKSA9PiBNYXRoLkxOMlxuICBdLFxuICBwaTogW1xuICAgIFMsXG4gICAgW10sXG4gICAgKCkgPT4gTWF0aC5QSVxuICBdLFxuICBlOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAoKSA9PiBNYXRoLkVcbiAgXSxcbiAgXCJeXCI6IFtcbiAgICBTLFxuICAgIFtTLCBTXSxcbiAgICAociwgW2UsIHRdKSA9PiBNYXRoLnBvdyhlLmV2YWx1YXRlKHIpLCB0LmV2YWx1YXRlKHIpKVxuICBdLFxuICBzcXJ0OiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5zcXJ0KGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIGxvZzEwOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5sb2coZS5ldmFsdWF0ZShyKSkgLyBNYXRoLkxOMTBcbiAgXSxcbiAgbG46IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmxvZyhlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBsb2cyOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5sb2coZS5ldmFsdWF0ZShyKSkgLyBNYXRoLkxOMlxuICBdLFxuICBzaW46IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLnNpbihlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBjb3M6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmNvcyhlLmV2YWx1YXRlKHIpKVxuICBdLFxuICB0YW46IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLnRhbihlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBhc2luOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5hc2luKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIGFjb3M6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmFjb3MoZS5ldmFsdWF0ZShyKSlcbiAgXSxcbiAgYXRhbjogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGguYXRhbihlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBtaW46IFtcbiAgICBTLFxuICAgIFVlKFMpLFxuICAgIChyLCBlKSA9PiBNYXRoLm1pbiguLi5lLm1hcCgodCkgPT4gdC5ldmFsdWF0ZShyKSkpXG4gIF0sXG4gIG1heDogW1xuICAgIFMsXG4gICAgVWUoUyksXG4gICAgKHIsIGUpID0+IE1hdGgubWF4KC4uLmUubWFwKCh0KSA9PiB0LmV2YWx1YXRlKHIpKSlcbiAgXSxcbiAgYWJzOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5hYnMoZS5ldmFsdWF0ZShyKSlcbiAgXSxcbiAgcm91bmQ6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICBjb25zdCB0ID0gZS5ldmFsdWF0ZShyKTtcbiAgICAgIHJldHVybiB0IDwgMCA/IC1NYXRoLnJvdW5kKC10KSA6IE1hdGgucm91bmQodCk7XG4gICAgfVxuICBdLFxuICBmbG9vcjogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGguZmxvb3IoZS5ldmFsdWF0ZShyKSlcbiAgXSxcbiAgY2VpbDogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGguY2VpbChlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBcImZpbHRlci09PVwiOiBbXG4gICAgTSxcbiAgICBbUCwgSV0sXG4gICAgKHIsIFtlLCB0XSkgPT4gci5wcm9wZXJ0aWVzKClbZS52YWx1ZV0gPT09IHQudmFsdWVcbiAgXSxcbiAgXCJmaWx0ZXItaWQtPT1cIjogW1xuICAgIE0sXG4gICAgW0ldLFxuICAgIChyLCBbZV0pID0+IHIuaWQoKSA9PT0gZS52YWx1ZVxuICBdLFxuICBcImZpbHRlci10eXBlLT09XCI6IFtcbiAgICBNLFxuICAgIFtQXSxcbiAgICAociwgW2VdKSA9PiByLmdlb21ldHJ5VHlwZSgpID09PSBlLnZhbHVlXG4gIF0sXG4gIFwiZmlsdGVyLTxcIjogW1xuICAgIE0sXG4gICAgW1AsIEldLFxuICAgIChyLCBbZSwgdF0pID0+IHtcbiAgICAgIGNvbnN0IG4gPSByLnByb3BlcnRpZXMoKVtlLnZhbHVlXSwgYSA9IHQudmFsdWU7XG4gICAgICByZXR1cm4gdHlwZW9mIG4gPT0gdHlwZW9mIGEgJiYgbiA8IGE7XG4gICAgfVxuICBdLFxuICBcImZpbHRlci1pZC08XCI6IFtcbiAgICBNLFxuICAgIFtJXSxcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICBjb25zdCB0ID0gci5pZCgpLCBuID0gZS52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSB0eXBlb2YgbiAmJiB0IDwgbjtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLT5cIjogW1xuICAgIE0sXG4gICAgW1AsIEldLFxuICAgIChyLCBbZSwgdF0pID0+IHtcbiAgICAgIGNvbnN0IG4gPSByLnByb3BlcnRpZXMoKVtlLnZhbHVlXSwgYSA9IHQudmFsdWU7XG4gICAgICByZXR1cm4gdHlwZW9mIG4gPT0gdHlwZW9mIGEgJiYgbiA+IGE7XG4gICAgfVxuICBdLFxuICBcImZpbHRlci1pZC0+XCI6IFtcbiAgICBNLFxuICAgIFtJXSxcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICBjb25zdCB0ID0gci5pZCgpLCBuID0gZS52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSB0eXBlb2YgbiAmJiB0ID4gbjtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLTw9XCI6IFtcbiAgICBNLFxuICAgIFtQLCBJXSxcbiAgICAociwgW2UsIHRdKSA9PiB7XG4gICAgICBjb25zdCBuID0gci5wcm9wZXJ0aWVzKClbZS52YWx1ZV0sIGEgPSB0LnZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBhICYmIG4gPD0gYTtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLWlkLTw9XCI6IFtcbiAgICBNLFxuICAgIFtJXSxcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICBjb25zdCB0ID0gci5pZCgpLCBuID0gZS52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSB0eXBlb2YgbiAmJiB0IDw9IG47XG4gICAgfVxuICBdLFxuICBcImZpbHRlci0+PVwiOiBbXG4gICAgTSxcbiAgICBbUCwgSV0sXG4gICAgKHIsIFtlLCB0XSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHIucHJvcGVydGllcygpW2UudmFsdWVdLCBhID0gdC52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgYSAmJiBuID49IGE7XG4gICAgfVxuICBdLFxuICBcImZpbHRlci1pZC0+PVwiOiBbXG4gICAgTSxcbiAgICBbSV0sXG4gICAgKHIsIFtlXSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHIuaWQoKSwgbiA9IGUudmFsdWU7XG4gICAgICByZXR1cm4gdHlwZW9mIHQgPT0gdHlwZW9mIG4gJiYgdCA+PSBuO1xuICAgIH1cbiAgXSxcbiAgXCJmaWx0ZXItaGFzXCI6IFtcbiAgICBNLFxuICAgIFtJXSxcbiAgICAociwgW2VdKSA9PiBlLnZhbHVlIGluIHIucHJvcGVydGllcygpXG4gIF0sXG4gIFwiZmlsdGVyLWhhcy1pZFwiOiBbXG4gICAgTSxcbiAgICBbXSxcbiAgICAocikgPT4gci5pZCgpICE9PSBudWxsICYmIHIuaWQoKSAhPT0gdm9pZCAwXG4gIF0sXG4gIFwiZmlsdGVyLXR5cGUtaW5cIjogW1xuICAgIE0sXG4gICAgW25lKFApXSxcbiAgICAociwgW2VdKSA9PiBlLnZhbHVlLmluZGV4T2Yoci5nZW9tZXRyeVR5cGUoKSkgPj0gMFxuICBdLFxuICBcImZpbHRlci1pZC1pblwiOiBbXG4gICAgTSxcbiAgICBbbmUoSSldLFxuICAgIChyLCBbZV0pID0+IGUudmFsdWUuaW5kZXhPZihyLmlkKCkpID49IDBcbiAgXSxcbiAgXCJmaWx0ZXItaW4tc21hbGxcIjogW1xuICAgIE0sXG4gICAgW1AsIG5lKEkpXSxcbiAgICAvLyBhc3N1bWVzIHYgaXMgYW4gYXJyYXkgbGl0ZXJhbFxuICAgIChyLCBbZSwgdF0pID0+IHQudmFsdWUuaW5kZXhPZihyLnByb3BlcnRpZXMoKVtlLnZhbHVlXSkgPj0gMFxuICBdLFxuICBcImZpbHRlci1pbi1sYXJnZVwiOiBbXG4gICAgTSxcbiAgICBbUCwgbmUoSSldLFxuICAgIC8vIGFzc3VtZXMgdiBpcyBhIGFycmF5IGxpdGVyYWwgd2l0aCB2YWx1ZXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBhbmQgb2YgYSBzaW5nbGUgdHlwZVxuICAgIChyLCBbZSwgdF0pID0+IFpsKHIucHJvcGVydGllcygpW2UudmFsdWVdLCB0LnZhbHVlLCAwLCB0LnZhbHVlLmxlbmd0aCAtIDEpXG4gIF0sXG4gIGFsbDoge1xuICAgIHR5cGU6IE0sXG4gICAgb3ZlcmxvYWRzOiBbXG4gICAgICBbXG4gICAgICAgIFtNLCBNXSxcbiAgICAgICAgKHIsIFtlLCB0XSkgPT4gZS5ldmFsdWF0ZShyKSAmJiB0LmV2YWx1YXRlKHIpXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBVZShNKSxcbiAgICAgICAgKHIsIGUpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHQgb2YgZSlcbiAgICAgICAgICAgIGlmICghdC5ldmFsdWF0ZShyKSlcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIF1cbiAgfSxcbiAgYW55OiB7XG4gICAgdHlwZTogTSxcbiAgICBvdmVybG9hZHM6IFtcbiAgICAgIFtcbiAgICAgICAgW00sIE1dLFxuICAgICAgICAociwgW2UsIHRdKSA9PiBlLmV2YWx1YXRlKHIpIHx8IHQuZXZhbHVhdGUocilcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFVlKE0pLFxuICAgICAgICAociwgZSkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBlKVxuICAgICAgICAgICAgaWYgKHQuZXZhbHVhdGUocikpXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIFwiIVwiOiBbXG4gICAgTSxcbiAgICBbTV0sXG4gICAgKHIsIFtlXSkgPT4gIWUuZXZhbHVhdGUocilcbiAgXSxcbiAgXCJpcy1zdXBwb3J0ZWQtc2NyaXB0XCI6IFtcbiAgICBNLFxuICAgIFtQXSxcbiAgICAvLyBBdCBwYXJzZSB0aW1lIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUsIHNvIHdlIG5lZWQgdG8gZXhjbHVkZSB0aGlzIGV4cHJlc3Npb24gd2l0aCBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnRcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICBjb25zdCB0ID0gci5nbG9iYWxzICYmIHIuZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcbiAgICAgIHJldHVybiB0ID8gdChlLmV2YWx1YXRlKHIpKSA6ICEwO1xuICAgIH1cbiAgXSxcbiAgdXBjYXNlOiBbXG4gICAgUCxcbiAgICBbUF0sXG4gICAgKHIsIFtlXSkgPT4gZS5ldmFsdWF0ZShyKS50b1VwcGVyQ2FzZSgpXG4gIF0sXG4gIGRvd25jYXNlOiBbXG4gICAgUCxcbiAgICBbUF0sXG4gICAgKHIsIFtlXSkgPT4gZS5ldmFsdWF0ZShyKS50b0xvd2VyQ2FzZSgpXG4gIF0sXG4gIGNvbmNhdDogW1xuICAgIFAsXG4gICAgVWUoSSksXG4gICAgKHIsIGUpID0+IGUubWFwKCh0KSA9PiB5dCh0LmV2YWx1YXRlKHIpKSkuam9pbihcIlwiKVxuICBdLFxuICBcInJlc29sdmVkLWxvY2FsZVwiOiBbXG4gICAgUCxcbiAgICBbdXJdLFxuICAgIChyLCBbZV0pID0+IGUuZXZhbHVhdGUocikucmVzb2x2ZWRMb2NhbGUoKVxuICBdXG59KTtcbmZ1bmN0aW9uIEtsKHIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocikgPyBgKCR7ci5tYXAoRCkuam9pbihcIiwgXCIpfSlgIDogYCgke0Qoci50eXBlKX0uLi4pYDtcbn1cbmZ1bmN0aW9uIHJyKHIpIHtcbiAgaWYgKHIgaW5zdGFuY2VvZiB5cilcbiAgICByZXR1cm4gcnIoci5ib3VuZEV4cHJlc3Npb24pO1xuICBpZiAociBpbnN0YW5jZW9mIG1lICYmIHIubmFtZSA9PT0gXCJlcnJvclwiKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHIgaW5zdGFuY2VvZiB2cilcbiAgICByZXR1cm4gITE7XG4gIGlmIChyIGluc3RhbmNlb2YgSGUpXG4gICAgcmV0dXJuICExO1xuICBpZiAociBpbnN0YW5jZW9mIFplKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHIgaW5zdGFuY2VvZiBNdClcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGUgPSByIGluc3RhbmNlb2YgJGUgfHwgciBpbnN0YW5jZW9mIGhlO1xuICBsZXQgdCA9ICEwO1xuICByZXR1cm4gci5lYWNoQ2hpbGQoKG4pID0+IHtcbiAgICBlID8gdCA9IHQgJiYgcnIobikgOiB0ID0gdCAmJiBuIGluc3RhbmNlb2YgaXQ7XG4gIH0pLCB0ID8gd3IocikgJiYgU3IociwgW1wiem9vbVwiLCBcImhlYXRtYXAtZGVuc2l0eVwiLCBcImVsZXZhdGlvblwiLCBcImxpbmUtcHJvZ3Jlc3NcIiwgXCJhY2N1bXVsYXRlZFwiLCBcImlzLXN1cHBvcnRlZC1zY3JpcHRcIl0pIDogITE7XG59XG5mdW5jdGlvbiB3cihyKSB7XG4gIGlmIChyIGluc3RhbmNlb2YgbWUpIHtcbiAgICBpZiAoci5uYW1lID09PSBcImdldFwiICYmIHIuYXJncy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHIubmFtZSA9PT0gXCJmZWF0dXJlLXN0YXRlXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHIubmFtZSA9PT0gXCJoYXNcIiAmJiByLmFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChyLm5hbWUgPT09IFwicHJvcGVydGllc1wiIHx8IHIubmFtZSA9PT0gXCJnZW9tZXRyeS10eXBlXCIgfHwgci5uYW1lID09PSBcImlkXCIpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKC9eZmlsdGVyLS8udGVzdChyLm5hbWUpKVxuICAgICAgcmV0dXJuICExO1xuICB9XG4gIGlmIChyIGluc3RhbmNlb2YgSGUgfHwgciBpbnN0YW5jZW9mIFplKVxuICAgIHJldHVybiAhMTtcbiAgbGV0IGUgPSAhMDtcbiAgcmV0dXJuIHIuZWFjaENoaWxkKCh0KSA9PiB7XG4gICAgZSAmJiAhd3IodCkgJiYgKGUgPSAhMSk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24ga3Qocikge1xuICBpZiAociBpbnN0YW5jZW9mIG1lICYmIHIubmFtZSA9PT0gXCJmZWF0dXJlLXN0YXRlXCIpXG4gICAgcmV0dXJuICExO1xuICBsZXQgZSA9ICEwO1xuICByZXR1cm4gci5lYWNoQ2hpbGQoKHQpID0+IHtcbiAgICBlICYmICFrdCh0KSAmJiAoZSA9ICExKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBTcihyLCBlKSB7XG4gIGlmIChyIGluc3RhbmNlb2YgbWUgJiYgZS5pbmRleE9mKHIubmFtZSkgPj0gMClcbiAgICByZXR1cm4gITE7XG4gIGxldCB0ID0gITA7XG4gIHJldHVybiByLmVhY2hDaGlsZCgobikgPT4ge1xuICAgIHQgJiYgIVNyKG4sIGUpICYmICh0ID0gITEpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFFyKHIpIHtcbiAgcmV0dXJuIHsgcmVzdWx0OiBcInN1Y2Nlc3NcIiwgdmFsdWU6IHIgfTtcbn1cbmZ1bmN0aW9uIHR0KHIpIHtcbiAgcmV0dXJuIHsgcmVzdWx0OiBcImVycm9yXCIsIHZhbHVlOiByIH07XG59XG5mdW5jdGlvbiBucihyKSB7XG4gIHJldHVybiByW1wicHJvcGVydHktdHlwZVwiXSA9PT0gXCJkYXRhLWRyaXZlblwiIHx8IHJbXCJwcm9wZXJ0eS10eXBlXCJdID09PSBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCI7XG59XG5mdW5jdGlvbiBibyhyKSB7XG4gIHJldHVybiAhIXIuZXhwcmVzc2lvbiAmJiByLmV4cHJlc3Npb24ucGFyYW1ldGVycy5pbmRleE9mKFwiem9vbVwiKSA+IC0xO1xufVxuZnVuY3Rpb24gd28ocikge1xuICByZXR1cm4gISFyLmV4cHJlc3Npb24gJiYgci5leHByZXNzaW9uLmludGVycG9sYXRlZDtcbn1cbmZ1bmN0aW9uIFIocikge1xuICByZXR1cm4gciBpbnN0YW5jZW9mIE51bWJlciA/IFwibnVtYmVyXCIgOiByIGluc3RhbmNlb2YgU3RyaW5nID8gXCJzdHJpbmdcIiA6IHIgaW5zdGFuY2VvZiBCb29sZWFuID8gXCJib29sZWFuXCIgOiBBcnJheS5pc0FycmF5KHIpID8gXCJhcnJheVwiIDogciA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHI7XG59XG5mdW5jdGlvbiBNbihyKSB7XG4gIHJldHVybiB0eXBlb2YgciA9PSBcIm9iamVjdFwiICYmIHIgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocikgJiYgcShyKSA9PT0gVmU7XG59XG5jbGFzcyBYbCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBlLCB0aGlzLl93YXJuaW5nSGlzdG9yeSA9IHt9LCB0aGlzLl9ldmFsdWF0b3IgPSBuZXcgdW8oKSwgdGhpcy5fZGVmYXVsdFZhbHVlID0gdCA/IEpsKHQpIDogbnVsbCwgdGhpcy5fZW51bVZhbHVlcyA9IHQgJiYgdC50eXBlID09PSBcImVudW1cIiA/IHQudmFsdWVzIDogbnVsbDtcbiAgfVxuICBldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBlLCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IHQsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlU3RhdGUgPSBuLCB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gYSwgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IG8gfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBpLCB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcbiAgfVxuICBldmFsdWF0ZShlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBlLCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IHQgfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IG4gfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmNhbm9uaWNhbCA9IGEsIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBvIHx8IG51bGwsIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gaSB8fCBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG4gICAgICBpZiAocyA9PSBudWxsIHx8IHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyAhPT0gcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLl9lbnVtVmFsdWVzICYmICEocyBpbiB0aGlzLl9lbnVtVmFsdWVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFUoYEV4cGVjdGVkIHZhbHVlIHRvIGJlIG9uZSBvZiAke09iamVjdC5rZXlzKHRoaXMuX2VudW1WYWx1ZXMpLm1hcCgobCkgPT4gSlNPTi5zdHJpbmdpZnkobCkpLmpvaW4oXCIsIFwiKX0sIGJ1dCBmb3VuZCAke0pTT04uc3RyaW5naWZ5KHMpfSBpbnN0ZWFkLmApO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdIaXN0b3J5W3MubWVzc2FnZV0gfHwgKHRoaXMuX3dhcm5pbmdIaXN0b3J5W3MubWVzc2FnZV0gPSAhMCwgdHlwZW9mIGNvbnNvbGUgPCBcInVcIiAmJiBjb25zb2xlLndhcm4ocy5tZXNzYWdlKSksIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIFNvKHIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocikgJiYgci5sZW5ndGggPiAwICYmIHR5cGVvZiByWzBdID09IFwic3RyaW5nXCIgJiYgclswXSBpbiBJbjtcbn1cbmZ1bmN0aW9uIHhvKHIsIGUpIHtcbiAgY29uc3QgdCA9IG5ldyBocihJbiwgcnIsIFtdLCBlID8gV2woZSkgOiB2b2lkIDApLCBuID0gdC5wYXJzZShyLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBlICYmIGUudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZUFubm90YXRpb246IFwiY29lcmNlXCIgfSA6IHZvaWQgMCk7XG4gIHJldHVybiBuID8gUXIobmV3IFhsKG4sIGUpKSA6IHR0KHQuZXJyb3JzKTtcbn1cbmNsYXNzIGJhIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMua2luZCA9IGUsIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IHQsIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGUgIT09IFwiY29uc3RhbnRcIiAmJiAha3QodC5leHByZXNzaW9uKSwgdGhpcy5nbG9iYWxTdGF0ZVJlZnMgPSBQbih0LmV4cHJlc3Npb24pO1xuICB9XG4gIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZSwgdCwgbiwgYSwgbywgaSkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhlLCB0LCBuLCBhLCBvLCBpKTtcbiAgfVxuICBldmFsdWF0ZShlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShlLCB0LCBuLCBhLCBvLCBpKTtcbiAgfVxufVxuY2xhc3Mgd2Ege1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuLCBhKSB7XG4gICAgdGhpcy5raW5kID0gZSwgdGhpcy56b29tU3RvcHMgPSBuLCB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSB0LCB0aGlzLmlzU3RhdGVEZXBlbmRlbnQgPSBlICE9PSBcImNhbWVyYVwiICYmICFrdCh0LmV4cHJlc3Npb24pLCB0aGlzLmdsb2JhbFN0YXRlUmVmcyA9IFBuKHQuZXhwcmVzc2lvbiksIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBhO1xuICB9XG4gIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZSwgdCwgbiwgYSwgbywgaSkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhlLCB0LCBuLCBhLCBvLCBpKTtcbiAgfVxuICBldmFsdWF0ZShlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZShlLCB0LCBuLCBhLCBvLCBpKTtcbiAgfVxuICBpbnRlcnBvbGF0aW9uRmFjdG9yKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA/IHhlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uVHlwZSwgZSwgdCwgbikgOiAwO1xuICB9XG59XG5mdW5jdGlvbiBZbChyLCBlKSB7XG4gIGNvbnN0IHQgPSB4byhyLCBlKTtcbiAgaWYgKHQucmVzdWx0ID09PSBcImVycm9yXCIpXG4gICAgcmV0dXJuIHQ7XG4gIGNvbnN0IG4gPSB0LnZhbHVlLmV4cHJlc3Npb24sIGEgPSB3cihuKTtcbiAgaWYgKCFhICYmICFucihlKSlcbiAgICByZXR1cm4gdHQoW25ldyB3ZShcIlwiLCBcImRhdGEgZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZFwiKV0pO1xuICBjb25zdCBvID0gU3IobiwgW1wiem9vbVwiXSk7XG4gIGlmICghbyAmJiAhYm8oZSkpXG4gICAgcmV0dXJuIHR0KFtuZXcgd2UoXCJcIiwgXCJ6b29tIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWRcIildKTtcbiAgY29uc3QgaSA9IEh0KG4pO1xuICBpZiAoIWkgJiYgIW8pXG4gICAgcmV0dXJuIHR0KFtuZXcgd2UoXCJcIiwgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKV0pO1xuICBpZiAoaSBpbnN0YW5jZW9mIHdlKVxuICAgIHJldHVybiB0dChbaV0pO1xuICBpZiAoaSBpbnN0YW5jZW9mIHhlICYmICF3byhlKSlcbiAgICByZXR1cm4gdHQoW25ldyB3ZShcIlwiLCAnXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIGNhbm5vdCBiZSB1c2VkIHdpdGggdGhpcyBwcm9wZXJ0eScpXSk7XG4gIGlmICghaSlcbiAgICByZXR1cm4gUXIoYSA/IG5ldyBiYShcImNvbnN0YW50XCIsIHQudmFsdWUpIDogbmV3IGJhKFwic291cmNlXCIsIHQudmFsdWUpKTtcbiAgY29uc3QgcyA9IGkgaW5zdGFuY2VvZiB4ZSA/IGkuaW50ZXJwb2xhdGlvbiA6IHZvaWQgMDtcbiAgcmV0dXJuIFFyKGEgPyBuZXcgd2EoXCJjYW1lcmFcIiwgdC52YWx1ZSwgaS5sYWJlbHMsIHMpIDogbmV3IHdhKFwiY29tcG9zaXRlXCIsIHQudmFsdWUsIGkubGFiZWxzLCBzKSk7XG59XG5mdW5jdGlvbiBIdChyKSB7XG4gIGxldCBlID0gbnVsbDtcbiAgaWYgKHIgaW5zdGFuY2VvZiBtcilcbiAgICBlID0gSHQoci5yZXN1bHQpO1xuICBlbHNlIGlmIChyIGluc3RhbmNlb2YgU3QpIHtcbiAgICBmb3IgKGNvbnN0IHQgb2Ygci5hcmdzKVxuICAgICAgaWYgKGUgPSBIdCh0KSwgZSlcbiAgICAgICAgYnJlYWs7XG4gIH0gZWxzZSAociBpbnN0YW5jZW9mIGdyIHx8IHIgaW5zdGFuY2VvZiB4ZSkgJiYgci5pbnB1dCBpbnN0YW5jZW9mIG1lICYmIHIuaW5wdXQubmFtZSA9PT0gXCJ6b29tXCIgJiYgKGUgPSByKTtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiB3ZSB8fCByLmVhY2hDaGlsZCgodCkgPT4ge1xuICAgIGNvbnN0IG4gPSBIdCh0KTtcbiAgICBuIGluc3RhbmNlb2Ygd2UgPyBlID0gbiA6ICFlICYmIG4gPyBlID0gbmV3IHdlKFwiXCIsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJykgOiBlICYmIG4gJiYgZSAhPT0gbiAmJiAoZSA9IG5ldyB3ZShcIlwiLCAnT25seSBvbmUgem9vbS1iYXNlZCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBQbihyLCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICByZXR1cm4gciBpbnN0YW5jZW9mIE10ICYmIGUuYWRkKHIua2V5KSwgci5lYWNoQ2hpbGQoKHQpID0+IHtcbiAgICBQbih0LCBlKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBXbChyKSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgY29sb3I6IFNlLFxuICAgIHN0cmluZzogUCxcbiAgICBudW1iZXI6IFMsXG4gICAgZW51bTogUCxcbiAgICBib29sZWFuOiBNLFxuICAgIGZvcm1hdHRlZDogY3IsXG4gICAgcGFkZGluZzogcHIsXG4gICAgbnVtYmVyQXJyYXk6IGZyLFxuICAgIGNvbG9yQXJyYXk6IHZ0LFxuICAgIHByb2plY3Rpb25EZWZpbml0aW9uOiBscixcbiAgICByZXNvbHZlZEltYWdlOiBfdCxcbiAgICB2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb246IGRyXG4gIH07XG4gIHJldHVybiByLnR5cGUgPT09IFwiYXJyYXlcIiA/IG5lKGVbci52YWx1ZV0gfHwgSSwgci5sZW5ndGgpIDogZVtyLnR5cGVdO1xufVxuZnVuY3Rpb24gSmwocikge1xuICBpZiAoci50eXBlID09PSBcImNvbG9yXCIgJiYgTW4oci5kZWZhdWx0KSlcbiAgICByZXR1cm4gbmV3ICQoMCwgMCwgMCwgMCk7XG4gIHN3aXRjaCAoci50eXBlKSB7XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gJC5wYXJzZShyLmRlZmF1bHQpIHx8IG51bGw7XG4gICAgY2FzZSBcInBhZGRpbmdcIjpcbiAgICAgIHJldHVybiBpZS5wYXJzZShyLmRlZmF1bHQpIHx8IG51bGw7XG4gICAgY2FzZSBcIm51bWJlckFycmF5XCI6XG4gICAgICByZXR1cm4gc2UucGFyc2Uoci5kZWZhdWx0KSB8fCBudWxsO1xuICAgIGNhc2UgXCJjb2xvckFycmF5XCI6XG4gICAgICByZXR1cm4gUS5wYXJzZShyLmRlZmF1bHQpIHx8IG51bGw7XG4gICAgY2FzZSBcInZhcmlhYmxlQW5jaG9yT2Zmc2V0Q29sbGVjdGlvblwiOlxuICAgICAgcmV0dXJuIHllLnBhcnNlKHIuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICBjYXNlIFwicHJvamVjdGlvbkRlZmluaXRpb25cIjpcbiAgICAgIHJldHVybiBkZS5wYXJzZShyLmRlZmF1bHQpIHx8IG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiByLmRlZmF1bHQgPT09IHZvaWQgMCA/IG51bGwgOiByLmRlZmF1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGtvKHIpIHtcbiAgaWYgKHIgPT09ICEwIHx8IHIgPT09ICExKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgc3dpdGNoIChyWzBdKSB7XG4gICAgY2FzZSBcImhhc1wiOlxuICAgICAgcmV0dXJuIHIubGVuZ3RoID49IDIgJiYgclsxXSAhPT0gXCIkaWRcIiAmJiByWzFdICE9PSBcIiR0eXBlXCI7XG4gICAgY2FzZSBcImluXCI6XG4gICAgICByZXR1cm4gci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIHJbMV0gIT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHJbMl0pKTtcbiAgICBjYXNlIFwiIWluXCI6XG4gICAgY2FzZSBcIiFoYXNcIjpcbiAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgcmV0dXJuICExO1xuICAgIGNhc2UgXCI9PVwiOlxuICAgIGNhc2UgXCIhPVwiOlxuICAgIGNhc2UgXCI+XCI6XG4gICAgY2FzZSBcIj49XCI6XG4gICAgY2FzZSBcIjxcIjpcbiAgICBjYXNlIFwiPD1cIjpcbiAgICAgIHJldHVybiByLmxlbmd0aCAhPT0gMyB8fCBBcnJheS5pc0FycmF5KHJbMV0pIHx8IEFycmF5LmlzQXJyYXkoclsyXSk7XG4gICAgY2FzZSBcImFueVwiOlxuICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgIGZvciAoY29uc3QgZSBvZiByLnNsaWNlKDEpKVxuICAgICAgICBpZiAoIWtvKGUpICYmIHR5cGVvZiBlICE9IFwiYm9vbGVhblwiKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICEwO1xuICB9XG59XG5mdW5jdGlvbiBMbyhyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWU7XG4gIHJldHVybiB0ID8gW25ldyBiKGUsIHQsIFwiY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4XCIpXSA6IFtdO1xufVxuZnVuY3Rpb24gQihyKSB7XG4gIHJldHVybiByIGluc3RhbmNlb2YgTnVtYmVyIHx8IHIgaW5zdGFuY2VvZiBTdHJpbmcgfHwgciBpbnN0YW5jZW9mIEJvb2xlYW4gPyByLnZhbHVlT2YoKSA6IHI7XG59XG5mdW5jdGlvbiBZZShyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKVxuICAgIHJldHVybiByLm1hcChZZSk7XG4gIGlmIChyIGluc3RhbmNlb2YgT2JqZWN0ICYmICEociBpbnN0YW5jZW9mIE51bWJlciB8fCByIGluc3RhbmNlb2YgU3RyaW5nIHx8IHIgaW5zdGFuY2VvZiBCb29sZWFuKSkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHQgaW4gcilcbiAgICAgIGVbdF0gPSBZZShyW3RdKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gQihyKTtcbn1cbmZ1bmN0aW9uIGxlKHIpIHtcbiAgY29uc3QgZSA9IHIua2V5LCB0ID0gci52YWx1ZSwgbiA9IHIudmFsdWVTcGVjIHx8IHt9LCBhID0gci5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fSwgbyA9IHIuc3R5bGUsIGkgPSByLnN0eWxlU3BlYywgcyA9IHIudmFsaWRhdGVTcGVjO1xuICBsZXQgbCA9IFtdO1xuICBjb25zdCB1ID0gUih0KTtcbiAgaWYgKHUgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIFtuZXcgYihlLCB0LCBgb2JqZWN0IGV4cGVjdGVkLCAke3V9IGZvdW5kYCldO1xuICBmb3IgKGNvbnN0IGMgaW4gdCkge1xuICAgIGNvbnN0IHAgPSBjLnNwbGl0KFwiLlwiKVswXSwgZCA9IG10KG4sIHApIHx8IG5bXCIqXCJdO1xuICAgIGxldCBmO1xuICAgIGlmIChtdChhLCBwKSlcbiAgICAgIGYgPSBhW3BdO1xuICAgIGVsc2UgaWYgKG10KG4sIHApKVxuICAgICAgZiA9IHM7XG4gICAgZWxzZSBpZiAoYVtcIipcIl0pXG4gICAgICBmID0gYVtcIipcIl07XG4gICAgZWxzZSBpZiAobltcIipcIl0pXG4gICAgICBmID0gcztcbiAgICBlbHNlIHtcbiAgICAgIGwucHVzaChuZXcgYihlLCB0W2NdLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7Y31cImApKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsID0gbC5jb25jYXQoZih7XG4gICAgICBrZXk6IChlICYmIGAke2V9LmApICsgYyxcbiAgICAgIHZhbHVlOiB0W2NdLFxuICAgICAgdmFsdWVTcGVjOiBkLFxuICAgICAgc3R5bGU6IG8sXG4gICAgICBzdHlsZVNwZWM6IGksXG4gICAgICBvYmplY3Q6IHQsXG4gICAgICBvYmplY3RLZXk6IGMsXG4gICAgICB2YWxpZGF0ZVNwZWM6IHNcbiAgICB9LCB0KSk7XG4gIH1cbiAgZm9yIChjb25zdCBjIGluIG4pXG4gICAgYVtjXSB8fCBuW2NdLnJlcXVpcmVkICYmIG5bY10uZGVmYXVsdCA9PT0gdm9pZCAwICYmIHRbY10gPT09IHZvaWQgMCAmJiBsLnB1c2gobmV3IGIoZSwgdCwgYG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCIke2N9XCJgKSk7XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24gUm4ocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIudmFsdWVTcGVjLCBuID0gci52YWxpZGF0ZVNwZWMsIGEgPSByLnN0eWxlLCBvID0gci5zdHlsZVNwZWMsIGkgPSByLmtleSwgcyA9IHIuYXJyYXlFbGVtZW50VmFsaWRhdG9yIHx8IG47XG4gIGlmIChSKGUpICE9PSBcImFycmF5XCIpXG4gICAgcmV0dXJuIFtuZXcgYihpLCBlLCBgYXJyYXkgZXhwZWN0ZWQsICR7UihlKX0gZm91bmRgKV07XG4gIGlmICh0Lmxlbmd0aCAmJiBlLmxlbmd0aCAhPT0gdC5sZW5ndGgpXG4gICAgcmV0dXJuIFtuZXcgYihpLCBlLCBgYXJyYXkgbGVuZ3RoICR7dC5sZW5ndGh9IGV4cGVjdGVkLCBsZW5ndGggJHtlLmxlbmd0aH0gZm91bmRgKV07XG4gIGlmICh0W1wibWluLWxlbmd0aFwiXSAmJiBlLmxlbmd0aCA8IHRbXCJtaW4tbGVuZ3RoXCJdKVxuICAgIHJldHVybiBbbmV3IGIoaSwgZSwgYGFycmF5IGxlbmd0aCBhdCBsZWFzdCAke3RbXCJtaW4tbGVuZ3RoXCJdfSBleHBlY3RlZCwgbGVuZ3RoICR7ZS5sZW5ndGh9IGZvdW5kYCldO1xuICBsZXQgbCA9IHtcbiAgICB0eXBlOiB0LnZhbHVlLFxuICAgIHZhbHVlczogdC52YWx1ZXNcbiAgfTtcbiAgby4kdmVyc2lvbiA8IDcgJiYgKGwuZnVuY3Rpb24gPSB0LmZ1bmN0aW9uKSwgUih0LnZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAobCA9IHQudmFsdWUpO1xuICBsZXQgdSA9IFtdO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IGUubGVuZ3RoOyBjKyspXG4gICAgdSA9IHUuY29uY2F0KHMoe1xuICAgICAgYXJyYXk6IGUsXG4gICAgICBhcnJheUluZGV4OiBjLFxuICAgICAgdmFsdWU6IGVbY10sXG4gICAgICB2YWx1ZVNwZWM6IGwsXG4gICAgICB2YWxpZGF0ZVNwZWM6IHIudmFsaWRhdGVTcGVjLFxuICAgICAgc3R5bGU6IGEsXG4gICAgICBzdHlsZVNwZWM6IG8sXG4gICAgICBrZXk6IGAke2l9WyR7Y31dYFxuICAgIH0pKTtcbiAgcmV0dXJuIHU7XG59XG5mdW5jdGlvbiB4cihyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWUsIG4gPSByLnZhbHVlU3BlYztcbiAgbGV0IGEgPSBSKHQpO1xuICByZXR1cm4gYSA9PT0gXCJudW1iZXJcIiAmJiB0ICE9PSB0ICYmIChhID0gXCJOYU5cIiksIGEgIT09IFwibnVtYmVyXCIgPyBbbmV3IGIoZSwgdCwgYG51bWJlciBleHBlY3RlZCwgJHthfSBmb3VuZGApXSA6IFwibWluaW11bVwiIGluIG4gJiYgdCA8IG4ubWluaW11bSA/IFtuZXcgYihlLCB0LCBgJHt0fSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUgJHtuLm1pbmltdW19YCldIDogXCJtYXhpbXVtXCIgaW4gbiAmJiB0ID4gbi5tYXhpbXVtID8gW25ldyBiKGUsIHQsIGAke3R9IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSAke24ubWF4aW11bX1gKV0gOiBbXTtcbn1cbmZ1bmN0aW9uIEVvKHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWVTcGVjLCB0ID0gQihyLnZhbHVlLnR5cGUpO1xuICBsZXQgbiwgYSA9IHt9LCBvLCBpO1xuICBjb25zdCBzID0gdCAhPT0gXCJjYXRlZ29yaWNhbFwiICYmIHIudmFsdWUucHJvcGVydHkgPT09IHZvaWQgMCwgbCA9ICFzLCB1ID0gUihyLnZhbHVlLnN0b3BzKSA9PT0gXCJhcnJheVwiICYmIFIoci52YWx1ZS5zdG9wc1swXSkgPT09IFwiYXJyYXlcIiAmJiBSKHIudmFsdWUuc3RvcHNbMF1bMF0pID09PSBcIm9iamVjdFwiLCBjID0gbGUoe1xuICAgIGtleTogci5rZXksXG4gICAgdmFsdWU6IHIudmFsdWUsXG4gICAgdmFsdWVTcGVjOiByLnN0eWxlU3BlYy5mdW5jdGlvbixcbiAgICB2YWxpZGF0ZVNwZWM6IHIudmFsaWRhdGVTcGVjLFxuICAgIHN0eWxlOiByLnN0eWxlLFxuICAgIHN0eWxlU3BlYzogci5zdHlsZVNwZWMsXG4gICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgIHN0b3BzOiBwLFxuICAgICAgZGVmYXVsdDogaFxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ID09PSBcImlkZW50aXR5XCIgJiYgcyAmJiBjLnB1c2gobmV3IGIoci5rZXksIHIudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwicHJvcGVydHlcIicpKSwgdCAhPT0gXCJpZGVudGl0eVwiICYmICFyLnZhbHVlLnN0b3BzICYmIGMucHVzaChuZXcgYihyLmtleSwgci52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzdG9wc1wiJykpLCB0ID09PSBcImV4cG9uZW50aWFsXCIgJiYgci52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhd28oci52YWx1ZVNwZWMpICYmIGMucHVzaChuZXcgYihyLmtleSwgci52YWx1ZSwgXCJleHBvbmVudGlhbCBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZFwiKSksIHIuc3R5bGVTcGVjLiR2ZXJzaW9uID49IDggJiYgKGwgJiYgIW5yKHIudmFsdWVTcGVjKSA/IGMucHVzaChuZXcgYihyLmtleSwgci52YWx1ZSwgXCJwcm9wZXJ0eSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZFwiKSkgOiBzICYmICFibyhyLnZhbHVlU3BlYykgJiYgYy5wdXNoKG5ldyBiKHIua2V5LCByLnZhbHVlLCBcInpvb20gZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIikpKSwgKHQgPT09IFwiY2F0ZWdvcmljYWxcIiB8fCB1KSAmJiByLnZhbHVlLnByb3BlcnR5ID09PSB2b2lkIDAgJiYgYy5wdXNoKG5ldyBiKHIua2V5LCByLnZhbHVlLCAnXCJwcm9wZXJ0eVwiIHByb3BlcnR5IGlzIHJlcXVpcmVkJykpLCBjO1xuICBmdW5jdGlvbiBwKG0pIHtcbiAgICBpZiAodCA9PT0gXCJpZGVudGl0eVwiKVxuICAgICAgcmV0dXJuIFtuZXcgYihtLmtleSwgbS52YWx1ZSwgJ2lkZW50aXR5IGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBhIFwic3RvcHNcIiBwcm9wZXJ0eScpXTtcbiAgICBsZXQgeSA9IFtdO1xuICAgIGNvbnN0IHcgPSBtLnZhbHVlO1xuICAgIHJldHVybiB5ID0geS5jb25jYXQoUm4oe1xuICAgICAga2V5OiBtLmtleSxcbiAgICAgIHZhbHVlOiB3LFxuICAgICAgdmFsdWVTcGVjOiBtLnZhbHVlU3BlYyxcbiAgICAgIHZhbGlkYXRlU3BlYzogbS52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogbS5zdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogbS5zdHlsZVNwZWMsXG4gICAgICBhcnJheUVsZW1lbnRWYWxpZGF0b3I6IGRcbiAgICB9KSksIFIodykgPT09IFwiYXJyYXlcIiAmJiB3Lmxlbmd0aCA9PT0gMCAmJiB5LnB1c2gobmV3IGIobS5rZXksIHcsIFwiYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wXCIpKSwgeTtcbiAgfVxuICBmdW5jdGlvbiBkKG0pIHtcbiAgICBsZXQgeSA9IFtdO1xuICAgIGNvbnN0IHcgPSBtLnZhbHVlLCB2ID0gbS5rZXk7XG4gICAgaWYgKFIodykgIT09IFwiYXJyYXlcIilcbiAgICAgIHJldHVybiBbbmV3IGIodiwgdywgYGFycmF5IGV4cGVjdGVkLCAke1Iodyl9IGZvdW5kYCldO1xuICAgIGlmICh3Lmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybiBbbmV3IGIodiwgdywgYGFycmF5IGxlbmd0aCAyIGV4cGVjdGVkLCBsZW5ndGggJHt3Lmxlbmd0aH0gZm91bmRgKV07XG4gICAgaWYgKHUpIHtcbiAgICAgIGlmIChSKHdbMF0pICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gW25ldyBiKHYsIHcsIGBvYmplY3QgZXhwZWN0ZWQsICR7Uih3WzBdKX0gZm91bmRgKV07XG4gICAgICBpZiAod1swXS56b29tID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiBbbmV3IGIodiwgdywgXCJvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHpvb21cIildO1xuICAgICAgaWYgKHdbMF0udmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIFtuZXcgYih2LCB3LCBcIm9iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgdmFsdWVcIildO1xuICAgICAgaWYgKGkgJiYgaSA+IEIod1swXS56b29tKSlcbiAgICAgICAgcmV0dXJuIFtuZXcgYih2LCB3WzBdLnpvb20sIFwic3RvcCB6b29tIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXJcIildO1xuICAgICAgQih3WzBdLnpvb20pICE9PSBpICYmIChpID0gQih3WzBdLnpvb20pLCBvID0gdm9pZCAwLCBhID0ge30pLCB5ID0geS5jb25jYXQobGUoe1xuICAgICAgICBrZXk6IGAke3Z9WzBdYCxcbiAgICAgICAgdmFsdWU6IHdbMF0sXG4gICAgICAgIHZhbHVlU3BlYzogeyB6b29tOiB7fSB9LFxuICAgICAgICB2YWxpZGF0ZVNwZWM6IG0udmFsaWRhdGVTcGVjLFxuICAgICAgICBzdHlsZTogbS5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBtLnN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHsgem9vbTogeHIsIHZhbHVlOiBmIH1cbiAgICAgIH0pKTtcbiAgICB9IGVsc2VcbiAgICAgIHkgPSB5LmNvbmNhdChmKHtcbiAgICAgICAga2V5OiBgJHt2fVswXWAsXG4gICAgICAgIHZhbHVlOiB3WzBdLFxuICAgICAgICB2YWxpZGF0ZVNwZWM6IG0udmFsaWRhdGVTcGVjLFxuICAgICAgICBzdHlsZTogbS5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBtLnN0eWxlU3BlY1xuICAgICAgfSwgdykpO1xuICAgIHJldHVybiBTbyhZZSh3WzFdKSkgPyB5LmNvbmNhdChbbmV3IGIoYCR7dn1bMV1gLCB3WzFdLCBcImV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiBzdG9wcy5cIildKSA6IHkuY29uY2F0KG0udmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogYCR7dn1bMV1gLFxuICAgICAgdmFsdWU6IHdbMV0sXG4gICAgICB2YWx1ZVNwZWM6IGUsXG4gICAgICB2YWxpZGF0ZVNwZWM6IG0udmFsaWRhdGVTcGVjLFxuICAgICAgc3R5bGU6IG0uc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IG0uc3R5bGVTcGVjXG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGYobSwgeSkge1xuICAgIGNvbnN0IHcgPSBSKG0udmFsdWUpLCB2ID0gQihtLnZhbHVlKSwgeCA9IG0udmFsdWUgIT09IG51bGwgPyBtLnZhbHVlIDogeTtcbiAgICBpZiAoIW4pXG4gICAgICBuID0gdztcbiAgICBlbHNlIGlmICh3ICE9PSBuKVxuICAgICAgcmV0dXJuIFtuZXcgYihtLmtleSwgeCwgYCR7d30gc3RvcCBkb21haW4gdHlwZSBtdXN0IG1hdGNoIHByZXZpb3VzIHN0b3AgZG9tYWluIHR5cGUgJHtufWApXTtcbiAgICBpZiAodyAhPT0gXCJudW1iZXJcIiAmJiB3ICE9PSBcInN0cmluZ1wiICYmIHcgIT09IFwiYm9vbGVhblwiKVxuICAgICAgcmV0dXJuIFtuZXcgYihtLmtleSwgeCwgXCJzdG9wIGRvbWFpbiB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLCBzdHJpbmcsIG9yIGJvb2xlYW5cIildO1xuICAgIGlmICh3ICE9PSBcIm51bWJlclwiICYmIHQgIT09IFwiY2F0ZWdvcmljYWxcIikge1xuICAgICAgbGV0IEEgPSBgbnVtYmVyIGV4cGVjdGVkLCAke3d9IGZvdW5kYDtcbiAgICAgIHJldHVybiBucihlKSAmJiB0ID09PSB2b2lkIDAgJiYgKEEgKz0gJ1xcbklmIHlvdSBpbnRlbmRlZCB0byB1c2UgYSBjYXRlZ29yaWNhbCBmdW5jdGlvbiwgc3BlY2lmeSBgXCJ0eXBlXCI6IFwiY2F0ZWdvcmljYWxcImAuJyksIFtuZXcgYihtLmtleSwgeCwgQSldO1xuICAgIH1cbiAgICByZXR1cm4gdCA9PT0gXCJjYXRlZ29yaWNhbFwiICYmIHcgPT09IFwibnVtYmVyXCIgJiYgKCFpc0Zpbml0ZSh2KSB8fCBNYXRoLmZsb29yKHYpICE9PSB2KSA/IFtuZXcgYihtLmtleSwgeCwgYGludGVnZXIgZXhwZWN0ZWQsIGZvdW5kICR7dn1gKV0gOiB0ICE9PSBcImNhdGVnb3JpY2FsXCIgJiYgdyA9PT0gXCJudW1iZXJcIiAmJiBvICE9PSB2b2lkIDAgJiYgdiA8IG8gPyBbbmV3IGIobS5rZXksIHgsIFwic3RvcCBkb21haW4gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlclwiKV0gOiAobyA9IHYsIHQgPT09IFwiY2F0ZWdvcmljYWxcIiAmJiB2IGluIGEgPyBbbmV3IGIobS5rZXksIHgsIFwic3RvcCBkb21haW4gdmFsdWVzIG11c3QgYmUgdW5pcXVlXCIpXSA6IChhW3ZdID0gITAsIFtdKSk7XG4gIH1cbiAgZnVuY3Rpb24gaChtKSB7XG4gICAgcmV0dXJuIG0udmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogbS5rZXksXG4gICAgICB2YWx1ZTogbS52YWx1ZSxcbiAgICAgIHZhbHVlU3BlYzogZSxcbiAgICAgIHZhbGlkYXRlU3BlYzogbS52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogbS5zdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogbS5zdHlsZVNwZWNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc3Qocikge1xuICBjb25zdCBlID0gKHIuZXhwcmVzc2lvbkNvbnRleHQgPT09IFwicHJvcGVydHlcIiA/IFlsIDogeG8pKFllKHIudmFsdWUpLCByLnZhbHVlU3BlYyk7XG4gIGlmIChlLnJlc3VsdCA9PT0gXCJlcnJvclwiKVxuICAgIHJldHVybiBlLnZhbHVlLm1hcCgobikgPT4gbmV3IGIoYCR7ci5rZXl9JHtuLmtleX1gLCByLnZhbHVlLCBuLm1lc3NhZ2UpKTtcbiAgY29uc3QgdCA9IGUudmFsdWUuZXhwcmVzc2lvbiB8fCBlLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgaWYgKHIuZXhwcmVzc2lvbkNvbnRleHQgPT09IFwicHJvcGVydHlcIiAmJiByLnByb3BlcnR5S2V5ID09PSBcInRleHQtZm9udFwiICYmICF0Lm91dHB1dERlZmluZWQoKSlcbiAgICByZXR1cm4gW25ldyBiKHIua2V5LCByLnZhbHVlLCBgSW52YWxpZCBkYXRhIGV4cHJlc3Npb24gZm9yIFwiJHtyLnByb3BlcnR5S2V5fVwiLiBPdXRwdXQgdmFsdWVzIG11c3QgYmUgY29udGFpbmVkIGFzIGxpdGVyYWxzIHdpdGhpbiB0aGUgZXhwcmVzc2lvbi5gKV07XG4gIGlmIChyLmV4cHJlc3Npb25Db250ZXh0ID09PSBcInByb3BlcnR5XCIgJiYgci5wcm9wZXJ0eVR5cGUgPT09IFwibGF5b3V0XCIgJiYgIWt0KHQpKVxuICAgIHJldHVybiBbbmV3IGIoci5rZXksIHIudmFsdWUsICdcImZlYXR1cmUtc3RhdGVcIiBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbGF5b3V0IHByb3BlcnRpZXMuJyldO1xuICBpZiAoci5leHByZXNzaW9uQ29udGV4dCA9PT0gXCJmaWx0ZXJcIiAmJiAha3QodCkpXG4gICAgcmV0dXJuIFtuZXcgYihyLmtleSwgci52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBmaWx0ZXJzLicpXTtcbiAgaWYgKHIuZXhwcmVzc2lvbkNvbnRleHQgJiYgci5leHByZXNzaW9uQ29udGV4dC5pbmRleE9mKFwiY2x1c3RlclwiKSA9PT0gMCkge1xuICAgIGlmICghU3IodCwgW1wiem9vbVwiLCBcImZlYXR1cmUtc3RhdGVcIl0pKVxuICAgICAgcmV0dXJuIFtuZXcgYihyLmtleSwgci52YWx1ZSwgJ1wiem9vbVwiIGFuZCBcImZlYXR1cmUtc3RhdGVcIiBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGNsdXN0ZXIgcHJvcGVydGllcy4nKV07XG4gICAgaWYgKHIuZXhwcmVzc2lvbkNvbnRleHQgPT09IFwiY2x1c3Rlci1pbml0aWFsXCIgJiYgIXdyKHQpKVxuICAgICAgcmV0dXJuIFtuZXcgYihyLmtleSwgci52YWx1ZSwgXCJGZWF0dXJlIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBpbml0aWFsIGV4cHJlc3Npb24gcGFydCBvZiBjbHVzdGVyIHByb3BlcnRpZXMuXCIpXTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBRbChyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci5rZXksIG4gPSBSKGUpO1xuICByZXR1cm4gbiAhPT0gXCJib29sZWFuXCIgPyBbbmV3IGIodCwgZSwgYGJvb2xlYW4gZXhwZWN0ZWQsICR7bn0gZm91bmRgKV0gOiBbXTtcbn1cbmZ1bmN0aW9uIGVuKHIpIHtcbiAgY29uc3QgZSA9IHIua2V5LCB0ID0gci52YWx1ZSwgbiA9IFIodCk7XG4gIHJldHVybiBuICE9PSBcInN0cmluZ1wiID8gW25ldyBiKGUsIHQsIGBjb2xvciBleHBlY3RlZCwgJHtufSBmb3VuZGApXSA6ICQucGFyc2UoU3RyaW5nKHQpKSA/IFtdIDogW25ldyBiKGUsIHQsIGBjb2xvciBleHBlY3RlZCwgXCIke3R9XCIgZm91bmRgKV07XG59XG5mdW5jdGlvbiBMdChyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWUsIG4gPSByLnZhbHVlU3BlYywgYSA9IFtdO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShuLnZhbHVlcykgPyBuLnZhbHVlcy5pbmRleE9mKEIodCkpID09PSAtMSAmJiBhLnB1c2gobmV3IGIoZSwgdCwgYGV4cGVjdGVkIG9uZSBvZiBbJHtuLnZhbHVlcy5qb2luKFwiLCBcIil9XSwgJHtKU09OLnN0cmluZ2lmeSh0KX0gZm91bmRgKSkgOiBPYmplY3Qua2V5cyhuLnZhbHVlcykuaW5kZXhPZihCKHQpKSA9PT0gLTEgJiYgYS5wdXNoKG5ldyBiKGUsIHQsIGBleHBlY3RlZCBvbmUgb2YgWyR7T2JqZWN0LmtleXMobi52YWx1ZXMpLmpvaW4oXCIsIFwiKX1dLCAke0pTT04uc3RyaW5naWZ5KHQpfSBmb3VuZGApKSwgYTtcbn1cbmZ1bmN0aW9uIHpuKHIpIHtcbiAgcmV0dXJuIGtvKFllKHIudmFsdWUpKSA/IHN0KFl0KHt9LCByLCB7XG4gICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwiZmlsdGVyXCIsXG4gICAgdmFsdWVTcGVjOiB7IHZhbHVlOiBcImJvb2xlYW5cIiB9XG4gIH0pKSA6IENvKHIpO1xufVxuZnVuY3Rpb24gQ28ocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIua2V5O1xuICBpZiAoUihlKSAhPT0gXCJhcnJheVwiKVxuICAgIHJldHVybiBbbmV3IGIodCwgZSwgYGFycmF5IGV4cGVjdGVkLCAke1IoZSl9IGZvdW5kYCldO1xuICBjb25zdCBuID0gci5zdHlsZVNwZWM7XG4gIGxldCBhLCBvID0gW107XG4gIGlmIChlLmxlbmd0aCA8IDEpXG4gICAgcmV0dXJuIFtuZXcgYih0LCBlLCBcImZpbHRlciBhcnJheSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBlbGVtZW50XCIpXTtcbiAgc3dpdGNoIChvID0gby5jb25jYXQoTHQoe1xuICAgIGtleTogYCR7dH1bMF1gLFxuICAgIHZhbHVlOiBlWzBdLFxuICAgIHZhbHVlU3BlYzogbi5maWx0ZXJfb3BlcmF0b3IsXG4gICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgc3R5bGVTcGVjOiByLnN0eWxlU3BlY1xuICB9KSksIEIoZVswXSkpIHtcbiAgICBjYXNlIFwiPFwiOlxuICAgIGNhc2UgXCI8PVwiOlxuICAgIGNhc2UgXCI+XCI6XG4gICAgY2FzZSBcIj49XCI6XG4gICAgICBlLmxlbmd0aCA+PSAyICYmIEIoZVsxXSkgPT09IFwiJHR5cGVcIiAmJiBvLnB1c2gobmV3IGIodCwgZSwgYFwiJHR5cGVcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXCIke2VbMF19XCJgKSk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgXCI9PVwiOlxuICAgIGNhc2UgXCIhPVwiOlxuICAgICAgZS5sZW5ndGggIT09IDMgJiYgby5wdXNoKG5ldyBiKHQsIGUsIGBmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFwiJHtlWzBdfVwiIG11c3QgaGF2ZSAzIGVsZW1lbnRzYCkpO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFwiaW5cIjpcbiAgICBjYXNlIFwiIWluXCI6XG4gICAgICBlLmxlbmd0aCA+PSAyICYmIChhID0gUihlWzFdKSwgYSAhPT0gXCJzdHJpbmdcIiAmJiBvLnB1c2gobmV3IGIoYCR7dH1bMV1gLCBlWzFdLCBgc3RyaW5nIGV4cGVjdGVkLCAke2F9IGZvdW5kYCkpKTtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgZS5sZW5ndGg7IGkrKylcbiAgICAgICAgYSA9IFIoZVtpXSksIEIoZVsxXSkgPT09IFwiJHR5cGVcIiA/IG8gPSBvLmNvbmNhdChMdCh7XG4gICAgICAgICAga2V5OiBgJHt0fVske2l9XWAsXG4gICAgICAgICAgdmFsdWU6IGVbaV0sXG4gICAgICAgICAgdmFsdWVTcGVjOiBuLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiByLnN0eWxlU3BlY1xuICAgICAgICB9KSkgOiBhICE9PSBcInN0cmluZ1wiICYmIGEgIT09IFwibnVtYmVyXCIgJiYgYSAhPT0gXCJib29sZWFuXCIgJiYgby5wdXNoKG5ldyBiKGAke3R9WyR7aX1dYCwgZVtpXSwgYHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCAke2F9IGZvdW5kYCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFueVwiOlxuICAgIGNhc2UgXCJhbGxcIjpcbiAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBlLmxlbmd0aDsgaSsrKVxuICAgICAgICBvID0gby5jb25jYXQoQ28oe1xuICAgICAgICAgIGtleTogYCR7dH1bJHtpfV1gLFxuICAgICAgICAgIHZhbHVlOiBlW2ldLFxuICAgICAgICAgIHN0eWxlOiByLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogci5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhc1wiOlxuICAgIGNhc2UgXCIhaGFzXCI6XG4gICAgICBhID0gUihlWzFdKSwgZS5sZW5ndGggIT09IDIgPyBvLnB1c2gobmV3IGIodCwgZSwgYGZpbHRlciBhcnJheSBmb3IgXCIke2VbMF19XCIgb3BlcmF0b3IgbXVzdCBoYXZlIDIgZWxlbWVudHNgKSkgOiBhICE9PSBcInN0cmluZ1wiICYmIG8ucHVzaChuZXcgYihgJHt0fVsxXWAsIGVbMV0sIGBzdHJpbmcgZXhwZWN0ZWQsICR7YX0gZm91bmRgKSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEFvKHIsIGUpIHtcbiAgY29uc3QgdCA9IHIua2V5LCBuID0gci52YWxpZGF0ZVNwZWMsIGEgPSByLnN0eWxlLCBvID0gci5zdHlsZVNwZWMsIGkgPSByLnZhbHVlLCBzID0gci5vYmplY3RLZXksIGwgPSBvW2Ake2V9XyR7ci5sYXllclR5cGV9YF07XG4gIGlmICghbClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHUgPSBzLm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICBpZiAoZSA9PT0gXCJwYWludFwiICYmIHUgJiYgbFt1WzFdXSAmJiBsW3VbMV1dLnRyYW5zaXRpb24pXG4gICAgcmV0dXJuIG4oe1xuICAgICAga2V5OiB0LFxuICAgICAgdmFsdWU6IGksXG4gICAgICB2YWx1ZVNwZWM6IG8udHJhbnNpdGlvbixcbiAgICAgIHN0eWxlOiBhLFxuICAgICAgc3R5bGVTcGVjOiBvXG4gICAgfSk7XG4gIGNvbnN0IGMgPSByLnZhbHVlU3BlYyB8fCBsW3NdO1xuICBpZiAoIWMpXG4gICAgcmV0dXJuIFtuZXcgYih0LCBpLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7c31cImApXTtcbiAgbGV0IHA7XG4gIGlmIChSKGkpID09PSBcInN0cmluZ1wiICYmIG5yKGMpICYmICFjLnRva2VucyAmJiAocCA9IC9eeyhbXn1dKyl9JC8uZXhlYyhpKSkpXG4gICAgcmV0dXJuIFtuZXcgYih0LCBpLCBgXCIke3N9XCIgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW9uIHN5bnRheFxuVXNlIGFuIGlkZW50aXR5IHByb3BlcnR5IGZ1bmN0aW9uIGluc3RlYWQ6IFxcYHsgXCJ0eXBlXCI6IFwiaWRlbnRpdHlcIiwgXCJwcm9wZXJ0eVwiOiAke0pTT04uc3RyaW5naWZ5KHBbMV0pfSB9XFxgLmApXTtcbiAgY29uc3QgZCA9IFtdO1xuICByZXR1cm4gci5sYXllclR5cGUgPT09IFwic3ltYm9sXCIgJiYgKHMgPT09IFwidGV4dC1maWVsZFwiICYmIGEgJiYgIWEuZ2x5cGhzICYmIGQucHVzaChuZXcgYih0LCBpLCAndXNlIG9mIFwidGV4dC1maWVsZFwiIHJlcXVpcmVzIGEgc3R5bGUgXCJnbHlwaHNcIiBwcm9wZXJ0eScpKSwgcyA9PT0gXCJ0ZXh0LWZvbnRcIiAmJiBNbihZZShpKSkgJiYgQihpLnR5cGUpID09PSBcImlkZW50aXR5XCIgJiYgZC5wdXNoKG5ldyBiKHQsIGksICdcInRleHQtZm9udFwiIGRvZXMgbm90IHN1cHBvcnQgaWRlbnRpdHkgZnVuY3Rpb25zJykpKSwgZC5jb25jYXQobih7XG4gICAga2V5OiByLmtleSxcbiAgICB2YWx1ZTogaSxcbiAgICB2YWx1ZVNwZWM6IGMsXG4gICAgc3R5bGU6IGEsXG4gICAgc3R5bGVTcGVjOiBvLFxuICAgIGV4cHJlc3Npb25Db250ZXh0OiBcInByb3BlcnR5XCIsXG4gICAgcHJvcGVydHlUeXBlOiBlLFxuICAgIHByb3BlcnR5S2V5OiBzXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIFRvKHIpIHtcbiAgcmV0dXJuIEFvKHIsIFwicGFpbnRcIik7XG59XG5mdW5jdGlvbiBfbyhyKSB7XG4gIHJldHVybiBBbyhyLCBcImxheW91dFwiKTtcbn1cbmZ1bmN0aW9uIElvKHIpIHtcbiAgbGV0IGUgPSBbXTtcbiAgY29uc3QgdCA9IHIudmFsdWUsIG4gPSByLmtleSwgYSA9IHIuc3R5bGUsIG8gPSByLnN0eWxlU3BlYztcbiAgaWYgKFIodCkgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIFtuZXcgYihuLCB0LCBgb2JqZWN0IGV4cGVjdGVkLCAke1IodCl9IGZvdW5kYCldO1xuICAhdC50eXBlICYmICF0LnJlZiAmJiBlLnB1c2gobmV3IGIobiwgdCwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICBsZXQgaSA9IEIodC50eXBlKTtcbiAgY29uc3QgcyA9IEIodC5yZWYpO1xuICBpZiAodC5pZCkge1xuICAgIGNvbnN0IGwgPSBCKHQuaWQpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgci5hcnJheUluZGV4OyB1KyspIHtcbiAgICAgIGNvbnN0IGMgPSBhLmxheWVyc1t1XTtcbiAgICAgIEIoYy5pZCkgPT09IGwgJiYgZS5wdXNoKG5ldyBiKG4sIHQuaWQsIGBkdXBsaWNhdGUgbGF5ZXIgaWQgXCIke3QuaWR9XCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lICR7Yy5pZC5fX2xpbmVfX31gKSk7XG4gICAgfVxuICB9XG4gIGlmIChcInJlZlwiIGluIHQpIHtcbiAgICBbXCJ0eXBlXCIsIFwic291cmNlXCIsIFwic291cmNlLWxheWVyXCIsIFwiZmlsdGVyXCIsIFwibGF5b3V0XCJdLmZvckVhY2goKHUpID0+IHtcbiAgICAgIHUgaW4gdCAmJiBlLnB1c2gobmV3IGIobiwgdFt1XSwgYFwiJHt1fVwiIGlzIHByb2hpYml0ZWQgZm9yIHJlZiBsYXllcnNgKSk7XG4gICAgfSk7XG4gICAgbGV0IGw7XG4gICAgYS5sYXllcnMuZm9yRWFjaCgodSkgPT4ge1xuICAgICAgQih1LmlkKSA9PT0gcyAmJiAobCA9IHUpO1xuICAgIH0pLCBsID8gbC5yZWYgPyBlLnB1c2gobmV3IGIobiwgdC5yZWYsIFwicmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXJcIikpIDogaSA9IEIobC50eXBlKSA6IGUucHVzaChuZXcgYihuLCB0LnJlZiwgYHJlZiBsYXllciBcIiR7c31cIiBub3QgZm91bmRgKSk7XG4gIH0gZWxzZSBpZiAoaSAhPT0gXCJiYWNrZ3JvdW5kXCIpXG4gICAgaWYgKCF0LnNvdXJjZSlcbiAgICAgIGUucHVzaChuZXcgYihuLCB0LCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbCA9IGEuc291cmNlcyAmJiBhLnNvdXJjZXNbdC5zb3VyY2VdLCB1ID0gbCAmJiBCKGwudHlwZSk7XG4gICAgICBsID8gdSA9PT0gXCJ2ZWN0b3JcIiAmJiBpID09PSBcInJhc3RlclwiID8gZS5wdXNoKG5ldyBiKG4sIHQuc291cmNlLCBgbGF5ZXIgXCIke3QuaWR9XCIgcmVxdWlyZXMgYSByYXN0ZXIgc291cmNlYCkpIDogdSAhPT0gXCJyYXN0ZXItZGVtXCIgJiYgaSA9PT0gXCJoaWxsc2hhZGVcIiA/IGUucHVzaChuZXcgYihuLCB0LnNvdXJjZSwgYGxheWVyIFwiJHt0LmlkfVwiIHJlcXVpcmVzIGEgcmFzdGVyLWRlbSBzb3VyY2VgKSkgOiB1ICE9PSBcInJhc3Rlci1kZW1cIiAmJiBpID09PSBcImNvbG9yLXJlbGllZlwiID8gZS5wdXNoKG5ldyBiKG4sIHQuc291cmNlLCBgbGF5ZXIgXCIke3QuaWR9XCIgcmVxdWlyZXMgYSByYXN0ZXItZGVtIHNvdXJjZWApKSA6IHUgPT09IFwicmFzdGVyXCIgJiYgaSAhPT0gXCJyYXN0ZXJcIiA/IGUucHVzaChuZXcgYihuLCB0LnNvdXJjZSwgYGxheWVyIFwiJHt0LmlkfVwiIHJlcXVpcmVzIGEgdmVjdG9yIHNvdXJjZWApKSA6IHUgPT09IFwidmVjdG9yXCIgJiYgIXRbXCJzb3VyY2UtbGF5ZXJcIl0gPyBlLnB1c2gobmV3IGIobiwgdCwgYGxheWVyIFwiJHt0LmlkfVwiIG11c3Qgc3BlY2lmeSBhIFwic291cmNlLWxheWVyXCJgKSkgOiB1ID09PSBcInJhc3Rlci1kZW1cIiAmJiBpICE9PSBcImhpbGxzaGFkZVwiICYmIGkgIT09IFwiY29sb3ItcmVsaWVmXCIgPyBlLnB1c2gobmV3IGIobiwgdC5zb3VyY2UsIFwicmFzdGVyLWRlbSBzb3VyY2UgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGxheWVyIHR5cGUgJ2hpbGxzaGFkZScgb3IgJ2NvbG9yLXJlbGllZicuXCIpKSA6IGkgPT09IFwibGluZVwiICYmIHQucGFpbnQgJiYgdC5wYWludFtcImxpbmUtZ3JhZGllbnRcIl0gJiYgKHUgIT09IFwiZ2VvanNvblwiIHx8ICFsLmxpbmVNZXRyaWNzKSAmJiBlLnB1c2gobmV3IGIobiwgdCwgYGxheWVyIFwiJHt0LmlkfVwiIHNwZWNpZmllcyBhIGxpbmUtZ3JhZGllbnQsIHdoaWNoIHJlcXVpcmVzIGEgR2VvSlNPTiBzb3VyY2Ugd2l0aCBcXGBsaW5lTWV0cmljc1xcYCBlbmFibGVkLmApKSA6IGUucHVzaChuZXcgYihuLCB0LnNvdXJjZSwgYHNvdXJjZSBcIiR7dC5zb3VyY2V9XCIgbm90IGZvdW5kYCkpO1xuICAgIH1cbiAgcmV0dXJuIGUgPSBlLmNvbmNhdChsZSh7XG4gICAga2V5OiBuLFxuICAgIHZhbHVlOiB0LFxuICAgIHZhbHVlU3BlYzogby5sYXllcixcbiAgICBzdHlsZTogci5zdHlsZSxcbiAgICBzdHlsZVNwZWM6IHIuc3R5bGVTcGVjLFxuICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgIFwiKlwiKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBlbmZvcmNlIHRoZSBzcGVjJ3MgYFwicmVxdWlyZXNcIjogdHJ1ZWAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCByZWZzO1xuICAgICAgLy8gdGhlIGFjdHVhbCByZXF1aXJlbWVudCBpcyB2YWxpZGF0ZWQgYWJvdmUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvNTc3Mi5cbiAgICAgIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiByLnZhbGlkYXRlU3BlYyh7XG4gICAgICAgICAga2V5OiBgJHtufS50eXBlYCxcbiAgICAgICAgICB2YWx1ZTogdC50eXBlLFxuICAgICAgICAgIHZhbHVlU3BlYzogby5sYXllci50eXBlLFxuICAgICAgICAgIHN0eWxlOiByLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogci5zdHlsZVNwZWMsXG4gICAgICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgICAgICBvYmplY3Q6IHQsXG4gICAgICAgICAgb2JqZWN0S2V5OiBcInR5cGVcIlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXI6IHpuLFxuICAgICAgbGF5b3V0KGwpIHtcbiAgICAgICAgcmV0dXJuIGxlKHtcbiAgICAgICAgICBsYXllcjogdCxcbiAgICAgICAgICBrZXk6IGwua2V5LFxuICAgICAgICAgIHZhbHVlOiBsLnZhbHVlLFxuICAgICAgICAgIHN0eWxlOiBsLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogbC5zdHlsZVNwZWMsXG4gICAgICAgICAgdmFsaWRhdGVTcGVjOiBsLnZhbGlkYXRlU3BlYyxcbiAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgXCIqXCIodSkge1xuICAgICAgICAgICAgICByZXR1cm4gX28oWXQoeyBsYXllclR5cGU6IGkgfSwgdSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcGFpbnQobCkge1xuICAgICAgICByZXR1cm4gbGUoe1xuICAgICAgICAgIGxheWVyOiB0LFxuICAgICAgICAgIGtleTogbC5rZXksXG4gICAgICAgICAgdmFsdWU6IGwudmFsdWUsXG4gICAgICAgICAgc3R5bGU6IGwuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiBsLnN0eWxlU3BlYyxcbiAgICAgICAgICB2YWxpZGF0ZVNwZWM6IGwudmFsaWRhdGVTcGVjLFxuICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICBcIipcIih1KSB7XG4gICAgICAgICAgICAgIHJldHVybiBUbyhZdCh7IGxheWVyVHlwZTogaSB9LCB1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKSwgZTtcbn1cbmZ1bmN0aW9uIFdlKHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWUsIHQgPSByLmtleSwgbiA9IFIoZSk7XG4gIHJldHVybiBuICE9PSBcInN0cmluZ1wiID8gW25ldyBiKHQsIGUsIGBzdHJpbmcgZXhwZWN0ZWQsICR7bn0gZm91bmRgKV0gOiBbXTtcbn1cbmZ1bmN0aW9uIGV1KHIpIHtcbiAgdmFyIGU7XG4gIGNvbnN0IHQgPSAoZSA9IHIuc291cmNlTmFtZSkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6IFwiXCIsIG4gPSByLnZhbHVlLCBhID0gci5zdHlsZVNwZWMsIG8gPSBhLnNvdXJjZV9yYXN0ZXJfZGVtLCBpID0gci5zdHlsZTtcbiAgbGV0IHMgPSBbXTtcbiAgY29uc3QgbCA9IFIobik7XG4gIGlmIChuID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHM7XG4gIGlmIChsICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBzLnB1c2gobmV3IGIoXCJzb3VyY2VfcmFzdGVyX2RlbVwiLCBuLCBgb2JqZWN0IGV4cGVjdGVkLCAke2x9IGZvdW5kYCkpLCBzO1xuICBjb25zdCBjID0gQihuLmVuY29kaW5nKSA9PT0gXCJjdXN0b21cIiwgcCA9IFtcInJlZEZhY3RvclwiLCBcImdyZWVuRmFjdG9yXCIsIFwiYmx1ZUZhY3RvclwiLCBcImJhc2VTaGlmdFwiXSwgZCA9IHIudmFsdWUuZW5jb2RpbmcgPyBgXCIke3IudmFsdWUuZW5jb2Rpbmd9XCJgIDogXCJEZWZhdWx0XCI7XG4gIGZvciAoY29uc3QgZiBpbiBuKVxuICAgICFjICYmIHAuaW5jbHVkZXMoZikgPyBzLnB1c2gobmV3IGIoZiwgbltmXSwgYEluIFwiJHt0fVwiOiBcIiR7Zn1cIiBpcyBvbmx5IHZhbGlkIHdoZW4gXCJlbmNvZGluZ1wiIGlzIHNldCB0byBcImN1c3RvbVwiLiAke2R9IGVuY29kaW5nIGZvdW5kYCkpIDogb1tmXSA/IHMgPSBzLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICBrZXk6IGYsXG4gICAgICB2YWx1ZTogbltmXSxcbiAgICAgIHZhbHVlU3BlYzogb1tmXSxcbiAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogaSxcbiAgICAgIHN0eWxlU3BlYzogYVxuICAgIH0pKSA6IHMucHVzaChuZXcgYihmLCBuW2ZdLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7Zn1cImApKTtcbiAgcmV0dXJuIHM7XG59XG5jb25zdCBTYSA9IHtcbiAgcHJvbW90ZUlkOiB0dVxufTtcbmZ1bmN0aW9uIE1vKHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWUsIHQgPSByLmtleSwgbiA9IHIuc3R5bGVTcGVjLCBhID0gci5zdHlsZSwgbyA9IHIudmFsaWRhdGVTcGVjO1xuICBpZiAoIWUudHlwZSlcbiAgICByZXR1cm4gW25ldyBiKHQsIGUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgY29uc3QgaSA9IEIoZS50eXBlKTtcbiAgbGV0IHM7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgXCJ2ZWN0b3JcIjpcbiAgICBjYXNlIFwicmFzdGVyXCI6XG4gICAgICByZXR1cm4gcyA9IGxlKHtcbiAgICAgICAga2V5OiB0LFxuICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgdmFsdWVTcGVjOiBuW2Bzb3VyY2VfJHtpLnJlcGxhY2UoXCItXCIsIFwiX1wiKX1gXSxcbiAgICAgICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogbixcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IFNhLFxuICAgICAgICB2YWxpZGF0ZVNwZWM6IG9cbiAgICAgIH0pLCBzO1xuICAgIGNhc2UgXCJyYXN0ZXItZGVtXCI6XG4gICAgICByZXR1cm4gcyA9IGV1KHtcbiAgICAgICAgc291cmNlTmFtZTogdCxcbiAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgIHN0eWxlOiByLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG4sXG4gICAgICAgIHZhbGlkYXRlU3BlYzogb1xuICAgICAgfSksIHM7XG4gICAgY2FzZSBcImdlb2pzb25cIjpcbiAgICAgIGlmIChzID0gbGUoe1xuICAgICAgICBrZXk6IHQsXG4gICAgICAgIHZhbHVlOiBlLFxuICAgICAgICB2YWx1ZVNwZWM6IG4uc291cmNlX2dlb2pzb24sXG4gICAgICAgIHN0eWxlOiBhLFxuICAgICAgICBzdHlsZVNwZWM6IG4sXG4gICAgICAgIHZhbGlkYXRlU3BlYzogbyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IFNhXG4gICAgICB9KSwgZS5jbHVzdGVyKVxuICAgICAgICBmb3IgKGNvbnN0IGwgaW4gZS5jbHVzdGVyUHJvcGVydGllcykge1xuICAgICAgICAgIGNvbnN0IFt1LCBjXSA9IGUuY2x1c3RlclByb3BlcnRpZXNbbF0sIHAgPSB0eXBlb2YgdSA9PSBcInN0cmluZ1wiID8gW3UsIFtcImFjY3VtdWxhdGVkXCJdLCBbXCJnZXRcIiwgbF1dIDogdTtcbiAgICAgICAgICBzLnB1c2goLi4uc3Qoe1xuICAgICAgICAgICAga2V5OiBgJHt0fS4ke2x9Lm1hcGAsXG4gICAgICAgICAgICB2YWx1ZTogYyxcbiAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiBcImNsdXN0ZXItbWFwXCJcbiAgICAgICAgICB9KSksIHMucHVzaCguLi5zdCh7XG4gICAgICAgICAgICBrZXk6IGAke3R9LiR7bH0ucmVkdWNlYCxcbiAgICAgICAgICAgIHZhbHVlOiBwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwiY2x1c3Rlci1yZWR1Y2VcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgY2FzZSBcInZpZGVvXCI6XG4gICAgICByZXR1cm4gbGUoe1xuICAgICAgICBrZXk6IHQsXG4gICAgICAgIHZhbHVlOiBlLFxuICAgICAgICB2YWx1ZVNwZWM6IG4uc291cmNlX3ZpZGVvLFxuICAgICAgICBzdHlsZTogYSxcbiAgICAgICAgdmFsaWRhdGVTcGVjOiBvLFxuICAgICAgICBzdHlsZVNwZWM6IG5cbiAgICAgIH0pO1xuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgcmV0dXJuIGxlKHtcbiAgICAgICAga2V5OiB0LFxuICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgdmFsdWVTcGVjOiBuLnNvdXJjZV9pbWFnZSxcbiAgICAgICAgc3R5bGU6IGEsXG4gICAgICAgIHZhbGlkYXRlU3BlYzogbyxcbiAgICAgICAgc3R5bGVTcGVjOiBuXG4gICAgICB9KTtcbiAgICBjYXNlIFwiY2FudmFzXCI6XG4gICAgICByZXR1cm4gW25ldyBiKHQsIG51bGwsIFwiUGxlYXNlIHVzZSBydW50aW1lIEFQSXMgdG8gYWRkIGNhbnZhcyBzb3VyY2VzLCByYXRoZXIgdGhhbiBpbmNsdWRpbmcgdGhlbSBpbiBzdHlsZXNoZWV0cy5cIiwgXCJzb3VyY2UuY2FudmFzXCIpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEx0KHtcbiAgICAgICAga2V5OiBgJHt0fS50eXBlYCxcbiAgICAgICAgdmFsdWU6IGUudHlwZSxcbiAgICAgICAgdmFsdWVTcGVjOiB7IHZhbHVlczogW1widmVjdG9yXCIsIFwicmFzdGVyXCIsIFwicmFzdGVyLWRlbVwiLCBcImdlb2pzb25cIiwgXCJ2aWRlb1wiLCBcImltYWdlXCJdIH1cbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB0dSh7IGtleTogciwgdmFsdWU6IGUgfSkge1xuICBpZiAoUihlKSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gV2UoeyBrZXk6IHIsIHZhbHVlOiBlIH0pO1xuICB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBpbiBlKVxuICAgICAgdC5wdXNoKC4uLldlKHsga2V5OiBgJHtyfS4ke259YCwgdmFsdWU6IGVbbl0gfSkpO1xuICAgIHJldHVybiB0O1xuICB9XG59XG5mdW5jdGlvbiBQbyhyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci5zdHlsZVNwZWMsIG4gPSB0LmxpZ2h0LCBhID0gci5zdHlsZTtcbiAgbGV0IG8gPSBbXTtcbiAgY29uc3QgaSA9IFIoZSk7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIG87XG4gIGlmIChpICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvID0gby5jb25jYXQoW25ldyBiKFwibGlnaHRcIiwgZSwgYG9iamVjdCBleHBlY3RlZCwgJHtpfSBmb3VuZGApXSksIG87XG4gIGZvciAoY29uc3QgcyBpbiBlKSB7XG4gICAgY29uc3QgbCA9IHMubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gICAgbCAmJiBuW2xbMV1dICYmIG5bbFsxXV0udHJhbnNpdGlvbiA/IG8gPSBvLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICBrZXk6IHMsXG4gICAgICB2YWx1ZTogZVtzXSxcbiAgICAgIHZhbHVlU3BlYzogdC50cmFuc2l0aW9uLFxuICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiBhLFxuICAgICAgc3R5bGVTcGVjOiB0XG4gICAgfSkpIDogbltzXSA/IG8gPSBvLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICBrZXk6IHMsXG4gICAgICB2YWx1ZTogZVtzXSxcbiAgICAgIHZhbHVlU3BlYzogbltzXSxcbiAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogYSxcbiAgICAgIHN0eWxlU3BlYzogdFxuICAgIH0pKSA6IG8gPSBvLmNvbmNhdChbbmV3IGIocywgZVtzXSwgYHVua25vd24gcHJvcGVydHkgXCIke3N9XCJgKV0pO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gUm8ocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIuc3R5bGVTcGVjLCBuID0gdC5za3ksIGEgPSByLnN0eWxlLCBvID0gUihlKTtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gW107XG4gIGlmIChvICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBbbmV3IGIoXCJza3lcIiwgZSwgYG9iamVjdCBleHBlY3RlZCwgJHtvfSBmb3VuZGApXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChjb25zdCBzIGluIGUpXG4gICAgbltzXSA/IGkgPSBpLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICBrZXk6IHMsXG4gICAgICB2YWx1ZTogZVtzXSxcbiAgICAgIHZhbHVlU3BlYzogbltzXSxcbiAgICAgIHN0eWxlOiBhLFxuICAgICAgc3R5bGVTcGVjOiB0XG4gICAgfSkpIDogaSA9IGkuY29uY2F0KFtuZXcgYihzLCBlW3NdLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7c31cImApXSk7XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gem8ocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIuc3R5bGVTcGVjLCBuID0gdC50ZXJyYWluLCBhID0gci5zdHlsZTtcbiAgbGV0IG8gPSBbXTtcbiAgY29uc3QgaSA9IFIoZSk7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIG87XG4gIGlmIChpICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvID0gby5jb25jYXQoW25ldyBiKFwidGVycmFpblwiLCBlLCBgb2JqZWN0IGV4cGVjdGVkLCAke2l9IGZvdW5kYCldKSwgbztcbiAgZm9yIChjb25zdCBzIGluIGUpXG4gICAgbltzXSA/IG8gPSBvLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICBrZXk6IHMsXG4gICAgICB2YWx1ZTogZVtzXSxcbiAgICAgIHZhbHVlU3BlYzogbltzXSxcbiAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogYSxcbiAgICAgIHN0eWxlU3BlYzogdFxuICAgIH0pKSA6IG8gPSBvLmNvbmNhdChbbmV3IGIocywgZVtzXSwgYHVua25vd24gcHJvcGVydHkgXCIke3N9XCJgKV0pO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIHJ1KHIpIHtcbiAgcmV0dXJuIFdlKHIpLmxlbmd0aCA9PT0gMCA/IFtdIDogc3Qocik7XG59XG5mdW5jdGlvbiBudShyKSB7XG4gIHJldHVybiBXZShyKS5sZW5ndGggPT09IDAgPyBbXSA6IHN0KHIpO1xufVxuZnVuY3Rpb24gYXUocikge1xuICBjb25zdCBlID0gci5rZXksIHQgPSByLnZhbHVlO1xuICBpZiAoUih0KSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHQubGVuZ3RoIDwgMSB8fCB0Lmxlbmd0aCA+IDQpXG4gICAgICByZXR1cm4gW25ldyBiKGUsIHQsIGBwYWRkaW5nIHJlcXVpcmVzIDEgdG8gNCB2YWx1ZXM7ICR7dC5sZW5ndGh9IHZhbHVlcyBmb3VuZGApXTtcbiAgICBjb25zdCBhID0ge1xuICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgIH07XG4gICAgbGV0IG8gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICBvID0gby5jb25jYXQoci52YWxpZGF0ZVNwZWMoe1xuICAgICAgICBrZXk6IGAke2V9WyR7aX1dYCxcbiAgICAgICAgdmFsdWU6IHRbaV0sXG4gICAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICAgIHZhbHVlU3BlYzogYVxuICAgICAgfSkpO1xuICAgIHJldHVybiBvO1xuICB9IGVsc2VcbiAgICByZXR1cm4geHIoe1xuICAgICAga2V5OiBlLFxuICAgICAgdmFsdWU6IHQsXG4gICAgICB2YWx1ZVNwZWM6IHt9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvdShyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWU7XG4gIGlmIChSKHQpID09PSBcImFycmF5XCIpIHtcbiAgICBjb25zdCBhID0ge1xuICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgIH07XG4gICAgaWYgKHQubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiBbbmV3IGIoZSwgdCwgXCJhcnJheSBsZW5ndGggYXQgbGVhc3QgMSBleHBlY3RlZCwgbGVuZ3RoIDAgZm91bmRcIildO1xuICAgIGxldCBvID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKVxuICAgICAgbyA9IG8uY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgICAga2V5OiBgJHtlfVske2l9XWAsXG4gICAgICAgIHZhbHVlOiB0W2ldLFxuICAgICAgICB2YWxpZGF0ZVNwZWM6IHIudmFsaWRhdGVTcGVjLFxuICAgICAgICB2YWx1ZVNwZWM6IGFcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gbztcbiAgfSBlbHNlXG4gICAgcmV0dXJuIHhyKHtcbiAgICAgIGtleTogZSxcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgdmFsdWVTcGVjOiB7fVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXUocikge1xuICBjb25zdCBlID0gci5rZXksIHQgPSByLnZhbHVlO1xuICBpZiAoUih0KSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHQubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiBbbmV3IGIoZSwgdCwgXCJhcnJheSBsZW5ndGggYXQgbGVhc3QgMSBleHBlY3RlZCwgbGVuZ3RoIDAgZm91bmRcIildO1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKVxuICAgICAgYSA9IGEuY29uY2F0KGVuKHtcbiAgICAgICAga2V5OiBgJHtlfVske299XWAsXG4gICAgICAgIHZhbHVlOiB0W29dXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIGE7XG4gIH0gZWxzZVxuICAgIHJldHVybiBlbih7XG4gICAgICBrZXk6IGUsXG4gICAgICB2YWx1ZTogdFxuICAgIH0pO1xufVxuZnVuY3Rpb24gc3Uocikge1xuICBjb25zdCBlID0gci5rZXksIHQgPSByLnZhbHVlLCBuID0gUih0KSwgYSA9IHIuc3R5bGVTcGVjO1xuICBpZiAobiAhPT0gXCJhcnJheVwiIHx8IHQubGVuZ3RoIDwgMSB8fCB0Lmxlbmd0aCAlIDIgIT09IDApXG4gICAgcmV0dXJuIFtuZXcgYihlLCB0LCBcInZhcmlhYmxlQW5jaG9yT2Zmc2V0Q29sbGVjdGlvbiByZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheSBvZiBldmVuIGxlbmd0aFwiKV07XG4gIGxldCBvID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkgKz0gMilcbiAgICBvID0gby5jb25jYXQoTHQoe1xuICAgICAga2V5OiBgJHtlfVske2l9XWAsXG4gICAgICB2YWx1ZTogdFtpXSxcbiAgICAgIHZhbHVlU3BlYzogYS5sYXlvdXRfc3ltYm9sW1widGV4dC1hbmNob3JcIl1cbiAgICB9KSksIG8gPSBvLmNvbmNhdChSbih7XG4gICAgICBrZXk6IGAke2V9WyR7aSArIDF9XWAsXG4gICAgICB2YWx1ZTogdFtpICsgMV0sXG4gICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogci5zdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogYVxuICAgIH0pKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBPbyhyKSB7XG4gIGxldCBlID0gW107XG4gIGNvbnN0IHQgPSByLnZhbHVlLCBuID0gci5rZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgY29uc3QgYSA9IFtdLCBvID0gW107XG4gICAgZm9yIChjb25zdCBpIGluIHQpIHtcbiAgICAgIHRbaV0uaWQgJiYgYS5pbmNsdWRlcyh0W2ldLmlkKSAmJiBlLnB1c2gobmV3IGIobiwgdCwgYGFsbCB0aGUgc3ByaXRlcycgaWRzIG11c3QgYmUgdW5pcXVlLCBidXQgJHt0W2ldLmlkfSBpcyBkdXBsaWNhdGVkYCkpLCBhLnB1c2godFtpXS5pZCksIHRbaV0udXJsICYmIG8uaW5jbHVkZXModFtpXS51cmwpICYmIGUucHVzaChuZXcgYihuLCB0LCBgYWxsIHRoZSBzcHJpdGVzJyBVUkxzIG11c3QgYmUgdW5pcXVlLCBidXQgJHt0W2ldLnVybH0gaXMgZHVwbGljYXRlZGApKSwgby5wdXNoKHRbaV0udXJsKTtcbiAgICAgIGNvbnN0IHMgPSB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICByZXF1aXJlZDogITBcbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICByZXF1aXJlZDogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGUgPSBlLmNvbmNhdChsZSh7XG4gICAgICAgIGtleTogYCR7bn1bJHtpfV1gLFxuICAgICAgICB2YWx1ZTogdFtpXSxcbiAgICAgICAgdmFsdWVTcGVjOiBzLFxuICAgICAgICB2YWxpZGF0ZVNwZWM6IHIudmFsaWRhdGVTcGVjXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gV2Uoe1xuICAgICAga2V5OiBuLFxuICAgICAgdmFsdWU6IHRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGx1KHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWUsIHQgPSByLnN0eWxlU3BlYywgbiA9IHQucHJvamVjdGlvbiwgYSA9IHIuc3R5bGUsIG8gPSBSKGUpO1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbXTtcbiAgaWYgKG8gIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIFtuZXcgYihcInByb2plY3Rpb25cIiwgZSwgYG9iamVjdCBleHBlY3RlZCwgJHtvfSBmb3VuZGApXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChjb25zdCBzIGluIGUpXG4gICAgbltzXSA/IGkgPSBpLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICBrZXk6IHMsXG4gICAgICB2YWx1ZTogZVtzXSxcbiAgICAgIHZhbHVlU3BlYzogbltzXSxcbiAgICAgIHN0eWxlOiBhLFxuICAgICAgc3R5bGVTcGVjOiB0XG4gICAgfSkpIDogaSA9IGkuY29uY2F0KFtuZXcgYihzLCBlW3NdLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7c31cImApXSk7XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gdXUocikge1xuICBjb25zdCBlID0gci5rZXk7XG4gIGxldCB0ID0gci52YWx1ZTtcbiAgdCA9IHQgaW5zdGFuY2VvZiBTdHJpbmcgPyB0LnZhbHVlT2YoKSA6IHQ7XG4gIGNvbnN0IG4gPSBSKHQpO1xuICByZXR1cm4gbiA9PT0gXCJhcnJheVwiICYmICFwdSh0KSAmJiAhY3UodCkgPyBbbmV3IGIoZSwgdCwgYHByb2plY3Rpb24gZXhwZWN0ZWQsIGludmFsaWQgYXJyYXkgJHtKU09OLnN0cmluZ2lmeSh0KX0gZm91bmRgKV0gOiBbXCJhcnJheVwiLCBcInN0cmluZ1wiXS5pbmNsdWRlcyhuKSA/IFtdIDogW25ldyBiKGUsIHQsIGBwcm9qZWN0aW9uIGV4cGVjdGVkLCBpbnZhbGlkIHR5cGUgXCIke259XCIgZm91bmRgKV07XG59XG5mdW5jdGlvbiBjdShyKSB7XG4gIHJldHVybiAhIVtcImludGVycG9sYXRlXCIsIFwic3RlcFwiLCBcImxpdGVyYWxcIl0uaW5jbHVkZXMoclswXSk7XG59XG5mdW5jdGlvbiBwdShyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHIpICYmIHIubGVuZ3RoID09PSAzICYmIHR5cGVvZiByWzBdID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJbMV0gPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgclsyXSA9PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gZnUocikge1xuICByZXR1cm4gISFyICYmIHIuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cbmZ1bmN0aW9uICRvKHIpIHtcbiAgcmV0dXJuIGZ1KHIudmFsdWUpID8gW10gOiBbXG4gICAgbmV3IGIoci5rZXksIHIudmFsdWUsIGBvYmplY3QgZXhwZWN0ZWQsICR7UihyLnZhbHVlKX0gZm91bmRgKVxuICBdO1xufVxuY29uc3QgeGEgPSB7XG4gIFwiKlwiKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgYXJyYXk6IFJuLFxuICBib29sZWFuOiBRbCxcbiAgbnVtYmVyOiB4cixcbiAgY29sb3I6IGVuLFxuICBjb25zdGFudHM6IExvLFxuICBlbnVtOiBMdCxcbiAgZmlsdGVyOiB6bixcbiAgZnVuY3Rpb246IEVvLFxuICBsYXllcjogSW8sXG4gIG9iamVjdDogbGUsXG4gIHNvdXJjZTogTW8sXG4gIGxpZ2h0OiBQbyxcbiAgc2t5OiBSbyxcbiAgdGVycmFpbjogem8sXG4gIHByb2plY3Rpb246IGx1LFxuICBwcm9qZWN0aW9uRGVmaW5pdGlvbjogdXUsXG4gIHN0cmluZzogV2UsXG4gIGZvcm1hdHRlZDogcnUsXG4gIHJlc29sdmVkSW1hZ2U6IG51LFxuICBwYWRkaW5nOiBhdSxcbiAgbnVtYmVyQXJyYXk6IG91LFxuICBjb2xvckFycmF5OiBpdSxcbiAgdmFyaWFibGVBbmNob3JPZmZzZXRDb2xsZWN0aW9uOiBzdSxcbiAgc3ByaXRlOiBPbyxcbiAgc3RhdGU6ICRvXG59O1xuZnVuY3Rpb24gYXIocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIudmFsdWVTcGVjLCBuID0gci5zdHlsZVNwZWM7XG4gIHJldHVybiByLnZhbGlkYXRlU3BlYyA9IGFyLCB0LmV4cHJlc3Npb24gJiYgTW4oQihlKSkgPyBFbyhyKSA6IHQuZXhwcmVzc2lvbiAmJiBTbyhZZShlKSkgPyBzdChyKSA6IHQudHlwZSAmJiB4YVt0LnR5cGVdID8geGFbdC50eXBlXShyKSA6IGxlKFl0KHt9LCByLCB7XG4gICAgdmFsdWVTcGVjOiB0LnR5cGUgPyBuW3QudHlwZV0gOiB0XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIEZvKHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWUsIHQgPSByLmtleSwgbiA9IFdlKHIpO1xuICByZXR1cm4gbi5sZW5ndGggfHwgKGUuaW5kZXhPZihcIntmb250c3RhY2t9XCIpID09PSAtMSAmJiBuLnB1c2gobmV3IGIodCwgZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie2ZvbnRzdGFja31cIiB0b2tlbicpKSwgZS5pbmRleE9mKFwie3JhbmdlfVwiKSA9PT0gLTEgJiYgbi5wdXNoKG5ldyBiKHQsIGUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntyYW5nZX1cIiB0b2tlbicpKSksIG47XG59XG5mdW5jdGlvbiBhZShyLCBlID0gRHMpIHtcbiAgbGV0IHQgPSBbXTtcbiAgcmV0dXJuIHQgPSB0LmNvbmNhdChhcih7XG4gICAga2V5OiBcIlwiLFxuICAgIHZhbHVlOiByLFxuICAgIHZhbHVlU3BlYzogZS4kcm9vdCxcbiAgICBzdHlsZVNwZWM6IGUsXG4gICAgc3R5bGU6IHIsXG4gICAgdmFsaWRhdGVTcGVjOiBhcixcbiAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgZ2x5cGhzOiBGbyxcbiAgICAgIFwiKlwiKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICB9KSksIHIuY29uc3RhbnRzICYmICh0ID0gdC5jb25jYXQoTG8oe1xuICAgIGtleTogXCJjb25zdGFudHNcIixcbiAgICB2YWx1ZTogci5jb25zdGFudHNcbiAgfSkpKSwgTm8odCk7XG59XG5hZS5zb3VyY2UgPSB2ZShnZShNbykpO1xuYWUuc3ByaXRlID0gdmUoZ2UoT28pKTtcbmFlLmdseXBocyA9IHZlKGdlKEZvKSk7XG5hZS5saWdodCA9IHZlKGdlKFBvKSk7XG5hZS5za3kgPSB2ZShnZShSbykpO1xuYWUudGVycmFpbiA9IHZlKGdlKHpvKSk7XG5hZS5zdGF0ZSA9IHZlKGdlKCRvKSk7XG5hZS5sYXllciA9IHZlKGdlKElvKSk7XG5hZS5maWx0ZXIgPSB2ZShnZSh6bikpO1xuYWUucGFpbnRQcm9wZXJ0eSA9IHZlKGdlKFRvKSk7XG5hZS5sYXlvdXRQcm9wZXJ0eSA9IHZlKGdlKF9vKSk7XG5mdW5jdGlvbiBnZShyKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHIoe1xuICAgICAgLi4uZSxcbiAgICAgIHZhbGlkYXRlU3BlYzogYXJcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIE5vKHIpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChyKS5zb3J0KChlLCB0KSA9PiBlLmxpbmUgLSB0LmxpbmUpO1xufVxuZnVuY3Rpb24gdmUocikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uZSkge1xuICAgIHJldHVybiBObyhyLmFwcGx5KHRoaXMsIGUpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGthKHIpIHtcbiAgaWYgKCFyKVxuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogaHRbQ3JbMF0ucmVmZXJlbmNlU3R5bGVJRF0uZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRFeHBhbmRlZFN0eWxlVVJMKCksXG4gICAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICExLFxuICAgICAgLy8gZGVmYXVsdCBzdHlsZXMgZG9uJ3QgcmVxdWlyZSBVUkwgbW9uaXRvcmluZ1xuICAgICAgaXNGYWxsYmFjazogITBcbiAgICB9O1xuICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHQgPSBodShyKTtcbiAgICByZXR1cm4gdC5pc1ZhbGlkU3R5bGUgPyB7XG4gICAgICBzdHlsZTogdC5zdHlsZU9iamVjdCxcbiAgICAgIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogITEsXG4gICAgICBpc0ZhbGxiYWNrOiAhMVxuICAgIH0gOiB0LmlzVmFsaWRKU09OID8ge1xuICAgICAgc3R5bGU6IGh0W0NyWzBdLnJlZmVyZW5jZVN0eWxlSURdLmdldERlZmF1bHRWYXJpYW50KCkuZ2V0RXhwYW5kZWRTdHlsZVVSTCgpLFxuICAgICAgcmVxdWlyZXNVcmxNb25pdG9yaW5nOiAhMSxcbiAgICAgIC8vIGRlZmF1bHQgc3R5bGVzIGRvbid0IHJlcXVpcmUgVVJMIG1vbml0b3JpbmdcbiAgICAgIGlzRmFsbGJhY2s6ICEwXG4gICAgfSA6IHIuc3RhcnRzV2l0aChcImh0dHBcIikgPyB7IHN0eWxlOiByLCByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICEwLCBpc0ZhbGxiYWNrOiAhMSB9IDogci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiLmpzb25cIikgPyB7XG4gICAgICBzdHlsZTogZHUociksXG4gICAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICEwLFxuICAgICAgaXNGYWxsYmFjazogITFcbiAgICB9IDoge1xuICAgICAgc3R5bGU6IENpKHIpLFxuICAgICAgcmVxdWlyZXNVcmxNb25pdG9yaW5nOiAhMCxcbiAgICAgIGlzRmFsbGJhY2s6ICExXG4gICAgfTtcbiAgfVxuICByZXR1cm4gciBpbnN0YW5jZW9mIEFpID8ge1xuICAgIHN0eWxlOiByLmdldEV4cGFuZGVkU3R5bGVVUkwoKSxcbiAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICExLFxuICAgIGlzRmFsbGJhY2s6ICExXG4gIH0gOiByIGluc3RhbmNlb2YgVGkgPyB7XG4gICAgc3R5bGU6IHIuZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRFeHBhbmRlZFN0eWxlVVJMKCksXG4gICAgcmVxdWlyZXNVcmxNb25pdG9yaW5nOiAhMSxcbiAgICBpc0ZhbGxiYWNrOiAhMVxuICB9IDogYWUocikubGVuZ3RoID09PSAwID8ge1xuICAgIHN0eWxlOiByLFxuICAgIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogITEsXG4gICAgaXNGYWxsYmFjazogITEsXG4gICAgaXNKU09OOiAhMFxuICB9IDoge1xuICAgIHN0eWxlOiBodFtDclswXS5yZWZlcmVuY2VTdHlsZUlEXS5nZXREZWZhdWx0VmFyaWFudCgpLmdldEV4cGFuZGVkU3R5bGVVUkwoKSxcbiAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICExLFxuICAgIC8vIGRlZmF1bHQgc3R5bGVzIGRvbid0IHJlcXVpcmUgVVJMIG1vbml0b3JpbmdcbiAgICBpc0ZhbGxiYWNrOiAhMFxuICB9O1xufVxuZnVuY3Rpb24gZHUocikge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHIpLmhyZWY7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHIsIGxvY2F0aW9uLm9yaWdpbikuaHJlZjtcbn1cbmZ1bmN0aW9uIGh1KHIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlID0gSlNPTi5wYXJzZShyKSwgdCA9IGFlKGUpO1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkSlNPTjogITAsXG4gICAgICBpc1ZhbGlkU3R5bGU6IHQubGVuZ3RoID09PSAwLFxuICAgICAgc3R5bGVPYmplY3Q6IHQubGVuZ3RoID09PSAwID8gZSA6IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZEpTT046ICExLFxuICAgICAgaXNWYWxpZFN0eWxlOiAhMSxcbiAgICAgIHN0eWxlT2JqZWN0OiBudWxsXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gVGUociwgZSwgdCkge1xuICBjb25zdCBuID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocik7XG4gIHJldHVybiBlICE9PSB2b2lkIDAgJiYgKG4uY2xhc3NOYW1lID0gZSksIHQgJiYgdC5hcHBlbmRDaGlsZChuKSwgbjtcbn1cbmZ1bmN0aW9uIEV0KHIpIHtcbiAgci5wYXJlbnROb2RlICYmIHIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyKTtcbn1cbmNsYXNzIG11IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgZyh0aGlzLCBcIl9tYXBcIik7XG4gICAgZyh0aGlzLCBcIl9jb250YWluZXJcIik7XG4gICAgZyh0aGlzLCBcIl90ZXJyYWluQnV0dG9uXCIpO1xuICAgIHFpKFtcIl90b2dnbGVUZXJyYWluXCIsIFwiX3VwZGF0ZVRlcnJhaW5JY29uXCJdLCB0aGlzKTtcbiAgfVxuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcCA9IGUsIHRoaXMuX2NvbnRhaW5lciA9IFRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKSwgdGhpcy5fdGVycmFpbkJ1dHRvbiA9IFRlKFwiYnV0dG9uXCIsIFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW5cIiwgdGhpcy5fY29udGFpbmVyKSwgVGUoXCJzcGFuXCIsIFwibWFwbGlicmVnbC1jdHJsLWljb25cIiwgdGhpcy5fdGVycmFpbkJ1dHRvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCB0aGlzLl90ZXJyYWluQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl90ZXJyYWluQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl90b2dnbGVUZXJyYWluKSwgdGhpcy5fdXBkYXRlVGVycmFpbkljb24oKSwgdGhpcy5fbWFwLm9uKFwidGVycmFpblwiLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbiksIHRoaXMuX2NvbnRhaW5lcjtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBFdCh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwidGVycmFpblwiLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbiksIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgfVxuICBfdG9nZ2xlVGVycmFpbigpIHtcbiAgICBqbyh0aGlzLl9tYXApLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbigpO1xuICB9XG4gIF91cGRhdGVUZXJyYWluSWNvbigpIHtcbiAgICB0aGlzLl90ZXJyYWluQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtdGVycmFpblwiKSwgdGhpcy5fdGVycmFpbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW4tZW5hYmxlZFwiKSwgdGhpcy5fbWFwLmhhc1RlcnJhaW4oKSA/ICh0aGlzLl90ZXJyYWluQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtdGVycmFpbi1lbmFibGVkXCIpLCB0aGlzLl90ZXJyYWluQnV0dG9uLnRpdGxlID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIlRlcnJhaW5Db250cm9sLkRpc2FibGVcIikpIDogKHRoaXMuX3RlcnJhaW5CdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC10ZXJyYWluXCIpLCB0aGlzLl90ZXJyYWluQnV0dG9uLnRpdGxlID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIlRlcnJhaW5Db250cm9sLkVuYWJsZVwiKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpvKHIpIHtcbiAgci5oYXNUZXJyYWluKCkgPyByLmRpc2FibGVUZXJyYWluKCkgOiByLmVuYWJsZVRlcnJhaW4oKTtcbn1cbmNsYXNzIHl1IGV4dGVuZHMgV2Ege1xuICBjb25zdHJ1Y3Rvcih0ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBzaG93Q29tcGFzczogdC5zaG93Q29tcGFzcyA/PyAhMCxcbiAgICAgIHNob3dab29tOiB0LnNob3dab29tID8/ICEwLFxuICAgICAgdmlzdWFsaXplUGl0Y2g6IHQudmlzdWFsaXplUGl0Y2ggPz8gITBcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBPdmVybG9hZGluZzogTGltaXQgaG93IGZsYXQgdGhlIGNvbXBhc3MgaWNvbiBjYW4gZ2V0XG4gICAgICovXG4gICAgZyh0aGlzLCBcIl9yb3RhdGVDb21wYXNzQXJyb3dcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX21hcC5nZXRCZWFyaW5nKCksIG4gPSB0aGlzLl9tYXAuZ2V0UGl0Y2goKSwgYSA9IHRoaXMub3B0aW9ucy52aXN1YWxpemVQaXRjaCA/IGBzY2FsZSgke01hdGgubWluKDEuNSwgMSAvIE1hdGguY29zKG4gKiAoTWF0aC5QSSAvIDE4MCkpICoqIDAuNSl9KSByb3RhdGVYKCR7TWF0aC5taW4oNzAsIG4pfWRlZykgcm90YXRlWigkey10fWRlZylgIDogYHJvdGF0ZSgkey10fWRlZylgO1xuICAgICAgdGhpcy5fY29tcGFzc0ljb24uc3R5bGUudHJhbnNmb3JtID0gYTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb21wYXNzICYmICh0aGlzLl9jb21wYXNzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jb21wYXNzLmNsaWNrRnVuY3Rpb24pLCB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAobikgPT4ge1xuICAgICAgdGhpcy5fbWFwLmdldFBpdGNoKCkgPT09IDAgPyB0aGlzLl9tYXAuZWFzZVRvKHsgcGl0Y2g6IE1hdGgubWluKHRoaXMuX21hcC5nZXRNYXhQaXRjaCgpLCA4MCkgfSkgOiB0aGlzLm9wdGlvbnMudmlzdWFsaXplUGl0Y2ggPyB0aGlzLl9tYXAucmVzZXROb3J0aFBpdGNoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IG4gfSkgOiB0aGlzLl9tYXAucmVzZXROb3J0aCh7fSwgeyBvcmlnaW5hbEV2ZW50OiBuIH0pO1xuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcmxvYWRpbmc6IHRoZSBidXR0b24gbm93IHN0b3JlcyBpdHMgY2xpY2sgY2FsbGJhY2sgc28gdGhhdCB3ZSBjYW4gbGF0ZXIgb24gZGVsZXRlIGl0IGFuZCByZXBsYWNlIGl0XG4gICAqL1xuICBfY3JlYXRlQnV0dG9uKHQsIG4pIHtcbiAgICBjb25zdCBhID0gc3VwZXIuX2NyZWF0ZUJ1dHRvbih0LCBuKTtcbiAgICByZXR1cm4gYS5jbGlja0Z1bmN0aW9uID0gbiwgYTtcbiAgfVxufVxuY29uc3QgTGEgPSBMLk1hcmtlciwgRWEgPSBMLkxuZ0xhdCwgZ3UgPSBMLkxuZ0xhdEJvdW5kcztcbmNsYXNzIHZ1IGV4dGVuZHMgUGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIGcodGhpcywgXCJsYXN0VXBkYXRlZENlbnRlclwiLCBuZXcgRWEoMCwgMCkpO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY2FtZXJhIGxvY2F0aW9uIHRvIGNlbnRlciBvbiB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24gdGhlIEdlb2xvY2F0aW9uIEFQSSBQb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZyh0aGlzLCBcIl91cGRhdGVDYW1lcmFcIiwgKHQpID0+IHtcbiAgICAgIHZhciBjO1xuICAgICAgY29uc3QgbiA9IG5ldyBFYSh0LmNvb3Jkcy5sb25naXR1ZGUsIHQuY29vcmRzLmxhdGl0dWRlKSwgYSA9IHQuY29vcmRzLmFjY3VyYWN5LCBpID0ge1xuICAgICAgICBiZWFyaW5nOiB0aGlzLl9tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAuLi50aGlzLm9wdGlvbnMuZml0Qm91bmRzT3B0aW9ucyxcbiAgICAgICAgbGluZWFyOiAhMFxuICAgICAgfSwgcyA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICBzID4gKCgoYyA9IHRoaXMub3B0aW9ucy5maXRCb3VuZHNPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogYy5tYXhab29tKSA/PyAzMCkgJiYgKGkuem9vbSA9IHMpLCB0aGlzLl9tYXAuZml0Qm91bmRzKGd1LmZyb21MbmdMYXQobiwgYSksIGksIHtcbiAgICAgICAgZ2VvbG9jYXRlU291cmNlOiAhMFxuICAgICAgICAvLyB0YWcgdGhpcyBjYW1lcmEgY2hhbmdlIHNvIGl0IHdvbid0IGNhdXNlIHRoZSBjb250cm9sIHRvIGNoYW5nZSB0byBiYWNrZ3JvdW5kIHN0YXRlXG4gICAgICB9KTtcbiAgICAgIGxldCBsID0gITE7XG4gICAgICBjb25zdCB1ID0gKCkgPT4ge1xuICAgICAgICBsID0gITA7XG4gICAgICB9O1xuICAgICAgdGhpcy5fbWFwLm9uY2UoXCJjbGlja1wiLCB1KSwgdGhpcy5fbWFwLm9uY2UoXCJkYmxjbGlja1wiLCB1KSwgdGhpcy5fbWFwLm9uY2UoXCJkcmFnc3RhcnRcIiwgdSksIHRoaXMuX21hcC5vbmNlKFwibW91c2Vkb3duXCIsIHUpLCB0aGlzLl9tYXAub25jZShcInRvdWNoc3RhcnRcIiwgdSksIHRoaXMuX21hcC5vbmNlKFwid2hlZWxcIiwgdSksIHRoaXMuX21hcC5vbmNlKFwibW92ZWVuZFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLCB1KSwgdGhpcy5fbWFwLm9mZihcImRibGNsaWNrXCIsIHUpLCB0aGlzLl9tYXAub2ZmKFwiZHJhZ3N0YXJ0XCIsIHUpLCB0aGlzLl9tYXAub2ZmKFwibW91c2Vkb3duXCIsIHUpLCB0aGlzLl9tYXAub2ZmKFwidG91Y2hzdGFydFwiLCB1KSwgdGhpcy5fbWFwLm9mZihcIndoZWVsXCIsIHUpLCAhbCAmJiAodGhpcy5sYXN0VXBkYXRlZENlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBnKHRoaXMsIFwiX2ZpbmlzaFNldHVwVUlcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHQgPT09ICExKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJHZW9sb2NhdGVDb250cm9sLkxvY2F0aW9uTm90QXZhaWxhYmxlXCIpO1xuICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5kaXNhYmxlZCA9ICEwLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSBuLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIkdlb2xvY2F0ZUNvbnRyb2wuRmluZE15TG9jYXRpb25cIik7XG4gICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmRpc2FibGVkID0gITEsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi50aXRsZSA9IG4sIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiAodGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpLCB0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmICh0aGlzLl9kb3RFbGVtZW50ID0gVGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tZG90XCIpLCB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIgPSBuZXcgTGEoeyBlbGVtZW50OiB0aGlzLl9kb3RFbGVtZW50IH0pLCB0aGlzLl9jaXJjbGVFbGVtZW50ID0gVGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tYWNjdXJhY3ktY2lyY2xlXCIpLCB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlciA9IG5ldyBMYSh7XG4gICAgICAgICAgZWxlbWVudDogdGhpcy5fY2lyY2xlRWxlbWVudCxcbiAgICAgICAgICBwaXRjaEFsaWdubWVudDogXCJtYXBcIlxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uICYmICh0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fb25ab29tKSksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50cmlnZ2VyLmJpbmQodGhpcykpLCB0aGlzLl9zZXR1cCA9ICEwLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgdGhpcy5fbWFwLm9uKFwibW92ZWVuZFwiLCAobikgPT4ge1xuICAgICAgICAgIGNvbnN0IGEgPSBuLm9yaWdpbmFsRXZlbnQgJiYgbi5vcmlnaW5hbEV2ZW50LnR5cGUgPT09IFwicmVzaXplXCIsIG8gPSB0aGlzLmxhc3RVcGRhdGVkQ2VudGVyLmRpc3RhbmNlVG8odGhpcy5fbWFwLmdldENlbnRlcigpKTtcbiAgICAgICAgICAhbi5nZW9sb2NhdGVTb3VyY2UgJiYgdGhpcy5fd2F0Y2hTdGF0ZSA9PT0gXCJBQ1RJVkVfTE9DS1wiICYmICFhICYmIG8gPiAxICYmICh0aGlzLl93YXRjaFN0YXRlID0gXCJCQUNLR1JPVU5EXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLmZpcmUobmV3IEV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25lbmRcIikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZyh0aGlzLCBcIl9vblpvb21cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5vcHRpb25zLnNob3dBY2N1cmFjeUNpcmNsZSAmJiB0aGlzLl91cGRhdGVDaXJjbGVSYWRpdXMoKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlQ2lyY2xlUmFkaXVzKCkge1xuICAgIGlmICh0aGlzLl93YXRjaFN0YXRlICE9PSBcIkJBQ0tHUk9VTkRcIiAmJiB0aGlzLl93YXRjaFN0YXRlICE9PSBcIkFDVElWRV9MT0NLXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IFt0aGlzLl9sYXN0S25vd25Qb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLCB0aGlzLl9sYXN0S25vd25Qb3NpdGlvbi5jb29yZHMubGF0aXR1ZGVdLCBuID0gdGhpcy5fbWFwLnByb2plY3QodCksIGEgPSB0aGlzLl9tYXAudW5wcm9qZWN0KFtuLngsIG4ueV0pLCBvID0gdGhpcy5fbWFwLnVucHJvamVjdChbbi54ICsgMjAsIG4ueV0pLCBpID0gYS5kaXN0YW5jZVRvKG8pIC8gMjAsIHMgPSBNYXRoLmNlaWwoMiAqIHRoaXMuX2FjY3VyYWN5IC8gaSk7XG4gICAgdGhpcy5fY2lyY2xlRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3N9cHhgLCB0aGlzLl9jaXJjbGVFbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3N9cHhgO1xuICB9XG4gIC8vIFdlIGFyZSBvdmVyd3JpdGluZyB0aGUgbWV0aG9kIF9zZXRFcnJvclN0YXRlIGZyb20gTWFwbGlicmUncyBHZW9sb2NhdGVDb250cm9sIGJlY2F1c2UgdGhlXG4gIC8vIGNhc2UgQkFDS0dST1VORF9FUlJPUiBpcyBub3QgZGVhbHQgd2l0aCBpbiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kIHlpZWxkcyBhbiBlcnJvci5cbiAgLy8gUmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL21hcGxpYnJlL21hcGxpYnJlLWdsLWpzL2lzc3Vlcy8yMjk0XG4gIF9zZXRFcnJvclN0YXRlKCkge1xuICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgY2FzZSBcIldBSVRJTkdfQUNUSVZFXCI6XG4gICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkFDVElWRV9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJBQ1RJVkVfRVJST1JcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkJBQ0tHUk9VTkRcIjpcbiAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQkFDS0dST1VORF9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBQ1RJVkVfRVJST1JcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB3YXRjaFN0YXRlICR7dGhpcy5fd2F0Y2hTdGF0ZX1gKTtcbiAgICB9XG4gIH1cbn1cbnZhciBNZSwgWSwgUGUsIFJlLCBudDtcbmNsYXNzIGJ1IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzZWxlY3Rvck9yRWxlbWVudCBFbGVtZW50IHRvIGJlIHVzZWQgYXMgY29udHJvbCwgc3BlY2lmaWVkIGFzIGVpdGhlciByZWZlcmVuY2UgdG8gZWxlbWVudCBpdHNlbGYgb3IgYSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgZWxlbWVudCBpbiBET01cbiAgICogQHBhcmFtIG9uQ2xpY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gb25SZW5kZXIgRnVuY3Rpb24gY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHVuZGVybHlpbmcgbWFwIHJlbmRlcnMgYSBuZXcgc3RhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBaKHRoaXMsIE1lKTtcbiAgICBaKHRoaXMsIFkpO1xuICAgIFoodGhpcywgUGUpO1xuICAgIFoodGhpcywgUmUpO1xuICAgIFoodGhpcywgbnQpO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTtcbiAgICAgIGlmICghYSkgdGhyb3cgbmV3IEVycm9yKGBObyBlbGVtZW50IGhhcyBiZWVuIGZvdW5kIHdpdGggc2VsZWN0b3IgXCIke2V9XCIgd2hlbiBjcmVhdGluZyBhbiBleHRlcm5hbCBjb250cm9sLmApO1xuICAgICAgSyh0aGlzLCBZLCBhKTtcbiAgICB9IGVsc2VcbiAgICAgIEsodGhpcywgWSwgZSk7XG4gICAgdCAmJiBLKHRoaXMsIFBlLCAoYSkgPT4ge1xuICAgICAgdChrKHRoaXMsIE1lKSwgayh0aGlzLCBZKSwgYSk7XG4gICAgfSksIG4gJiYgSyh0aGlzLCBSZSwgKGEpID0+IHtcbiAgICAgIG4oayh0aGlzLCBNZSksIGsodGhpcywgWSksIGEpO1xuICAgIH0pLCBLKHRoaXMsIG50LCBrKHRoaXMsIFkpLnBhcmVudEVsZW1lbnQpO1xuICB9XG4gIG9uQWRkKGUpIHtcbiAgICByZXR1cm4gSyh0aGlzLCBNZSwgZSksIGsodGhpcywgUGUpICYmIGsodGhpcywgWSkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGsodGhpcywgUGUpKSwgayh0aGlzLCBSZSkgJiYgayh0aGlzLCBNZSkub24oXCJyZW5kZXJcIiwgayh0aGlzLCBSZSkpLCBFdChrKHRoaXMsIFkpKSwgayh0aGlzLCBZKTtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBrKHRoaXMsIFBlKSAmJiBrKHRoaXMsIFkpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBrKHRoaXMsIFBlKSksIGsodGhpcywgUmUpICYmIGsodGhpcywgTWUpLm9mZihcInJlbmRlclwiLCBrKHRoaXMsIFJlKSksIGsodGhpcywgbnQpID8gayh0aGlzLCBudCkuYXBwZW5kQ2hpbGQoayh0aGlzLCBZKSkgOiBFdChrKHRoaXMsIFkpKTtcbiAgfVxufVxuTWUgPSBuZXcgV2Vha01hcCgpLCBZID0gbmV3IFdlYWtNYXAoKSwgUGUgPSBuZXcgV2Vha01hcCgpLCBSZSA9IG5ldyBXZWFrTWFwKCksIG50ID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIHd1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgZyh0aGlzLCBcIm1hcFwiKTtcbiAgICBnKHRoaXMsIFwiY29udGFpbmVyXCIpO1xuICAgIGcodGhpcywgXCJwcm9qZWN0aW9uQnV0dG9uXCIpO1xuICB9XG4gIG9uQWRkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAgPSBlLCB0aGlzLmNvbnRhaW5lciA9IFRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKSwgdGhpcy5wcm9qZWN0aW9uQnV0dG9uID0gVGUoXCJidXR0b25cIiwgXCJtYXBsaWJyZWdsLWN0cmwtcHJvamVjdGlvblwiLCB0aGlzLmNvbnRhaW5lciksIFRlKFwic3BhblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1pY29uXCIsIHRoaXMucHJvamVjdGlvbkJ1dHRvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCB0aGlzLnByb2plY3Rpb25CdXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMucHJvamVjdGlvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGVQcm9qZWN0aW9uLmJpbmQodGhpcykpLCBlLm9uKFwicHJvamVjdGlvbnRyYW5zaXRpb25cIiwgdGhpcy51cGRhdGVQcm9qZWN0aW9uSWNvbi5iaW5kKHRoaXMpKSwgdGhpcy51cGRhdGVQcm9qZWN0aW9uSWNvbigpLCB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBFdCh0aGlzLmNvbnRhaW5lciksIHRoaXMubWFwLm9mZihcInByb2plY3Rpb250cmFuc2l0aW9uXCIsIHRoaXMudXBkYXRlUHJvamVjdGlvbkljb24pLCB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgfVxuICB0b2dnbGVQcm9qZWN0aW9uKCkge1xuICAgIERvKHRoaXMubWFwKSwgdGhpcy51cGRhdGVQcm9qZWN0aW9uSWNvbigpO1xuICB9XG4gIHVwZGF0ZVByb2plY3Rpb25JY29uKCkge1xuICAgIHRoaXMucHJvamVjdGlvbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXByb2plY3Rpb24tZ2xvYmVcIiksIHRoaXMucHJvamVjdGlvbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXByb2plY3Rpb24tbWVyY2F0b3JcIiksIHRoaXMubWFwLmlzR2xvYmVQcm9qZWN0aW9uKCkgPyAodGhpcy5wcm9qZWN0aW9uQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtcHJvamVjdGlvbi1tZXJjYXRvclwiKSwgdGhpcy5wcm9qZWN0aW9uQnV0dG9uLnRpdGxlID0gXCJFbmFibGUgTWVyY2F0b3IgcHJvamVjdGlvblwiKSA6ICh0aGlzLnByb2plY3Rpb25CdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1wcm9qZWN0aW9uLWdsb2JlXCIpLCB0aGlzLnByb2plY3Rpb25CdXR0b24udGl0bGUgPSBcIkVuYWJsZSBHbG9iZSBwcm9qZWN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBEbyhyKSB7XG4gIHIuZ2V0UHJvamVjdGlvbigpID09PSB2b2lkIDAgJiYgci5zZXRQcm9qZWN0aW9uKHsgdHlwZTogXCJtZXJjYXRvclwiIH0pLCByLmlzR2xvYmVQcm9qZWN0aW9uKCkgPyByLmVuYWJsZU1lcmNhdG9yUHJvamVjdGlvbigpIDogci5lbmFibGVHbG9iZVByb2plY3Rpb24oKTtcbn1cbmNvbnN0IHB0ID0ge1xuICBcInpvb20taW5cIjogKHIpID0+IHIuem9vbUluKCksXG4gIFwiem9vbS1vdXRcIjogKHIpID0+IHIuem9vbU91dCgpLFxuICBcInRvZ2dsZS1wcm9qZWN0aW9uXCI6IERvLFxuICBcInRvZ2dsZS10ZXJyYWluXCI6IGpvLFxuICBcInJlc2V0LXZpZXdcIjogKHIpID0+IHtcbiAgICByLmdldFBpdGNoKCkgPT09IDAgPyByLmVhc2VUbyh7IHBpdGNoOiBNYXRoLm1pbihyLmdldE1heFBpdGNoKCksIDgwKSB9KSA6IHIucmVzZXROb3J0aFBpdGNoKCk7XG4gIH0sXG4gIFwicmVzZXQtYmVhcmluZ1wiOiAocikgPT4ge1xuICAgIHIucm90YXRlVG8oMCk7XG4gIH0sXG4gIFwicmVzZXQtcGl0Y2hcIjogKHIpID0+IHtcbiAgICByLnNldFBpdGNoKDApO1xuICB9LFxuICBcInJlc2V0LXJvbGxcIjogKHIpID0+IHtcbiAgICByLnNldFJvbGwoMCk7XG4gIH1cbn07XG52YXIgQXQsIGF0O1xuY2xhc3MgdG4gZXh0ZW5kcyBidSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEV4dGVybmFsIENvbnRyb2wgdG8gaGF2ZSBhIHByZWRlZmluZWQgZnVuY3Rpb25hbGl0eVxuICAgKiBAcGFyYW0gY29udHJvbEVsZW1lbnQgRWxlbWVudCB0byBiZSB1c2VkIGFzIGNvbnRyb2wsIHNwZWNpZmllZCBhcyByZWZlcmVuY2UgdG8gZWxlbWVudCBpdHNlbGZcbiAgICogQHBhcmFtIGNvbnRyb2xUeXBlIE9uZSBvZiB0aGUgcHJlZGVmaW5lZCB0eXBlcyBvZiBmdW5jdGlvbmFsaXR5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgaWYgKG4gJiYgIShuIGluIHB0KSkgdGhyb3cgbmV3IEVycm9yKGBkYXRhLW1hcHRpbGVyLWNvbnRyb2wgdmFsdWUgXCIke259XCIgaXMgaW52YWxpZC5gKTtcbiAgICBzdXBlcih0LCBuICYmIHB0W25dKTtcbiAgICBaKHRoaXMsIEF0KTtcbiAgICBaKHRoaXMsIGF0LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBvbkFkZCh0KSB7XG4gICAgcmV0dXJuIEsodGhpcywgQXQsIHQpLCBzdXBlci5vbkFkZCh0KTtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBmb3IgKGNvbnN0IFt0LCBuXSBvZiBrKHRoaXMsIGF0KSkge1xuICAgICAgY29uc3QgYSA9IHQuZGVyZWYoKTtcbiAgICAgIGEgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgbik7XG4gICAgfVxuICAgIGsodGhpcywgYXQpLmNsZWFyKCksIHN1cGVyLm9uUmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSBhIGNoaWxkIGVsZW1lbnQgdG8gYmUgcGFydCBvZiB0aGlzIGNvbnRyb2wgYW5kIHRvIGhhdmUgYSBwcmVkZWZpbmVkIGZ1bmN0aW9uYWxpdHkgYWRkZWRcbiAgICogQHBhcmFtIGNvbnRyb2xFbGVtZW50IEVsZW1lbnQgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGNvbnRyb2wgZWxlbWVudCBhbmQgdGhhdCBvcHRpb25hbGx5IHNob3VsZCBoYXZlIHNvbWUgZnVuY3Rpb25hbGl0eVxuICAgKiBAcGFyYW0gY29udHJvbFR5cGUgT25lIG9mIHRoZSBwcmVkZWZpbmVkIHR5cGVzIG9mIGZ1bmN0aW9uYWxpdHlcbiAgICovXG4gIGNvbmZpZ3VyZUdyb3VwSXRlbSh0LCBuKSB7XG4gICAgaWYgKCFuKSByZXR1cm47XG4gICAgaWYgKCEobiBpbiBwdCkpIHRocm93IG5ldyBFcnJvcihgZGF0YS1tYXB0aWxlci1jb250cm9sIHZhbHVlIFwiJHtufVwiIGlzIGludmFsaWQuYCk7XG4gICAgY29uc3QgYSA9IChvKSA9PiB7XG4gICAgICBwdFtuXShrKHRoaXMsIEF0KSwgdCwgbyk7XG4gICAgfTtcbiAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhKSwgayh0aGlzLCBhdCkuc2V0KG5ldyBXZWFrUmVmKHQpLCBhKTtcbiAgfVxufVxuQXQgPSBuZXcgV2Vha01hcCgpLCBhdCA9IG5ldyBXZWFrTWFwKCksIGcodG4sIFwiY29udHJvbENhbGxiYWNrc1wiLCBwdCk7XG52YXIgVywgZmUsIHplLCBPZSwgdGUsIFR0LCBHLCBVbywgb2UsIEJvO1xuY2xhc3MgJHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgWih0aGlzLCBHKTtcbiAgICBaKHRoaXMsIFcpO1xuICAgIGcodGhpcywgXCJtYXBcIik7XG4gICAgWih0aGlzLCBmZSk7XG4gICAgWih0aGlzLCB6ZSk7XG4gICAgWih0aGlzLCBPZSk7XG4gICAgWih0aGlzLCB0ZSwgITEpO1xuICAgIFoodGhpcywgVHQpO1xuICAgIGUuc3R5bGUgIT09IHZvaWQgMCAmJiBLKHRoaXMsIHRlLCAhMCksIEsodGhpcywgVywge1xuICAgICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgICB6b29tQWRqdXN0OiAtNCxcbiAgICAgIHBvc2l0aW9uOiBcInRvcC1yaWdodFwiLFxuICAgICAgLy8gaW5oZXJpdCBtYXAgb3B0aW9uc1xuICAgICAgLi4udCxcbiAgICAgIC8vIG92ZXJyaWRlIGFueSBsaW5nZXJpbmcgY29udHJvbCBvcHRpb25zXG4gICAgICBmb3JjZU5vQXR0cmlidXRpb25Db250cm9sOiAhMCxcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogITEsXG4gICAgICBuYXZpZ2F0aW9uQ29udHJvbDogITEsXG4gICAgICBnZW9sb2NhdGVDb250cm9sOiAhMSxcbiAgICAgIG1hcHRpbGVyTG9nbzogITEsXG4gICAgICBtaW5pbWFwOiAhMSxcbiAgICAgIGhhc2g6ICExLFxuICAgICAgcGl0Y2hBZGp1c3Q6ICExLFxuICAgICAgLy8gb3ZlcnJpZGUgbWFwIG9wdGlvbnMgd2l0aCBuZXcgdXNlciBkZWZpbmVkIG1pbmltYXAgb3B0aW9uc1xuICAgICAgLi4uZSxcbiAgICAgIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzAwMFwiLFxuICAgICAgICB3aWR0aDogXCI0MDBweFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMzAwcHhcIixcbiAgICAgICAgLi4uZS5jb250YWluZXJTdHlsZSA/PyB7fVxuICAgICAgfVxuICAgIH0pLCBlLmxvY2tab29tICE9PSB2b2lkIDAgJiYgKGsodGhpcywgVykubWluWm9vbSA9IGUubG9ja1pvb20sIGsodGhpcywgVykubWF4Wm9vbSA9IGUubG9ja1pvb20pO1xuICB9XG4gIHNldFN0eWxlKGUsIHQpIHtcbiAgICBrKHRoaXMsIHRlKSB8fCB0aGlzLm1hcC5zZXRTdHlsZShlLCB0KSwgWCh0aGlzLCBHLCBvZSkuY2FsbCh0aGlzKTtcbiAgfVxuICBhZGRMYXllcihlLCB0KSB7XG4gICAgcmV0dXJuIGsodGhpcywgdGUpIHx8IHRoaXMubWFwLmFkZExheWVyKGUsIHQpLCBYKHRoaXMsIEcsIG9lKS5jYWxsKHRoaXMpLCB0aGlzLm1hcDtcbiAgfVxuICBtb3ZlTGF5ZXIoZSwgdCkge1xuICAgIHJldHVybiBrKHRoaXMsIHRlKSB8fCB0aGlzLm1hcC5tb3ZlTGF5ZXIoZSwgdCksIFgodGhpcywgRywgb2UpLmNhbGwodGhpcyksIHRoaXMubWFwO1xuICB9XG4gIHJlbW92ZUxheWVyKGUpIHtcbiAgICByZXR1cm4gayh0aGlzLCB0ZSkgfHwgdGhpcy5tYXAucmVtb3ZlTGF5ZXIoZSksIFgodGhpcywgRywgb2UpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgc2V0TGF5ZXJab29tUmFuZ2UoZSwgdCwgbikge1xuICAgIHJldHVybiBrKHRoaXMsIHRlKSB8fCB0aGlzLm1hcC5zZXRMYXllclpvb21SYW5nZShlLCB0LCBuKSwgWCh0aGlzLCBHLCBvZSkuY2FsbCh0aGlzKSwgdGhpcztcbiAgfVxuICBzZXRGaWx0ZXIoZSwgdCwgbikge1xuICAgIHJldHVybiBrKHRoaXMsIHRlKSB8fCB0aGlzLm1hcC5zZXRGaWx0ZXIoZSwgdCwgbiksIFgodGhpcywgRywgb2UpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgc2V0UGFpbnRQcm9wZXJ0eShlLCB0LCBuLCBhKSB7XG4gICAgcmV0dXJuIGsodGhpcywgdGUpIHx8IHRoaXMubWFwLnNldFBhaW50UHJvcGVydHkoZSwgdCwgbiwgYSksIFgodGhpcywgRywgb2UpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgc2V0TGF5b3V0UHJvcGVydHkoZSwgdCwgbiwgYSkge1xuICAgIHJldHVybiBrKHRoaXMsIHRlKSB8fCB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eShlLCB0LCBuLCBhKSwgWCh0aGlzLCBHLCBvZSkuY2FsbCh0aGlzKSwgdGhpcztcbiAgfVxuICBzZXRHbHlwaHMoZSwgdCkge1xuICAgIHJldHVybiBrKHRoaXMsIHRlKSB8fCB0aGlzLm1hcC5zZXRHbHlwaHMoZSwgdCksIFgodGhpcywgRywgb2UpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgb25BZGQoZSkge1xuICAgIEsodGhpcywgZmUsIGUpLCBLKHRoaXMsIHplLCBUZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybCBtYXBsaWJyZWdsLWN0cmwtZ3JvdXBcIikpO1xuICAgIGZvciAoY29uc3QgW3QsIG5dIG9mIE9iamVjdC5lbnRyaWVzKGsodGhpcywgVykuY29udGFpbmVyU3R5bGUpKVxuICAgICAgayh0aGlzLCB6ZSkuc3R5bGUuc2V0UHJvcGVydHkodCwgbik7XG4gICAgcmV0dXJuIGsodGhpcywgVykuY29udGFpbmVyID0gayh0aGlzLCB6ZSksIGsodGhpcywgVykuem9vbSA9IGUuZ2V0Wm9vbSgpICsgayh0aGlzLCBXKS56b29tQWRqdXN0LCB0aGlzLm1hcCA9IG5ldyBHbyhrKHRoaXMsIFcpKSwgdGhpcy5tYXAub25jZShcInN0eWxlLmxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5tYXAucmVzaXplKCk7XG4gICAgfSksIHRoaXMubWFwLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIFgodGhpcywgRywgVW8pLmNhbGwodGhpcywgayh0aGlzLCBXKS5wYXJlbnRSZWN0KSwgSyh0aGlzLCBUdCwgWCh0aGlzLCBHLCBCbykuY2FsbCh0aGlzKSk7XG4gICAgfSksIGsodGhpcywgemUpO1xuICB9XG4gIG9uUmVtb3ZlKCkge1xuICAgIHZhciBlO1xuICAgIChlID0gayh0aGlzLCBUdCkpID09IG51bGwgfHwgZS5jYWxsKHRoaXMpLCBFdChrKHRoaXMsIHplKSk7XG4gIH1cbn1cblcgPSBuZXcgV2Vha01hcCgpLCBmZSA9IG5ldyBXZWFrTWFwKCksIHplID0gbmV3IFdlYWtNYXAoKSwgT2UgPSBuZXcgV2Vha01hcCgpLCB0ZSA9IG5ldyBXZWFrTWFwKCksIFR0ID0gbmV3IFdlYWtNYXAoKSwgRyA9IG5ldyBXZWFrU2V0KCksIFVvID0gZnVuY3Rpb24oZSkge1xuICBlID09PSB2b2lkIDAgfHwgZS5saW5lUGFpbnQgPT09IHZvaWQgMCAmJiBlLmZpbGxQYWludCA9PT0gdm9pZCAwIHx8IChLKHRoaXMsIE9lLCB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgbmFtZTogXCJwYXJlbnRSZWN0XCJcbiAgICB9LFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgIGNvb3JkaW5hdGVzOiBbW1tdLCBbXSwgW10sIFtdLCBbXV1dXG4gICAgfVxuICB9KSwgdGhpcy5tYXAuYWRkU291cmNlKFwicGFyZW50UmVjdFwiLCB7XG4gICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgZGF0YTogayh0aGlzLCBPZSlcbiAgfSksIChlLmxpbmVMYXlvdXQgIT09IHZvaWQgMCB8fCBlLmxpbmVQYWludCAhPT0gdm9pZCAwKSAmJiB0aGlzLm1hcC5hZGRMYXllcih7XG4gICAgaWQ6IFwicGFyZW50UmVjdE91dGxpbmVcIixcbiAgICB0eXBlOiBcImxpbmVcIixcbiAgICBzb3VyY2U6IFwicGFyZW50UmVjdFwiLFxuICAgIGxheW91dDoge1xuICAgICAgLi4uZS5saW5lTGF5b3V0XG4gICAgfSxcbiAgICBwYWludDoge1xuICAgICAgXCJsaW5lLWNvbG9yXCI6IFwiI0ZGRlwiLFxuICAgICAgXCJsaW5lLXdpZHRoXCI6IDEsXG4gICAgICBcImxpbmUtb3BhY2l0eVwiOiAwLjg1LFxuICAgICAgLi4uZS5saW5lUGFpbnRcbiAgICB9XG4gIH0pLCBlLmZpbGxQYWludCAhPT0gdm9pZCAwICYmIHRoaXMubWFwLmFkZExheWVyKHtcbiAgICBpZDogXCJwYXJlbnRSZWN0RmlsbFwiLFxuICAgIHR5cGU6IFwiZmlsbFwiLFxuICAgIHNvdXJjZTogXCJwYXJlbnRSZWN0XCIsXG4gICAgbGF5b3V0OiB7fSxcbiAgICBwYWludDoge1xuICAgICAgXCJmaWxsLWNvbG9yXCI6IFwiIzA4RlwiLFxuICAgICAgXCJmaWxsLW9wYWNpdHlcIjogMC4xMzUsXG4gICAgICAuLi5lLmZpbGxQYWludFxuICAgIH1cbiAgfSksIFgodGhpcywgRywgb2UpLmNhbGwodGhpcykpO1xufSwgb2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGsodGhpcywgT2UpID09PSB2b2lkIDApIHJldHVybjtcbiAgY29uc3QgeyBkZXZpY2VQaXhlbFJhdGlvOiBlIH0gPSB3aW5kb3csIHQgPSBrKHRoaXMsIGZlKS5nZXRDYW52YXMoKSwgbiA9IHQud2lkdGggLyBlLCBhID0gdC5oZWlnaHQgLyBlLCBvID0gayh0aGlzLCBmZSkudW5wcm9qZWN0LmJpbmQoayh0aGlzLCBmZSkpLCBpID0gbyhbMCwgMF0pLCBzID0gbyhbbiwgMF0pLCBsID0gbyhbMCwgYV0pLCB1ID0gbyhbbiwgYV0pO1xuICBrKHRoaXMsIE9lKS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtbbC50b0FycmF5KCksIHUudG9BcnJheSgpLCBzLnRvQXJyYXkoKSwgaS50b0FycmF5KCksIGwudG9BcnJheSgpXV07XG4gIGNvbnN0IGMgPSB0aGlzLm1hcC5nZXRTb3VyY2UoXCJwYXJlbnRSZWN0XCIpO1xuICBjICE9PSB2b2lkIDAgJiYgYy5zZXREYXRhKGsodGhpcywgT2UpKTtcbn0sIEJvID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHsgcGl0Y2hBZGp1c3Q6IGUgfSA9IGsodGhpcywgVyksIHQgPSAoKSA9PiB7XG4gICAgaShcInBhcmVudFwiKTtcbiAgfSwgbiA9ICgpID0+IHtcbiAgICBpKFwibWluaW1hcFwiKTtcbiAgfSwgYSA9ICgpID0+IHtcbiAgICBrKHRoaXMsIGZlKS5vbihcIm1vdmVcIiwgdCksIHRoaXMubWFwLm9uKFwibW92ZVwiLCBuKTtcbiAgfSwgbyA9ICgpID0+IHtcbiAgICBrKHRoaXMsIGZlKS5vZmYoXCJtb3ZlXCIsIHQpLCB0aGlzLm1hcC5vZmYoXCJtb3ZlXCIsIG4pO1xuICB9LCBpID0gKHMpID0+IHtcbiAgICBvKCk7XG4gICAgY29uc3QgbCA9IHMgPT09IFwicGFyZW50XCIgPyBrKHRoaXMsIGZlKSA6IHRoaXMubWFwLCB1ID0gcyA9PT0gXCJwYXJlbnRcIiA/IHRoaXMubWFwIDogayh0aGlzLCBmZSksIGMgPSBsLmdldENlbnRlcigpLCBwID0gbC5nZXRab29tKCkgKyBrKHRoaXMsIFcpLnpvb21BZGp1c3QgKiAocyA9PT0gXCJwYXJlbnRcIiA/IDEgOiAtMSksIGQgPSBsLmdldEJlYXJpbmcoKSwgZiA9IGwuZ2V0UGl0Y2goKTtcbiAgICB1Lmp1bXBUbyh7XG4gICAgICBjZW50ZXI6IGMsXG4gICAgICB6b29tOiBwLFxuICAgICAgYmVhcmluZzogZCxcbiAgICAgIHBpdGNoOiBlID8gZiA6IDBcbiAgICB9KSwgWCh0aGlzLCBHLCBvZSkuY2FsbCh0aGlzKSwgYSgpO1xuICB9O1xuICByZXR1cm4gYSgpLCAoKSA9PiB7XG4gICAgbygpO1xuICB9O1xufTtcbmNsYXNzIFN1IHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtYXAgOiBhIE1hcCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gZGVsYXkgOiBhIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgcGF5bG9hZCBpcyBzZW50IHRvIE1hcFRpbGVyIGNsb3VkIChjYW5ub3QgYmUgbGVzcyB0aGFuIDEwMDBtcylcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQgPSAyZTMpIHtcbiAgICBnKHRoaXMsIFwibWFwXCIpO1xuICAgIGcodGhpcywgXCJyZWdpc3RlcmVkTW9kdWxlc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBnKHRoaXMsIFwidmlld2VyVHlwZVwiKTtcbiAgICB0aGlzLm1hcCA9IGUsIHRoaXMudmlld2VyVHlwZSA9IFwiTWFwXCIsIHNldFRpbWVvdXQoXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghai50ZWxlbWV0cnkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5wcmVwYXJlUGF5bG9hZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIChhd2FpdCBmZXRjaChuLCB7IG1ldGhvZDogXCJQT1NUXCIgfSkpLm9rIHx8IGNvbnNvbGUud2FybihcIlRoZSBtZXRyaWNzIGNvdWxkIG5vdCBiZSBzZW50IHRvIE1hcFRpbGVyIENsb3VkXCIpO1xuICAgICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG1ldHJpY3MgY291bGQgbm90IGJlIHNlbnQgdG8gTWFwVGlsZXIgQ2xvdWRcIiwgYSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBNYXRoLm1heCgxZTMsIHQpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBtb2R1bGUgdG8gdGhlIHRlbGVtZXRyeSBzeXN0ZW0gb2YgdGhlIFNESy5cbiAgICogVGhlIGFyZ3VtZW50cyBgbmFtZWAgYW5kIGB2ZXJzaW9uYCBsaWtlbHkgY29tZSBmcm9tIHRoZSBwYWNrYWdlLmpzb25cbiAgICogb2YgZWFjaCBtb2R1bGUuXG4gICAqL1xuICByZWdpc3Rlck1vZHVsZShlLCB0KSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kdWxlcy5hZGQoYCR7ZX06JHt0fWApO1xuICB9XG4gIHJlZ2lzdGVyVmlld2VyVHlwZShlID0gXCJNYXBcIikge1xuICAgIHRoaXMudmlld2VyVHlwZSA9IGU7XG4gIH1cbiAgcHJlcGFyZVBheWxvYWQoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBVUkwoSi50ZWxlbWV0cnlVUkwpO1xuICAgIHJldHVybiBlLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzZGtcIiwgS2MoKSksIGUuc2VhcmNoUGFyYW1zLmFwcGVuZChcImtleVwiLCBqLmFwaUtleSksIGUuc2VhcmNoUGFyYW1zLmFwcGVuZChcIm10c2lkXCIsIGRuKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic2Vzc2lvblwiLCBqLnNlc3Npb24gPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2FjaGluZ1wiLCBqLmNhY2hpbmcgPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibGFuZy11cGRhdGVkXCIsIHRoaXMubWFwLmlzTGFuZ3VhZ2VVcGRhdGVkKCkgPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwidGVycmFpblwiLCB0aGlzLm1hcC5nZXRUZXJyYWluKCkgPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiZ2xvYmVcIiwgdGhpcy5tYXAuaXNHbG9iZVByb2plY3Rpb24oKSA/IFwiMVwiIDogXCIwXCIpLCBlLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJ2aWV3ZXJUeXBlXCIsIHRoaXMudmlld2VyVHlwZSksIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMuc2l6ZSA+IDAgJiYgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibW9kdWxlc1wiLCBBcnJheS5mcm9tKHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMpLmpvaW4oXCJ8XCIpKSwgZS5ocmVmO1xuICB9XG59XG52YXIgQ3QgPSB0eXBlb2YgRmxvYXQzMkFycmF5IDwgXCJ1XCIgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmZ1bmN0aW9uIGd0KCkge1xuICB2YXIgciA9IG5ldyBDdCgxNik7XG4gIHJldHVybiBDdCAhPSBGbG9hdDMyQXJyYXkgJiYgKHJbMV0gPSAwLCByWzJdID0gMCwgclszXSA9IDAsIHJbNF0gPSAwLCByWzZdID0gMCwgcls3XSA9IDAsIHJbOF0gPSAwLCByWzldID0gMCwgclsxMV0gPSAwLCByWzEyXSA9IDAsIHJbMTNdID0gMCwgclsxNF0gPSAwKSwgclswXSA9IDEsIHJbNV0gPSAxLCByWzEwXSA9IDEsIHJbMTVdID0gMSwgcjtcbn1cbmZ1bmN0aW9uIHh1KHIsIGUsIHQsIG4sIGEsIG8sIGksIHMsIGwsIHUsIGMsIHAsIGQsIGYsIGgsIG0sIHkpIHtcbiAgcmV0dXJuIHJbMF0gPSBlLCByWzFdID0gdCwgclsyXSA9IG4sIHJbM10gPSBhLCByWzRdID0gbywgcls1XSA9IGksIHJbNl0gPSBzLCByWzddID0gbCwgcls4XSA9IHUsIHJbOV0gPSBjLCByWzEwXSA9IHAsIHJbMTFdID0gZCwgclsxMl0gPSBmLCByWzEzXSA9IGgsIHJbMTRdID0gbSwgclsxNV0gPSB5LCByO1xufVxuZnVuY3Rpb24ga3UociwgZSwgdCkge1xuICB2YXIgbiA9IGVbMF0sIGEgPSBlWzFdLCBvID0gZVsyXSwgaSA9IGVbM10sIHMgPSBlWzRdLCBsID0gZVs1XSwgdSA9IGVbNl0sIGMgPSBlWzddLCBwID0gZVs4XSwgZCA9IGVbOV0sIGYgPSBlWzEwXSwgaCA9IGVbMTFdLCBtID0gZVsxMl0sIHkgPSBlWzEzXSwgdyA9IGVbMTRdLCB2ID0gZVsxNV0sIHggPSB0WzBdLCBBID0gdFsxXSwgRSA9IHRbMl0sIEMgPSB0WzNdO1xuICByZXR1cm4gclswXSA9IHggKiBuICsgQSAqIHMgKyBFICogcCArIEMgKiBtLCByWzFdID0geCAqIGEgKyBBICogbCArIEUgKiBkICsgQyAqIHksIHJbMl0gPSB4ICogbyArIEEgKiB1ICsgRSAqIGYgKyBDICogdywgclszXSA9IHggKiBpICsgQSAqIGMgKyBFICogaCArIEMgKiB2LCB4ID0gdFs0XSwgQSA9IHRbNV0sIEUgPSB0WzZdLCBDID0gdFs3XSwgcls0XSA9IHggKiBuICsgQSAqIHMgKyBFICogcCArIEMgKiBtLCByWzVdID0geCAqIGEgKyBBICogbCArIEUgKiBkICsgQyAqIHksIHJbNl0gPSB4ICogbyArIEEgKiB1ICsgRSAqIGYgKyBDICogdywgcls3XSA9IHggKiBpICsgQSAqIGMgKyBFICogaCArIEMgKiB2LCB4ID0gdFs4XSwgQSA9IHRbOV0sIEUgPSB0WzEwXSwgQyA9IHRbMTFdLCByWzhdID0geCAqIG4gKyBBICogcyArIEUgKiBwICsgQyAqIG0sIHJbOV0gPSB4ICogYSArIEEgKiBsICsgRSAqIGQgKyBDICogeSwgclsxMF0gPSB4ICogbyArIEEgKiB1ICsgRSAqIGYgKyBDICogdywgclsxMV0gPSB4ICogaSArIEEgKiBjICsgRSAqIGggKyBDICogdiwgeCA9IHRbMTJdLCBBID0gdFsxM10sIEUgPSB0WzE0XSwgQyA9IHRbMTVdLCByWzEyXSA9IHggKiBuICsgQSAqIHMgKyBFICogcCArIEMgKiBtLCByWzEzXSA9IHggKiBhICsgQSAqIGwgKyBFICogZCArIEMgKiB5LCByWzE0XSA9IHggKiBvICsgQSAqIHUgKyBFICogZiArIEMgKiB3LCByWzE1XSA9IHggKiBpICsgQSAqIGMgKyBFICogaCArIEMgKiB2LCByO1xufVxuZnVuY3Rpb24gTHUociwgZSwgdCkge1xuICB2YXIgbiA9IHRbMF0sIGEgPSB0WzFdLCBvID0gdFsyXTtcbiAgcmV0dXJuIHJbMF0gPSBlWzBdICogbiwgclsxXSA9IGVbMV0gKiBuLCByWzJdID0gZVsyXSAqIG4sIHJbM10gPSBlWzNdICogbiwgcls0XSA9IGVbNF0gKiBhLCByWzVdID0gZVs1XSAqIGEsIHJbNl0gPSBlWzZdICogYSwgcls3XSA9IGVbN10gKiBhLCByWzhdID0gZVs4XSAqIG8sIHJbOV0gPSBlWzldICogbywgclsxMF0gPSBlWzEwXSAqIG8sIHJbMTFdID0gZVsxMV0gKiBvLCByWzEyXSA9IGVbMTJdLCByWzEzXSA9IGVbMTNdLCByWzE0XSA9IGVbMTRdLCByWzE1XSA9IGVbMTVdLCByO1xufVxuZnVuY3Rpb24gQ2EociwgZSwgdCkge1xuICB2YXIgbiA9IE1hdGguc2luKHQpLCBhID0gTWF0aC5jb3ModCksIG8gPSBlWzRdLCBpID0gZVs1XSwgcyA9IGVbNl0sIGwgPSBlWzddLCB1ID0gZVs4XSwgYyA9IGVbOV0sIHAgPSBlWzEwXSwgZCA9IGVbMTFdO1xuICByZXR1cm4gZSAhPT0gciAmJiAoclswXSA9IGVbMF0sIHJbMV0gPSBlWzFdLCByWzJdID0gZVsyXSwgclszXSA9IGVbM10sIHJbMTJdID0gZVsxMl0sIHJbMTNdID0gZVsxM10sIHJbMTRdID0gZVsxNF0sIHJbMTVdID0gZVsxNV0pLCByWzRdID0gbyAqIGEgKyB1ICogbiwgcls1XSA9IGkgKiBhICsgYyAqIG4sIHJbNl0gPSBzICogYSArIHAgKiBuLCByWzddID0gbCAqIGEgKyBkICogbiwgcls4XSA9IHUgKiBhIC0gbyAqIG4sIHJbOV0gPSBjICogYSAtIGkgKiBuLCByWzEwXSA9IHAgKiBhIC0gcyAqIG4sIHJbMTFdID0gZCAqIGEgLSBsICogbiwgcjtcbn1cbmZ1bmN0aW9uIEV1KHIsIGUsIHQpIHtcbiAgdmFyIG4gPSBNYXRoLnNpbih0KSwgYSA9IE1hdGguY29zKHQpLCBvID0gZVswXSwgaSA9IGVbMV0sIHMgPSBlWzJdLCBsID0gZVszXSwgdSA9IGVbOF0sIGMgPSBlWzldLCBwID0gZVsxMF0sIGQgPSBlWzExXTtcbiAgcmV0dXJuIGUgIT09IHIgJiYgKHJbNF0gPSBlWzRdLCByWzVdID0gZVs1XSwgcls2XSA9IGVbNl0sIHJbN10gPSBlWzddLCByWzEyXSA9IGVbMTJdLCByWzEzXSA9IGVbMTNdLCByWzE0XSA9IGVbMTRdLCByWzE1XSA9IGVbMTVdKSwgclswXSA9IG8gKiBhIC0gdSAqIG4sIHJbMV0gPSBpICogYSAtIGMgKiBuLCByWzJdID0gcyAqIGEgLSBwICogbiwgclszXSA9IGwgKiBhIC0gZCAqIG4sIHJbOF0gPSBvICogbiArIHUgKiBhLCByWzldID0gaSAqIG4gKyBjICogYSwgclsxMF0gPSBzICogbiArIHAgKiBhLCByWzExXSA9IGwgKiBuICsgZCAqIGEsIHI7XG59XG5mdW5jdGlvbiBBYShyLCBlLCB0KSB7XG4gIHZhciBuID0gTWF0aC5zaW4odCksIGEgPSBNYXRoLmNvcyh0KSwgbyA9IGVbMF0sIGkgPSBlWzFdLCBzID0gZVsyXSwgbCA9IGVbM10sIHUgPSBlWzRdLCBjID0gZVs1XSwgcCA9IGVbNl0sIGQgPSBlWzddO1xuICByZXR1cm4gZSAhPT0gciAmJiAocls4XSA9IGVbOF0sIHJbOV0gPSBlWzldLCByWzEwXSA9IGVbMTBdLCByWzExXSA9IGVbMTFdLCByWzEyXSA9IGVbMTJdLCByWzEzXSA9IGVbMTNdLCByWzE0XSA9IGVbMTRdLCByWzE1XSA9IGVbMTVdKSwgclswXSA9IG8gKiBhICsgdSAqIG4sIHJbMV0gPSBpICogYSArIGMgKiBuLCByWzJdID0gcyAqIGEgKyBwICogbiwgclszXSA9IGwgKiBhICsgZCAqIG4sIHJbNF0gPSB1ICogYSAtIG8gKiBuLCByWzVdID0gYyAqIGEgLSBpICogbiwgcls2XSA9IHAgKiBhIC0gcyAqIG4sIHJbN10gPSBkICogYSAtIGwgKiBuLCByO1xufVxuZnVuY3Rpb24gQ3UociwgZSwgdCwgbiwgYSkge1xuICB2YXIgbyA9IDEgLyBNYXRoLnRhbihlIC8gMik7XG4gIGlmIChyWzBdID0gbyAvIHQsIHJbMV0gPSAwLCByWzJdID0gMCwgclszXSA9IDAsIHJbNF0gPSAwLCByWzVdID0gbywgcls2XSA9IDAsIHJbN10gPSAwLCByWzhdID0gMCwgcls5XSA9IDAsIHJbMTFdID0gLTEsIHJbMTJdID0gMCwgclsxM10gPSAwLCByWzE1XSA9IDAsIGEgIT0gbnVsbCAmJiBhICE9PSAxIC8gMCkge1xuICAgIHZhciBpID0gMSAvIChuIC0gYSk7XG4gICAgclsxMF0gPSAoYSArIG4pICogaSwgclsxNF0gPSAyICogYSAqIG4gKiBpO1xuICB9IGVsc2VcbiAgICByWzEwXSA9IC0xLCByWzE0XSA9IC0yICogbjtcbiAgcmV0dXJuIHI7XG59XG52YXIgQXUgPSBDdTtcbmZ1bmN0aW9uIFp0KCkge1xuICB2YXIgciA9IG5ldyBDdCgzKTtcbiAgcmV0dXJuIEN0ICE9IEZsb2F0MzJBcnJheSAmJiAoclswXSA9IDAsIHJbMV0gPSAwLCByWzJdID0gMCksIHI7XG59XG5mdW5jdGlvbiBUdShyLCBlLCB0KSB7XG4gIHZhciBuID0gbmV3IEN0KDMpO1xuICByZXR1cm4gblswXSA9IHIsIG5bMV0gPSBlLCBuWzJdID0gdCwgbjtcbn1cbmZ1bmN0aW9uIEZyKHIsIGUpIHtcbiAgdmFyIHQgPSBlWzBdLCBuID0gZVsxXSwgYSA9IGVbMl0sIG8gPSB0ICogdCArIG4gKiBuICsgYSAqIGE7XG4gIHJldHVybiBvID4gMCAmJiAobyA9IDEgLyBNYXRoLnNxcnQobykpLCByWzBdID0gZVswXSAqIG8sIHJbMV0gPSBlWzFdICogbywgclsyXSA9IGVbMl0gKiBvLCByO1xufVxuZnVuY3Rpb24gVGEociwgZSwgdCkge1xuICB2YXIgbiA9IGVbMF0sIGEgPSBlWzFdLCBvID0gZVsyXSwgaSA9IHRbMF0sIHMgPSB0WzFdLCBsID0gdFsyXTtcbiAgcmV0dXJuIHJbMF0gPSBhICogbCAtIG8gKiBzLCByWzFdID0gbyAqIGkgLSBuICogbCwgclsyXSA9IG4gKiBzIC0gYSAqIGksIHI7XG59XG4oZnVuY3Rpb24oKSB7XG4gIHZhciByID0gWnQoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICB2YXIgcywgbDtcbiAgICBmb3IgKHQgfHwgKHQgPSAzKSwgbiB8fCAobiA9IDApLCBhID8gbCA9IE1hdGgubWluKGEgKiB0ICsgbiwgZS5sZW5ndGgpIDogbCA9IGUubGVuZ3RoLCBzID0gbjsgcyA8IGw7IHMgKz0gdClcbiAgICAgIHJbMF0gPSBlW3NdLCByWzFdID0gZVtzICsgMV0sIHJbMl0gPSBlW3MgKyAyXSwgbyhyLCByLCBpKSwgZVtzXSA9IHJbMF0sIGVbcyArIDFdID0gclsxXSwgZVtzICsgMl0gPSByWzJdO1xuICAgIHJldHVybiBlO1xuICB9O1xufSkoKTtcbmZ1bmN0aW9uIF91KHIpIHtcbiAgcmV0dXJuIHIgJiYgci5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLCBcImRlZmF1bHRcIikgPyByLmRlZmF1bHQgOiByO1xufVxudmFyIE5yLCBfYTtcbmZ1bmN0aW9uIEl1KCkge1xuICByZXR1cm4gX2EgfHwgKF9hID0gMSwgTnIgPSB7XG4gICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gICAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICAgIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcbiAgICByZWQ6IFsyNTUsIDAsIDBdLFxuICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gICAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gICAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG4gIH0pLCBOcjtcbn1cbnZhciBqciwgSWE7XG5mdW5jdGlvbiBxbygpIHtcbiAgaWYgKElhKSByZXR1cm4ganI7XG4gIElhID0gMTtcbiAgY29uc3QgciA9IEl1KCksIGUgPSB7fTtcbiAgZm9yIChjb25zdCBhIG9mIE9iamVjdC5rZXlzKHIpKVxuICAgIGVbclthXV0gPSBhO1xuICBjb25zdCB0ID0ge1xuICAgIHJnYjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInJnYlwiIH0sXG4gICAgaHNsOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwiaHNsXCIgfSxcbiAgICBoc3Y6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJoc3ZcIiB9LFxuICAgIGh3YjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcImh3YlwiIH0sXG4gICAgY215azogeyBjaGFubmVsczogNCwgbGFiZWxzOiBcImNteWtcIiB9LFxuICAgIHh5ejogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInh5elwiIH0sXG4gICAgbGFiOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwibGFiXCIgfSxcbiAgICBsY2g6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJsY2hcIiB9LFxuICAgIGhleDogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJoZXhcIl0gfSxcbiAgICBrZXl3b3JkOiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImtleXdvcmRcIl0gfSxcbiAgICBhbnNpMTY6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiYW5zaTE2XCJdIH0sXG4gICAgYW5zaTI1NjogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJhbnNpMjU2XCJdIH0sXG4gICAgaGNnOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcImhcIiwgXCJjXCIsIFwiZ1wiXSB9LFxuICAgIGFwcGxlOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcInIxNlwiLCBcImcxNlwiLCBcImIxNlwiXSB9LFxuICAgIGdyYXk6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiZ3JheVwiXSB9XG4gIH07XG4gIGpyID0gdDtcbiAgZm9yIChjb25zdCBhIG9mIE9iamVjdC5rZXlzKHQpKSB7XG4gICAgaWYgKCEoXCJjaGFubmVsc1wiIGluIHRbYV0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogXCIgKyBhKTtcbiAgICBpZiAoIShcImxhYmVsc1wiIGluIHRbYV0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogXCIgKyBhKTtcbiAgICBpZiAodFthXS5sYWJlbHMubGVuZ3RoICE9PSB0W2FdLmNoYW5uZWxzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiBcIiArIGEpO1xuICAgIGNvbnN0IHsgY2hhbm5lbHM6IG8sIGxhYmVsczogaSB9ID0gdFthXTtcbiAgICBkZWxldGUgdFthXS5jaGFubmVscywgZGVsZXRlIHRbYV0ubGFiZWxzLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodFthXSwgXCJjaGFubmVsc1wiLCB7IHZhbHVlOiBvIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodFthXSwgXCJsYWJlbHNcIiwgeyB2YWx1ZTogaSB9KTtcbiAgfVxuICB0LnJnYi5oc2wgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAyNTUsIGkgPSBhWzFdIC8gMjU1LCBzID0gYVsyXSAvIDI1NSwgbCA9IE1hdGgubWluKG8sIGksIHMpLCB1ID0gTWF0aC5tYXgobywgaSwgcyksIGMgPSB1IC0gbDtcbiAgICBsZXQgcCwgZDtcbiAgICB1ID09PSBsID8gcCA9IDAgOiBvID09PSB1ID8gcCA9IChpIC0gcykgLyBjIDogaSA9PT0gdSA/IHAgPSAyICsgKHMgLSBvKSAvIGMgOiBzID09PSB1ICYmIChwID0gNCArIChvIC0gaSkgLyBjKSwgcCA9IE1hdGgubWluKHAgKiA2MCwgMzYwKSwgcCA8IDAgJiYgKHAgKz0gMzYwKTtcbiAgICBjb25zdCBmID0gKGwgKyB1KSAvIDI7XG4gICAgcmV0dXJuIHUgPT09IGwgPyBkID0gMCA6IGYgPD0gMC41ID8gZCA9IGMgLyAodSArIGwpIDogZCA9IGMgLyAoMiAtIHUgLSBsKSwgW3AsIGQgKiAxMDAsIGYgKiAxMDBdO1xuICB9LCB0LnJnYi5oc3YgPSBmdW5jdGlvbihhKSB7XG4gICAgbGV0IG8sIGksIHMsIGwsIHU7XG4gICAgY29uc3QgYyA9IGFbMF0gLyAyNTUsIHAgPSBhWzFdIC8gMjU1LCBkID0gYVsyXSAvIDI1NSwgZiA9IE1hdGgubWF4KGMsIHAsIGQpLCBoID0gZiAtIE1hdGgubWluKGMsIHAsIGQpLCBtID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIChmIC0geSkgLyA2IC8gaCArIDEgLyAyO1xuICAgIH07XG4gICAgcmV0dXJuIGggPT09IDAgPyAobCA9IDAsIHUgPSAwKSA6ICh1ID0gaCAvIGYsIG8gPSBtKGMpLCBpID0gbShwKSwgcyA9IG0oZCksIGMgPT09IGYgPyBsID0gcyAtIGkgOiBwID09PSBmID8gbCA9IDEgLyAzICsgbyAtIHMgOiBkID09PSBmICYmIChsID0gMiAvIDMgKyBpIC0gbyksIGwgPCAwID8gbCArPSAxIDogbCA+IDEgJiYgKGwgLT0gMSkpLCBbXG4gICAgICBsICogMzYwLFxuICAgICAgdSAqIDEwMCxcbiAgICAgIGYgKiAxMDBcbiAgICBdO1xuICB9LCB0LnJnYi5od2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhWzFdO1xuICAgIGxldCBzID0gYVsyXTtcbiAgICBjb25zdCBsID0gdC5yZ2IuaHNsKGEpWzBdLCB1ID0gMSAvIDI1NSAqIE1hdGgubWluKG8sIE1hdGgubWluKGksIHMpKTtcbiAgICByZXR1cm4gcyA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgobywgTWF0aC5tYXgoaSwgcykpLCBbbCwgdSAqIDEwMCwgcyAqIDEwMF07XG4gIH0sIHQucmdiLmNteWsgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAyNTUsIGkgPSBhWzFdIC8gMjU1LCBzID0gYVsyXSAvIDI1NSwgbCA9IE1hdGgubWluKDEgLSBvLCAxIC0gaSwgMSAtIHMpLCB1ID0gKDEgLSBvIC0gbCkgLyAoMSAtIGwpIHx8IDAsIGMgPSAoMSAtIGkgLSBsKSAvICgxIC0gbCkgfHwgMCwgcCA9ICgxIC0gcyAtIGwpIC8gKDEgLSBsKSB8fCAwO1xuICAgIHJldHVybiBbdSAqIDEwMCwgYyAqIDEwMCwgcCAqIDEwMCwgbCAqIDEwMF07XG4gIH07XG4gIGZ1bmN0aW9uIG4oYSwgbykge1xuICAgIHJldHVybiAoYVswXSAtIG9bMF0pICoqIDIgKyAoYVsxXSAtIG9bMV0pICoqIDIgKyAoYVsyXSAtIG9bMl0pICoqIDI7XG4gIH1cbiAgcmV0dXJuIHQucmdiLmtleXdvcmQgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGVbYV07XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4gbztcbiAgICBsZXQgaSA9IDEgLyAwLCBzO1xuICAgIGZvciAoY29uc3QgbCBvZiBPYmplY3Qua2V5cyhyKSkge1xuICAgICAgY29uc3QgdSA9IHJbbF0sIGMgPSBuKGEsIHUpO1xuICAgICAgYyA8IGkgJiYgKGkgPSBjLCBzID0gbCk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LCB0LmtleXdvcmQucmdiID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiByW2FdO1xuICB9LCB0LnJnYi54eXogPSBmdW5jdGlvbihhKSB7XG4gICAgbGV0IG8gPSBhWzBdIC8gMjU1LCBpID0gYVsxXSAvIDI1NSwgcyA9IGFbMl0gLyAyNTU7XG4gICAgbyA9IG8gPiAwLjA0MDQ1ID8gKChvICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IG8gLyAxMi45MiwgaSA9IGkgPiAwLjA0MDQ1ID8gKChpICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IGkgLyAxMi45MiwgcyA9IHMgPiAwLjA0MDQ1ID8gKChzICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IHMgLyAxMi45MjtcbiAgICBjb25zdCBsID0gbyAqIDAuNDEyNCArIGkgKiAwLjM1NzYgKyBzICogMC4xODA1LCB1ID0gbyAqIDAuMjEyNiArIGkgKiAwLjcxNTIgKyBzICogMC4wNzIyLCBjID0gbyAqIDAuMDE5MyArIGkgKiAwLjExOTIgKyBzICogMC45NTA1O1xuICAgIHJldHVybiBbbCAqIDEwMCwgdSAqIDEwMCwgYyAqIDEwMF07XG4gIH0sIHQucmdiLmxhYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gdC5yZ2IueHl6KGEpO1xuICAgIGxldCBpID0gb1swXSwgcyA9IG9bMV0sIGwgPSBvWzJdO1xuICAgIGkgLz0gOTUuMDQ3LCBzIC89IDEwMCwgbCAvPSAxMDguODgzLCBpID0gaSA+IDg4NTZlLTYgPyBpICoqICgxIC8gMykgOiA3Ljc4NyAqIGkgKyAxNiAvIDExNiwgcyA9IHMgPiA4ODU2ZS02ID8gcyAqKiAoMSAvIDMpIDogNy43ODcgKiBzICsgMTYgLyAxMTYsIGwgPSBsID4gODg1NmUtNiA/IGwgKiogKDEgLyAzKSA6IDcuNzg3ICogbCArIDE2IC8gMTE2O1xuICAgIGNvbnN0IHUgPSAxMTYgKiBzIC0gMTYsIGMgPSA1MDAgKiAoaSAtIHMpLCBwID0gMjAwICogKHMgLSBsKTtcbiAgICByZXR1cm4gW3UsIGMsIHBdO1xuICB9LCB0LmhzbC5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAzNjAsIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBsZXQgbCwgdSwgYztcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIHJldHVybiBjID0gcyAqIDI1NSwgW2MsIGMsIGNdO1xuICAgIHMgPCAwLjUgPyBsID0gcyAqICgxICsgaSkgOiBsID0gcyArIGkgLSBzICogaTtcbiAgICBjb25zdCBwID0gMiAqIHMgLSBsLCBkID0gWzAsIDAsIDBdO1xuICAgIGZvciAobGV0IGYgPSAwOyBmIDwgMzsgZisrKVxuICAgICAgdSA9IG8gKyAxIC8gMyAqIC0oZiAtIDEpLCB1IDwgMCAmJiB1KyssIHUgPiAxICYmIHUtLSwgNiAqIHUgPCAxID8gYyA9IHAgKyAobCAtIHApICogNiAqIHUgOiAyICogdSA8IDEgPyBjID0gbCA6IDMgKiB1IDwgMiA/IGMgPSBwICsgKGwgLSBwKSAqICgyIC8gMyAtIHUpICogNiA6IGMgPSBwLCBkW2ZdID0gYyAqIDI1NTtcbiAgICByZXR1cm4gZDtcbiAgfSwgdC5oc2wuaHN2ID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdO1xuICAgIGxldCBpID0gYVsxXSAvIDEwMCwgcyA9IGFbMl0gLyAxMDAsIGwgPSBpO1xuICAgIGNvbnN0IHUgPSBNYXRoLm1heChzLCAwLjAxKTtcbiAgICBzICo9IDIsIGkgKj0gcyA8PSAxID8gcyA6IDIgLSBzLCBsICo9IHUgPD0gMSA/IHUgOiAyIC0gdTtcbiAgICBjb25zdCBjID0gKHMgKyBpKSAvIDIsIHAgPSBzID09PSAwID8gMiAqIGwgLyAodSArIGwpIDogMiAqIGkgLyAocyArIGkpO1xuICAgIHJldHVybiBbbywgcCAqIDEwMCwgYyAqIDEwMF07XG4gIH0sIHQuaHN2LnJnYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVswXSAvIDYwLCBpID0gYVsxXSAvIDEwMDtcbiAgICBsZXQgcyA9IGFbMl0gLyAxMDA7XG4gICAgY29uc3QgbCA9IE1hdGguZmxvb3IobykgJSA2LCB1ID0gbyAtIE1hdGguZmxvb3IobyksIGMgPSAyNTUgKiBzICogKDEgLSBpKSwgcCA9IDI1NSAqIHMgKiAoMSAtIGkgKiB1KSwgZCA9IDI1NSAqIHMgKiAoMSAtIGkgKiAoMSAtIHUpKTtcbiAgICBzd2l0Y2ggKHMgKj0gMjU1LCBsKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbcywgZCwgY107XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbcCwgcywgY107XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbYywgcywgZF07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbYywgcCwgc107XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbZCwgYywgc107XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBbcywgYywgcF07XG4gICAgfVxuICB9LCB0Lmhzdi5oc2wgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMCwgbCA9IE1hdGgubWF4KHMsIDAuMDEpO1xuICAgIGxldCB1LCBjO1xuICAgIGMgPSAoMiAtIGkpICogcztcbiAgICBjb25zdCBwID0gKDIgLSBpKSAqIGw7XG4gICAgcmV0dXJuIHUgPSBpICogbCwgdSAvPSBwIDw9IDEgPyBwIDogMiAtIHAsIHUgPSB1IHx8IDAsIGMgLz0gMiwgW28sIHUgKiAxMDAsIGMgKiAxMDBdO1xuICB9LCB0Lmh3Yi5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAzNjA7XG4gICAgbGV0IGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBjb25zdCBsID0gaSArIHM7XG4gICAgbGV0IHU7XG4gICAgbCA+IDEgJiYgKGkgLz0gbCwgcyAvPSBsKTtcbiAgICBjb25zdCBjID0gTWF0aC5mbG9vcig2ICogbyksIHAgPSAxIC0gcztcbiAgICB1ID0gNiAqIG8gLSBjLCBjICYgMSAmJiAodSA9IDEgLSB1KTtcbiAgICBjb25zdCBkID0gaSArIHUgKiAocCAtIGkpO1xuICAgIGxldCBmLCBoLCBtO1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZiA9IHAsIGggPSBkLCBtID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGYgPSBkLCBoID0gcCwgbSA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBmID0gaSwgaCA9IHAsIG0gPSBkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZiA9IGksIGggPSBkLCBtID0gcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGYgPSBkLCBoID0gaSwgbSA9IHA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBmID0gcCwgaCA9IGksIG0gPSBkO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFtmICogMjU1LCBoICogMjU1LCBtICogMjU1XTtcbiAgfSwgdC5jbXlrLnJnYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVswXSAvIDEwMCwgaSA9IGFbMV0gLyAxMDAsIHMgPSBhWzJdIC8gMTAwLCBsID0gYVszXSAvIDEwMCwgdSA9IDEgLSBNYXRoLm1pbigxLCBvICogKDEgLSBsKSArIGwpLCBjID0gMSAtIE1hdGgubWluKDEsIGkgKiAoMSAtIGwpICsgbCksIHAgPSAxIC0gTWF0aC5taW4oMSwgcyAqICgxIC0gbCkgKyBsKTtcbiAgICByZXR1cm4gW3UgKiAyNTUsIGMgKiAyNTUsIHAgKiAyNTVdO1xuICB9LCB0Lnh5ei5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAxMDAsIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBsZXQgbCwgdSwgYztcbiAgICByZXR1cm4gbCA9IG8gKiAzLjI0MDYgKyBpICogLTEuNTM3MiArIHMgKiAtMC40OTg2LCB1ID0gbyAqIC0wLjk2ODkgKyBpICogMS44NzU4ICsgcyAqIDAuMDQxNSwgYyA9IG8gKiAwLjA1NTcgKyBpICogLTAuMjA0ICsgcyAqIDEuMDU3LCBsID0gbCA+IDMxMzA4ZS03ID8gMS4wNTUgKiBsICoqICgxIC8gMi40KSAtIDAuMDU1IDogbCAqIDEyLjkyLCB1ID0gdSA+IDMxMzA4ZS03ID8gMS4wNTUgKiB1ICoqICgxIC8gMi40KSAtIDAuMDU1IDogdSAqIDEyLjkyLCBjID0gYyA+IDMxMzA4ZS03ID8gMS4wNTUgKiBjICoqICgxIC8gMi40KSAtIDAuMDU1IDogYyAqIDEyLjkyLCBsID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbCksIDEpLCB1ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdSksIDEpLCBjID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYyksIDEpLCBbbCAqIDI1NSwgdSAqIDI1NSwgYyAqIDI1NV07XG4gIH0sIHQueHl6LmxhYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBsZXQgbyA9IGFbMF0sIGkgPSBhWzFdLCBzID0gYVsyXTtcbiAgICBvIC89IDk1LjA0NywgaSAvPSAxMDAsIHMgLz0gMTA4Ljg4MywgbyA9IG8gPiA4ODU2ZS02ID8gbyAqKiAoMSAvIDMpIDogNy43ODcgKiBvICsgMTYgLyAxMTYsIGkgPSBpID4gODg1NmUtNiA/IGkgKiogKDEgLyAzKSA6IDcuNzg3ICogaSArIDE2IC8gMTE2LCBzID0gcyA+IDg4NTZlLTYgPyBzICoqICgxIC8gMykgOiA3Ljc4NyAqIHMgKyAxNiAvIDExNjtcbiAgICBjb25zdCBsID0gMTE2ICogaSAtIDE2LCB1ID0gNTAwICogKG8gLSBpKSwgYyA9IDIwMCAqIChpIC0gcyk7XG4gICAgcmV0dXJuIFtsLCB1LCBjXTtcbiAgfSwgdC5sYWIueHl6ID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdLCBpID0gYVsxXSwgcyA9IGFbMl07XG4gICAgbGV0IGwsIHUsIGM7XG4gICAgdSA9IChvICsgMTYpIC8gMTE2LCBsID0gaSAvIDUwMCArIHUsIGMgPSB1IC0gcyAvIDIwMDtcbiAgICBjb25zdCBwID0gdSAqKiAzLCBkID0gbCAqKiAzLCBmID0gYyAqKiAzO1xuICAgIHJldHVybiB1ID0gcCA+IDg4NTZlLTYgPyBwIDogKHUgLSAxNiAvIDExNikgLyA3Ljc4NywgbCA9IGQgPiA4ODU2ZS02ID8gZCA6IChsIC0gMTYgLyAxMTYpIC8gNy43ODcsIGMgPSBmID4gODg1NmUtNiA/IGYgOiAoYyAtIDE2IC8gMTE2KSAvIDcuNzg3LCBsICo9IDk1LjA0NywgdSAqPSAxMDAsIGMgKj0gMTA4Ljg4MywgW2wsIHUsIGNdO1xuICB9LCB0LmxhYi5sY2ggPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhWzFdLCBzID0gYVsyXTtcbiAgICBsZXQgbDtcbiAgICBsID0gTWF0aC5hdGFuMihzLCBpKSAqIDM2MCAvIDIgLyBNYXRoLlBJLCBsIDwgMCAmJiAobCArPSAzNjApO1xuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoaSAqIGkgKyBzICogcyk7XG4gICAgcmV0dXJuIFtvLCBjLCBsXTtcbiAgfSwgdC5sY2gubGFiID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdLCBpID0gYVsxXSwgbCA9IGFbMl0gLyAzNjAgKiAyICogTWF0aC5QSSwgdSA9IGkgKiBNYXRoLmNvcyhsKSwgYyA9IGkgKiBNYXRoLnNpbihsKTtcbiAgICByZXR1cm4gW28sIHUsIGNdO1xuICB9LCB0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbihhLCBvID0gbnVsbCkge1xuICAgIGNvbnN0IFtpLCBzLCBsXSA9IGE7XG4gICAgbGV0IHUgPSBvID09PSBudWxsID8gdC5yZ2IuaHN2KGEpWzJdIDogbztcbiAgICBpZiAodSA9IE1hdGgucm91bmQodSAvIDUwKSwgdSA9PT0gMClcbiAgICAgIHJldHVybiAzMDtcbiAgICBsZXQgYyA9IDMwICsgKE1hdGgucm91bmQobCAvIDI1NSkgPDwgMiB8IE1hdGgucm91bmQocyAvIDI1NSkgPDwgMSB8IE1hdGgucm91bmQoaSAvIDI1NSkpO1xuICAgIHJldHVybiB1ID09PSAyICYmIChjICs9IDYwKSwgYztcbiAgfSwgdC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0LnJnYi5hbnNpMTYodC5oc3YucmdiKGEpLCBhWzJdKTtcbiAgfSwgdC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVswXSwgaSA9IGFbMV0sIHMgPSBhWzJdO1xuICAgIHJldHVybiBvID09PSBpICYmIGkgPT09IHMgPyBvIDwgOCA/IDE2IDogbyA+IDI0OCA/IDIzMSA6IE1hdGgucm91bmQoKG8gLSA4KSAvIDI0NyAqIDI0KSArIDIzMiA6IDE2ICsgMzYgKiBNYXRoLnJvdW5kKG8gLyAyNTUgKiA1KSArIDYgKiBNYXRoLnJvdW5kKGkgLyAyNTUgKiA1KSArIE1hdGgucm91bmQocyAvIDI1NSAqIDUpO1xuICB9LCB0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgbGV0IG8gPSBhICUgMTA7XG4gICAgaWYgKG8gPT09IDAgfHwgbyA9PT0gNylcbiAgICAgIHJldHVybiBhID4gNTAgJiYgKG8gKz0gMy41KSwgbyA9IG8gLyAxMC41ICogMjU1LCBbbywgbywgb107XG4gICAgY29uc3QgaSA9ICh+fihhID4gNTApICsgMSkgKiAwLjUsIHMgPSAobyAmIDEpICogaSAqIDI1NSwgbCA9IChvID4+IDEgJiAxKSAqIGkgKiAyNTUsIHUgPSAobyA+PiAyICYgMSkgKiBpICogMjU1O1xuICAgIHJldHVybiBbcywgbCwgdV07XG4gIH0sIHQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgaWYgKGEgPj0gMjMyKSB7XG4gICAgICBjb25zdCB1ID0gKGEgLSAyMzIpICogMTAgKyA4O1xuICAgICAgcmV0dXJuIFt1LCB1LCB1XTtcbiAgICB9XG4gICAgYSAtPSAxNjtcbiAgICBsZXQgbztcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihhIC8gMzYpIC8gNSAqIDI1NSwgcyA9IE1hdGguZmxvb3IoKG8gPSBhICUgMzYpIC8gNikgLyA1ICogMjU1LCBsID0gbyAlIDYgLyA1ICogMjU1O1xuICAgIHJldHVybiBbaSwgcywgbF07XG4gIH0sIHQucmdiLmhleCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBpID0gKCgoTWF0aC5yb3VuZChhWzBdKSAmIDI1NSkgPDwgMTYpICsgKChNYXRoLnJvdW5kKGFbMV0pICYgMjU1KSA8PCA4KSArIChNYXRoLnJvdW5kKGFbMl0pICYgMjU1KSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIFwiMDAwMDAwXCIuc3Vic3RyaW5nKGkubGVuZ3RoKSArIGk7XG4gIH0sIHQuaGV4LnJnYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYS50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgbGV0IGkgPSBvWzBdO1xuICAgIG9bMF0ubGVuZ3RoID09PSAzICYmIChpID0gaS5zcGxpdChcIlwiKS5tYXAoKHApID0+IHAgKyBwKS5qb2luKFwiXCIpKTtcbiAgICBjb25zdCBzID0gcGFyc2VJbnQoaSwgMTYpLCBsID0gcyA+PiAxNiAmIDI1NSwgdSA9IHMgPj4gOCAmIDI1NSwgYyA9IHMgJiAyNTU7XG4gICAgcmV0dXJuIFtsLCB1LCBjXTtcbiAgfSwgdC5yZ2IuaGNnID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdIC8gMjU1LCBpID0gYVsxXSAvIDI1NSwgcyA9IGFbMl0gLyAyNTUsIGwgPSBNYXRoLm1heChNYXRoLm1heChvLCBpKSwgcyksIHUgPSBNYXRoLm1pbihNYXRoLm1pbihvLCBpKSwgcyksIGMgPSBsIC0gdTtcbiAgICBsZXQgcCwgZDtcbiAgICByZXR1cm4gYyA8IDEgPyBwID0gdSAvICgxIC0gYykgOiBwID0gMCwgYyA8PSAwID8gZCA9IDAgOiBsID09PSBvID8gZCA9IChpIC0gcykgLyBjICUgNiA6IGwgPT09IGkgPyBkID0gMiArIChzIC0gbykgLyBjIDogZCA9IDQgKyAobyAtIGkpIC8gYywgZCAvPSA2LCBkICU9IDEsIFtkICogMzYwLCBjICogMTAwLCBwICogMTAwXTtcbiAgfSwgdC5oc2wuaGNnID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzFdIC8gMTAwLCBpID0gYVsyXSAvIDEwMCwgcyA9IGkgPCAwLjUgPyAyICogbyAqIGkgOiAyICogbyAqICgxIC0gaSk7XG4gICAgbGV0IGwgPSAwO1xuICAgIHJldHVybiBzIDwgMSAmJiAobCA9IChpIC0gMC41ICogcykgLyAoMSAtIHMpKSwgW2FbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xuICB9LCB0Lmhzdi5oY2cgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMV0gLyAxMDAsIGkgPSBhWzJdIC8gMTAwLCBzID0gbyAqIGk7XG4gICAgbGV0IGwgPSAwO1xuICAgIHJldHVybiBzIDwgMSAmJiAobCA9IChpIC0gcykgLyAoMSAtIHMpKSwgW2FbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xuICB9LCB0LmhjZy5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAzNjAsIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIHJldHVybiBbcyAqIDI1NSwgcyAqIDI1NSwgcyAqIDI1NV07XG4gICAgY29uc3QgbCA9IFswLCAwLCAwXSwgdSA9IG8gJSAxICogNiwgYyA9IHUgJSAxLCBwID0gMSAtIGM7XG4gICAgbGV0IGQgPSAwO1xuICAgIHN3aXRjaCAoTWF0aC5mbG9vcih1KSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBsWzBdID0gMSwgbFsxXSA9IGMsIGxbMl0gPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbFswXSA9IHAsIGxbMV0gPSAxLCBsWzJdID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGxbMF0gPSAwLCBsWzFdID0gMSwgbFsyXSA9IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBsWzBdID0gMCwgbFsxXSA9IHAsIGxbMl0gPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgbFswXSA9IGMsIGxbMV0gPSAwLCBsWzJdID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsWzBdID0gMSwgbFsxXSA9IDAsIGxbMl0gPSBwO1xuICAgIH1cbiAgICByZXR1cm4gZCA9ICgxIC0gaSkgKiBzLCBbXG4gICAgICAoaSAqIGxbMF0gKyBkKSAqIDI1NSxcbiAgICAgIChpICogbFsxXSArIGQpICogMjU1LFxuICAgICAgKGkgKiBsWzJdICsgZCkgKiAyNTVcbiAgICBdO1xuICB9LCB0LmhjZy5oc3YgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMV0gLyAxMDAsIGkgPSBhWzJdIC8gMTAwLCBzID0gbyArIGkgKiAoMSAtIG8pO1xuICAgIGxldCBsID0gMDtcbiAgICByZXR1cm4gcyA+IDAgJiYgKGwgPSBvIC8gcyksIFthWzBdLCBsICogMTAwLCBzICogMTAwXTtcbiAgfSwgdC5oY2cuaHNsID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMCAqICgxIC0gbykgKyAwLjUgKiBvO1xuICAgIGxldCBsID0gMDtcbiAgICByZXR1cm4gcyA+IDAgJiYgcyA8IDAuNSA/IGwgPSBvIC8gKDIgKiBzKSA6IHMgPj0gMC41ICYmIHMgPCAxICYmIChsID0gbyAvICgyICogKDEgLSBzKSkpLCBbYVswXSwgbCAqIDEwMCwgcyAqIDEwMF07XG4gIH0sIHQuaGNnLmh3YiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVsxXSAvIDEwMCwgaSA9IGFbMl0gLyAxMDAsIHMgPSBvICsgaSAqICgxIC0gbyk7XG4gICAgcmV0dXJuIFthWzBdLCAocyAtIG8pICogMTAwLCAoMSAtIHMpICogMTAwXTtcbiAgfSwgdC5od2IuaGNnID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzFdIC8gMTAwLCBzID0gMSAtIGFbMl0gLyAxMDAsIGwgPSBzIC0gbztcbiAgICBsZXQgdSA9IDA7XG4gICAgcmV0dXJuIGwgPCAxICYmICh1ID0gKHMgLSBsKSAvICgxIC0gbCkpLCBbYVswXSwgbCAqIDEwMCwgdSAqIDEwMF07XG4gIH0sIHQuYXBwbGUucmdiID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbYVswXSAvIDY1NTM1ICogMjU1LCBhWzFdIC8gNjU1MzUgKiAyNTUsIGFbMl0gLyA2NTUzNSAqIDI1NV07XG4gIH0sIHQucmdiLmFwcGxlID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbYVswXSAvIDI1NSAqIDY1NTM1LCBhWzFdIC8gMjU1ICogNjU1MzUsIGFbMl0gLyAyNTUgKiA2NTUzNV07XG4gIH0sIHQuZ3JheS5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIFthWzBdIC8gMTAwICogMjU1LCBhWzBdIC8gMTAwICogMjU1LCBhWzBdIC8gMTAwICogMjU1XTtcbiAgfSwgdC5ncmF5LmhzbCA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gWzAsIDAsIGFbMF1dO1xuICB9LCB0LmdyYXkuaHN2ID0gdC5ncmF5LmhzbCwgdC5ncmF5Lmh3YiA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gWzAsIDEwMCwgYVswXV07XG4gIH0sIHQuZ3JheS5jbXlrID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgYVswXV07XG4gIH0sIHQuZ3JheS5sYWIgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIFthWzBdLCAwLCAwXTtcbiAgfSwgdC5ncmF5LmhleCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gTWF0aC5yb3VuZChhWzBdIC8gMTAwICogMjU1KSAmIDI1NSwgcyA9ICgobyA8PCAxNikgKyAobyA8PCA4KSArIG8pLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBcIjAwMDAwMFwiLnN1YnN0cmluZyhzLmxlbmd0aCkgKyBzO1xuICB9LCB0LnJnYi5ncmF5ID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbKGFbMF0gKyBhWzFdICsgYVsyXSkgLyAzIC8gMjU1ICogMTAwXTtcbiAgfSwganI7XG59XG52YXIgRHIsIE1hO1xuZnVuY3Rpb24gTXUoKSB7XG4gIGlmIChNYSkgcmV0dXJuIERyO1xuICBNYSA9IDE7XG4gIGNvbnN0IHIgPSBxbygpO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIGNvbnN0IG8gPSB7fSwgaSA9IE9iamVjdC5rZXlzKHIpO1xuICAgIGZvciAobGV0IHMgPSBpLmxlbmd0aCwgbCA9IDA7IGwgPCBzOyBsKyspXG4gICAgICBvW2lbbF1dID0ge1xuICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG4gICAgICAgIC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuICAgICAgICBkaXN0YW5jZTogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgfTtcbiAgICByZXR1cm4gbztcbiAgfVxuICBmdW5jdGlvbiB0KG8pIHtcbiAgICBjb25zdCBpID0gZSgpLCBzID0gW29dO1xuICAgIGZvciAoaVtvXS5kaXN0YW5jZSA9IDA7IHMubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGwgPSBzLnBvcCgpLCB1ID0gT2JqZWN0LmtleXMocltsXSk7XG4gICAgICBmb3IgKGxldCBjID0gdS5sZW5ndGgsIHAgPSAwOyBwIDwgYzsgcCsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSB1W3BdLCBmID0gaVtkXTtcbiAgICAgICAgZi5kaXN0YW5jZSA9PT0gLTEgJiYgKGYuZGlzdGFuY2UgPSBpW2xdLmRpc3RhbmNlICsgMSwgZi5wYXJlbnQgPSBsLCBzLnVuc2hpZnQoZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICBmdW5jdGlvbiBuKG8sIGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIGkobyhzKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhKG8sIGkpIHtcbiAgICBjb25zdCBzID0gW2lbb10ucGFyZW50LCBvXTtcbiAgICBsZXQgbCA9IHJbaVtvXS5wYXJlbnRdW29dLCB1ID0gaVtvXS5wYXJlbnQ7XG4gICAgZm9yICg7IGlbdV0ucGFyZW50OyApXG4gICAgICBzLnVuc2hpZnQoaVt1XS5wYXJlbnQpLCBsID0gbihyW2lbdV0ucGFyZW50XVt1XSwgbCksIHUgPSBpW3VdLnBhcmVudDtcbiAgICByZXR1cm4gbC5jb252ZXJzaW9uID0gcywgbDtcbiAgfVxuICByZXR1cm4gRHIgPSBmdW5jdGlvbihvKSB7XG4gICAgY29uc3QgaSA9IHQobyksIHMgPSB7fSwgbCA9IE9iamVjdC5rZXlzKGkpO1xuICAgIGZvciAobGV0IHUgPSBsLmxlbmd0aCwgYyA9IDA7IGMgPCB1OyBjKyspIHtcbiAgICAgIGNvbnN0IHAgPSBsW2NdO1xuICAgICAgaVtwXS5wYXJlbnQgIT09IG51bGwgJiYgKHNbcF0gPSBhKHAsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH0sIERyO1xufVxudmFyIFVyLCBQYTtcbmZ1bmN0aW9uIFB1KCkge1xuICBpZiAoUGEpIHJldHVybiBVcjtcbiAgUGEgPSAxO1xuICBjb25zdCByID0gcW8oKSwgZSA9IE11KCksIHQgPSB7fSwgbiA9IE9iamVjdC5rZXlzKHIpO1xuICBmdW5jdGlvbiBhKGkpIHtcbiAgICBjb25zdCBzID0gZnVuY3Rpb24oLi4ubCkge1xuICAgICAgY29uc3QgdSA9IGxbMF07XG4gICAgICByZXR1cm4gdSA9PSBudWxsID8gdSA6ICh1Lmxlbmd0aCA+IDEgJiYgKGwgPSB1KSwgaShsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gXCJjb252ZXJzaW9uXCIgaW4gaSAmJiAocy5jb252ZXJzaW9uID0gaS5jb252ZXJzaW9uKSwgcztcbiAgfVxuICBmdW5jdGlvbiBvKGkpIHtcbiAgICBjb25zdCBzID0gZnVuY3Rpb24oLi4ubCkge1xuICAgICAgY29uc3QgdSA9IGxbMF07XG4gICAgICBpZiAodSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gdTtcbiAgICAgIHUubGVuZ3RoID4gMSAmJiAobCA9IHUpO1xuICAgICAgY29uc3QgYyA9IGkobCk7XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgZm9yIChsZXQgcCA9IGMubGVuZ3RoLCBkID0gMDsgZCA8IHA7IGQrKylcbiAgICAgICAgICBjW2RdID0gTWF0aC5yb3VuZChjW2RdKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gICAgcmV0dXJuIFwiY29udmVyc2lvblwiIGluIGkgJiYgKHMuY29udmVyc2lvbiA9IGkuY29udmVyc2lvbiksIHM7XG4gIH1cbiAgcmV0dXJuIG4uZm9yRWFjaCgoaSkgPT4ge1xuICAgIHRbaV0gPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRbaV0sIFwiY2hhbm5lbHNcIiwgeyB2YWx1ZTogcltpXS5jaGFubmVscyB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRbaV0sIFwibGFiZWxzXCIsIHsgdmFsdWU6IHJbaV0ubGFiZWxzIH0pO1xuICAgIGNvbnN0IHMgPSBlKGkpO1xuICAgIE9iamVjdC5rZXlzKHMpLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBzW3VdO1xuICAgICAgdFtpXVt1XSA9IG8oYyksIHRbaV1bdV0ucmF3ID0gYShjKTtcbiAgICB9KTtcbiAgfSksIFVyID0gdCwgVXI7XG59XG52YXIgUnUgPSBQdSgpO1xuY29uc3QgenUgPSAvKiBAX19QVVJFX18gKi8gX3UoUnUpO1xuZnVuY3Rpb24gUmEoeyBnbDogciwgdHlwZTogZSwgc291cmNlOiB0IH0pIHtcbiAgY29uc3QgbiA9IHIuY3JlYXRlU2hhZGVyKGUpO1xuICBpZiAobiA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIHNoYWRlclwiKTtcbiAgaWYgKHIuc2hhZGVyU291cmNlKG4sIHQpLCByLmNvbXBpbGVTaGFkZXIobiksICFyLmdldFNoYWRlclBhcmFtZXRlcihuLCByLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB0aHJvdyBjb25zb2xlLmVycm9yKFwiU2hhZGVyIGNvbXBpbGF0aW9uIGVycm9yOlwiLCByLmdldFNoYWRlckluZm9Mb2cobikpLCByLmRlbGV0ZVNoYWRlcihuKSwgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXBpbGUgc2hhZGVyXCIpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIE91KHsgZ2w6IHIsIHZlcnRleFNoYWRlclNvdXJjZTogZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHQgfSkge1xuICBjb25zdCBuID0gUmEoe1xuICAgIGdsOiByLFxuICAgIHR5cGU6IHIuVkVSVEVYX1NIQURFUixcbiAgICBzb3VyY2U6IGVcbiAgfSksIGEgPSBSYSh7IGdsOiByLCB0eXBlOiByLkZSQUdNRU5UX1NIQURFUiwgc291cmNlOiB0IH0pLCBvID0gci5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmIChyLmF0dGFjaFNoYWRlcihvLCBuKSwgci5hdHRhY2hTaGFkZXIobywgYSksIHIubGlua1Byb2dyYW0obyksICFyLmdldFByb2dyYW1QYXJhbWV0ZXIobywgci5MSU5LX1NUQVRVUykpXG4gICAgdGhyb3cgY29uc29sZS5lcnJvcihcIkVycm9yOiBcIiwgci5nZXRQcm9ncmFtSW5mb0xvZyhvKSksIG5ldyBFcnJvcihcIkNhbm5vdCBsaW5rIHNoYWRlciBwcm9ncmFtXCIpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uICR1KHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHIuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsIHQpO1xuICBpZiAobiA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgdW5pZm9ybSBsb2NhdGlvbiBmb3IgJHt0fWApO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFZvKHtcbiAgZ2w6IHIsXG4gIHZlcnRleFNoYWRlclNvdXJjZTogZSxcbiAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHQsXG4gIGF0dHJpYnV0ZXNLZXlzOiBuLFxuICB1bmlmb3Jtc0tleXM6IGEsXG4gIHZlcnRpY2VzOiBvLFxuICBpbmRpY2VzOiBpXG59KSB7XG4gIGNvbnN0IHMgPSBPdSh7IGdsOiByLCB2ZXJ0ZXhTaGFkZXJTb3VyY2U6IGUsIGZyYWdtZW50U2hhZGVyU291cmNlOiB0IH0pLCBsID0gbi5yZWR1Y2UoKGYsIGgpID0+IChmW2hdID0gci5nZXRBdHRyaWJMb2NhdGlvbihzLCBgYV8ke2h9YCksIGYpLCB7fSksIHUgPSBhLnJlZHVjZSgoZiwgaCkgPT4gKGZbaF0gPSAkdShyLCBzLCBgdV8ke2h9YCksIGYpLCB7fSksIGMgPSByLmNyZWF0ZUJ1ZmZlcigpO1xuICByLmJpbmRCdWZmZXIoci5BUlJBWV9CVUZGRVIsIGMpLCByLmJ1ZmZlckRhdGEoci5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkobyksIHIuU1RBVElDX0RSQVcpO1xuICBsZXQgcCwgZDtcbiAgcmV0dXJuIGkgIT09IHZvaWQgMCAmJiAocCA9IHIuY3JlYXRlQnVmZmVyKCksIGQgPSBpLmxlbmd0aCwgci5iaW5kQnVmZmVyKHIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHApLCByLmJ1ZmZlckRhdGEoci5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KGkpLCByLlNUQVRJQ19EUkFXKSksIHtcbiAgICBzaGFkZXJQcm9ncmFtOiBzLFxuICAgIHByb2dyYW1JbmZvOiB7XG4gICAgICBhdHRyaWJ1dGVzTG9jYXRpb25zOiBsLFxuICAgICAgdW5pZm9ybXNMb2NhdGlvbnM6IHVcbiAgICB9LFxuICAgIHBvc2l0aW9uQnVmZmVyOiBjLFxuICAgIGluZGV4QnVmZmVyOiBwLFxuICAgIGluZGV4QnVmZmVyTGVuZ3RoOiBkXG4gIH07XG59XG5mdW5jdGlvbiBLdChyKSB7XG4gIGlmICghcilcbiAgICByZXR1cm4gWzEsIDEsIDEsIDBdO1xuICBpZiAociA9PT0gXCJ0cmFuc3BhcmVudFwiKVxuICAgIHJldHVybiBbMSwgMSwgMSwgMF07XG4gIHRyeSB7XG4gICAgY29uc3QgZSA9IEZ1KHIpLCB0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSk/JC9pLmV4ZWMoZSk7XG4gICAgaWYgKHQgIT0gbnVsbCAmJiB0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgYSA9ICEhdFs0XTtcbiAgICAgIHJldHVybiBbLi4uenUuaGV4LnJnYihlKS5tYXAoKG8pID0+IG8gLyAyNTUpLCBhID8gcGFyc2VJbnQodFs0XSwgMTYpIC8gMjU1IDogMV07XG4gICAgfVxuICAgIGNvbnN0IG4gPSBlLm1hdGNoKC8oXFxkXFwuXFxkKFxcZCspP3xcXGR7M318XFxkezJ9fFxcZHsxfSkvZ2kpID8/IFtcIjBcIiwgXCIwXCIsIFwiMFwiXTtcbiAgICBpZiAoZS5pbmNsdWRlcyhcInJnYlwiKSkge1xuICAgICAgY29uc3QgYSA9IGUuaW5jbHVkZXMoXCJyZ2JhXCIpLCBvID0gW1xuICAgICAgICAuLi5uLm1hcCgoaSkgPT4gcGFyc2VGbG9hdChpKSkubWFwKChpLCBzKSA9PiBzIDwgMyA/IGkgLyAyNTUgOiBpKVxuICAgICAgICAvLyBiZWNhdXNlIGFscGhhIGlzIGluIHRoZSByYW5nZSAwIC0gMSwgbm90IDAgLSAyNTVcbiAgICAgIF07XG4gICAgICByZXR1cm4gYSB8fCBvLnB1c2goMSksIG87XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gY29uc29sZS53YXJuKFtgW3BhcnNlQ29sb3JTdHJpbmdUb1ZlYzRdOiBDb2xvciAke3J9IGlzIGVpdGhlciBub3QgYSB2YWxpZCBjb2xvciBvciBpdHMgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLCBkZWZhdWx0aW5nIHRvIGJsYWNrYF0pLCBbMCwgMCwgMCwgMV07XG59XG5sZXQgZnQ7XG5mdW5jdGlvbiBGdShyKSB7XG4gIHJldHVybiBmdCA9IGZ0ID8/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpLCBmdCA/IChmdC5maWxsU3R5bGUgPSByLCBmdC5maWxsU3R5bGUpIDogXCIjMDAwMDAwXCI7XG59XG5jb25zdCBPbiA9IDEsIHVlID0gT24gLyAyLCBjZSA9IE9uIC8gMiwgcGUgPSBPbiAvIDIsIE51ID0gWy0wLjUsIC0wLjUsIHBlLCB1ZSwgLTAuNSwgcGUsIHVlLCBjZSwgcGUsIC0wLjUsIGNlLCBwZV0sIGp1ID0gWy0wLjUsIC0wLjUsIC0wLjUsIC0wLjUsIGNlLCAtMC41LCB1ZSwgY2UsIC0wLjUsIHVlLCAtMC41LCAtMC41XSwgRHUgPSBbLTAuNSwgY2UsIC0wLjUsIC0wLjUsIGNlLCBwZSwgdWUsIGNlLCBwZSwgdWUsIGNlLCAtMC41XSwgVXUgPSBbLTAuNSwgLTAuNSwgLTAuNSwgdWUsIC0wLjUsIC0wLjUsIHVlLCAtMC41LCBwZSwgLTAuNSwgLTAuNSwgcGVdLCBCdSA9IFt1ZSwgLTAuNSwgLTAuNSwgdWUsIGNlLCAtMC41LCB1ZSwgY2UsIHBlLCB1ZSwgLTAuNSwgcGVdLCBxdSA9IFstMC41LCAtMC41LCAtMC41LCAtMC41LCAtMC41LCBwZSwgLTAuNSwgY2UsIHBlLCAtMC41LCBjZSwgLTAuNV0sIFZ1ID0gWy4uLk51LCAuLi5qdSwgLi4uRHUsIC4uLlV1LCAuLi5CdSwgLi4ucXVdLCBHdSA9IFtcbiAgLy8gRnJvbnRcbiAgMCxcbiAgMSxcbiAgMixcbiAgMCxcbiAgMixcbiAgMyxcbiAgLy8gQmFja1xuICA0LFxuICA1LFxuICA2LFxuICA0LFxuICA2LFxuICA3LFxuICAvLyBMZWZ0XG4gIDgsXG4gIDksXG4gIDEwLFxuICA4LFxuICAxMCxcbiAgMTEsXG4gIC8vIFJpZ2h0XG4gIDEyLFxuICAxMyxcbiAgMTQsXG4gIDEyLFxuICAxNCxcbiAgMTUsXG4gIC8vIFVwXG4gIDE2LFxuICAxNyxcbiAgMTgsXG4gIDE2LFxuICAxOCxcbiAgMTksXG4gIC8vIERvd25cbiAgMjAsXG4gIDIxLFxuICAyMixcbiAgMjAsXG4gIDIyLFxuICAyM1xuXSwgSHUgPSBgYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjtcbnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3TWF0cml4O1xuICBcbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZUZXh0dXJlQ29vcmQgPSB2ZWMzKC1hX3ZlcnRleFBvc2l0aW9uLngsIGFfdmVydGV4UG9zaXRpb24ueSwgYV92ZXJ0ZXhQb3NpdGlvbi56KTtcbiAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb25NYXRyaXggKiB1X21vZGVsVmlld01hdHJpeCAqIHZlYzQoYV92ZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcbn1cbmAsIHphID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDtcblxuJVVTRV9URVhUVVJFX01BQ1JPX01BUktFUiVcblxuIyBpZmRlZiBVU0VfVEVYVFVSRVxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1X2N1YmVTYW1wbGVyO1xudW5pZm9ybSBmbG9hdCB1X2ZhZGVPcGFjaXR5O1xuIyBlbmRpZlxuXG51bmlmb3JtIHZlYzQgdV9iZ0NvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICAjaWZkZWYgVVNFX1RFWFRVUkVcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKHVfY3ViZVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gbWl4KFxuICAgICAgdV9iZ0NvbG9yLFxuICAgICAgdGV4Q29sb3IsXG4gICAgICBtaW4odGV4Q29sb3IuYSwgdV9mYWRlT3BhY2l0eSlcbiAgICApO1xuXG4gICAgZ2xfRnJhZ0NvbG9yLmEgPSBtYXgoZ2xfRnJhZ0NvbG9yLmEsIHVfZmFkZU9wYWNpdHkpO1xuXG4gICNlbHNlXG4gIGdsX0ZyYWdDb2xvciA9IHVfYmdDb2xvcjtcbiAgI2VuZGlmXG59XG5gO1xudmFyIFp1ID0gLyogQF9fUFVSRV9fICovICgocikgPT4gKHIuVU5JVkVSU0VfREFSSyA9IFwidW5pdmVyc2UtZGFya1wiLCByKSkoWnUgfHwge30pO1xuY29uc3QgS2UgPSB7XG4gIHN0YXJzOiB7XG4gICAgY29sb3I6IFwiaHNsKDIzMywxMDAlLDkyJSlcIixcbiAgICBwcmVzZXQ6IFwic3RhcnNcIlxuICB9LFxuICBzcGFjZToge1xuICAgIGNvbG9yOiBcImhzbCgyMTAsIDEwMCUsIDQlKVwiLFxuICAgIHByZXNldDogXCJzcGFjZVwiXG4gIH0sXG4gIG1pbGt5d2F5OiB7XG4gICAgY29sb3I6IFwiaHNsKDIzMywxMDAlLDkyJSlcIixcbiAgICBwcmVzZXQ6IFwibWlsa3l3YXlcIlxuICB9LFxuICBcIm1pbGt5d2F5LXN1YnRsZVwiOiB7XG4gICAgY29sb3I6IFwiaHNsKDIzMywxMDAlLDkyJSlcIixcbiAgICBwcmVzZXQ6IFwibWlsa3l3YXktc3VidGxlXCJcbiAgfSxcbiAgXCJtaWxreXdheS1icmlnaHRcIjoge1xuICAgIGNvbG9yOiBcImhzbCgyMzMsMTAwJSw5MiUpXCIsXG4gICAgcHJlc2V0OiBcIm1pbGt5d2F5LWJyaWdodFwiXG4gIH0sXG4gIFwibWlsa3l3YXktY29sb3JlZFwiOiB7XG4gICAgY29sb3I6IFwiYmxhY2tcIixcbiAgICBwcmVzZXQ6IFwibWlsa3l3YXktY29sb3JlZFwiXG4gIH1cbn07XG52YXIgQmUgPSAvKiBAX19QVVJFX18gKi8gKChyKSA9PiAoci5QT1NJVElWRV9YID0gXCJwWFwiLCByLk5FR0FUSVZFX1ggPSBcIm5YXCIsIHIuUE9TSVRJVkVfWSA9IFwicFlcIiwgci5ORUdBVElWRV9ZID0gXCJuWVwiLCByLlBPU0lUSVZFX1ogPSBcInBaXCIsIHIuTkVHQVRJVkVfWiA9IFwiblpcIiwgcikpKEJlIHx8IHt9KTtcbmNvbnN0IFZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgT2EgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xubGV0ICRhO1xuZnVuY3Rpb24gS3UoeyBnbDogciwgZmFjZXM6IGUsIG9uUmVhZHk6IHQsIGZvcmNlUmVmcmVzaDogbiB9KSB7XG4gIGlmIChWdC5nZXQocikgJiYgIW4gJiYgJGEgPT09IEpTT04uc3RyaW5naWZ5KGUpKSB7XG4gICAgdChWdC5nZXQociksIE9hLmdldChyKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gICRhID0gSlNPTi5zdHJpbmdpZnkoZSk7XG4gIGNvbnN0IGEgPSBWdC5nZXQocikgPz8gci5jcmVhdGVUZXh0dXJlKCk7XG4gIGlmICghZSkge1xuICAgIGNvbnNvbGUud2FybihcIltDdWJlbWFwTGF5ZXJdW2xvYWRDdWJlbWFwVGV4dHVyZV06IEZhY2VzIGFyZSBudWxsXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvID0gT2JqZWN0LmtleXMoZSkubGVuZ3RoO1xuICBpZiAobyAhPT0gNikge1xuICAgIGNvbnNvbGUud2FybihgW0N1YmVtYXBMYXllcl1bbG9hZEN1YmVtYXBUZXh0dXJlXTogRmFjZXMgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSA2IGltYWdlcywgYnV0IGZvdW5kICR7b31gKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaSA9IE9iamVjdC5lbnRyaWVzKGUpLm1hcCgoW3MsIGxdKSA9PiBuZXcgUHJvbWlzZSgodSwgYykgPT4ge1xuICAgIGNvbnN0IHAgPSBzO1xuICAgIGlmIChsID09PSB2b2lkIDApIHtcbiAgICAgIGMobmV3IEVycm9yKGBbQ3ViZW1hcExheWVyXVtsb2FkQ3ViZW1hcFRleHR1cmVdOiBGYWNlICR7c30gaXMgdW5kZWZpbmVkYCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkID0gbmV3IEltYWdlKCk7XG4gICAgZC5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgY29uc3QgZiA9ICgpID0+IHtcbiAgICAgIHUoeyBpbWFnZTogZCwga2V5OiBwIH0pO1xuICAgIH07XG4gICAgZC5zcmMgPSBsLCBkLmNvbXBsZXRlICYmIGQubmF0dXJhbFdpZHRoID4gMCA/IGYoKSA6IGQub25sb2FkID0gZiwgZC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgYyhuZXcgRXJyb3IoYFtDdWJlbWFwTGF5ZXJdW2xvYWRDdWJlbWFwVGV4dHVyZV06IEVycm9yIGxvYWRpbmcgaW1hZ2UgJHtsfWApKTtcbiAgICB9O1xuICB9KSk7XG4gIFByb21pc2UuYWxsKGkpLnRoZW4oKHMpID0+IHtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHMubGVuZ3RoOyB1KyspIHtcbiAgICAgIGNvbnN0IHAgPSByLlJHQkEsIGQgPSByLlJHQkEsIGYgPSByLlVOU0lHTkVEX0JZVEUsIHsgaW1hZ2U6IGgsIGtleTogbSB9ID0gc1t1XSA/PyB7fTtcbiAgICAgIGlmICghaCB8fCAhbSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbQ3ViZW1hcExheWVyXVtsb2FkQ3ViZW1hcFRleHR1cmVdOiBJbWFnZSBvciBrZXkgaXMgbnVsbFwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB5ID0gWHUociwgbSk7XG4gICAgICByLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV9DVUJFX01BUCwgYSksIHIudGV4UGFyYW1ldGVyaShyLlRFWFRVUkVfQ1VCRV9NQVAsIHIuVEVYVFVSRV9NQUdfRklMVEVSLCByLkxJTkVBUiksIHIudGV4UGFyYW1ldGVyaShyLlRFWFRVUkVfQ1VCRV9NQVAsIHIuVEVYVFVSRV9NSU5fRklMVEVSLCByLkxJTkVBUiksIHIudGV4UGFyYW1ldGVyaShyLlRFWFRVUkVfQ1VCRV9NQVAsIHIuVEVYVFVSRV9XUkFQX1MsIHIuQ0xBTVBfVE9fRURHRSksIHIudGV4UGFyYW1ldGVyaShyLlRFWFRVUkVfQ1VCRV9NQVAsIHIuVEVYVFVSRV9XUkFQX1QsIHIuQ0xBTVBfVE9fRURHRSksIHIudGV4SW1hZ2UyRCh5LCAwLCBwLCBkLCBmLCBoKTtcbiAgICB9XG4gICAgci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfQ1VCRV9NQVAsIGEpLCByLmdlbmVyYXRlTWlwbWFwKHIuVEVYVFVSRV9DVUJFX01BUCksIHIudGV4UGFyYW1ldGVyaShyLlRFWFRVUkVfQ1VCRV9NQVAsIHIuVEVYVFVSRV9NSU5fRklMVEVSLCByLkxJTkVBUl9NSVBNQVBfTElORUFSKSwgci50ZXhQYXJhbWV0ZXJpKHIuVEVYVFVSRV9DVUJFX01BUCwgci5URVhUVVJFX01BR19GSUxURVIsIHIuTElORUFSKTtcbiAgICBjb25zdCBsID0gcy5tYXAoKHUpID0+IHUuaW1hZ2UpO1xuICAgIHQoYSwgbCksIE9hLnNldChyLCBsKSwgVnQuc2V0KHIsIGEpO1xuICB9KS5jYXRjaCgocykgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbQ3ViZW1hcExheWVyXVtsb2FkQ3ViZW1hcFRleHR1cmVdOiBFcnJvciBsb2FkaW5nIGN1YmVtYXAgdGV4dHVyZVwiLCBzKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBYdShyLCBlKSB7XG4gIGlmIChlID09PSBCZS5QT1NJVElWRV9YKVxuICAgIHJldHVybiByLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDtcbiAgaWYgKGUgPT09IEJlLk5FR0FUSVZFX1gpXG4gICAgcmV0dXJuIHIuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YO1xuICBpZiAoZSA9PT0gQmUuUE9TSVRJVkVfWSlcbiAgICByZXR1cm4gci5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k7XG4gIGlmIChlID09PSBCZS5ORUdBVElWRV9ZKVxuICAgIHJldHVybiByLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTtcbiAgaWYgKGUgPT09IEJlLlBPU0lUSVZFX1opXG4gICAgcmV0dXJuIHIuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aO1xuICBpZiAoZSA9PT0gQmUuTkVHQVRJVkVfWilcbiAgICByZXR1cm4gci5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o7XG4gIHRocm93IG5ldyBFcnJvcihgW0N1YmVtYXBMYXllcl1bbG9hZEN1YmVtYXBUZXh0dXJlXTogSW52YWxpZCBrZXkgJHtlfWApO1xufVxuZnVuY3Rpb24gWXUociwgZSwgdCkge1xuICByZXR1cm4gW1xuICAgIEZlKHJbMF0sIGVbMF0sIHQpLFxuICAgIEZlKHJbMV0sIGVbMV0sIHQpLFxuICAgIEZlKHJbMl0sIGVbMl0sIHQpLFxuICAgIEZlKHJbM10sIGVbM10sIHQpXG4gIF07XG59XG5mdW5jdGlvbiBGZShyLCBlLCB0KSB7XG4gIHJldHVybiByICsgKGUgLSByKSAqIHQ7XG59XG5mdW5jdGlvbiBvcihyKSB7XG4gIGlmICghcilcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IGUgPSBPYmplY3Qua2V5cyhyKS5zb3J0KCkubWFwKCh0KSA9PiBbdCwgclt0XV0pO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGUpO1xufVxuY29uc3QgSmUgPSBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9yZXNvdXJjZXMvc3BhY2VcIiwgV3UgPSBbXCJ2ZXJ0ZXhQb3NpdGlvblwiXSwgSnUgPSBbXCJwcm9qZWN0aW9uTWF0cml4XCIsIFwibW9kZWxWaWV3TWF0cml4XCIsIFwiY3ViZVNhbXBsZXJcIiwgXCJiZ0NvbG9yXCIsIFwiZmFkZU9wYWNpdHlcIl0sIEZhID0gXCIlVVNFX1RFWFRVUkVfTUFDUk9fTUFSS0VSJVwiLCBRdSA9IFwiI2RlZmluZSBVU0VfVEVYVFVSRVwiLCBOYSA9IEtlLnN0YXJzO1xuZnVuY3Rpb24gZWMociwgZSkge1xuICBpZiAoIXJuKHIpKVxuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfTtcbiAgaWYgKHIgPT09ICEwKVxuICAgIHJldHVybiBlO1xuICBjb25zdCB0ID0ge1xuICAgIC4uLnJcbiAgfTtcbiAgaWYgKHIuZmFjZXMgfHwgci5wYXRoKVxuICAgIHJldHVybiBkZWxldGUgdC5wcmVzZXQsIHQ7XG4gIGNvbnN0IG4gPSByLnByZXNldDtcbiAgaWYgKCEobiA9PT0gdm9pZCAwKSAmJiAhKG4gaW4gS2UpKVxuICAgIHRocm93IG5ldyBFcnJvcihgW0N1YmVtYXBMYXllcl06IEludmFsaWQgcHJlc2V0IFwiJHtufVwiLiBBdmFpbGFibGUgcHJlc2V0czogJHtPYmplY3Qua2V5cyhLZSkuam9pbihcIiwgXCIpfWApO1xuICByZXR1cm4ge1xuICAgIC4uLnQsXG4gICAgLy8gdGhpcyBfY291bGRfIGJlIG51bGxpc2hfXG4gICAgY29sb3I6IHQuY29sb3IgPz8gS2Vbbl0uY29sb3IgPz8gXCJoc2woMjMzLDEwMCUsOTIlKVwiXG4gIH07XG59XG5jbGFzcyBCciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEN1YmVtYXBMYXllclxuICAgKlxuICAgKiBAcGFyYW0ge0N1YmVtYXBMYXllckNvbnN0cnVjdG9yT3B0aW9ucyB8IHRydWV9IGN1YmVtYXBDb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjdWJlbWFwIGxheWVyIG9yIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBvcHRpb25zLlxuICAgKiBDYW4gc3BlY2lmeSBmYWNlcywgcHJlc2V0LCBwYXRoLCBhbmQgY29sb3IgcHJvcGVydGllcyB0byBjb25maWd1cmUgdGhlIGN1YmVtYXAuXG4gICAqXG4gICAqIEByZW1hcmtzIFlvdSBzaG91bGRuJ3QgaGF2ZSB0byB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseS5cbiAgICogSW5zdGVhZCwgdXNlIHRoZSBgTWFwLnNldEhhbG9gIG1ldGhvZCB0byBjcmVhdGUgYW5kIGFkZCBhIGhhbG8gbGF5ZXIgdG8gdGhlIG1hcC5cbiAgICogVGhlIGNvbnN0cnVjdG9yIGluaXRpYWxpemVzIHRoZSBjdWJlbWFwIHdpdGggdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAqIEl0IHByb2Nlc3NlcyB0aGUgZmFjZXMgZGVmaW5pdGlvbiwgc2V0cyB1cCBiYWNrZ3JvdW5kIGNvbG9ycywgYW5kIGRldGVybWluZXNcbiAgICogd2hldGhlciB0byB1c2UgYSBjdWJlbWFwIHRleHR1cmUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgZyh0aGlzLCBcImlkXCIsIFwiQ3ViZW1hcCBMYXllclwiKTtcbiAgICBnKHRoaXMsIFwidHlwZVwiLCBcImN1c3RvbVwiKTtcbiAgICBnKHRoaXMsIFwicmVuZGVyaW5nTW9kZVwiLCBcIjNkXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBsYXllciBpcyBhZGRlZC5cbiAgICAgKiBAdHlwZSB7TWFwU0RLfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZyh0aGlzLCBcIm1hcFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3ViZW1hcCBmYWNlcyBkZWZpbml0aW9uLCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgcHJlc2V0LCBwYXRoLCBvciBleHBsaWNpdCBmYWNlIFVSTHMuXG4gICAgICogQHR5cGUge0N1YmVtYXBGYWNlcyB8IG51bGx9XG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHNldCBkdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBsYXllciBhbmQgY2FuIGJlIHVwZGF0ZWQgbGF0ZXIuXG4gICAgICogSWYgbm8gZmFjZXMgYXJlIGRlZmluZWQsIGl0IHdpbGwgYmUgYG51bGxgLlxuICAgICAqL1xuICAgIGcodGhpcywgXCJmYWNlc1wiKTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0byB1c2UgYSBjdWJlbWFwIHRleHR1cmUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwidXNlQ3ViZW1hcFRleHR1cmVcIiwgITApO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG9wYWNpdHkgb2YgdGhlIGZhZGUgZWZmZWN0IGFwcGxpZWQgdG8gdGhlIGN1YmVtYXAgaW1hZ2UgdGV4dHVyZSwgdXNlZCBmb3IgZmFkaW5nIGluIGFuZCBvdXQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IDAuMFxuICAgICAqL1xuICAgIGcodGhpcywgXCJjdXJyZW50RmFkZU9wYWNpdHlcIiwgMCk7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1YmVtYXAgbmVlZHMgdG8gYmUgdXBkYXRlZCwgdHlwaWNhbGx5IHdoZW4gdGhlIGZhY2VzIG9yIHRleHR1cmUgY2hhbmdlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZyh0aGlzLCBcImN1YmVNYXBOZWVkc1VwZGF0ZVwiLCAhMSk7XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGN1YmVtYXAgbGF5ZXIsIHJlcHJlc2VudGVkIGFzIGEgVmVjNCAoUkdCQSkuXG4gICAgICogQHR5cGUge1ZlYzR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwiYmdDb2xvclwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgYmFja2dyb3VuZCBjb2xvciB1c2VkIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvbnMuXG4gICAgICogQHR5cGUge1ZlYzR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwicHJldmlvdXNCZ0NvbG9yXCIsIFswLCAwLCAwLCAwXSk7XG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHdoaWNoIHRoZSBsYXllciB3aWxsIHRyYW5zaXRpb24uXG4gICAgICogQHR5cGUge1ZlYzR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwidGFyZ2V0QmdDb2xvclwiLCBbMCwgMCwgMCwgMF0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWx0YSB2YWx1ZSB1c2VkIGZvciB0cmFuc2l0aW9uaW5nIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLiAwID0gc3RhcnQgb2YgdHJhbnNpdGlvbiwgMSA9IGVuZCBvZiB0cmFuc2l0aW9uLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgaW5jcmVtZW50ZWQgb3ZlciB0aW1lIHRvIGNyZWF0ZSBhIHNtb290aCB0cmFuc2l0aW9uIGVmZmVjdC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZyh0aGlzLCBcInRyYW5zaXRpb25EZWx0YVwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgV2ViR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGN1YmVtYXAgbGF5ZXIuXG4gICAgICogQHR5cGUge1dlYkdMQ29udGV4dH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGcodGhpcywgXCJnbFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3ViZW1hcCBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2hhZGVyIHByb2dyYW0sIGJ1ZmZlcnMgYW5kIHVuaWZvcm0gbG9jYXRpb25zIGZvciByZW5kZXJpbmcuXG4gICAgICogQHR5cGUge09iamVjdDNEfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZyh0aGlzLCBcImN1YmVtYXBcIik7XG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIHRleHR1cmUgdXNlZCBmb3IgdGhlIGN1YmVtYXAsIHdoaWNoIGlzIGNyZWF0ZWQgZnJvbSB0aGUgZGVmaW5lZCBmYWNlcy5cbiAgICAgKiBUaGlzIHRleHR1cmUgaXMgdXNlZCB0byByZW5kZXIgdGhlIGN1YmVtYXAgaW4gdGhlIHNjZW5lLlxuICAgICAqIEB0eXBlIHtXZWJHTFRleHR1cmUgfCB1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwidGV4dHVyZVwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBmYWNlcyBkZWZpbml0aW9uLCB1c2VkIHRvIGRpZmYgLyB0cmFjayBjaGFuZ2VzIGluIHRoZSBjdWJlbWFwIGZhY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZyh0aGlzLCBcImN1cnJlbnRGYWNlc0RlZmluaXRpb25LZXlcIiwgXCJcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGN1YmVtYXAgbGF5ZXIuXG4gICAgICogQHR5cGUge0N1YmVtYXBMYXllckNvbnN0cnVjdG9yT3B0aW9uc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGcodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIGcodGhpcywgXCJhbmltYXRpb25BY3RpdmVcIiwgITApO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBjdWJlbWFwIGltYWdlIGZhZGluZyBpbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBncmFkdWFsbHkgaW5jcmVhc2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBjdWJlbWFwIGltYWdlIHRvIGNyZWF0ZSBhIGZhZGUtaW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwiaW1hZ2VJc0FuaW1hdGluZ1wiLCAhMSk7XG4gICAgLyoqXG4gICAgICogVGhlIGRlbHRhIHZhbHVlIHVzZWQgZm9yIHRoZSBpbWFnZSBmYWRlLWluIGFuaW1hdGlvbi5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIGluY3JlbWVudGVkIG92ZXIgdGltZSB0byBjcmVhdGUgYSBzbW9vdGggZmFkZS1pbiBlZmZlY3QuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGcodGhpcywgXCJpbWFnZUZhZGVJbkRlbHRhXCIsIDApO1xuICAgIGNvbnN0IHQgPSBlYyhlLCBOYSk7XG4gICAgdGhpcy5vcHRpb25zID0gdCwgdGhpcy5jdXJyZW50RmFjZXNEZWZpbml0aW9uS2V5ID0gSlNPTi5zdHJpbmdpZnkodC5mYWNlcyA/PyB0LnByZXNldCA/PyB0LnBhdGgpLCB0aGlzLmJnQ29sb3IgPSBbMCwgMCwgMCwgMF0sIHRoaXMudGFyZ2V0QmdDb2xvciA9IEt0KHQuY29sb3IpLCB0aGlzLmZhY2VzID0gamEodCksIHRoaXMudXNlQ3ViZW1hcFRleHR1cmUgPSB0aGlzLmZhY2VzICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdWJlbWFwIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGZhY2VzIGFuZCBzaGFkZXIgY29uZmlndXJhdGlvbi5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGN1YmVtYXAgZmFjZXMgY2hhbmdlIG9yIHdoZW4gdGhlIGxheWVyIGlzIGluaXRpYWxpemVkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHJlbWFya3NcbiAgICogSXQgY3JlYXRlcyBhIG5ldyBPYmplY3QzRCBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLFxuICAgKiBhdHRyaWJ1dGVzLCBhbmQgdW5pZm9ybXMuIFRoZSBjdWJlbWFwIHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgdGhpcyBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgdXBkYXRlQ3ViZW1hcCh7IGZhY2VzTmVlZFVwZGF0ZTogZSB9ID0geyBmYWNlc05lZWRVcGRhdGU6ICEwIH0pIHtcbiAgICB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlID0gdGhpcy5mYWNlcyAhPT0gbnVsbDtcbiAgICBjb25zdCB0ID0gSnUuZmlsdGVyKChuKSA9PiBuID09PSBcImN1YmVTYW1wbGVyXCIgfHwgbiA9PT0gXCJmYWRlT3BhY2l0eVwiID8gdGhpcy51c2VDdWJlbWFwVGV4dHVyZSA6ICEwKTtcbiAgICB0aGlzLmN1YmVtYXAgPSBWbyh7XG4gICAgICBnbDogdGhpcy5nbCxcbiAgICAgIHZlcnRleFNoYWRlclNvdXJjZTogSHUsXG4gICAgICAvLyBCZWNhdXNlIHdlIG9ubHkgd2FudCB0byB1c2UgdGhlIHJlYWQgdGhlIHRleHR1cmUgaW4gZ2wgaWYgd2UncmUgc3VwcG9zZWQgdG9cbiAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlOiB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlID8gemEucmVwbGFjZShGYSwgUXUpIDogemEucmVwbGFjZShGYSwgXCJcIiksXG4gICAgICBhdHRyaWJ1dGVzS2V5czogV3UsXG4gICAgICB1bmlmb3Jtc0tleXM6IHQsXG4gICAgICB2ZXJ0aWNlczogVnUsXG4gICAgICBpbmRpY2VzOiBHdVxuICAgIH0pLCB0aGlzLmN1YmVNYXBOZWVkc1VwZGF0ZSA9IGUsIHRoaXMudXNlQ3ViZW1hcFRleHR1cmUgJiYgdGhpcy51cGRhdGVUZXh0dXJlKHRoaXMuZ2wsIHRoaXMuZmFjZXMpLCB0aGlzLmFuaW1hdGVDb2xvckNoYW5nZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGN1YmVtYXAgYW5kIHNldHMgdXAgdGhlIFdlYkdMIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFwU0RLfSBtYXAgLSBUaGUgbWFwIGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgbGF5ZXIgaXMgYWRkZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqL1xuICBvbkFkZChlLCB0KSB7XG4gICAgdGhpcy5tYXAgPSBlLCB0aGlzLmdsID0gdCwgdGhpcy51cGRhdGVDdWJlbWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcC5cbiAgICogQ2xlYW5zIHVwIHRoZSBjdWJlbWFwIHJlc291cmNlcyBhbmQgV2ViR0wgYnVmZmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtNYXBTREt9IF9tYXAgLSBUaGUgbWFwIGluc3RhbmNlIGZyb20gd2hpY2ggdGhpcyBsYXllciBpcyByZW1vdmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKi9cbiAgb25SZW1vdmUoZSwgdCkge1xuICAgIHRoaXMuY3ViZW1hcCAmJiAodGhpcy50ZXh0dXJlICYmIHQuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpLCB0LmRlbGV0ZVByb2dyYW0odGhpcy5jdWJlbWFwLnNoYWRlclByb2dyYW0pLCB0LmRlbGV0ZUJ1ZmZlcih0aGlzLmN1YmVtYXAucG9zaXRpb25CdWZmZXIpLCB0aGlzLnRleHR1cmUgPSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdWJlbWFwIHRleHR1cmUgd2l0aCB0aGUgcHJvdmlkZWQgZmFjZXMuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBjdWJlbWFwIGZhY2VzIGNoYW5nZSBvciB3aGVuIHRoZSBsYXllciBpcyBpbml0aWFsaXplZC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTENvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge0N1YmVtYXBGYWNlc30gZmFjZXMgLSBUaGUgY3ViZW1hcCBmYWNlcyB0byBiZSBsb2FkZWQgaW50byB0aGUgdGV4dHVyZS5cbiAgICovXG4gIHVwZGF0ZVRleHR1cmUoZSwgdCkge1xuICAgIGlmICh0aGlzLmN1YmVNYXBOZWVkc1VwZGF0ZSA9PT0gITAgJiYgIXRoaXMuaW1hZ2VJc0FuaW1hdGluZykge1xuICAgICAgaWYgKHRoaXMuY3ViZU1hcE5lZWRzVXBkYXRlID0gITEsICF0aGlzLnVzZUN1YmVtYXBUZXh0dXJlKVxuICAgICAgICByZXR1cm47XG4gICAgICBLdSh7XG4gICAgICAgIGdsOiBlLFxuICAgICAgICBmYWNlczogdCxcbiAgICAgICAgb25SZWFkeTogKG4pID0+IHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBuLCB0aGlzLmFuaW1hdGVJbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBiZWZvcmUgdGhlIGxheWVyIGlzIHJlbmRlcmVkLlxuICAgKiBVcGRhdGVzIHRoZSBjdWJlbWFwIHRleHR1cmUgd2l0aCB0aGUgY3VycmVudCBmYWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTENvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge0N1c3RvbVJlbmRlck1ldGhvZElucHV0fSBfb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlbmRlciBtZXRob2QuXG4gICAqL1xuICBwcmVyZW5kZXIoZSwgdCkge1xuICAgIHRoaXMuZmFjZXMgJiYgdGhpcy51cGRhdGVUZXh0dXJlKHRoaXMuZ2wsIHRoaXMuZmFjZXMpO1xuICB9XG4gIC8qKlxuICAgKiBMZXJwcyB0aGUgYmFja2dyb3VuZCBjb2xvciB0cmFuc2l0aW9uIG9mIHRoZSBjdWJlbWFwIGxheWVyLlxuICAgKiBUaGlzIG1ldGhvZCBzbW9vdGhseSB0cmFuc2l0aW9ucyB0aGUgYmFja2dyb3VuZCBjb2xvciBmcm9tIHRoZSBwcmV2aW91cyBjb2xvciB0byB0aGUgdGFyZ2V0IGNvbG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0ZUNvbG9yQ2hhbmdlKCkge1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25EZWx0YSA8IDEgJiYgKHJlcXVlc3RBbmltYXRpb25GcmFtZShlKSwgdGhpcy5iZ0NvbG9yID0gWXUodGhpcy5wcmV2aW91c0JnQ29sb3IsIHRoaXMudGFyZ2V0QmdDb2xvciwgdGhpcy50cmFuc2l0aW9uRGVsdGEpLCB0aGlzLnRyYW5zaXRpb25EZWx0YSArPSAwLjA3NSwgdGhpcy5tYXAudHJpZ2dlclJlcGFpbnQoKSk7XG4gICAgfTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSBjdWJlbWFwIGltYWdlIGZhZGluZyBpbi5cbiAgICogVGhpcyBtZXRob2QgZ3JhZHVhbGx5IGluY3JlYXNlcyB0aGUgb3BhY2l0eSBvZiB0aGUgY3ViZW1hcCBpbWFnZSB0byBjcmVhdGUgYSBmYWRlLWluIGVmZmVjdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGFuaW1hdGVJbigpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VJc0FuaW1hdGluZykge1xuICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbkFjdGl2ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRGYWRlT3BhY2l0eSA9IDEsIHRoaXMuaW1hZ2VGYWRlSW5EZWx0YSA9IDEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgICB0aGlzLmltYWdlSXNBbmltYXRpbmcgPSAhMDtcbiAgICAgICAgY29uc3QgdCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZUZhZGVJbkRlbHRhID0gTWF0aC5taW4odGhpcy5pbWFnZUZhZGVJbkRlbHRhICsgMC4wNSwgMSksIHRoaXMuY3VycmVudEZhZGVPcGFjaXR5ID0gRmUoMCwgMSwgdGhpcy5pbWFnZUZhZGVJbkRlbHRhKSwgdGhpcy5tYXAudHJpZ2dlclJlcGFpbnQoKSwgdGhpcy5pbWFnZUZhZGVJbkRlbHRhIDwgMSkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmltYWdlSXNBbmltYXRpbmcgPSAhMSwgdGhpcy5pbWFnZUZhZGVJbkRlbHRhID0gMCwgZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSBjdWJlbWFwIGltYWdlIGZhZGluZyBvdXQuXG4gICAqIFRoaXMgbWV0aG9kIGdyYWR1YWxseSBkZWNyZWFzZXMgdGhlIG9wYWNpdHkgb2YgdGhlIGN1YmVtYXAgaW1hZ2UgdG8gY3JlYXRlIGEgZmFkZS1vdXQgZWZmZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgYW5pbWF0ZU91dCgpIHtcbiAgICBpZiAoISh0aGlzLmltYWdlSXNBbmltYXRpbmcgfHwgIXRoaXMuYW5pbWF0aW9uQWN0aXZlKSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlRmFkZUluRGVsdGEgPSBNYXRoLm1pbih0aGlzLmltYWdlRmFkZUluRGVsdGEgKyAwLjA1LCAxKSwgdGhpcy5jdXJyZW50RmFkZU9wYWNpdHkgPSBGZSgxLCAwLCB0aGlzLmltYWdlRmFkZUluRGVsdGEpLCB0aGlzLm1hcC50cmlnZ2VyUmVwYWludCgpLCB0aGlzLmltYWdlRmFkZUluRGVsdGEgPj0gMSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZUlzQW5pbWF0aW5nID0gITEsIHRoaXMuaW1hZ2VGYWRlSW5EZWx0YSA9IDAsIGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCk7XG4gICAgICB9KTtcbiAgfVxuICBzZXRBbmltYXRpb25BY3RpdmUoZSkge1xuICAgIHRoaXMuYW5pbWF0aW9uQWN0aXZlID0gZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3ViZW1hcCBsYXllciB0byB0aGUgV2ViR0wgY29udGV4dC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGludGVybmFsbHkgZHVyaW5nIHRoZSByZW5kZXJpbmcgcGhhc2Ugb2YgdGhlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtDdXN0b21SZW5kZXJNZXRob2RJbnB1dH0gX29wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZW5kZXIgbWV0aG9kLlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBtYXAsIGN1YmVtYXAsIG9yIHRleHR1cmUgaXMgdW5kZWZpbmVkLlxuICAgKi9cbiAgcmVuZGVyKGUsIHQpIHtcbiAgICBpZiAoIXRoaXMubWFwLmlzR2xvYmVQcm9qZWN0aW9uKCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMubWFwID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQ3ViZW1hcExheWVyXTogTWFwIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBpZiAodGhpcy5jdWJlbWFwID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQ3ViZW1hcExheWVyXTogQ3ViZW1hcCBpcyB1bmRlZmluZWRcIik7XG4gICAgdGhpcy50ZXh0dXJlLCBlLmRpc2FibGUoZS5ERVBUSF9URVNUKSwgZS5lbmFibGUoZS5CTEVORCksIGUuYmxlbmRGdW5jKGUuU1JDX0FMUEhBLCBlLkRTVF9BTFBIQSksIGUudXNlUHJvZ3JhbSh0aGlzLmN1YmVtYXAuc2hhZGVyUHJvZ3JhbSksIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUiwgdGhpcy5jdWJlbWFwLnBvc2l0aW9uQnVmZmVyKSwgZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuY3ViZW1hcC5wcm9ncmFtSW5mby5hdHRyaWJ1dGVzTG9jYXRpb25zLnZlcnRleFBvc2l0aW9uLCAzLCBlLkZMT0FULCAhMSwgMCwgMCksIGUuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5jdWJlbWFwLnByb2dyYW1JbmZvLmF0dHJpYnV0ZXNMb2NhdGlvbnMudmVydGV4UG9zaXRpb24pO1xuICAgIGNvbnN0IG4gPSAwLjEsIGEgPSAxZTQsIG8gPSBlLmNhbnZhcywgaSA9IG8uY2xpZW50V2lkdGggLyBvLmNsaWVudEhlaWdodCwgcyA9IHRoaXMubWFwLnRyYW5zZm9ybSwgbCA9IHMuZm92ICogKE1hdGguUEkgLyAxODApLCB1ID0gZ3QoKTtcbiAgICBBdSh1LCBsLCBpLCBuLCBhKSwgQWEodSwgdSwgcy5yb2xsSW5SYWRpYW5zKSwgQ2EodSwgdSwgLXMucGl0Y2hJblJhZGlhbnMpLCBBYSh1LCB1LCBzLmJlYXJpbmdJblJhZGlhbnMpO1xuICAgIGNvbnN0IGMgPSBzLmNlbnRlci5sYXQgKiBNYXRoLlBJIC8gMTgwLCBwID0gcy5jZW50ZXIubG5nICogTWF0aC5QSSAvIDE4MDtcbiAgICBDYSh1LCB1LCBjKSwgRXUodSwgdSwgLXApLCBlLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5jdWJlbWFwLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLnByb2plY3Rpb25NYXRyaXgsICExLCB1KTtcbiAgICBjb25zdCBkID0gZ3QoKTtcbiAgICBpZiAoZS51bmlmb3JtTWF0cml4NGZ2KHRoaXMuY3ViZW1hcC5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5tb2RlbFZpZXdNYXRyaXgsICExLCBkKSwgZS51bmlmb3JtNGZ2KHRoaXMuY3ViZW1hcC5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5iZ0NvbG9yLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYmdDb2xvcikpLCBlLnVuaWZvcm0xZih0aGlzLmN1YmVtYXAucHJvZ3JhbUluZm8udW5pZm9ybXNMb2NhdGlvbnMuZmFkZU9wYWNpdHksIHRoaXMuY3VycmVudEZhZGVPcGFjaXR5KSwgdGhpcy51c2VDdWJlbWFwVGV4dHVyZSAmJiB0aGlzLnRleHR1cmUgJiYgKGUuYWN0aXZlVGV4dHVyZShlLlRFWFRVUkUwKSwgZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSksIGUudW5pZm9ybTFpKHRoaXMuY3ViZW1hcC5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5jdWJlU2FtcGxlciwgMCkpLCB0aGlzLmN1YmVtYXAuaW5kZXhCdWZmZXIgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IGJ1ZmZlciBpcyB1bmRlZmluZWRcIik7XG4gICAgaWYgKHRoaXMuY3ViZW1hcC5pbmRleEJ1ZmZlckxlbmd0aCA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggYnVmZmVyIGxlbmd0aCBpcyB1bmRlZmluZWRcIik7XG4gICAgZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuY3ViZW1hcC5pbmRleEJ1ZmZlciksIGUuZHJhd0VsZW1lbnRzKGUuVFJJQU5HTEVTLCB0aGlzLmN1YmVtYXAuaW5kZXhCdWZmZXJMZW5ndGgsIGUuVU5TSUdORURfU0hPUlQsIDApO1xuICB9XG4gIHNldEJnQ29sb3IoZSkge1xuICAgIHRoaXMudGFyZ2V0QmdDb2xvciA9IGUsIHRoaXMucHJldmlvdXNCZ0NvbG9yID0gdGhpcy5iZ0NvbG9yLCB0aGlzLnRyYW5zaXRpb25EZWx0YSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgY3ViZW1hcCBsYXllci5cbiAgICogQHJldHVybnMge0N1YmVtYXBMYXllckNvbnN0cnVjdG9yT3B0aW9uc30gVGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgZ2V0Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY3ViZW1hcCBuZWVkcyB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzcGVjaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0N1YmVtYXBEZWZpbml0aW9ufSBzcGVjIC0gVGhlIGN1YmVtYXAgc3BlY2lmaWNhdGlvbiB0byBjb21wYXJlIHdpdGggdGhlIGN1cnJlbnQgY3ViZW1hcC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGN1YmVtYXAgbmVlZHMgdG8gYmUgdXBkYXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc2hvdWxkVXBkYXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICBpZiAoZSA9PT0gdm9pZCAwICYmIHQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbiA9IG9yKGUpLCBhID0gb3IodCk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG4pICE9PSBKU09OLnN0cmluZ2lmeShhKTtcbiAgfVxuICBhc3luYyBzZXRDdWJlbWFwRmFjZXMoZSkge1xuICAgIGlmIChhd2FpdCB0aGlzLmFuaW1hdGVPdXQoKSwgIWUuZmFjZXMgJiYgIWUucHJlc2V0ICYmICFlLnBhdGgpIHtcbiAgICAgIHRoaXMuZmFjZXMgPSBudWxsLCB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlID0gITEsIHRoaXMuY3VycmVudEZhY2VzRGVmaW5pdGlvbktleSA9IFwiZW1wdHlcIiwgYXdhaXQgdGhpcy5hbmltYXRlSW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mYWNlcyA9IGphKGUpLCB0aGlzLmN1cnJlbnRGYWNlc0RlZmluaXRpb25LZXkgPSBKU09OLnN0cmluZ2lmeShlLmZhY2VzID8/IGUucHJlc2V0ID8/IGUucGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1YmVtYXAgZm9yIHRoZSBsYXllciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGVmaW5pdGlvbi5cbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3ViZW1hcCBmYWNlcywgYmFja2dyb3VuZCBjb2xvciwgYW5kIHRyaWdnZXJzIGEgcmVwYWludCBvZiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge0N1YmVtYXBEZWZpbml0aW9ufSBjdWJlbWFwIC0gVGhlIGN1YmVtYXAgZGVmaW5pdGlvbiBjb250YWluaW5nIGZhY2VzLCBwcmVzZXQsIHBhdGgsIG9yIGNvbG9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3ViZW1hcCBpcyBzZXQgYW5kIHRoZSBtYXAgaXMgdXBkYXRlZC5cbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIHRoZSBwcm92aWRlZCBjdWJlbWFwIGRlZmluaXRpb24gaGFzIGEgY29sb3IsIGFuZCBpZiBzbywgaXQgdXBkYXRlcyB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGZhY2VzIGRlZmluaXRpb24gaGFzIGNoYW5nZWQgY29tcGFyZWQgdG8gdGhlIGN1cnJlbnQgb25lLFxuICAgKiBhbmQgaWYgc28sIGl0IHVwZGF0ZXMgdGhlIGN1YmVtYXAgZmFjZXMuXG4gICAqIEZpbmFsbHksIGl0IGNhbGxzIGB1cGRhdGVDdWJlbWFwYCB0byBhcHBseSB0aGUgY2hhbmdlcyBhbmQgdHJpZ2dlciBhIHJlcGFpbnQgb2YgdGhlIG1hcC5cbiAgICovXG4gIGFzeW5jIHNldEN1YmVtYXAoZSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcImJvb2xlYW5cIiA/IE5hIDogZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0O1xuICAgIGNvbnN0IG4gPSBKU09OLnN0cmluZ2lmeSh0LmZhY2VzID8/IHQucHJlc2V0ID8/IHQucGF0aCksIGEgPSB0aGlzLmN1cnJlbnRGYWNlc0RlZmluaXRpb25LZXkgIT09IG47XG4gICAgYSAmJiAoYXdhaXQgdGhpcy5zZXRDdWJlbWFwRmFjZXModCksIHRoaXMuY3ViZU1hcE5lZWRzVXBkYXRlID0gITApO1xuICAgIGNvbnN0IG8gPSBLdCh0LmNvbG9yKTtcbiAgICBpZiAodC5jb2xvciAmJiB0aGlzLnRhcmdldEJnQ29sb3IudG9TdHJpbmcoKSAhPT0gby50b1N0cmluZygpKVxuICAgICAgdGhpcy5zZXRCZ0NvbG9yKG8pO1xuICAgIGVsc2UgaWYgKCF0LmNvbG9yICYmIHQucHJlc2V0ICYmIHQucHJlc2V0IGluIEtlKSB7XG4gICAgICBjb25zdCBpID0gS2VbdC5wcmVzZXRdO1xuICAgICAgdGhpcy5zZXRCZ0NvbG9yKEt0KGkuY29sb3IpKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVDdWJlbWFwKHsgZmFjZXNOZWVkVXBkYXRlOiBhIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgY3ViZW1hcCBsYXllciBieSBzZXR0aW5nIGl0cyB2aXNpYmlsaXR5IHRvIFwidmlzaWJsZVwiLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIG1ha2UgdGhlIGN1YmVtYXAgbGF5ZXIgdmlzaWJsZSBvbiB0aGUgbWFwLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eSh0aGlzLmlkLCBcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgY3ViZW1hcCBsYXllciBieSBzZXR0aW5nIGl0cyB2aXNpYmlsaXR5IHRvIFwibm9uZVwiLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHJlbW92ZSB0aGUgY3ViZW1hcCBsYXllciBmcm9tIHRoZSBtYXAgd2l0aG91dCBkZWxldGluZyBpdC5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5tYXAuc2V0TGF5b3V0UHJvcGVydHkodGhpcy5pZCwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gcm4ocikge1xuICByZXR1cm4gciA/IHR5cGVvZiByID09IFwiYm9vbGVhblwiID8gITAgOiAhKCFyLnBhdGggJiYgIXIucHJlc2V0ICYmICFyLmZhY2VzICYmICFyLmNvbG9yIHx8IHIucHJlc2V0ICYmICEoci5wcmVzZXQgaW4gS2UpIHx8IHIuZmFjZXMgJiYgKCFyLmZhY2VzLnBYIHx8ICFyLmZhY2VzLm5YIHx8ICFyLmZhY2VzLnBZIHx8ICFyLmZhY2VzLm5ZIHx8ICFyLmZhY2VzLnBaIHx8ICFyLmZhY2VzLm5aKSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGphKHIpIHtcbiAgaWYgKHIuZmFjZXMpXG4gICAgcmV0dXJuIHIuZmFjZXM7XG4gIGlmIChyLnByZXNldClcbiAgICByZXR1cm4ge1xuICAgICAgcFg6IGAke0plfS8ke3IucHJlc2V0fS9weC53ZWJwYCxcbiAgICAgIG5YOiBgJHtKZX0vJHtyLnByZXNldH0vbngud2VicGAsXG4gICAgICBwWTogYCR7SmV9LyR7ci5wcmVzZXR9L3B5LndlYnBgLFxuICAgICAgblk6IGAke0plfS8ke3IucHJlc2V0fS9ueS53ZWJwYCxcbiAgICAgIHBaOiBgJHtKZX0vJHtyLnByZXNldH0vcHoud2VicGAsXG4gICAgICBuWjogYCR7SmV9LyR7ci5wcmVzZXR9L256LndlYnBgXG4gICAgfTtcbiAgaWYgKHIucGF0aCkge1xuICAgIGNvbnN0IGUgPSByLnBhdGguYmFzZVVybCwgdCA9IHIucGF0aC5mb3JtYXQgPz8gXCJwbmdcIjtcbiAgICByZXR1cm4ge1xuICAgICAgcFg6IGAke2V9L3B4LiR7dH1gLFxuICAgICAgblg6IGAke2V9L254LiR7dH1gLFxuICAgICAgcFk6IGAke2V9L3B5LiR7dH1gLFxuICAgICAgblk6IGAke2V9L255LiR7dH1gLFxuICAgICAgcFo6IGAke2V9L3B6LiR7dH1gLFxuICAgICAgblo6IGAke2V9L256LiR7dH1gXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IHRjID0gYGF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XG5cbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcbnVuaWZvcm0gbWF0NCB1X3JvdGF0aW9uTWF0cml4O1xuXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XG5cbnZhcnlpbmcgdmVjMiB2X3BvcztcbnZhcnlpbmcgZmxvYXQgdl9zY2FsZTtcblxudm9pZCBtYWluKCkge1xuICB2X3NjYWxlID0gdV9zY2FsZTtcbiAgdl9wb3MgPSBhX3Bvc2l0aW9uLnh5ICogdV9zY2FsZTtcbiAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHVfcm90YXRpb25NYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XG59XG5gLCByYyA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbnZhcnlpbmcgdmVjMiB2X3BvcztcbiAgICAgIFxudW5pZm9ybSBpbnQgdV9zdG9wc051bWJlcjtcbnVuaWZvcm0gZmxvYXQgdV9zdG9wc1sxMDBdO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JzWzEwMF07XG51bmlmb3JtIGZsb2F0IHVfbWF4RGlzdGFuY2U7XG5cbnZhcnlpbmcgZmxvYXQgdl9zY2FsZTtcblxuY29uc3QgZmxvYXQgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG52ZWMyIGNlbnRlciA9IHZlYzIoMC4wLCAwLjApO1xudm9pZCBtYWluKCkge1xuICBmbG9hdCByYXdEaXN0YW5jZSA9IGRpc3RhbmNlKGNlbnRlciwgdl9wb3MpO1xuICBmbG9hdCBkaXN0YW5jZUZyb21HbG9iZUVkZ2UgPSByYXdEaXN0YW5jZSAtIDEuMDtcblxuICAgIHZlYzQgY29sb3IgPSB1X2NvbG9yc1swXTtcblxuICAvLyBpZiB3ZSdyZSBmdXJ0aGVyIHRoYW4gdGhlIG1heCBkaXN0YW5jZSwgd2Ugc2hvdWxkIG5vdCByZW5kZXIgYW55dGhpbmcuXG4gIC8vIFRoaXMgaXMgdG8gYWx3YXlzIHJlbmRlciBhIGNpcmNsZSwgb3RoZXJ3aXNlIHdlIGVuZCB1cCByZW5kZXJpbmdcbiAgLy8gdG8gdGhlIGNvcm5lcnMgb2YgdGhlIHBsYW5lLlxuICBpZiAoZGlzdGFuY2UoY2VudGVyLCB2X3BvcykgPiB1X21heERpc3RhbmNlICogdl9zY2FsZSkge1xuICAgIGRpc2NhcmQ7XG4gIH1cblxuICBmb3IgKGludCBpID0gMTsgaSA8IDEwMDsgaSsrKSB7XG4gICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgbGFzdCBzdG9wXG4gICAgLy8gd2Ugc2hvdWxkIGZpbGwgdG8gdGhlIGVuZCB3aXRoIHRoZSBsYXN0IHN0b3AgY29sb3JcbiAgICBpZiAoaSA+PSB1X3N0b3BzTnVtYmVyKSB7XG4gICAgICBjb2xvciA9IHVfY29sb3JzW2kgLSAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZsb2F0IHNjYWxlZFN0b3BQb3NpdGlvbiA9IHVfc3RvcHNbaV0gKiBwb3codl9zY2FsZSwgMS42KTtcbiAgICBmbG9hdCBsYXN0U3RvcFZhbHVlID0gdV9zdG9wc1tpIC0gMV07XG4gICAgZmxvYXQgdGhpc1N0b3BWYWx1ZSA9IHVfc3RvcHNbaV07XG5cbiAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIGJsZW5kaW5nIGVycm9ycyB3aGVuIHRoZSBzdG9wcyBhcmUgdGhlIHNhbWVcbiAgICAvLyBlZyB3aGVuIHlvdSB3b3VsZCB3YW50IGEgc2hhcnAgZWRnZSBiZXR3ZWVuIHR3byBzdG9wcy5cbiAgICAvLyBcXGBudW1iZXJzQXJlRXF1YWxcXGAgd2lsbCBiZSAxLjAgaWYgdGhlIG51bWJlcnMgYXJlIGVxdWFsLCAwLjAgaWYgdGhleSBhcmUgbm90LlxuICAgIC8vIFdlIHRoZW4gc3VidHJhY3QgRVBTSUxPTiBmcm9tIHRoZSBsYXN0IHN0b3AgbWFraW5nIHRoZSBzdG9wIHZhbHVlIF9hbG1vc3RfIGVxdWFsXG4gICAgLy8gdG8gdGhlIG5leHQgc3RvcCBidXQgbm90IGVub3VnaCB0byBjYXVzZSBibGVuZGluZyBpc3N1ZXMuXG4gICAgLy8gSXQncyBtb3JlIGVmZmljaWVudCB0byBkbyB0aGlzIHRoYW4gYW4gaWYgLyBlbHNlIHN0YXRlbWVudC5cbiAgICBmbG9hdCBudW1iZXJzQXJlRXF1YWwgPSAxLjAgLSBzdGVwKEVQU0lMT04sIGFicyhsYXN0U3RvcFZhbHVlIC0gdGhpc1N0b3BWYWx1ZSkpO1xuICAgIGxhc3RTdG9wVmFsdWUgPSBsYXN0U3RvcFZhbHVlIC0gbnVtYmVyc0FyZUVxdWFsICogRVBTSUxPTjtcblxuICAgIGZsb2F0IGxhc3RTY2FsZWRTdG9wUG9zaXRpb24gPSBsYXN0U3RvcFZhbHVlICogcG93KHZfc2NhbGUsIDEuNik7XG5cbiAgICBpZiAoZGlzdGFuY2VGcm9tR2xvYmVFZGdlIDw9IHNjYWxlZFN0b3BQb3NpdGlvbikge1xuICAgICAgZmxvYXQgc3RvcEJsZW5kRmFjdG9yID0gKGRpc3RhbmNlRnJvbUdsb2JlRWRnZSAtIGxhc3RTY2FsZWRTdG9wUG9zaXRpb24pIC8gKHNjYWxlZFN0b3BQb3NpdGlvbiAtIGxhc3RTY2FsZWRTdG9wUG9zaXRpb24pO1xuICAgICAgY29sb3IgPSBtaXgodV9jb2xvcnNbaSAtIDFdLCB1X2NvbG9yc1tpXSwgc3RvcEJsZW5kRmFjdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiICogY29sb3IuYSwgY29sb3IuYSk7XG59XG5gLCBkdCA9IDIsIG5jID0gW1wicG9zaXRpb25cIl0sIGFjID0gW1wibWF0cml4XCIsIFwicm90YXRpb25NYXRyaXhcIiwgXCJzdG9wc051bWJlclwiLCBcInN0b3BzXCIsIFwiY29sb3JzXCIsIFwibWF4RGlzdGFuY2VcIiwgXCJzY2FsZVwiXSwgb2MgPSBbXG4gIC0yLFxuICAtMixcbiAgMCxcbiAgZHQsXG4gIC0yLFxuICAwLFxuICAtMixcbiAgZHQsXG4gIDAsXG4gIGR0LFxuICBkdCxcbiAgMFxuXSwgUWUgPSB7XG4gIHNjYWxlOiAwLjksXG4gIHN0b3BzOiBbXG4gICAgWzAsIFwicmdiYSgxNzYsIDIwOCwgMjQwLCAxKVwiXSxcbiAgICBbMC4xLCBcInJnYmEoOTgsIDE2OCwgMjI5LCAwLjMpXCJdLFxuICAgIFswLjIsIFwicmdiYSg5OCwgMTY4LCAyMjksIDAuMClcIl1cbiAgXVxufSwgRGEgPSAwLjA2O1xuY2xhc3MgcXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSYWRpYWxHcmFkaWVudExheWVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JhZGlhbEdyYWRpZW50TGF5ZXJDb25zdHJ1Y3Rvck9wdGlvbnMgfCBib29sZWFufSBncmFkaWVudCAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJhZGlhbCBncmFkaWVudCBvciBhIGJvb2xlYW4gdmFsdWUuXG4gICAqIElmIGEgYm9vbGVhbiBpcyBwcm92aWRlZCwgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMgd2lsbCBiZSB1c2VkLlxuICAgKiBJZiBhbiBgUmFkaWFsR3JhZGllbnRMYXllckNvbnN0cnVjdG9yT3B0aW9uc2AgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGcodGhpcywgXCJpZFwiLCBcIkhhbG8gTGF5ZXJcIik7XG4gICAgZyh0aGlzLCBcInR5cGVcIiwgXCJjdXN0b21cIik7XG4gICAgZyh0aGlzLCBcInJlbmRlcmluZ01vZGVcIiwgXCIzZFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZ3JhZGllbnQgZGVmaW5pdGlvbiB1c2VkIGJ5IHRoaXMgbGF5ZXIuXG4gICAgICogSXQgY29udGFpbnMgdGhlIHN0b3BzIGFuZCBzY2FsZSBmb3IgdGhlIHJhZGlhbCBncmFkaWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtHcmFkaWVudERlZmluaXRpb259XG4gICAgICovXG4gICAgZyh0aGlzLCBcImdyYWRpZW50XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgcmFkaWFsIGdyYWRpZW50LCB3aGljaCBkZXRlcm1pbmVzIGl0cyBzaXplLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgYW5pbWF0ZWQgZnJvbSAwIHRvIHRoZSB0YXJnZXQgc2NhbGUgZHVyaW5nIHRoZSBsYXllcidzIGFwcGVhcmFuY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGcodGhpcywgXCJzY2FsZVwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYW5pbWF0aW9uIGRlbHRhIHZhbHVlIHVzZWQgdG8gY29udHJvbCB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGdyYWRpZW50J3MgYXBwZWFyYW5jZSBhbmltYXRpb24uXG4gICAgICogSXQgaXMgaW5jcmVtZW50ZWQgZHVyaW5nIGVhY2ggZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiB1bnRpbCBpdCByZWFjaGVzIDEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGcodGhpcywgXCJhbmltYXRpb25EZWx0YVwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgTWFwU0RLIGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgbGF5ZXIgaXMgYWRkZWQuXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNYXBTREt9XG4gICAgICovXG4gICAgZyh0aGlzLCBcIm1hcFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgM0Qgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFkaWFsIGdyYWRpZW50IHBsYW5lLlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCBhbmQgY29udGFpbnMgdGhlIHNoYWRlciBwcm9ncmFtIGFuZCBidWZmZXJzLlxuICAgICAqIEl0IGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgcmFkaWFsIGdyYWRpZW50IGVmZmVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3QzRDwodHlwZW9mIEFUVFJJQlVURVNfS0VZUylbbnVtYmVyXSwgKHR5cGVvZiBVTklGT1JNU19LRVlTKVtudW1iZXJdPn1cbiAgICAgKi9cbiAgICBnKHRoaXMsIFwicGxhbmVcIik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgaGFsbyBzaG91bGQgYmUgYW5pbWF0ZWQgaW4gYW5kIG91dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGcodGhpcywgXCJhbmltYXRpb25BY3RpdmVcIiwgITApO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhpcy5ncmFkaWVudCA9IFFlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gVWEoZSk7XG4gICAgaWYgKHQubGVuZ3RoID4gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW1JhZGlhbEdyYWRpZW50TGF5ZXJdOiBJbnZhbGlkIEhhbG8gc3BlY2lmaWNhdGlvbjpcbiAtICR7dC5qb2luKGBcbiAtIGApfVxuICAgIGApO1xuICAgIHRoaXMuZ3JhZGllbnQgPSB7XG4gICAgICAuLi5RZSxcbiAgICAgIC4uLmVcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSByYWRpYWwgZ3JhZGllbnQgbGF5ZXIgdG8gdGhlIHNwZWNpZmllZCBtYXAuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFwIHdoZW4gdGhlIGxheWVyIGlzIGFkZGVkIHRvIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge01hcFNES30gbWFwIC0gVGhlIE1hcFNESyBpbnN0YW5jZSB0byB3aGljaCB0aGlzIGxheWVyIGlzIGJlaW5nIGFkZGVkXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBsYXllclxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBvbkFkZChlLCB0KSB7XG4gICAgdGhpcy5tYXAgPSBlLCB0aGlzLnBsYW5lID0gVm8oe1xuICAgICAgZ2w6IHQsXG4gICAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2U6IHRjLFxuICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHJjLFxuICAgICAgYXR0cmlidXRlc0tleXM6IG5jLFxuICAgICAgdW5pZm9ybXNLZXlzOiBhYyxcbiAgICAgIHZlcnRpY2VzOiBvY1xuICAgIH0pLCB0aGlzLmFuaW1hdGVJbigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdyYWRpZW50IGNvbmZpZ3VyYXRpb24gb2YgdGhlIHJhZGlhbCBncmFkaWVudCBsYXllci5cbiAgICpcbiAgICogQHJldHVybnMge0dyYWRpZW50RGVmaW5pdGlvbn0gVGhlIGN1cnJlbnQgZ3JhZGllbnQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIGdldENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5ncmFkaWVudDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBncmFkaWVudCBuZWVkcyB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzcGVjaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0dyYWRpZW50RGVmaW5pdGlvbn0gc3BlYyAtIFRoZSBncmFkaWVudCBzcGVjaWZpY2F0aW9uIHRvIGNvbXBhcmUgd2l0aCB0aGUgY3VycmVudCBncmFkaWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdyYWRpZW50IG5lZWRzIHRvIGJlIHVwZGF0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHNob3VsZFVwZGF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgaWYgKGUgPT09IHZvaWQgMCAmJiB0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG4gPSBvcihlKSwgYSA9IG9yKHQpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuKSAhPT0gSlNPTi5zdHJpbmdpZnkoYSk7XG4gIH1cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSByYWRpYWwgZ3JhZGllbnQgaW50byB2aWV3IGJ5IGdyYWR1YWxseSBzY2FsaW5nIGZyb20gMCB0byB0aGUgdGFyZ2V0IHNjYWxlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB1c2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0byBjcmVhdGUgYSBzbW9vdGggc2NhbGluZyBhbmltYXRpb24gZWZmZWN0LlxuICAgKiBEdXJpbmcgZWFjaCBmcmFtZSwgaXQ6XG4gICAqICAgMS4gSW50ZXJwb2xhdGVzIHRoZSBzY2FsZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIHRoZSB0YXJnZXQgc2NhbGVcbiAgICogICAyLiBJbmNyZW1lbnRzIHRoZSBhbmltYXRpb24gcHJvZ3Jlc3MgKGFuaW1hdGlvbkRlbHRhKVxuICAgKiAgIDMuIFRyaWdnZXJzIGEgbWFwIHJlcGFpbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICovXG4gIGFzeW5jIGFuaW1hdGVJbigpIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0aW9uQWN0aXZlKSB7XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5ncmFkaWVudC5zY2FsZSwgdGhpcy5hbmltYXRpb25EZWx0YSA9IDEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgdGhpcy5hbmltYXRpb25EZWx0YSA9IDA7XG4gICAgICBjb25zdCB0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25EZWx0YSA8IDEpIHtcbiAgICAgICAgICB0aGlzLnNjYWxlID0gRmUoMCwgdGhpcy5ncmFkaWVudC5zY2FsZSwgdGhpcy5hbmltYXRpb25EZWx0YSksIHRoaXMuYW5pbWF0aW9uRGVsdGEgKz0gRGEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgdGhlIHJhZGlhbCBncmFkaWVudCBsYXllciBvdXQgYnkgZ3JhZHVhbGx5IHJlZHVjaW5nIGl0cyBzY2FsZSB0byB6ZXJvLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgc21vb3RoIHRyYW5zaXRpb24gZWZmZWN0IGJ5IGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHNjYWxlXG4gICAqIGZyb20gaXRzIGN1cnJlbnQgdmFsdWUgdG8gemVybyBvdmVyIG11bHRpcGxlIGFuaW1hdGlvbiBmcmFtZXMuIER1cmluZyBlYWNoIGZyYW1lLFxuICAgKiB0aGUgYW5pbWF0aW9uIHByb2dyZXNzZXMgYnkgaW5jcmVtZW50aW5nIHRoZSBpbnRlcm5hbCBhbmltYXRpb24gZGVsdGEgdmFsdWUuXG4gICAqXG4gICAqIFRoZSBtYXAgaXMgcmVwYWludGVkIGFmdGVyIGVhY2ggYW5pbWF0aW9uIHN0ZXAgdG8gcmVmbGVjdCB0aGUgdXBkYXRlZCBzY2FsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgYXN5bmMgYW5pbWF0ZU91dCgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25BY3RpdmUpXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25EZWx0YSA9IDAsIG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsdGEgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gRmUodGhpcy5ncmFkaWVudC5zY2FsZSwgMCwgdGhpcy5hbmltYXRpb25EZWx0YSksIHRoaXMuYW5pbWF0aW9uRGVsdGEgKz0gRGEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0KCk7XG4gICAgICB9KTtcbiAgfVxuICBvblJlbW92ZShlLCB0KSB7XG4gICAgdGhpcy5wbGFuZSAhPT0gdm9pZCAwICYmICh0LmRlbGV0ZVByb2dyYW0odGhpcy5wbGFuZS5zaGFkZXJQcm9ncmFtKSwgdC5kZWxldGVCdWZmZXIodGhpcy5wbGFuZS5wb3NpdGlvbkJ1ZmZlcikpO1xuICB9XG4gIHByZXJlbmRlcihlLCB0KSB7XG4gIH1cbiAgcmVuZGVyKGUsIHQpIHtcbiAgICBpZiAodGhpcy5tYXAgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSYWRpYWxHcmFkaWVudExheWVyXTogTWFwIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBpZiAoIXRoaXMubWFwLmlzR2xvYmVQcm9qZWN0aW9uKCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucGxhbmUgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSYWRpYWxHcmFkaWVudExheWVyXTogUGxhbmUgaXMgdW5kZWZpbmVkXCIpO1xuICAgIGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLCBlLmVuYWJsZShlLkJMRU5EKSwgZS51c2VQcm9ncmFtKHRoaXMucGxhbmUuc2hhZGVyUHJvZ3JhbSksIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUiwgdGhpcy5wbGFuZS5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgY29uc3QgbiA9IHRoaXMucGxhbmUucHJvZ3JhbUluZm8uYXR0cmlidXRlc0xvY2F0aW9ucy5wb3NpdGlvbjtcbiAgICBlLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG4pLCBlLnZlcnRleEF0dHJpYlBvaW50ZXIobiwgMywgZS5GTE9BVCwgITEsIDAsIDApO1xuICAgIGNvbnN0IGEgPSBndCgpLCBvID0gdGhpcy5zY2FsZTtcbiAgICBMdShhLCBhLCBbbywgbywgb10pO1xuICAgIGNvbnN0IGkgPSBndCgpO1xuICAgIGt1KGksIHQuZGVmYXVsdFByb2plY3Rpb25EYXRhLm1haW5NYXRyaXgsIGEpO1xuICAgIGNvbnN0IHMgPSB0aGlzLnBsYW5lLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLm1hdHJpeDtcbiAgICBlLnVuaWZvcm1NYXRyaXg0ZnYocywgITEsIGkpO1xuICAgIGNvbnN0IGwgPSBndCgpLCB1ID0gdGhpcy5tYXAudHJhbnNmb3JtLmNhbWVyYVBvc2l0aW9uLCBjID0gRnIoWnQoKSwgdSksIHAgPSBUdSgwLCAxLCAwKSwgZCA9IFp0KCk7XG4gICAgVGEoZCwgcCwgYyksIEZyKGQsIGQpO1xuICAgIGNvbnN0IGYgPSBadCgpO1xuICAgIFRhKGYsIGMsIGQpLCBGcihmLCBmKSwgeHUobCwgZFswXSwgZFsxXSwgZFsyXSwgMCwgZlswXSwgZlsxXSwgZlsyXSwgMCwgY1swXSwgY1sxXSwgY1syXSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgY29uc3QgaCA9IHRoaXMucGxhbmUucHJvZ3JhbUluZm8udW5pZm9ybXNMb2NhdGlvbnMucm90YXRpb25NYXRyaXg7XG4gICAgZS51bmlmb3JtTWF0cml4NGZ2KGgsICExLCBsKTtcbiAgICBjb25zdCBtID0gdGhpcy5ncmFkaWVudC5zdG9wcy5sZW5ndGgsIHkgPSBbXSwgdyA9IFtdO1xuICAgIGZvciAobGV0IHYgPSAwOyB2IDw9IG07IHYrKylcbiAgICAgIGlmICh2IDwgbSkge1xuICAgICAgICB5W3ZdID0gdGhpcy5ncmFkaWVudC5zdG9wc1t2XVswXTtcbiAgICAgICAgY29uc3QgeCA9IEt0KHRoaXMuZ3JhZGllbnQuc3RvcHNbdl1bMV0pO1xuICAgICAgICB3LnB1c2goLi4ueCk7XG4gICAgICB9XG4gICAgZS51bmlmb3JtMWkodGhpcy5wbGFuZS5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5zdG9wc051bWJlciwgbSksIGUudW5pZm9ybTFmdih0aGlzLnBsYW5lLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLnN0b3BzLCBuZXcgRmxvYXQzMkFycmF5KHkpKSwgZS51bmlmb3JtNGZ2KHRoaXMucGxhbmUucHJvZ3JhbUluZm8udW5pZm9ybXNMb2NhdGlvbnMuY29sb3JzLCBuZXcgRmxvYXQzMkFycmF5KHcpKSwgZS51bmlmb3JtMWYodGhpcy5wbGFuZS5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5tYXhEaXN0YW5jZSwgZHQpLCBlLnVuaWZvcm0xZih0aGlzLnBsYW5lLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLnNjYWxlLCBvKSwgZS5kcmF3QXJyYXlzKGUuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IGdyYWRpZW50IGZvciB0aGUgcmFkaWFsIGdyYWRpZW50IGxheWVyIGFuZCBhbmltYXRlcyB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgYW5pbWF0ZXMgdGhlIGN1cnJlbnQgZ3JhZGllbnQgb3V0LCB0aGVuIHVwZGF0ZXMgdGhlIGdyYWRpZW50XG4gICAqIHByb3BlcnR5IHdpdGggdGhlIG5ldyBncmFkaWVudCBkZWZpbml0aW9uLCBhbmQgZmluYWxseSBhbmltYXRlcyB0aGUgbmV3IGdyYWRpZW50IGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0dyYWRpZW50RGVmaW5pdGlvbn0gZ3JhZGllbnQgLSBUaGUgbmV3IGdyYWRpZW50IGRlZmluaXRpb24gdG8gc2V0IGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbmV3IGdyYWRpZW50IGlzIHNldCBhbmQgYW5pbWF0ZWQgaW4uXG4gICAqL1xuICBhc3luYyBzZXRHcmFkaWVudChlKSB7XG4gICAgaWYgKGUgPT09ICExKSB7XG4gICAgICBhd2FpdCB0aGlzLmFuaW1hdGVPdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hbmltYXRlT3V0KCk7XG4gICAgY29uc3QgdCA9IFVhKGUpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFtSYWRpYWxHcmFkaWVudExheWVyXTogSW52YWxpZCBIYWxvIHNwZWNpZmljYXRpb246XG4gLSAke3Quam9pbihgXG4gLSBgKX1cbiAgICBgKTtcbiAgICBlID09PSAhMCA/ICh0aGlzLmdyYWRpZW50LnNjYWxlID0gUWUuc2NhbGUsIHRoaXMuZ3JhZGllbnQuc3RvcHMgPSBRZS5zdG9wcykgOiAodGhpcy5ncmFkaWVudC5zY2FsZSA9IGUuc2NhbGUgPz8gUWUuc2NhbGUsIHRoaXMuZ3JhZGllbnQuc3RvcHMgPSBlLnN0b3BzID8/IFFlLnN0b3BzKSwgYXdhaXQgdGhpcy5hbmltYXRlSW4oKTtcbiAgfVxuICBzZXRBbmltYXRpb25BY3RpdmUoZSkge1xuICAgIHRoaXMuYW5pbWF0aW9uQWN0aXZlID0gZTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMubWFwLnNldExheW91dFByb3BlcnR5KHRoaXMuaWQsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eSh0aGlzLmlkLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xuICB9XG59XG5jb25zdCBpYyA9IFtcInNjYWxlXCIsIFwic3RvcHNcIl07XG5mdW5jdGlvbiBVYShyKSB7XG4gIHZhciB0O1xuICBjb25zdCBlID0gW107XG4gIGlmICh0eXBlb2YgciA9PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gW107XG4gIHRyeSB7XG4gICAgY29uc3QgbiA9IE9iamVjdC5rZXlzKHIpLmZpbHRlcigoYSkgPT4gIWljLmluY2x1ZGVzKGEpKTtcbiAgICBuLmxlbmd0aCA+IDAgJiYgZS5wdXNoKGBQcm9wZXJ0aWVzICR7bi5tYXAoKGEpID0+IGBcXGAke2F9XFxgYCkuam9pbihcIiwgXCIpfSBhcmUgbm90IHN1cHBvcnRlZC5gKTtcbiAgfSBjYXRjaCB7XG4gICAgZS5wdXNoKFwiSGFsbyBzcGVjaWZpY2F0aW9uIGlzIG5vdCBhbiBvYmplY3QuXCIpO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygci5zY2FsZSAhPSBcIm51bWJlclwiICYmIGUucHVzaChcIkhhbG8gYHNjYWxlYCBwcm9wZXJ0eSBpcyBub3QgYSBudW1iZXIuXCIpLCAoIXIuc3RvcHMgfHwgci5zdG9wcy5sZW5ndGggPT09IDApICYmIGUucHVzaChcIkhhbG8gYHN0b3BzYCBwcm9wZXJ0eSBpcyBub3QgYW4gYXJyYXkuXCIpLCAodCA9IHIuc3RvcHMpICE9IG51bGwgJiYgdC5zb21lKChuKSA9PiB0eXBlb2YgblswXSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBuWzFdICE9IFwic3RyaW5nXCIpICYmIGUucHVzaChcIkhhbG8gYHN0b3BzYCBwcm9wZXJ0eSBpcyBub3QgYW4gYXJyYXkgb2YgW251bWJlciwgc3RyaW5nXVwiKSwgZTtcbn1cbmNvbnN0IHNjID0ge1xuICBQT0lOVDogXCJQT0lOVFwiLFxuICBDT1VOVFJZOiBcIkNPVU5UUllcIlxufTtcbmxldCBHbyA9IGNsYXNzIEhvIGV4dGVuZHMgTC5NYXAge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgSGkodC5jb250YWluZXIpLCB0LmFwaUtleSAmJiAoai5hcGlLZXkgPSB0LmFwaUtleSk7XG4gICAgY29uc3QgeyBzdHlsZTogbiwgcmVxdWlyZXNVcmxNb25pdG9yaW5nOiBhLCBpc0ZhbGxiYWNrOiBvIH0gPSBrYSh0LnN0eWxlKTtcbiAgICBvICYmIGNvbnNvbGUud2FybihcbiAgICAgIFwiSW52YWxpZCBzdHlsZS4gQSBzdHlsZSBtdXN0IGJlIGEgdmFsaWQgVVJMIHRvIGEgc3R5bGUuanNvbiwgYSBKU09OIHN0cmluZyByZXByZXNlbnRpbmcgYSB2YWxpZCBTdHlsZVNwZWNpZmljYXRpb24gb3IgYSB2YWxpZCBTdHlsZVNwZWNpZmljYXRpb24gb2JqZWN0LiBGYWxsYmFjayB0byBkZWZhdWx0IE1hcFRpbGVyIHN0eWxlLlwiXG4gICAgKSwgai5hcGlLZXkgfHwgY29uc29sZS53YXJuKFwiTWFwVGlsZXIgQ2xvdWQgQVBJIGtleSBpcyBub3Qgc2V0LiBWaXNpdCBodHRwczovL21hcHRpbGVyLmNvbSBhbmQgdHJ5IENsb3VkIGZvciBmcmVlIVwiKTtcbiAgICBjb25zdCBpID0gbG9jYXRpb24uaGFzaDtcbiAgICBsZXQgcyA9IHtcbiAgICAgIGNvbXBhY3Q6ICExXG4gICAgfTtcbiAgICB0LmN1c3RvbUF0dHJpYnV0aW9uID8gcy5jdXN0b21BdHRyaWJ1dGlvbiA9IHQuY3VzdG9tQXR0cmlidXRpb24gOiB0LmF0dHJpYnV0aW9uQ29udHJvbCAmJiB0eXBlb2YgdC5hdHRyaWJ1dGlvbkNvbnRyb2wgPT0gXCJvYmplY3RcIiAmJiAocyA9IHtcbiAgICAgIC4uLnMsXG4gICAgICAuLi50LmF0dHJpYnV0aW9uQ29udHJvbFxuICAgIH0pO1xuICAgIGNvbnN0IGwgPSB7XG4gICAgICAuLi50LFxuICAgICAgc3R5bGU6IG4sXG4gICAgICBtYXBsaWJyZUxvZ286ICExLFxuICAgICAgdHJhbnNmb3JtUmVxdWVzdDogdGEodC50cmFuc2Zvcm1SZXF1ZXN0KSxcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogdC5mb3JjZU5vQXR0cmlidXRpb25Db250cm9sID09PSAhMCA/ICExIDogc1xuICAgIH07XG4gICAgZGVsZXRlIGwuc3R5bGU7XG4gICAgc3VwZXIobCk7XG4gICAgZyh0aGlzLCBcInRlbGVtZXRyeVwiKTtcbiAgICBnKHRoaXMsIFwic3BhY2VcIik7XG4gICAgZyh0aGlzLCBcImhhbG9cIik7XG4gICAgZyh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgZyh0aGlzLCBcImlzVGVycmFpbkVuYWJsZWRcIiwgITEpO1xuICAgIGcodGhpcywgXCJ0ZXJyYWluRXhhZ2dlcmF0aW9uXCIsIDEpO1xuICAgIGcodGhpcywgXCJwcmltYXJ5TGFuZ3VhZ2VcIik7XG4gICAgZyh0aGlzLCBcInRlcnJhaW5Hcm93aW5nXCIsICExKTtcbiAgICBnKHRoaXMsIFwidGVycmFpbkZsYXR0ZW5pbmdcIiwgITEpO1xuICAgIGcodGhpcywgXCJtaW5pbWFwXCIpO1xuICAgIGcodGhpcywgXCJmb3JjZUxhbmd1YWdlVXBkYXRlXCIpO1xuICAgIGcodGhpcywgXCJsYW5ndWFnZUFsd2F5c0JlZW5TdHlsZVwiKTtcbiAgICBnKHRoaXMsIFwiaXNSZWFkeVwiLCAhMSk7XG4gICAgZyh0aGlzLCBcInRlcnJhaW5BbmltYXRpb25EdXJhdGlvblwiLCAxZTMpO1xuICAgIGcodGhpcywgXCJtb25pdG9yZWRTdHlsZVVybHNcIik7XG4gICAgZyh0aGlzLCBcInN0eWxlSW5Qcm9jZXNzXCIsICExKTtcbiAgICBnKHRoaXMsIFwiY3VyZW50UHJvamVjdGlvblwiKTtcbiAgICBnKHRoaXMsIFwib3JpZ2luYWxMYWJlbFN0eWxlXCIsIG5ldyB3aW5kb3cuTWFwKCkpO1xuICAgIGcodGhpcywgXCJpc1N0eWxlTG9jYWxpemVkXCIsICExKTtcbiAgICBnKHRoaXMsIFwibGFuZ3VhZ2VJc1VwZGF0ZWRcIiwgITEpO1xuICAgIHRoaXMub3B0aW9ucyA9IHQsIHRoaXMuc2V0U3R5bGUobiksIGEgJiYgdGhpcy5tb25pdG9yU3R5bGVVcmwobik7XG4gICAgY29uc3QgdSA9ICgpID0+IHtcbiAgICAgIGxldCBoID0gXCJUaGUgZGlzdGFudCBzdHlsZSBjb3VsZCBub3QgYmUgbG9hZGVkLlwiO1xuICAgICAgdGhpcy5nZXRTdHlsZSgpID8gaCArPSBcIiBMZWF2aW5nIHRoZSBzdHlsZSBhcyBpcy5cIiA6ICh0aGlzLnNldFN0eWxlKGh0LlNUUkVFVFMpLCBoICs9IGBMb2FkaW5nIGRlZmF1bHQgTWFwVGlsZXIgQ2xvdWQgc3R5bGUgXCIke2h0LlNUUkVFVFMuZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRJZCgpfVwiIGFzIGEgZmFsbGJhY2suYCksIGNvbnNvbGUud2FybihoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm9uKFwic3R5bGUubG9hZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0eWxlSW5Qcm9jZXNzID0gITE7XG4gICAgfSksIHRoaXMub24oXCJlcnJvclwiLCAoaCkgPT4ge1xuICAgICAgaWYgKGNvbnNvbGUuZXJyb3IoaC5lcnJvciksIGguZXJyb3IgaW5zdGFuY2VvZiBMLkFKQVhFcnJvcikge1xuICAgICAgICBjb25zdCB5ID0gaC5lcnJvci51cmwsIHcgPSBuZXcgVVJMKHkpO1xuICAgICAgICB3LnNlYXJjaCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHYgPSB3LmhyZWY7XG4gICAgICAgIHRoaXMubW9uaXRvcmVkU3R5bGVVcmxzICYmIHRoaXMubW9uaXRvcmVkU3R5bGVVcmxzLmhhcyh2KSAmJiAodGhpcy5tb25pdG9yZWRTdHlsZVVybHMuZGVsZXRlKHYpLCB1KCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHlsZUluUHJvY2Vzcykge1xuICAgICAgICB1KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KSwgai5jYWNoaW5nICYmICFIciAmJiBjb25zb2xlLndhcm4oXCJUaGUgY2FjaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGluIHNlY3VyZSBjb250ZXh0cy4gTW9yZSBpbmZvIGF0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZVwiKSwgai5jYWNoaW5nICYmIEhyICYmIEJpKCksIHR5cGVvZiB0Lmxhbmd1YWdlID4gXCJ1XCIpXG4gICAgICB0aGlzLnByaW1hcnlMYW5ndWFnZSA9IGoucHJpbWFyeUxhbmd1YWdlO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaCA9IEtuKHQubGFuZ3VhZ2UsIHopO1xuICAgICAgdGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPSBoID8/IGoucHJpbWFyeUxhbmd1YWdlO1xuICAgIH1cbiAgICB0aGlzLmZvcmNlTGFuZ3VhZ2VVcGRhdGUgPSAhKHRoaXMucHJpbWFyeUxhbmd1YWdlID09PSB6LlNUWUxFIHx8IHRoaXMucHJpbWFyeUxhbmd1YWdlID09PSB6LlNUWUxFX0xPQ0spLCB0aGlzLmxhbmd1YWdlQWx3YXlzQmVlblN0eWxlID0gdGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPT09IHouU1RZTEUsIHRoaXMudGVycmFpbkV4YWdnZXJhdGlvbiA9IHQudGVycmFpbkV4YWdnZXJhdGlvbiA/PyB0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24sIHRoaXMuY3VyZW50UHJvamVjdGlvbiA9IHQucHJvamVjdGlvbiwgdGhpcy5vbihcInN0eWxlLmxvYWRcIiwgKGgpID0+IHtcbiAgICAgIHRoaXMuY3VyZW50UHJvamVjdGlvbiA9PT0gXCJtZXJjYXRvclwiID8gdGhpcy5zZXRQcm9qZWN0aW9uKHsgdHlwZTogXCJtZXJjYXRvclwiIH0pIDogdGhpcy5jdXJlbnRQcm9qZWN0aW9uID09PSBcImdsb2JlXCIgJiYgdGhpcy5zZXRQcm9qZWN0aW9uKHsgdHlwZTogXCJnbG9iZVwiIH0pO1xuICAgIH0pLCB0aGlzLm9uY2UoXCJzdHlsZWRhdGFcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0Lmdlb2xvY2F0ZSB8fCB0LmNlbnRlciB8fCB0Lmhhc2ggJiYgaSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHQuZ2VvbG9jYXRlID09PSBzYy5DT1VOVFJZKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5maXRUb0lwQm91bmRzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh5KSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih5Lm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbGV0IGg7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNlbnRlck9uSXBQb2ludCh0Lnpvb20pLCBoID0gdGhpcy5nZXRDYW1lcmFIYXNoKCk7XG4gICAgICB9IGNhdGNoICh5KSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih5Lm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgKGF3YWl0IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XG4gICAgICAgIG5hbWU6IFwiZ2VvbG9jYXRpb25cIlxuICAgICAgfSkpLnN0YXRlID09PSBcImdyYW50ZWRcIiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKFxuICAgICAgICAvLyBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICh5KSA9PiB7XG4gICAgICAgICAgaCA9PT0gdGhpcy5nZXRDYW1lcmFIYXNoKCkgJiYgKHRoaXMudGVycmFpbiA/IHRoaXMuZWFzZVRvKHtcbiAgICAgICAgICAgIGNlbnRlcjogW3kuY29vcmRzLmxvbmdpdHVkZSwgeS5jb29yZHMubGF0aXR1ZGVdLFxuICAgICAgICAgICAgem9vbTogdC56b29tIHx8IDEyLFxuICAgICAgICAgICAgZHVyYXRpb246IDJlM1xuICAgICAgICAgIH0pIDogdGhpcy5vbmNlKFwidGVycmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVhc2VUbyh7XG4gICAgICAgICAgICAgIGNlbnRlcjogW3kuY29vcmRzLmxvbmdpdHVkZSwgeS5jb29yZHMubGF0aXR1ZGVdLFxuICAgICAgICAgICAgICB6b29tOiB0Lnpvb20gfHwgMTIsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAyZTNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXJyb3IgY2FsbGJhY2tcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICB7XG4gICAgICAgICAgbWF4aW11bUFnZTogMjQgKiAzNjAwICogMWUzLFxuICAgICAgICAgIC8vIGEgZGF5IGluIG1pbGxpc2VjXG4gICAgICAgICAgdGltZW91dDogNWUzLFxuICAgICAgICAgIC8vIG1pbGxpc2Vjb25kc1xuICAgICAgICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogITFcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgdGhpcy5vbihcInN0eWxlZGF0YVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldFByaW1hcnlMYW5ndWFnZSh0aGlzLnByaW1hcnlMYW5ndWFnZSk7XG4gICAgfSksIHRoaXMub24oXCJzdHlsZWRhdGFcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5nZXRUZXJyYWluKCkgPT09IG51bGwgJiYgdGhpcy5pc1RlcnJhaW5FbmFibGVkICYmIHRoaXMuZW5hYmxlVGVycmFpbih0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24pO1xuICAgIH0pLCB0aGlzLm9uY2UoXCJsb2FkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBoID0geyBsb2dvOiBudWxsIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtID0gT2JqZWN0LmtleXModGhpcy5zdHlsZS5zb3VyY2VDYWNoZXMpLm1hcCgodikgPT4gdGhpcy5nZXRTb3VyY2UodikpLmZpbHRlcigodikgPT4gdiAmJiBcInVybFwiIGluIHYgJiYgdHlwZW9mIHYudXJsID09IFwic3RyaW5nXCIgJiYgdi51cmwuaW5jbHVkZXMoXCJ0aWxlcy5qc29uXCIpKSwgeSA9IG5ldyBVUkwobVswXS51cmwpO1xuICAgICAgICB5LnNlYXJjaFBhcmFtcy5oYXMoXCJrZXlcIikgfHwgeS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGouYXBpS2V5KSwgaCA9IGF3YWl0IChhd2FpdCBmZXRjaCh5LmhyZWYpKS5qc29uKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIGlmICh0LmN1c3RvbUNvbnRyb2xzKSB7XG4gICAgICAgIGNvbnN0IG0gPSBcIltkYXRhLW1hcHRpbGVyLWNvbnRyb2wtZ3JvdXBdXCIsIHkgPSBcIltkYXRhLW1hcHRpbGVyLWNvbnRyb2xdXCIsIHcgPSAoQykgPT4ge1xuICAgICAgICAgIGxldCBOID0gQy5kYXRhc2V0Lm1hcHRpbGVyQ29udHJvbDtcbiAgICAgICAgICByZXR1cm4gKE4gPT09IFwidHJ1ZVwiIHx8IE4gPT09IFwiXCIpICYmIChOID0gdm9pZCAwKSwgTjtcbiAgICAgICAgfSwgdiA9IChDKSA9PiBDLmRhdGFzZXQubWFwdGlsZXJQb3NpdGlvbjtcbiAgICAgICAgbGV0IHggPSBbLi4udGhpcy5fY29udGFpbmVyLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChtKV0sIEEgPSBbLi4udGhpcy5fY29udGFpbmVyLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh5KV0uZmlsdGVyKFxuICAgICAgICAgIChDKSA9PiBDLmNsb3Nlc3QobSkgPT09IG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0LmN1c3RvbUNvbnRyb2xzID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBDID0gdC5jdXN0b21Db250cm9scztcbiAgICAgICAgICB4ID0geC5maWx0ZXIoKE4pID0+IE4ubWF0Y2hlcyhDKSB8fCBOLmNsb3Nlc3QoQykgIT09IG51bGwpLCBBID0gQS5maWx0ZXIoKE4pID0+IE4ubWF0Y2hlcyhDKSB8fCBOLmNsb3Nlc3QoQykgIT09IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgQyBvZiB4KSB7XG4gICAgICAgICAgY29uc3QgTiA9IG5ldyB0bihDKTtcbiAgICAgICAgICB0aGlzLmFkZENvbnRyb2woTiwgdihDKSk7XG4gICAgICAgICAgZm9yIChjb25zdCBlZSBvZiBDLnF1ZXJ5U2VsZWN0b3JBbGwoeSkpXG4gICAgICAgICAgICBOLmNvbmZpZ3VyZUdyb3VwSXRlbShlZSwgdyhlZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgQyBvZiBBKVxuICAgICAgICAgIHRoaXMuYWRkQ29udHJvbChuZXcgdG4oQywgdyhDKSksIHYoQykpO1xuICAgICAgICBjb25zdCBFID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgbG5nOiBDLCBsYXQ6IE4gfSA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1jZW50ZXItbG5nXCIsIFN0cmluZyhDKSksIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbWFwdGlsZXItY2VudGVyLWxhdFwiLCBTdHJpbmcoTikpLCB0aGlzLl9jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLW1hcHRpbGVyLXpvb21cIiwgU3RyaW5nKHRoaXMuZ2V0Wm9vbSgpKSksIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbWFwdGlsZXItYmVhcmluZ1wiLCBTdHJpbmcodGhpcy5nZXRCZWFyaW5nKCkpKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1waXRjaFwiLCBTdHJpbmcodGhpcy5nZXRQaXRjaCgpKSksIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbWFwdGlsZXItcm9sbFwiLCBTdHJpbmcodGhpcy5nZXRSb2xsKCkpKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1pcy1nbG9iZS1wcm9qZWN0aW9uXCIsIFN0cmluZyh0aGlzLmlzR2xvYmVQcm9qZWN0aW9uKCkpKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1oYXMtdGVycmFpblwiLCBTdHJpbmcodGhpcy5oYXNUZXJyYWluKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgRSgpLCB0aGlzLm9uKFwicmVuZGVyXCIsIEUpO1xuICAgICAgfVxuICAgICAgaWYgKHQuZm9yY2VOb0F0dHJpYnV0aW9uQ29udHJvbCAhPT0gITApXG4gICAgICAgIGlmIChcImxvZ29cIiBpbiBoICYmIGgubG9nbykge1xuICAgICAgICAgIGNvbnN0IG0gPSBoLmxvZ287XG4gICAgICAgICAgdGhpcy5hZGRDb250cm9sKG5ldyBXbih7IGxvZ29VUkw6IG0gfSksIHQubG9nb1Bvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHQubWFwdGlsZXJMb2dvICYmIHRoaXMuYWRkQ29udHJvbChuZXcgV24oKSwgdC5sb2dvUG9zaXRpb24pO1xuICAgICAgaWYgKHQuc2NhbGVDb250cm9sKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0LnNjYWxlQ29udHJvbCA9PT0gITAgfHwgdC5zY2FsZUNvbnRyb2wgPT09IHZvaWQgMCA/IFwiYm90dG9tLXJpZ2h0XCIgOiB0LnNjYWxlQ29udHJvbCwgeSA9IG5ldyB6aSh7IHVuaXQ6IGoudW5pdCB9KTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHksIG0pLCBqLm9uKFwidW5pdFwiLCAodykgPT4ge1xuICAgICAgICAgIHkuc2V0VW5pdCh3KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodC5uYXZpZ2F0aW9uQ29udHJvbCAhPT0gITEpIHtcbiAgICAgICAgY29uc3QgbSA9IHQubmF2aWdhdGlvbkNvbnRyb2wgPT09ICEwIHx8IHQubmF2aWdhdGlvbkNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiB0Lm5hdmlnYXRpb25Db250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IHl1KCksIG0pO1xuICAgICAgfVxuICAgICAgaWYgKHQuZ2VvbG9jYXRlQ29udHJvbCAhPT0gITEpIHtcbiAgICAgICAgY29uc3QgbSA9IHQuZ2VvbG9jYXRlQ29udHJvbCA9PT0gITAgfHwgdC5nZW9sb2NhdGVDb250cm9sID09PSB2b2lkIDAgPyBcInRvcC1yaWdodFwiIDogdC5nZW9sb2NhdGVDb250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2woXG4gICAgICAgICAgLy8gbmV3IG1hcGxpYnJlZ2wuR2VvbG9jYXRlQ29udHJvbCh7XG4gICAgICAgICAgbmV3IHZ1KHtcbiAgICAgICAgICAgIHBvc2l0aW9uT3B0aW9uczoge1xuICAgICAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6ICEwLFxuICAgICAgICAgICAgICBtYXhpbXVtQWdlOiAwLFxuICAgICAgICAgICAgICB0aW1lb3V0OiA2ZTNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRCb3VuZHNPcHRpb25zOiB7XG4gICAgICAgICAgICAgIG1heFpvb206IDE1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2tVc2VyTG9jYXRpb246ICEwLFxuICAgICAgICAgICAgc2hvd0FjY3VyYWN5Q2lyY2xlOiAhMCxcbiAgICAgICAgICAgIHNob3dVc2VyTG9jYXRpb246ICEwXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHQudGVycmFpbkNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgbSA9IHQudGVycmFpbkNvbnRyb2wgPT09ICEwIHx8IHQudGVycmFpbkNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiB0LnRlcnJhaW5Db250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IG11KCksIG0pO1xuICAgICAgfVxuICAgICAgaWYgKHQucHJvamVjdGlvbkNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgbSA9IHQucHJvamVjdGlvbkNvbnRyb2wgPT09ICEwIHx8IHQucHJvamVjdGlvbkNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiB0LnByb2plY3Rpb25Db250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IHd1KCksIG0pO1xuICAgICAgfVxuICAgICAgaWYgKHQuZnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgbSA9IHQuZnVsbHNjcmVlbkNvbnRyb2wgPT09ICEwIHx8IHQuZnVsbHNjcmVlbkNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiB0LmZ1bGxzY3JlZW5Db250cm9sO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IE9pKHt9KSwgbSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzUmVhZHkgPSAhMCwgdGhpcy5maXJlKFwicmVhZHlcIiwgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgfSk7XG4gICAgbGV0IGMgPSAhMSwgcCA9ICExLCBkO1xuICAgIHRoaXMub25jZShcInJlYWR5XCIsICgpID0+IHtcbiAgICAgIGMgPSAhMCwgcCAmJiB0aGlzLmZpcmUoXCJsb2FkV2l0aFRlcnJhaW5cIiwgZCk7XG4gICAgfSksIHRoaXMub25jZShcInN0eWxlLmxvYWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtaW5pbWFwOiBoIH0gPSB0O1xuICAgICAgaWYgKHR5cGVvZiBoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHpvb206IG0sXG4gICAgICAgICAgY2VudGVyOiB5LFxuICAgICAgICAgIHN0eWxlOiB3LFxuICAgICAgICAgIGxhbmd1YWdlOiB2LFxuICAgICAgICAgIGFwaUtleTogeCxcbiAgICAgICAgICBtYXB0aWxlckxvZ286IEEsXG4gICAgICAgICAgY2FudmFzQ29udGV4dEF0dHJpYnV0ZXM6IEUsXG4gICAgICAgICAgcmVmcmVzaEV4cGlyZWRUaWxlczogQyxcbiAgICAgICAgICBtYXhCb3VuZHM6IE4sXG4gICAgICAgICAgc2Nyb2xsWm9vbTogZWUsXG4gICAgICAgICAgbWluWm9vbTogTGUsXG4gICAgICAgICAgbWF4Wm9vbTogRWUsXG4gICAgICAgICAgYm94Wm9vbTogVixcbiAgICAgICAgICBsb2NhbGU6IGJlLFxuICAgICAgICAgIGZhZGVEdXJhdGlvbjogenQsXG4gICAgICAgICAgY3Jvc3NTb3VyY2VDb2xsaXNpb25zOiBPdCxcbiAgICAgICAgICBjbGlja1RvbGVyYW5jZTogJHQsXG4gICAgICAgICAgYm91bmRzOiBGdCxcbiAgICAgICAgICBmaXRCb3VuZHNPcHRpb25zOiBOdCxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBqdCxcbiAgICAgICAgICB2YWxpZGF0ZVN0eWxlOiBEdFxuICAgICAgICB9ID0gdDtcbiAgICAgICAgdGhpcy5taW5pbWFwID0gbmV3ICRyKGgsIHtcbiAgICAgICAgICB6b29tOiBtLFxuICAgICAgICAgIGNlbnRlcjogeSxcbiAgICAgICAgICBzdHlsZTogdyxcbiAgICAgICAgICBsYW5ndWFnZTogdixcbiAgICAgICAgICBhcGlLZXk6IHgsXG4gICAgICAgICAgY29udGFpbmVyOiBcIm51bGxcIixcbiAgICAgICAgICBtYXB0aWxlckxvZ286IEEsXG4gICAgICAgICAgY2FudmFzQ29udGV4dEF0dHJpYnV0ZXM6IEUsXG4gICAgICAgICAgcmVmcmVzaEV4cGlyZWRUaWxlczogQyxcbiAgICAgICAgICBtYXhCb3VuZHM6IE4sXG4gICAgICAgICAgc2Nyb2xsWm9vbTogZWUsXG4gICAgICAgICAgbWluWm9vbTogTGUsXG4gICAgICAgICAgbWF4Wm9vbTogRWUsXG4gICAgICAgICAgYm94Wm9vbTogVixcbiAgICAgICAgICBsb2NhbGU6IGJlLFxuICAgICAgICAgIGZhZGVEdXJhdGlvbjogenQsXG4gICAgICAgICAgY3Jvc3NTb3VyY2VDb2xsaXNpb25zOiBPdCxcbiAgICAgICAgICBjbGlja1RvbGVyYW5jZTogJHQsXG4gICAgICAgICAgYm91bmRzOiBGdCxcbiAgICAgICAgICBmaXRCb3VuZHNPcHRpb25zOiBOdCxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBqdCxcbiAgICAgICAgICB2YWxpZGF0ZVN0eWxlOiBEdFxuICAgICAgICB9KSwgdGhpcy5hZGRDb250cm9sKHRoaXMubWluaW1hcCwgaC5wb3NpdGlvbiA/PyBcImJvdHRvbS1sZWZ0XCIpO1xuICAgICAgfSBlbHNlIGggPT09ICEwID8gKHRoaXMubWluaW1hcCA9IG5ldyAkcih7fSwgdCksIHRoaXMuYWRkQ29udHJvbCh0aGlzLm1pbmltYXAsIFwiYm90dG9tLWxlZnRcIikpIDogaCAhPT0gdm9pZCAwICYmIGggIT09ICExICYmICh0aGlzLm1pbmltYXAgPSBuZXcgJHIoe30sIHQpLCB0aGlzLmFkZENvbnRyb2wodGhpcy5taW5pbWFwLCBoKSk7XG4gICAgfSk7XG4gICAgY29uc3QgZiA9IChoKSA9PiB7XG4gICAgICBoLnRlcnJhaW4gJiYgKHAgPSAhMCwgZCA9IHtcbiAgICAgICAgdHlwZTogXCJsb2FkV2l0aFRlcnJhaW5cIixcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICB0ZXJyYWluOiBoLnRlcnJhaW5cbiAgICAgIH0sIHRoaXMub2ZmKFwidGVycmFpblwiLCBmKSwgYyAmJiB0aGlzLmZpcmUoXCJsb2FkV2l0aFRlcnJhaW5cIiwgZCkpO1xuICAgIH07XG4gICAgdGhpcy5vbihcInRlcnJhaW5cIiwgZiksIHQudGVycmFpbiAmJiB0aGlzLmVuYWJsZVRlcnJhaW4odC50ZXJyYWluRXhhZ2dlcmF0aW9uID8/IHRoaXMudGVycmFpbkV4YWdnZXJhdGlvbiksIHRoaXMub25jZShcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5nZXRDYW52YXMoKS5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCAoaCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fcmVtb3ZlZCA9PT0gITApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbd2ViZ2xjb250ZXh0bG9zdF1cIiwgXCJXZWJHTCBjb250ZXh0IGxvc3QgYWZ0ZXIgbWFwIHJlbW92YWwuIFRoaXMgaXMgaGFybWxlc3MuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJbd2ViZ2xjb250ZXh0bG9zdF1cIiwgXCJVbmV4cGVjdGVkIGxvc3Mgb2YgV2ViR0wgY29udGV4dCFcIiksIHRoaXMuZmlyZShcIndlYmdsQ29udGV4dExvc3RcIiwgaCk7XG4gICAgICB9KSwgdC5oYWxvICYmIHRoaXMuaW5pdEhhbG8oeyBvcHRpb25zOiB0LCBiZWZvcmU6IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVswXSB9KSwgdC5zcGFjZSAmJiB0aGlzLmluaXRTcGFjZSh7IG9wdGlvbnM6IHQsIGJlZm9yZTogdGhpcy5nZXRMYXllcnNPcmRlcigpWzBdIH0pO1xuICAgIH0pLCB0aGlzLnRlbGVtZXRyeSA9IG5ldyBTdSh0aGlzKTtcbiAgfVxuICBnZXRTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFjZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3BhY2UgZm9yIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7Q3ViZW1hcERlZmluaXRpb259IHNwYWNlIHRoZSBgQ3ViZW1hcERlZmluaXRpb25gIG9wdGlvbnMgdG8gc2V0LlxuICAgKiBAcmVtYXJrcyBUaGlzIG1ldGhvZCwgYXQgcHJlc2VudCwgKiogb3ZlcndyaXRlcyAqKiB0aGUgY3VycmVudCBjb25maWcuXG4gICAqIElmIGFuIG9wdGlvbiBpcyBub3Qgc2V0IGl0IHdpbGwgaW50ZXJuYWxseSByZXZlcnQgdG8gdGhlIGRlZmF1bHQgb3B0aW9uXG4gICAqIHVubGVzcyBleHBsaWNpdGx5IHNldCB3aGVuIGNhbGxpbmcuXG4gICAqL1xuICBzZXRTcGFjZSh0LCBuID0gITApIHtcbiAgICBpZiAobiAmJiAodGhpcy5vcHRpb25zLnNwYWNlID0gdCksIHQgPT09ICExKSB7XG4gICAgICB0aGlzLnNwYWNlID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcGFjZSkge1xuICAgICAgdGhpcy5zcGFjZS5zZXRDdWJlbWFwKHQpLCB0aGlzLmdldExheWVyKHRoaXMuc3BhY2UuaWQpIHx8IHRoaXMuYWRkTGF5ZXIodGhpcy5zcGFjZSwgdGhpcy5nZXRMYXllcnNPcmRlcigpWzBdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zcGFjZSA9IG5ldyBCcih0KSwgdGhpcy5vbmNlKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBhID0gdGhpcy5nZXRMYXllcnNPcmRlcigpWzBdO1xuICAgICAgdGhpcy5zcGFjZSAmJiB0aGlzLmFkZExheWVyKHRoaXMuc3BhY2UsIGEpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgc3BhY2UgbGF5ZXIuXG4gICAqL1xuICBlbmFibGVTcGFjZUFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRTcGFjZUFuaW1hdGlvbkFjdGl2ZSghMCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgc3BhY2UgbGF5ZXIuXG4gICAqL1xuICBkaXNhYmxlU3BhY2VBbmltYXRpb25zKCkge1xuICAgIHRoaXMuc2V0U3BhY2VBbmltYXRpb25BY3RpdmUoITEpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgaGFsbyBsYXllci5cbiAgICovXG4gIGVuYWJsZUhhbG9BbmltYXRpb25zKCkge1xuICAgIHRoaXMuc2V0SGFsb0FuaW1hdGlvbkFjdGl2ZSghMCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgaGFsbyBsYXllci5cbiAgICovXG4gIGRpc2FibGVIYWxvQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLnNldEhhbG9BbmltYXRpb25BY3RpdmUoITEpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIGhhbG8gbGF5ZXIgc2hvdWxkIGJlIGFuaW1hdGVkIGluIGFuZCBvdXQuXG4gICAqIEBwYXJhbSBhY3RpdmUgLSBXaGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICovXG4gIHNldEhhbG9BbmltYXRpb25BY3RpdmUodCkge1xuICAgIHRoaXMuaGFsbyA/IHRoaXMuaGFsby5zZXRBbmltYXRpb25BY3RpdmUodCkgOiB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgKG4gPSB0aGlzLmhhbG8pID09IG51bGwgfHwgbi5zZXRBbmltYXRpb25BY3RpdmUodCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgc3BhY2UgbGF5ZXIgc2hvdWxkIGJlIGFuaW1hdGVkIGluIGFuZCBvdXQuXG4gICAqIEBwYXJhbSBhY3RpdmUgLSBXaGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICovXG4gIHNldFNwYWNlQW5pbWF0aW9uQWN0aXZlKHQpIHtcbiAgICB0aGlzLnNwYWNlID8gdGhpcy5zcGFjZS5zZXRBbmltYXRpb25BY3RpdmUodCkgOiB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgKG4gPSB0aGlzLnNwYWNlKSA9PSBudWxsIHx8IG4uc2V0QW5pbWF0aW9uQWN0aXZlKHQpO1xuICAgIH0pO1xuICB9XG4gIHNldFNwYWNlRnJvbVNwZWMoeyBzcGVjOiB0IH0pIHtcbiAgICB2YXIgbztcbiAgICBpZiAodGhpcy5vcHRpb25zLnNwYWNlID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRoaXMuc2V0U3BhY2UodCwgITApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNwYWNlICE9PSAhMCAmJiBybih0aGlzLm9wdGlvbnMuc3BhY2UpKSB7XG4gICAgICB0aGlzLnNldFNwYWNlKHRoaXMub3B0aW9ucy5zcGFjZSwgITApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gcm4odCk7XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KChvID0gdGhpcy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0Q29uZmlnKCkpID09PSBKU09OLnN0cmluZ2lmeSh0KSkge1xuICAgICAgaWYgKHRoaXMuc3BhY2UgJiYgIXRoaXMuZ2V0TGF5ZXIodGhpcy5zcGFjZS5pZCkpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVswXTtcbiAgICAgICAgdGhpcy5hZGRMYXllcih0aGlzLnNwYWNlLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4pIHtcbiAgICAgIHRoaXMuc2V0U3BhY2UodCwgITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNwYWNlID09PSAhMCkge1xuICAgICAgdGhpcy5zZXRTcGFjZSghMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgoKSA9PiB7XG4gICAgICB0aGlzLnNwYWNlICYmIHRoaXMuaXNHbG9iZVByb2plY3Rpb24oKSAmJiB0aGlzLnNwYWNlLnNldEN1YmVtYXAodCk7XG4gICAgfSkoKTtcbiAgfVxuICBzZXRIYWxvRnJvbVNwZWMoeyBzcGVjOiB0IH0pIHtcbiAgICB2YXIgYSwgbztcbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbG8gPT09ICExKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9wdGlvbnMuaGFsbyBpcyBmYWxzZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0ID09IFwiYm9vbGVhblwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNwZWMgaXMgYm9vbGVhblwiLCB0KSwgdGhpcy5zZXRIYWxvKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoKGEgPSB0aGlzLmhhbG8pID09IG51bGwgPyB2b2lkIDAgOiBhLmdldENvbmZpZygpKSA9PT0gSlNPTi5zdHJpbmdpZnkodCkpIHtcbiAgICAgIGlmIChjb25zb2xlLmxvZyhcIkhBTE8gSVMgVEhFIFNBTUVcIiwgdCksIHRoaXMuaGFsbyAmJiAhdGhpcy5nZXRMYXllcih0aGlzLmhhbG8uaWQpKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmdldExheWVyc09yZGVyKCkuaW5kZXhPZigoKG8gPSB0aGlzLnNwYWNlKSA9PSBudWxsID8gdm9pZCAwIDogby5pZCkgPz8gXCJcIikgKyAxLCBzID0gdGhpcy5nZXRMYXllcnNPcmRlcigpW2ldO1xuICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdCAmJiAhdGhpcy5vcHRpb25zLmhhbG8pIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic3BlYyBpcyBmYWxzZSwgYW5kIG9wdGlvbnMuaGFsbyBpcyBmYWxzZVwiKSwgdGhpcy5zZXRIYWxvKHtcbiAgICAgICAgc3RvcHM6IFtcbiAgICAgICAgICBbMCwgXCJ0cmFuc3BhcmVudFwiXSxcbiAgICAgICAgICBbMSwgXCJ0cmFuc3BhcmVudFwiXVxuICAgICAgICBdLFxuICAgICAgICBzY2FsZTogMVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgoKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmIChjb25zb2xlLmxvZyhcInVwZGF0ZUhhbG9cIiwgdCksIHRoaXMuaGFsbykge1xuICAgICAgICBpZiAoY29uc29sZS5sb2coXCJoYWxvIGV4aXN0c1wiLCB0aGlzLmdldExheWVyKHRoaXMuaGFsby5pZCkpLCAhdGhpcy5nZXRMYXllcih0aGlzLmhhbG8uaWQpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJoYWxvIG5vdCBpbiBtYXAsIGFkZGluZyBpdFwiKTtcbiAgICAgICAgICBjb25zdCBzID0gdGhpcy5nZXRMYXllcnNPcmRlcigpLmluZGV4T2YoKChpID0gdGhpcy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaWQpID8/IFwiXCIpICsgMSwgbCA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVtzXTtcbiAgICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgbCk7XG4gICAgICAgIH1cbiAgICAgICAgdCAmJiAoY29uc29sZS5sb2coXCJTRVQgSEFMTyBGUk9NIFNQRUNcIiwgdCksIHRoaXMuaGFsby5zZXRHcmFkaWVudCh0KSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuICBpbml0U3BhY2UoeyBvcHRpb25zOiB0ID0gdGhpcy5vcHRpb25zLCBiZWZvcmU6IG4gPSB0aGlzLmdldExheWVyc09yZGVyKClbMF0sIHNwZWM6IGEgfSkge1xuICAgIGlmICh0aGlzLnNwYWNlKSB7XG4gICAgICB0aGlzLmdldExheWVyKHRoaXMuc3BhY2UuaWQpIHx8IHRoaXMuYWRkTGF5ZXIodGhpcy5zcGFjZSwgbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0LnNwYWNlID09PSAhMSkgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBhO1xuICAgIGlmICh0LnNwYWNlKSB7XG4gICAgICB0aGlzLnNwYWNlID0gbmV3IEJyKHQuc3BhY2UpLCB0aGlzLmFkZExheWVyKHRoaXMuc3BhY2UsIG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvICYmICh0aGlzLnNwYWNlID0gbmV3IEJyKG8pLCB0aGlzLmFkZExheWVyKHRoaXMuc3BhY2UsIG4pKTtcbiAgfVxuICBpbml0SGFsbyh7IG9wdGlvbnM6IHQgPSB0aGlzLm9wdGlvbnMsIGJlZm9yZTogbiA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVswXSwgc3BlYzogYSB9KSB7XG4gICAgaWYgKHRoaXMuaGFsbyAmJiB0aGlzLmdldExheWVyKHRoaXMuaGFsby5pZCkgfHwgdC5oYWxvID09PSAhMSkgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBhO1xuICAgIGlmICh0LmhhbG8pIHtcbiAgICAgIHRoaXMuaGFsbyA9IG5ldyBxcih0LmhhbG8pLCB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG8gJiYgKHRoaXMuaGFsbyA9IG5ldyBxcihvKSwgdGhpcy5hZGRMYXllcih0aGlzLmhhbG8sIG4pKTtcbiAgfVxuICBnZXRIYWxvKCkge1xuICAgIHJldHVybiB0aGlzLmhhbG87XG4gIH1cbiAgc2V0SGFsbyh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYWxvID0gdCwgISF0aGlzLmlzR2xvYmVQcm9qZWN0aW9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmhhbG8pIHtcbiAgICAgICAgdGhpcy5oYWxvLnNldEdyYWRpZW50KHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhhbG8gPSBuZXcgcXIodCksIHRoaXMub25jZShcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICB2YXIgcztcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKSwgYSA9IG5bMF0sIG8gPSBuLmluZGV4T2YoKChzID0gdGhpcy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaWQpID8/IFwiXCIpICsgMiwgaSA9IG5bb107XG4gICAgICAgIHRoaXMuaGFsbyAmJiB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgdGhpcy5zcGFjZSA/IGkgOiBhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVjcmVhdGVzIHRoZSBtYXAgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBvcHRpb25zLlxuICAgKiBVc2VmdWwgZm9yIFdlYkdMIGNvbnRleHQgbG9zcy5cbiAgICovXG4gIHJlY3JlYXRlKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICBjZW50ZXI6IHRoaXMuZ2V0Q2VudGVyKCksXG4gICAgICB6b29tOiB0aGlzLmdldFpvb20oKSxcbiAgICAgIGJlYXJpbmc6IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgcGl0Y2g6IHRoaXMuZ2V0UGl0Y2goKVxuICAgIH07XG4gICAgdGhpcy5yZW1vdmUoKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBuZXcgSG8oeyAuLi50aGlzLm9wdGlvbnMgfSkpLCB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuanVtcFRvKHQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGR1cmF0aW9uIChtaWxsaXNlYykgb2YgdGhlIHRlcnJhaW4gYW5pbWF0aW9uIGZvciBncm93aW5nIG9yIGZsYXR0ZW5pbmcuXG4gICAqIE11c3QgYmUgcG9zaXRpdmUuIChCdWlsdC1pbiBkZWZhdWx0OiBgMTAwMGAgbWlsbGlzZWNvbmRzKVxuICAgKi9cbiAgc2V0VGVycmFpbkFuaW1hdGlvbkR1cmF0aW9uKHQpIHtcbiAgICB0aGlzLnRlcnJhaW5BbmltYXRpb25EdXJhdGlvbiA9IE1hdGgubWF4KHQsIDApO1xuICB9XG4gIC8qKlxuICAgKiBBd2FpdHMgZm9yIF90aGlzXyBNYXAgaW5zdGFuY2UgdG8gYmUgXCJsb2FkZWRcIiBhbmQgcmV0dXJucyBhIFByb21pc2UgdG8gdGhlIE1hcC5cbiAgICogSWYgX3RoaXNfIE1hcCBpbnN0YW5jZSBpcyBhbHJlYWR5IGxvYWRlZCwgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQgZGlyZWN0bHksXG4gICAqIG90aGVyd2lzZSwgaXQgaXMgcmVzb2x2ZWQgYXMgYSByZXN1bHQgb2YgdGhlIFwibG9hZFwiIGV2ZW50LlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgb25Mb2FkQXN5bmMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2FkZWQoKSkge1xuICAgICAgICB0KHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBd2FpdHMgZm9yIF90aGlzXyBNYXAgaW5zdGFuY2UgdG8gYmUgXCJyZWFkeVwiIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0byB0aGUgTWFwLlxuICAgKiBJZiBfdGhpc18gTWFwIGluc3RhbmNlIGlzIGFscmVhZHkgcmVhZHksIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkIGRpcmVjdGx5LFxuICAgKiBvdGhlcndpc2UsIGl0IGlzIHJlc29sdmVkIGFzIGEgcmVzdWx0IG9mIHRoZSBcInJlYWR5XCIgZXZlbnQuXG4gICAqIEEgbWFwIGluc3RhbmNlIGlzIFwicmVhZHlcIiB3aGVuIGFsbCB0aGUgY29udHJvbHMgdGhhdCBjYW4gYmUgbWFuYWdlZCBieSB0aGUgY29udHJ1Y3RvciBhcmVcbiAgICogZGVhbHQgd2l0aC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBcImxvYWRcIiBldmVudCwgZHVlIHRvIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlXG4gICAqIG9mIHNvbWUgYnVpbHQtaW4gY29udHJvbHMuXG4gICAqL1xuICBhc3luYyBvblJlYWR5QXN5bmMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1JlYWR5KSB7XG4gICAgICAgIHQodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25jZShcInJlYWR5XCIsICgpID0+IHtcbiAgICAgICAgdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBd2FpdHMgZm9yIF90aGlzXyBNYXAgaW5zdGFuY2UgdG8gYmUgXCJsb2FkZWRcIiBhcyB3ZWxsIGFzIHdpdGggdGVycmFpbiBiZWluZyBub24tbnVsbCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICogYW5kIHJldHVybnMgYSBQcm9taXNlIHRvIHRoZSBNYXAuXG4gICAqIElmIF90aGlzXyBNYXAgaW5zdGFuY2UgaXMgYWxyZWFkeSBsb2FkZWQgd2l0aCB0ZXJyYWluLCB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZCBkaXJlY3RseSxcbiAgICogb3RoZXJ3aXNlLCBpdCBpcyByZXNvbHZlZCBhcyBhIHJlc3VsdCBvZiB0aGUgXCJsb2FkV2l0aFRlcnJhaW5cIiBldmVudC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIG9uTG9hZFdpdGhUZXJyYWluQXN5bmMoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1JlYWR5ICYmIHRoaXMudGVycmFpbikge1xuICAgICAgICB0KHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uY2UoXCJsb2FkV2l0aFRlcnJhaW5cIiwgKCkgPT4ge1xuICAgICAgICB0KHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbW9uaXRvclN0eWxlVXJsKHQpIHtcbiAgICB0eXBlb2YgdGhpcy5tb25pdG9yZWRTdHlsZVVybHMgPiBcInVcIiAmJiAodGhpcy5tb25pdG9yZWRTdHlsZVVybHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBjb25zdCBuID0gbmV3IFVSTCh0KTtcbiAgICBuLnNlYXJjaCA9IFwiXCIsIHRoaXMubW9uaXRvcmVkU3R5bGVVcmxzLmFkZChuLmhyZWYpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHN0eWxlIG9mIHRoZSBtYXAuXG4gICAqIENhbiBiZTpcbiAgICogLSBhIGZ1bGwgc3R5bGUgVVJMIChwb3NzaWJseSB3aXRoIEFQSSBrZXkpXG4gICAqIC0gYSBzaG9ydGhhbmQgd2l0aCBvbmx5IHRoZSBNYXBUSWxlciBzdHlsZSBuYW1lIChlZy4gYFwic3RyZWV0cy12MlwiYClcbiAgICogLSBhIGxvbmdlciBmb3JtIHdpdGggdGhlIHByZWZpeCBgXCJtYXB0aWxlcjovL1wiYCAoZWcuIGBcIm1hcHRpbGVyOi8vc3RyZWV0cy12MlwiYClcbiAgICovXG4gIHNldFN0eWxlKHQsIG4gPSB7fSkge1xuICAgIHZhciBzLCBsLCB1LCBjLCBwO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICB0cmFuc2Zvcm1TdHlsZTogKGQsIGYpID0+IHtcbiAgICAgICAgdmFyIEUsIEMsIE4sIGVlLCBMZSwgRWUsIFYsIGJlLCB6dCwgT3QsICR0LCBGdCwgTnQsIGp0LCBEdCwgam4sIERuLCBVbiwgQm4sIHFuLCBWbiwgR247XG4gICAgICAgIGNvbnN0IGggPSAhKChDID0gKEUgPSBmID09IG51bGwgPyB2b2lkIDAgOiBmLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogRS5tYXB0aWxlcikgIT0gbnVsbCAmJiBDLnNwYWNlKSAmJiAhISgoZWUgPSAoTiA9IGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBOLm1hcHRpbGVyKSAhPSBudWxsICYmIGVlLnNwYWNlKSwgbSA9ICEoKEVlID0gKExlID0gZiA9PSBudWxsID8gdm9pZCAwIDogZi5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IExlLm1hcHRpbGVyKSAhPSBudWxsICYmIEVlLmhhbG8pICYmICEhKChiZSA9IChWID0gZCA9PSBudWxsID8gdm9pZCAwIDogZC5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IFYubWFwdGlsZXIpICE9IG51bGwgJiYgYmUuaGFsbyk7XG4gICAgICAgIGggJiYgKGNvbnNvbGUudHJhY2UoXCJzcGFjZSBoYXMgYmVlbiByZW1vdmVkIGZyb20gc3R5bGUsIHJlbW92aW5nIGl0XCIpLCAoenQgPSB0aGlzLnNwYWNlKSA9PSBudWxsIHx8IHp0Lm9uUmVtb3ZlKHRoaXMsIHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dChcIndlYmdsMlwiKSksIHRoaXMuc3BhY2UgPSB2b2lkIDApLCBtICYmIChjb25zb2xlLnRyYWNlKFwiaGFsbyBoYXMgYmVlbiByZW1vdmVkIGZyb20gc3R5bGUsIHJlbW92aW5nIGl0XCIpLCAoT3QgPSB0aGlzLmhhbG8pID09IG51bGwgfHwgT3Qub25SZW1vdmUodGhpcywgdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KFwid2ViZ2wyXCIpKSwgdGhpcy5oYWxvID0gdm9pZCAwKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuc3BhY2UgPyB0aGlzLnNwYWNlLnNob3VsZFVwZGF0ZSgoRnQgPSAoJHQgPSBmID09IG51bGwgPyB2b2lkIDAgOiBmLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogJHQubWFwdGlsZXIpID09IG51bGwgPyB2b2lkIDAgOiBGdC5zcGFjZSkgOiAhMCwgdyA9IHRoaXMuaGFsbyA/IHRoaXMuaGFsby5zaG91bGRVcGRhdGUoKGp0ID0gKE50ID0gZiA9PSBudWxsID8gdm9pZCAwIDogZi5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IE50Lm1hcHRpbGVyKSA9PSBudWxsID8gdm9pZCAwIDoganQuaGFsbykgOiAhMCwgdiA9ICgoRHQgPSBkID09IG51bGwgPyB2b2lkIDAgOiBkLnRlcnJhaW4pID09IG51bGwgPyB2b2lkIDAgOiBEdC5zb3VyY2UpICE9PSAoKGpuID0gZiA9PSBudWxsID8gdm9pZCAwIDogZi50ZXJyYWluKSA9PSBudWxsID8gdm9pZCAwIDogam4uc291cmNlKSB8fCAoKERuID0gZCA9PSBudWxsID8gdm9pZCAwIDogZC50ZXJyYWluKSA9PSBudWxsID8gdm9pZCAwIDogRG4uZXhhZ2dlcmF0aW9uKSAhPT0gKChVbiA9IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYudGVycmFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IFVuLmV4YWdnZXJhdGlvbiksIHggPSB5IHx8IHYsIEEgPSB3IHx8IHY7XG4gICAgICAgIGlmICh4KVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBDZSA9ICgocW4gPSAoQm4gPSBmID09IG51bGwgPyB2b2lkIDAgOiBmLm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogQm4ubWFwdGlsZXIpID09IG51bGwgPyB2b2lkIDAgOiBxbi5zcGFjZSkgPz8gITE7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJzdHlsZS5sb2FkXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIGN0O1xuICAgICAgICAgICAgICB0aGlzLmdldExheWVyKCgoY3QgPSB0aGlzLnNwYWNlKSA9PSBudWxsID8gdm9pZCAwIDogY3QuaWQpID8/IFwiXCIpID8gdGhpcy5zZXRTcGFjZUZyb21TcGVjKHsgc3BlYzogQ2UgfSkgOiB0aGlzLmluaXRTcGFjZSh7IHNwZWM6IENlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoQ2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoQ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKEEpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IENlID0gKChHbiA9IChWbiA9IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYubWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBWbi5tYXB0aWxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IEduLmhhbG8pID8/ICExO1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwic3R5bGUubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBjdDtcbiAgICAgICAgICAgICAgdGhpcy5nZXRMYXllcigoKGN0ID0gdGhpcy5oYWxvKSA9PSBudWxsID8gdm9pZCAwIDogY3QuaWQpID8/IFwiXCIpID8gdGhpcy5zZXRIYWxvRnJvbVNwZWMoeyBzcGVjOiBDZSB9KSA6IHRoaXMuaW5pdEhhbG8oeyBzcGVjOiBDZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKENlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKENlKTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRpZmY6ICEwLFxuICAgICAgLi4ublxuICAgIH07XG4gICAgdGhpcy5vcmlnaW5hbExhYmVsU3R5bGUuY2xlYXIoKSwgKHMgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgcy5zZXRTdHlsZSh0LCB7fSksIHRoaXMuZm9yY2VMYW5ndWFnZVVwZGF0ZSA9ICEwLCB0aGlzLm9uY2UoXCJpZGxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZm9yY2VMYW5ndWFnZVVwZGF0ZSA9ICExO1xuICAgIH0pO1xuICAgIGNvbnN0IGkgPSBrYSh0KTtcbiAgICBpZiAoaS5yZXF1aXJlc1VybE1vbml0b3JpbmcgJiYgdGhpcy5tb25pdG9yU3R5bGVVcmwoaS5zdHlsZSksIGkuaXNGYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0U3R5bGUoKSlcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIltNYXAuc2V0U3R5bGVdOiBJbnZhbGlkIHN0eWxlLiBBIHN0eWxlIG11c3QgYmUgYSB2YWxpZCBVUkwgdG8gYSBzdHlsZS5qc29uLCBhIEpTT04gc3RyaW5nIHJlcHJlc2VudGluZyBhIHZhbGlkIFN0eWxlU3BlY2lmaWNhdGlvbiBvciBhIHZhbGlkIFN0eWxlU3BlY2lmaWNhdGlvbiBvYmplY3QuIEtlZXBpbmcgdGhlIGN1cmVudCBzdHlsZSBpbnN0ZWFkLlwiXG4gICAgICAgICksIHRoaXM7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW01hcC5zZXRTdHlsZV06IEludmFsaWQgc3R5bGUuIEEgc3R5bGUgbXVzdCBiZSBhIHZhbGlkIFVSTCB0byBhIHN0eWxlLmpzb24sIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdmFsaWQgU3R5bGVTcGVjaWZpY2F0aW9uIG9yIGEgdmFsaWQgU3R5bGVTcGVjaWZpY2F0aW9uIG9iamVjdC4gRmFsbGJhY2sgdG8gZGVmYXVsdCBNYXBUaWxlciBzdHlsZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHN1cGVyLnNldFN0eWxlKGkuc3R5bGUsIG8pLCB0aGlzLnN0eWxlSW5Qcm9jZXNzID0gITA7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgdGhpcy5zdHlsZUluUHJvY2VzcyA9ICExLCBjb25zb2xlLmVycm9yKFwiW01hcC5zZXRTdHlsZV06IEVycm9yIHdoaWxlIHNldHRpbmcgc3R5bGU6XCIsIGQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKGkuaXNKU09OKSB7XG4gICAgICAgIGNvbnN0IGQgPSAodSA9IChsID0gaS5zdHlsZS5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwubWFwdGlsZXIpID09IG51bGwgPyB2b2lkIDAgOiB1LmhhbG8sIGYgPSAocCA9IChjID0gaS5zdHlsZS5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGMubWFwdGlsZXIpID09IG51bGwgPyB2b2lkIDAgOiBwLnNwYWNlO1xuICAgICAgICBkICYmIHRoaXMuc2V0SGFsbyhkKSwgZiAmJiB0aGlzLnNldFNwYWNlKGYpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTWFwLnNldFN0eWxlXTogRXJyb3Igd2hpbGUgc2V0dGluZyBoYWxvIG9yIHNwYWNlIGZyb20gc3R5bGU6XCIsIGQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIFtNYXBMaWJyZSBzdHlsZSBsYXllcl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy9sYXllcnMpXG4gICAqIHRvIHRoZSBtYXAncyBzdHlsZS5cbiAgICpcbiAgICogQSBsYXllciBkZWZpbmVzIGhvdyBkYXRhIGZyb20gYSBzcGVjaWZpZWQgc291cmNlIHdpbGwgYmUgc3R5bGVkLiBSZWFkIG1vcmUgYWJvdXQgbGF5ZXIgdHlwZXNcbiAgICogYW5kIGF2YWlsYWJsZSBwYWludCBhbmQgbGF5b3V0IHByb3BlcnRpZXMgaW4gdGhlIFtNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjL2xheWVycykuXG4gICAqXG4gICAqIEBwYXJhbSBsYXllciAtIFRoZSBsYXllciB0byBhZGQsXG4gICAqIGNvbmZvcm1pbmcgdG8gZWl0aGVyIHRoZSBNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uJ3MgW2xheWVyIGRlZmluaXRpb25dKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvbGF5ZXJzKSBvcixcbiAgICogbGVzcyBjb21tb25seSwgdGhlIHtAbGluayBDdXN0b21MYXllckludGVyZmFjZX0gc3BlY2lmaWNhdGlvbi5cbiAgICogVGhlIE1hcExpYnJlIFN0eWxlIFNwZWNpZmljYXRpb24ncyBsYXllciBkZWZpbml0aW9uIGlzIGFwcHJvcHJpYXRlIGZvciBtb3N0IGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIGJlZm9yZUlkIC0gVGhlIElEIG9mIGFuIGV4aXN0aW5nIGxheWVyIHRvIGluc2VydCB0aGUgbmV3IGxheWVyIGJlZm9yZSxcbiAgICogcmVzdWx0aW5nIGluIHRoZSBuZXcgbGF5ZXIgYXBwZWFyaW5nIHZpc3VhbGx5IGJlbmVhdGggdGhlIGV4aXN0aW5nIGxheWVyLlxuICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBsYXllciB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxheWVycyBhcnJheVxuICAgKiBhbmQgYXBwZWFyIHZpc3VhbGx5IGFib3ZlIGFsbCBvdGhlciBsYXllcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKi9cbiAgYWRkTGF5ZXIodCwgbikge1xuICAgIHZhciBhO1xuICAgIHJldHVybiAoYSA9IHRoaXMubWluaW1hcCkgPT0gbnVsbCB8fCBhLmFkZExheWVyKHQsIG4pLCBzdXBlci5hZGRMYXllcih0LCBuKTtcbiAgfVxuICAvKipcbiAgICogTW92ZXMgYSBsYXllciB0byBhIGRpZmZlcmVudCB6LXBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIG1vdmUuXG4gICAqIEBwYXJhbSBiZWZvcmVJZCAtIFRoZSBJRCBvZiBhbiBleGlzdGluZyBsYXllciB0byBpbnNlcnQgdGhlIG5ldyBsYXllciBiZWZvcmUuIFdoZW4gdmlld2luZyB0aGUgbWFwLCB0aGUgYGlkYCBsYXllciB3aWxsIGFwcGVhciBiZW5lYXRoIHRoZSBgYmVmb3JlSWRgIGxheWVyLiBJZiBgYmVmb3JlSWRgIGlzIG9taXR0ZWQsIHRoZSBsYXllciB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxheWVycyBhcnJheSBhbmQgYXBwZWFyIGFib3ZlIGFsbCBvdGhlciBsYXllcnMgb24gdGhlIG1hcC5cbiAgICogQHJldHVybnMgYHRoaXNgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIE1vdmUgYSBsYXllciB3aXRoIElEICdwb2x5Z29uJyBiZWZvcmUgdGhlIGxheWVyIHdpdGggSUQgJ2NvdW50cnktbGFiZWwnLiBUaGUgYHBvbHlnb25gIGxheWVyIHdpbGwgYXBwZWFyIGJlbmVhdGggdGhlIGBjb3VudHJ5LWxhYmVsYCBsYXllciBvbiB0aGUgbWFwLlxuICAgKiBgYGB0c1xuICAgKiBtYXAubW92ZUxheWVyKCdwb2x5Z29uJywgJ2NvdW50cnktbGFiZWwnKTtcbiAgICogYGBgXG4gICAqL1xuICBtb3ZlTGF5ZXIodCwgbikge1xuICAgIHZhciBhO1xuICAgIHJldHVybiAoYSA9IHRoaXMubWluaW1hcCkgPT0gbnVsbCB8fCBhLm1vdmVMYXllcih0LCBuKSwgc3VwZXIubW92ZUxheWVyKHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBJRCBmcm9tIHRoZSBtYXAncyBzdHlsZS5cbiAgICpcbiAgICogQW4ge0BsaW5rIEVycm9yRXZlbnR9IHdpbGwgYmUgZmlyZWQgaWYgdGhlIGltYWdlIHBhcmFtZXRlciBpcyBpbnZhbGQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBJZiBhIGxheWVyIHdpdGggSUQgJ3N0YXRlLWRhdGEnIGV4aXN0cywgcmVtb3ZlIGl0LlxuICAgKiBgYGB0c1xuICAgKiBpZiAobWFwLmdldExheWVyKCdzdGF0ZS1kYXRhJykpIG1hcC5yZW1vdmVMYXllcignc3RhdGUtZGF0YScpO1xuICAgKiBgYGBcbiAgICovXG4gIHJlbW92ZUxheWVyKHQpIHtcbiAgICB2YXIgbjtcbiAgICByZXR1cm4gKG4gPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgbi5yZW1vdmVMYXllcih0KSwgc3VwZXIucmVtb3ZlTGF5ZXIodCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHpvb20gZXh0ZW50IGZvciB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLiBUaGUgem9vbSBleHRlbnQgaW5jbHVkZXMgdGhlXG4gICAqIFttaW5pbXVtIHpvb20gbGV2ZWxdKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvbGF5ZXJzLyNtaW56b29tKVxuICAgKiBhbmQgW21heGltdW0gem9vbSBsZXZlbF0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy9sYXllcnMvI21heHpvb20pKVxuICAgKiBhdCB3aGljaCB0aGUgbGF5ZXIgd2lsbCBiZSByZW5kZXJlZC5cbiAgICpcbiAgICogTm90ZTogRm9yIHN0eWxlIGxheWVycyB1c2luZyB2ZWN0b3Igc291cmNlcywgc3R5bGUgbGF5ZXJzIGNhbm5vdCBiZSByZW5kZXJlZCBhdCB6b29tIGxldmVscyBsb3dlciB0aGFuIHRoZVxuICAgKiBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIF9zb3VyY2UgbGF5ZXJfIGJlY2F1c2UgdGhlIGRhdGEgZG9lcyBub3QgZXhpc3QgYXQgdGhvc2Ugem9vbSBsZXZlbHMuIElmIHRoZSBtaW5pbXVtXG4gICAqIHpvb20gbGV2ZWwgb2YgdGhlIHNvdXJjZSBsYXllciBpcyBoaWdoZXIgdGhhbiB0aGUgbWluaW11bSB6b29tIGxldmVsIGRlZmluZWQgaW4gdGhlIHN0eWxlIGxheWVyLCB0aGUgc3R5bGVcbiAgICogbGF5ZXIgd2lsbCBub3QgYmUgcmVuZGVyZWQgYXQgYWxsIHpvb20gbGV2ZWxzIGluIHRoZSB6b29tIHJhbmdlLlxuICAgKi9cbiAgc2V0TGF5ZXJab29tUmFuZ2UodCwgbiwgYSkge1xuICAgIHZhciBvO1xuICAgIHJldHVybiAobyA9IHRoaXMubWluaW1hcCkgPT0gbnVsbCB8fCBvLnNldExheWVyWm9vbVJhbmdlKHQsIG4sIGEpLCBzdXBlci5zZXRMYXllclpvb21SYW5nZSh0LCBuLCBhKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVyIGZvciB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLlxuICAgKlxuICAgKiBGaWx0ZXJzIGNvbnRyb2wgd2hpY2ggZmVhdHVyZXMgYSBzdHlsZSBsYXllciByZW5kZXJzIGZyb20gaXRzIHNvdXJjZS5cbiAgICogQW55IGZlYXR1cmUgZm9yIHdoaWNoIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYHRydWVgIHdpbGwgYmVcbiAgICogcmVuZGVyZWQgb24gdGhlIG1hcC4gVGhvc2UgdGhhdCBhcmUgZmFsc2Ugd2lsbCBiZSBoaWRkZW4uXG4gICAqXG4gICAqIFVzZSBgc2V0RmlsdGVyYCB0byBzaG93IGEgc3Vic2V0IG9mIHlvdXIgc291cmNlIGRhdGEuXG4gICAqXG4gICAqIFRvIGNsZWFyIHRoZSBmaWx0ZXIsIHBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuICAgKi9cbiAgc2V0RmlsdGVyKHQsIG4sIGEpIHtcbiAgICB2YXIgbztcbiAgICByZXR1cm4gKG8gPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgby5zZXRGaWx0ZXIodCwgbiwgYSksIHN1cGVyLnNldEZpbHRlcih0LCBuLCBhKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwYWludCBwcm9wZXJ0eSBpbiB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0gbGF5ZXJJZCAtIFRoZSBJRCBvZiB0aGUgbGF5ZXIgdG8gc2V0IHRoZSBwYWludCBwcm9wZXJ0eSBpbi5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFpbnQgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHBhaW50IHByb3BlcnR5IHRvIHNldC5cbiAgICogTXVzdCBiZSBvZiBhIHR5cGUgYXBwcm9wcmlhdGUgZm9yIHRoZSBwcm9wZXJ0eSwgYXMgZGVmaW5lZCBpbiB0aGUgW01hcExpYnJlIFN0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvKS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybnMgYHRoaXNgXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIG1hcC5zZXRQYWludFByb3BlcnR5KCdteS1sYXllcicsICdmaWxsLWNvbG9yJywgJyNmYWFmZWUnKTtcbiAgICogYGBgXG4gICAqL1xuICBzZXRQYWludFByb3BlcnR5KHQsIG4sIGEsIG8pIHtcbiAgICB2YXIgaTtcbiAgICByZXR1cm4gKGkgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgaS5zZXRQYWludFByb3BlcnR5KHQsIG4sIGEsIG8pLCBzdXBlci5zZXRQYWludFByb3BlcnR5KHQsIG4sIGEsIG8pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGxheW91dCBwcm9wZXJ0eSBpbiB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLlxuICAgKiBMYXlvdXQgcHJvcGVydGllcyBkZWZpbmUgaG93IHRoZSBsYXllciBpcyBzdHlsZWQuXG4gICAqIExheW91dCBwcm9wZXJ0aWVzIGZvciBsYXllcnMgb2YgdGhlIHNhbWUgdHlwZSBhcmUgZG9jdW1lbnRlZCB0b2dldGhlci5cbiAgICogTGF5ZXJzIG9mIGRpZmZlcmVudCB0eXBlcyBoYXZlIGRpZmZlcmVudCBsYXlvdXQgcHJvcGVydGllcy5cbiAgICogU2VlIHRoZSBbTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy8pIGZvciB0aGUgY29tcGxldGUgbGlzdCBvZiBsYXlvdXQgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIGxheWVySWQgLSBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHNldCB0aGUgbGF5b3V0IHByb3BlcnR5IGluLlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsYXlvdXQgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGxheW91dCBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIE11c3QgYmUgb2YgYSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHksIGFzIGRlZmluZWQgaW4gdGhlIFtNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjLykuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKi9cbiAgc2V0TGF5b3V0UHJvcGVydHkodCwgbiwgYSwgbykge1xuICAgIHZhciBpO1xuICAgIHJldHVybiAoaSA9IHRoaXMubWluaW1hcCkgPT0gbnVsbCB8fCBpLnNldExheW91dFByb3BlcnR5KHQsIG4sIGEsIG8pLCBzdXBlci5zZXRMYXlvdXRQcm9wZXJ0eSh0LCBuLCBhLCBvKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlJ3MgZ2x5cGhzIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gZ2x5cGhzVXJsIC0gR2x5cGggVVJMIHRvIHNldC4gTXVzdCBjb25mb3JtIHRvIHRoZSBbTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy9nbHlwaHMvKS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybnMgYHRoaXNgXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIG1hcC5zZXRHbHlwaHMoJ2h0dHBzOi8vZGVtb3RpbGVzLm1hcGxpYnJlLm9yZy9mb250L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2V0R2x5cGhzKHQsIG4pIHtcbiAgICB2YXIgYTtcbiAgICByZXR1cm4gKGEgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgYS5zZXRHbHlwaHModCwgbiksIHN1cGVyLnNldEdseXBocyh0LCBuKTtcbiAgfVxuICBnZXRTdHlsZUxhbmd1YWdlKCkge1xuICAgIHJldHVybiAhdGhpcy5zdHlsZSB8fCAhdGhpcy5zdHlsZS5zdHlsZXNoZWV0IHx8ICF0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGEgfHwgdHlwZW9mIHRoaXMuc3R5bGUuc3R5bGVzaGVldC5tZXRhZGF0YSAhPSBcIm9iamVjdFwiID8gbnVsbCA6IFwibWFwdGlsZXI6bGFuZ3VhZ2VcIiBpbiB0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGEgJiYgdHlwZW9mIHRoaXMuc3R5bGUuc3R5bGVzaGVldC5tZXRhZGF0YVtcIm1hcHRpbGVyOmxhbmd1YWdlXCJdID09IFwic3RyaW5nXCIgPyBfaSh0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGFbXCJtYXB0aWxlcjpsYW5ndWFnZVwiXSkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIHByaW1hcnkgbGFuZ3VhZ2Ugb2YgdGhlIG1hcC4gTm90ZSB0aGF0IG5vdCBhbGwgdGhlIGxhbmd1YWdlcyBzaG9ydGhhbmRzIHByb3ZpZGVkIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzZXRMYW5ndWFnZSh0KSB7XG4gICAgdmFyIG47XG4gICAgKG4gPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgbi5tYXAuc2V0TGFuZ3VhZ2UodCksIHRoaXMub25TdHlsZVJlYWR5KCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UHJpbWFyeUxhbmd1YWdlKHQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgdGhlIHByaW1hcnkgbGFuZ3VhZ2Ugb2YgdGhlIG1hcC4gTm90ZSB0aGF0IG5vdCBhbGwgdGhlIGxhbmd1YWdlcyBzaG9ydGhhbmRzIHByb3ZpZGVkIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzZXRQcmltYXJ5TGFuZ3VhZ2UodCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldFN0eWxlTGFuZ3VhZ2UoKSwgYSA9IEtuKHQsIHopO1xuICAgIGlmICghYSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbGFuZ3VhZ2UgXCIke2F9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoYS5mbGFnID09PSB6LlNUWUxFLmZsYWcgJiYgbiAmJiAobi5mbGFnID09PSB6LkFVVE8uZmxhZyB8fCBuLmZsYWcgPT09IHouVklTSVRPUi5mbGFnKSkgJiYgKGEuZmxhZyAhPT0gei5TVFlMRS5mbGFnICYmICh0aGlzLmxhbmd1YWdlQWx3YXlzQmVlblN0eWxlID0gITEpLCB0aGlzLmxhbmd1YWdlQWx3YXlzQmVlblN0eWxlIHx8IHRoaXMucHJpbWFyeUxhbmd1YWdlID09PSBhICYmICF0aGlzLmZvcmNlTGFuZ3VhZ2VVcGRhdGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnByaW1hcnlMYW5ndWFnZS5mbGFnID09PSB6LlNUWUxFX0xPQ0suZmxhZykge1xuICAgICAgY29uc29sZS53YXJuKFwiVGhlIGxhbmd1YWdlIGNhbm5vdCBiZSBjaGFuZ2VkIGJlY2F1c2UgdGhpcyBtYXAgaGFzIGJlZW4gaW5zdGFudGlhdGVkIHdpdGggdGhlIFNUWUxFX0xPQ0sgbGFuZ3VhZ2UgZmxhZy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJpbWFyeUxhbmd1YWdlID0gYTtcbiAgICBsZXQgbyA9IGE7XG4gICAgaWYgKGEuZmxhZyA9PT0gei5TVFlMRS5mbGFnKSB7XG4gICAgICBpZiAoIW4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIHN0eWxlIGhhcyBubyBkZWZhdWx0IGxhbmd1YWdlcyBvciBoYXMgYW4gaW52YWxpZCBvbmUuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvID0gbjtcbiAgICB9XG4gICAgbGV0IGkgPSB6LkxPQ0FMLmZsYWcsIHMgPSBbXCJnZXRcIiwgaV07XG4gICAgby5mbGFnID09PSB6LlZJU0lUT1IuZmxhZyA/IChpID0gWW4oKS5mbGFnLCBzID0gW1xuICAgICAgXCJjYXNlXCIsXG4gICAgICBbXCJhbGxcIiwgW1wiaGFzXCIsIGldLCBbXCJoYXNcIiwgei5MT0NBTC5mbGFnXV0sXG4gICAgICBbXG4gICAgICAgIFwiY2FzZVwiLFxuICAgICAgICBbXCI9PVwiLCBbXCJnZXRcIiwgaV0sIFtcImdldFwiLCB6LkxPQ0FMLmZsYWddXSxcbiAgICAgICAgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ10sXG4gICAgICAgIFtcImZvcm1hdFwiLCBbXCJnZXRcIiwgaV0sIHsgXCJmb250LXNjYWxlXCI6IDAuOCB9LCBgXG5gLCBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXSwgeyBcImZvbnQtc2NhbGVcIjogMS4xIH1dXG4gICAgICBdLFxuICAgICAgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ11cbiAgICBdKSA6IG8uZmxhZyA9PT0gei5WSVNJVE9SX0VOR0xJU0guZmxhZyA/IChpID0gei5FTkdMSVNILmZsYWcsIHMgPSBbXG4gICAgICBcImNhc2VcIixcbiAgICAgIFtcImFsbFwiLCBbXCJoYXNcIiwgaV0sIFtcImhhc1wiLCB6LkxPQ0FMLmZsYWddXSxcbiAgICAgIFtcbiAgICAgICAgXCJjYXNlXCIsXG4gICAgICAgIFtcIj09XCIsIFtcImdldFwiLCBpXSwgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ11dLFxuICAgICAgICBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXSxcbiAgICAgICAgW1wiZm9ybWF0XCIsIFtcImdldFwiLCBpXSwgeyBcImZvbnQtc2NhbGVcIjogMC44IH0sIGBcbmAsIFtcImdldFwiLCB6LkxPQ0FMLmZsYWddLCB7IFwiZm9udC1zY2FsZVwiOiAxLjEgfV1cbiAgICAgIF0sXG4gICAgICBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXVxuICAgIF0pIDogby5mbGFnID09PSB6LkFVVE8uZmxhZyA/IChpID0gWW4oKS5mbGFnLCBzID0gW1wiY29hbGVzY2VcIiwgW1wiZ2V0XCIsIGldLCBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXV0pIDogbyA9PT0gei5MT0NBTCA/IChpID0gei5MT0NBTC5mbGFnLCBzID0gW1wiZ2V0XCIsIGldKSA6IChpID0gby5mbGFnLCBzID0gW1wiY29hbGVzY2VcIiwgW1wiZ2V0XCIsIGldLCBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXV0pO1xuICAgIGNvbnN0IHsgbGF5ZXJzOiBsIH0gPSB0aGlzLmdldFN0eWxlKCksIHUgPSB0aGlzLm9yaWdpbmFsTGFiZWxTdHlsZS5zaXplID09PSAwO1xuICAgIGlmICh1KSB7XG4gICAgICBjb25zdCBjID0gUWkobCwgdGhpcyk7XG4gICAgICB0aGlzLmlzU3R5bGVMb2NhbGl6ZWQgPSBPYmplY3Qua2V5cyhjLmxvY2FsaXplZCkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjIG9mIGwpIHtcbiAgICAgIGlmIChjLnR5cGUgIT09IFwic3ltYm9sXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcCA9IGMsIGQgPSB0aGlzLmdldFNvdXJjZShwLnNvdXJjZSk7XG4gICAgICBpZiAoIWQgfHwgIShcInVybFwiIGluIGQgJiYgdHlwZW9mIGQudXJsID09IFwic3RyaW5nXCIpIHx8IG5ldyBVUkwoZC51cmwpLmhvc3QgIT09IEoubWFwdGlsZXJBcGlIb3N0KVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHsgaWQ6IGgsIGxheW91dDogbSB9ID0gcDtcbiAgICAgIGlmICghbSB8fCAhKFwidGV4dC1maWVsZFwiIGluIG0pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGxldCB5O1xuICAgICAgaWYgKHUgPyAoeSA9IHRoaXMuZ2V0TGF5b3V0UHJvcGVydHkoaCwgXCJ0ZXh0LWZpZWxkXCIpLCB0aGlzLm9yaWdpbmFsTGFiZWxTdHlsZS5zZXQoaCwgeSkpIDogeSA9IHRoaXMub3JpZ2luYWxMYWJlbFN0eWxlLmdldChoKSwgdHlwZW9mIHkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5zOiB3LCBleGFjdE1hdGNoOiB2IH0gPSBLaSh5LCB0aGlzLmlzU3R5bGVMb2NhbGl6ZWQpO1xuICAgICAgICBpZiAoIXcpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodilcbiAgICAgICAgICB0aGlzLnNldExheW91dFByb3BlcnR5KGgsIFwidGV4dC1maWVsZFwiLCBzKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgeCA9IFhpKHksIHMsIHRoaXMuaXNTdHlsZUxvY2FsaXplZCk7XG4gICAgICAgICAgdGhpcy5zZXRMYXlvdXRQcm9wZXJ0eShoLCBcInRleHQtZmllbGRcIiwgeCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHcgPSBaaSh5LCBzLCB0aGlzLmlzU3R5bGVMb2NhbGl6ZWQpO1xuICAgICAgICB0aGlzLnNldExheW91dFByb3BlcnR5KGgsIFwidGV4dC1maWVsZFwiLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sYW5ndWFnZUlzVXBkYXRlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaW1hcnkgbGFuZ3VhZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFByaW1hcnlMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmltYXJ5TGFuZ3VhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZXhhZ2dlcmF0aW9uIGZhY3RvciBhcHBsaWVkIHRvIHRoZSB0ZXJyYWluXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRUZXJyYWluRXhhZ2dlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIEtub3cgaWYgdGVycmlhbiBpcyBlbmFibGVkIG9yIG5vdFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVGVycmFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1RlcnJhaW5FbmFibGVkO1xuICB9XG4gIGdyb3dUZXJyYWluKHQpIHtcbiAgICBpZiAoIXRoaXMudGVycmFpbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gcGVyZm9ybWFuY2Uubm93KCksIGEgPSB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uLCBvID0gdCAtIGEsIGkgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudGVycmFpbiB8fCB0aGlzLnRlcnJhaW5GbGF0dGVuaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBzID0gKHBlcmZvcm1hbmNlLm5vdygpIC0gbikgLyB0aGlzLnRlcnJhaW5BbmltYXRpb25EdXJhdGlvbjtcbiAgICAgIGlmIChzIDwgMC45OSkge1xuICAgICAgICBjb25zdCBsID0gMSAtICgxIC0gcykgKiogNCwgdSA9IGEgKyBsICogbztcbiAgICAgICAgdGhpcy50ZXJyYWluLmV4YWdnZXJhdGlvbiA9IHUsIHJlcXVlc3RBbmltYXRpb25GcmFtZShpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnRlcnJhaW5Hcm93aW5nID0gITEsIHRoaXMudGVycmFpbkZsYXR0ZW5pbmcgPSAhMSwgdGhpcy50ZXJyYWluLmV4YWdnZXJhdGlvbiA9IHQsIHRoaXMuZmlyZShcInRlcnJhaW5BbmltYXRpb25TdG9wXCIsIHsgdGVycmFpbjogdGhpcy50ZXJyYWluIH0pO1xuICAgICAgdGhpcy5fZWxldmF0aW9uRnJlZXplID0gITEsIHRoaXMudHJpZ2dlclJlcGFpbnQoKTtcbiAgICB9O1xuICAgICF0aGlzLnRlcnJhaW5Hcm93aW5nICYmICF0aGlzLnRlcnJhaW5GbGF0dGVuaW5nICYmIHRoaXMuZmlyZShcInRlcnJhaW5BbmltYXRpb25TdGFydFwiLCB7IHRlcnJhaW46IHRoaXMudGVycmFpbiB9KSwgdGhpcy50ZXJyYWluR3Jvd2luZyA9ICEwLCB0aGlzLnRlcnJhaW5GbGF0dGVuaW5nID0gITEsIHJlcXVlc3RBbmltYXRpb25GcmFtZShpKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgM0QgdGVycmFpbiB2aXN1YWxpemF0aW9uXG4gICAqL1xuICBlbmFibGVUZXJyYWluKHQgPSB0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24pIHtcbiAgICBpZiAodCA8IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRlcnJhaW4gZXhhZ2dlcmF0aW9uIGNhbm5vdCBiZSBuZWdhdGl2ZS5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG4gPSAobykgPT4ge1xuICAgICAgIXRoaXMudGVycmFpbiB8fCBvLnR5cGUgIT09IFwiZGF0YVwiIHx8IG8uZGF0YVR5cGUgIT09IFwic291cmNlXCIgfHwgIShcInNvdXJjZVwiIGluIG8pIHx8IG8uc291cmNlSWQgIT09IFwibWFwdGlsZXItdGVycmFpblwiIHx8IG8uc291cmNlLnR5cGUgIT09IFwicmFzdGVyLWRlbVwiIHx8IG8uaXNTb3VyY2VMb2FkZWQgJiYgKHRoaXMub2ZmKFwiZGF0YVwiLCBuKSwgdGhpcy5ncm93VGVycmFpbih0KSk7XG4gICAgfSwgYSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNUZXJyYWluRW5hYmxlZCA9ICEwLCB0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24gPSB0LCB0aGlzLm9uKFwiZGF0YVwiLCBuKSwgdGhpcy5hZGRTb3VyY2UoSi50ZXJyYWluU291cmNlSWQsIHtcbiAgICAgICAgdHlwZTogXCJyYXN0ZXItZGVtXCIsXG4gICAgICAgIHVybDogSi50ZXJyYWluU291cmNlVVJMXG4gICAgICB9KSwgdGhpcy5zZXRUZXJyYWluKHtcbiAgICAgICAgc291cmNlOiBKLnRlcnJhaW5Tb3VyY2VJZCxcbiAgICAgICAgZXhhZ2dlcmF0aW9uOiAwXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmdldFRlcnJhaW4oKSkge1xuICAgICAgdGhpcy5pc1RlcnJhaW5FbmFibGVkID0gITAsIHRoaXMuZ3Jvd1RlcnJhaW4odCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmxvYWRlZCgpIHx8IHRoaXMuaXNUZXJyYWluRW5hYmxlZClcbiAgICAgIGEoKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0VGVycmFpbigpICYmIHRoaXMuZ2V0U291cmNlKEoudGVycmFpblNvdXJjZUlkKSB8fCBhKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIG8oKTtcbiAgICAgIH0pLCB0aGlzLm9uY2UoXCJtb3ZlZW5kXCIsICgpID0+IHtcbiAgICAgICAgbygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSAzRCB0ZXJyYWluIHZpc3VhbGl6YXRpb25cbiAgICovXG4gIGRpc2FibGVUZXJyYWluKCkge1xuICAgIGlmICghdGhpcy50ZXJyYWluKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNUZXJyYWluRW5hYmxlZCA9ICExO1xuICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKSwgbiA9IHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb24sIGEgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudGVycmFpbiB8fCB0aGlzLnRlcnJhaW5Hcm93aW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdCkgLyB0aGlzLnRlcnJhaW5BbmltYXRpb25EdXJhdGlvbjtcbiAgICAgIGlmICh0aGlzLl9lbGV2YXRpb25GcmVlemUgPSAhMSwgbyA8IDAuOTkpIHtcbiAgICAgICAgY29uc3QgaSA9ICgxIC0gbykgKiogNCwgcyA9IG4gKiBpO1xuICAgICAgICB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uID0gcywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb24gPSAwLCB0aGlzLnRlcnJhaW5Hcm93aW5nID0gITEsIHRoaXMudGVycmFpbkZsYXR0ZW5pbmcgPSAhMSwgdGhpcy5zZXRUZXJyYWluKCksIHRoaXMuZ2V0U291cmNlKEoudGVycmFpblNvdXJjZUlkKSAmJiB0aGlzLnJlbW92ZVNvdXJjZShKLnRlcnJhaW5Tb3VyY2VJZCksIHRoaXMuZmlyZShcInRlcnJhaW5BbmltYXRpb25TdG9wXCIsIHsgdGVycmFpbjogbnVsbCB9KTtcbiAgICAgIHRoaXMudHJpZ2dlclJlcGFpbnQoKTtcbiAgICB9O1xuICAgICF0aGlzLnRlcnJhaW5Hcm93aW5nICYmICF0aGlzLnRlcnJhaW5GbGF0dGVuaW5nICYmIHRoaXMuZmlyZShcInRlcnJhaW5BbmltYXRpb25TdGFydFwiLCB7IHRlcnJhaW46IHRoaXMudGVycmFpbiB9KSwgdGhpcy50ZXJyYWluR3Jvd2luZyA9ICExLCB0aGlzLnRlcnJhaW5GbGF0dGVuaW5nID0gITAsIHJlcXVlc3RBbmltYXRpb25GcmFtZShhKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgM0QgdGVycmFpbiBleGFnZXJhdGlvbiBmYWN0b3IuXG4gICAqIElmIHRoZSB0ZXJyYWluIHdhcyBub3QgZW5hYmxlZCBwcmlvciB0byB0aGUgY2FsbCBvZiB0aGlzIG1ldGhvZCxcbiAgICogdGhlIG1ldGhvZCBgLmVuYWJsZVRlcnJhaW4oKWAgd2lsbCBiZSBjYWxsZWQuXG4gICAqIElmIGBhbmltYXRlYCBpcyBgdHJ1ZWAsIHRoZSB0ZXJyYWluIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgYW5pbWF0ZWQgaW4gdGhlIHNwYW4gb2YgMSBzZWNvbmQuXG4gICAqIElmIGBhbmltYXRlYCBpcyBgZmFsc2VgLCBubyBhbmltYXRlZCB0cmFuc2l0aW9uIHRvIHRoZSBuZXdseSBkZWZpbmVkIGV4YWdnZXJhdGlvbi5cbiAgICovXG4gIHNldFRlcnJhaW5FeGFnZ2VyYXRpb24odCwgbiA9ICEwKSB7XG4gICAgIW4gJiYgdGhpcy50ZXJyYWluID8gKHRoaXMudGVycmFpbkV4YWdnZXJhdGlvbiA9IHQsIHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb24gPSB0LCB0aGlzLnRyaWdnZXJSZXBhaW50KCkpIDogdGhpcy5lbmFibGVUZXJyYWluKHQpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIGFjdGlvbiB3aGVuIHRoZSBzdHlsZSBpcyByZWFkeS4gSXQgY291bGQgYmUgYXQgdGhlIG1vbWVudCBvZiBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIG9yIGxhdGVyLlxuICAgKi9cbiAgb25TdHlsZVJlYWR5KHQpIHtcbiAgICB0aGlzLmlzU3R5bGVMb2FkZWQoKSA/IHQoKSA6IHRoaXMub25jZShcInN0eWxlZGF0YVwiLCAoKSA9PiB7XG4gICAgICB0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZml0VG9JcEJvdW5kcygpIHtcbiAgICBjb25zdCB0ID0gYXdhaXQgWG4uaW5mbygpO1xuICAgIHRoaXMuZml0Qm91bmRzKHQuY291bnRyeV9ib3VuZHMsIHtcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgcGFkZGluZzogMTAwXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2VudGVyT25JcFBvaW50KHQpIHtcbiAgICBjb25zdCBuID0gYXdhaXQgWG4uaW5mbygpO1xuICAgIHRoaXMuanVtcFRvKHtcbiAgICAgIGNlbnRlcjogW24ubG9uZ2l0dWRlID8/IDAsIG4ubGF0aXR1ZGUgPz8gMF0sXG4gICAgICB6b29tOiB0IHx8IDExXG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2FtZXJhSGFzaCgpIHtcbiAgICBjb25zdCB0ID0gbmV3IEZsb2F0MzJBcnJheSg1KSwgbiA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgcmV0dXJuIHRbMF0gPSBuLmxuZywgdFsxXSA9IG4ubGF0LCB0WzJdID0gdGhpcy5nZXRab29tKCksIHRbM10gPSB0aGlzLmdldFBpdGNoKCksIHRbNF0gPSB0aGlzLmdldEJlYXJpbmcoKSwga2kuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBTREsgY29uZmlnIG9iamVjdC5cbiAgICogVGhpcyBpcyBjb252ZW5pZW50IHRvIGRpc3BhdGNoIHRoZSBTREsgY29uZmlndXJhdGlvbiB0byBleHRlcm5hbGx5IGJ1aWx0IGxheWVyc1xuICAgKiB0aGF0IGRvIG5vdCBkaXJlY3RseSBoYXZlIGFjY2VzcyB0byB0aGUgU0RLIGNvbmZpZ3VyYXRpb24gYnV0IGRvIGhhdmUgYWNjZXNzIHRvIGEgTWFwIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0U2RrQ29uZmlnKCkge1xuICAgIHJldHVybiBqO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIHNlc3Npb24gSUQuIENvbnZlbmllbnQgdG8gZGlzcGF0Y2ggdG8gZXh0ZXJuYWx5IGJ1aWx0IGNvbXBvbmVudFxuICAgKiB0aGF0IGRvIG5vdCBkaXJlY3RseSBoYXZlIGFjY2VzcyB0byB0aGUgU0RLIGNvbmZpZ3VyYXRpb24gYnV0IGRvIGhhdmUgYWNjZXNzIHRvIGEgTWFwIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0TWFwdGlsZXJTZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIGRuO1xuICB9XG4gIC8qKlxuICAgKiAgVXBkYXRlcyB0aGUgcmVxdWVzdE1hbmFnZXIncyB0cmFuc2Zvcm0gcmVxdWVzdCB3aXRoIGEgbmV3IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNmb3JtUmVxdWVzdCBBIGNhbGxiYWNrIHJ1biBiZWZvcmUgdGhlIE1hcCBtYWtlcyBhIHJlcXVlc3QgZm9yIGFuIGV4dGVybmFsIFVSTC4gVGhlIGNhbGxiYWNrIGNhbiBiZSB1c2VkIHRvIG1vZGlmeSB0aGUgdXJsLCBzZXQgaGVhZGVycywgb3Igc2V0IHRoZSBjcmVkZW50aWFscyBwcm9wZXJ0eSBmb3IgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzLlxuICAgKiAgICBFeHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSBgdXJsYCBwcm9wZXJ0eSBhbmQgb3B0aW9uYWxseSBgaGVhZGVyc2AgYW5kIGBjcmVkZW50aWFsc2AgcHJvcGVydGllc1xuICAgKlxuICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICpcbiAgICogIEBleGFtcGxlXG4gICAqICBtYXAuc2V0VHJhbnNmb3JtUmVxdWVzdCgodXJsOiBzdHJpbmcsIHJlc291cmNlVHlwZTogc3RyaW5nKSA9PiB7fSk7XG4gICAqL1xuICBzZXRUcmFuc2Zvcm1SZXF1ZXN0KHQpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0VHJhbnNmb3JtUmVxdWVzdCh0YSh0KSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHtAbGluayBQcm9qZWN0aW9uU3BlY2lmaWNhdGlvbn0uXG4gICAqIEByZXR1cm5zIHRoZSBwcm9qZWN0aW9uIHNwZWNpZmljYXRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGxldCBwcm9qZWN0aW9uID0gbWFwLmdldFByb2plY3Rpb24oKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXRQcm9qZWN0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnN0eWxlLmdldFByb2plY3Rpb24oKTtcbiAgICByZXR1cm4gIXQgPT09IHZvaWQgMCAmJiB0aGlzLnN0eWxlLnByb2plY3Rpb24gPyB7IHR5cGU6IHRoaXMuc3R5bGUucHJvamVjdGlvbi5uYW1lIH0gOiB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBnbG9iZSBwcm9qZWN0aW9uIGlzIGN1cnJlbnRseSBiZWluZyB1c2VkXG4gICAqL1xuICBpc0dsb2JlUHJvamVjdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgcmV0dXJuIHQgPyB0LnR5cGUgPT09IFwiZ2xvYmVcIiA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgZ2xvYmUgcHJvamVjdGlvbi5cbiAgICovXG4gIGVuYWJsZUdsb2JlUHJvamVjdGlvbigpIHtcbiAgICB0aGlzLmlzR2xvYmVQcm9qZWN0aW9uKCkgIT09ICEwICYmICh0aGlzLnNldFByb2plY3Rpb24oeyB0eXBlOiBcImdsb2JlXCIgfSksIHRoaXMuY3VyZW50UHJvamVjdGlvbiA9IFwiZ2xvYmVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKi9cbiAgZW5hYmxlTWVyY2F0b3JQcm9qZWN0aW9uKCkge1xuICAgIHRoaXMuaXNHbG9iZVByb2plY3Rpb24oKSAhPT0gITEgJiYgKHRoaXMuc2V0UHJvamVjdGlvbih7IHR5cGU6IFwibWVyY2F0b3JcIiB9KSwgdGhpcy5jdXJlbnRQcm9qZWN0aW9uID0gXCJtZXJjYXRvclwiKTtcbiAgfVxuICBzZXRQcm9qZWN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy5maXJlKFwicHJvamVjdGlvbi5jaGFuZ2VcIiwgeyB0YXJnZXQ6IHRoaXMsIHByb2plY3Rpb246IHQgfSksIHN1cGVyLnNldFByb2plY3Rpb24odCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlzIHRoZSBsYW5ndWFnZSB3YXMgZXZlciB1cGRhdGVkLCBtZWFuaW5nIGNoYW5nZWRcbiAgICogZnJvbSB3aGF0IGlzIGRlbGl2ZXJlZCBpbiB0aGUgc3R5bGUuXG4gICAqIFJldHVybnMgYGZhbHNlYCBpZiBsYW5ndWFnZSBpbiB1c2UgaXMgdGhlIGxhbmd1YWdlIGZyb20gdGhlIHN0eWxlXG4gICAqIGFuZCBoYXMgbmV2ZXIgYmVlbiBjaGFuZ2VkLlxuICAgKi9cbiAgaXNMYW5ndWFnZVVwZGF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VJc1VwZGF0ZWQ7XG4gIH1cbn07XG5jbGFzcyByZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEgPSB7fSkge1xuICAgIGcodGhpcywgXCJ0eXBlXCIpO1xuICAgIGcodGhpcywgXCJ0YXJnZXRcIik7XG4gICAgZyh0aGlzLCBcIm9yaWdpbmFsRXZlbnRcIik7XG4gICAgZyh0aGlzLCBcImltYWdlWFwiKTtcbiAgICBnKHRoaXMsIFwiaW1hZ2VZXCIpO1xuICAgIGcodGhpcywgXCJpc091dE9mQm91bmRzXCIpO1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMudGFyZ2V0ID0gdCwgdGhpcy5vcmlnaW5hbEV2ZW50ID0gbiA/PyBudWxsLCBPYmplY3QuYXNzaWduKHRoaXMsIGEpO1xuICB9XG59XG5jb25zdCBabyA9IFtcbiAgLy8gcGFzcyBub3RoaW5nIG90aGVyIHRoYW4gdGFyZ2V0IChtYXAgLyB2aWV3ZXIpIGFuZCB0eXBlXG4gIFwiaWRsZVwiLFxuICBcInJlbmRlclwiLFxuICBcImxvYWRcIixcbiAgXCJyZW1vdmVcIixcbiAgXCJpZGxlXCJcbiAgLy8gdGhlc2UgYXJlIGZpcmVkIG9uIGxheWVycywgbm90IHRoZSBtYXAsXG4gIC8vIGtlZXBpbmcgdGhlbSBmb3IgcmVmZXJlbmNlXG4gIC8vIFwiY29udGVudFwiLFxuICAvLyBcInZpc2liaWxpdHlcIixcbl0sIEtvID0gW1xuICBcImVycm9yXCJcbiAgLy8gRXJyb3JFdmVudFxuXSwgWG8gPSBbXCJyZXNpemVcIl0sIFlvID0gW1wid2ViZ2xjb250ZXh0bG9zdFwiLCBcIndlYmdsY29udGV4dHJlc3RvcmVkXCJdLCBXbyA9IFtcbiAgXCJtb3ZlZW5kXCIsXG4gIFwibW92ZXN0YXJ0XCIsXG4gIFwibW92ZVwiLFxuICBcInpvb21lbmRcIixcbiAgXCJ6b29tc3RhcnRcIixcbiAgXCJ6b29tXCIsXG4gIFwicm90YXRlc3RhcnRcIixcbiAgXCJyb3RhdGVlbmRcIixcbiAgXCJyb3RhdGVcIixcbiAgXCJkcmFnc3RhcnRcIixcbiAgXCJkcmFnZW5kXCIsXG4gIFwiZHJhZ1wiLFxuICBcImJveHpvb21jYW5jZWxcIixcbiAgXCJib3h6b29tZW5kXCIsXG4gIFwiYm94em9vbXN0YXJ0XCJcbl0sIEpvID0gW1wiY2xpY2tcIiwgXCJkYmxjbGlja1wiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLCBcIm1vdXNlb3ZlclwiLCBcImNvbnRleHRtZW51XCIsIFwidG91Y2hzdGFydFwiLCBcInRvdWNoZW5kXCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hjYW5jZWxcIl0sIFFvID0gW1wiY29vcGVyYXRpdmVnZXN0dXJlcHJldmVudGVkXCJdLCBlaSA9IFtcbiAgXCJkYXRhXCIsXG4gIFwiZGF0YWxvYWRpbmdcIixcbiAgXCJzb3VyY2VkYXRhXCIsXG4gIFwic291cmNlZGF0YWxvYWRpbmdcIixcbiAgXCJkYXRhYWJvcnRcIixcbiAgXCJzb3VyY2VkYXRhYWJvcnRcIlxuICAvLyB0aGlzIGlzIGZpcmVkIG9uIGxheWVycywgbm90IHRoZSBtYXBcbiAgLy8ga2VlcGluZyBpdCBmb3IgcmVmZXJlbmNlXG4gIC8vIFwibWV0YWRhdGFcIixcbl0sIGxjID0gW1xuICAuLi5abyxcbiAgLi4uS28sXG4gIC4uLlhvLFxuICAuLi5ZbyxcbiAgLi4uV28sXG4gIC4uLkpvLFxuICAuLi5laSxcbiAgLi4uUW9cbl0sIHVjID0gW1wibG5nTGF0XCIsIFwiX2RlZmF1bHRQcmV2ZW50ZWRcIl07XG5mdW5jdGlvbiBjYyh7IG1hcDogciwgdmlld2VyOiBlLCBsbmdMYXRUb1B4OiB0IH0pIHtcbiAgbGMuZm9yRWFjaCgobikgPT4ge1xuICAgIHRyeSB7XG4gICAgICByLm9uKG4sIChhKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBuO1xuICAgICAgICBpZiAoSm8uaW5jbHVkZXMobykpIHtcbiAgICAgICAgICBjb25zdCBmID0gYSwgaCA9IGYubG5nTGF0ICYmIHQoZi5sbmdMYXQpLCBtID0gZS5nZXRJbWFnZU1ldGFkYXRhKCksIHcgPSB7XG4gICAgICAgICAgICBpc091dE9mQm91bmRzOiBtID8gaFswXSA8IDAgfHwgaFswXSA+IG0ud2lkdGggfHwgaFsxXSA8IDAgfHwgaFsxXSA+IG0uaGVpZ2h0IDogITAsXG4gICAgICAgICAgICBpbWFnZVg6IGhbMF0sXG4gICAgICAgICAgICBpbWFnZVk6IGhbMV0sXG4gICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYSkuZmlsdGVyKChbdl0pID0+ICF1Yy5pbmNsdWRlcyh2KSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlLmZpcmUobmV3IHJlKG4sIGUsIGYub3JpZ2luYWxFdmVudCwgdykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gbjtcbiAgICAgICAgaWYgKFdvLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgICAgY29uc3QgZiA9IGE7XG4gICAgICAgICAgZS5maXJlKG5ldyByZShuLCBlLCBmLm9yaWdpbmFsRXZlbnQsIGYpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcyA9IG47XG4gICAgICAgIGlmIChLby5pbmNsdWRlcyhzKSkge1xuICAgICAgICAgIGNvbnN0IGYgPSBhO1xuICAgICAgICAgIGUuZmlyZShuZXcgcmUobiwgZSwgbnVsbCwgZikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsID0gbjtcbiAgICAgICAgaWYgKFhvLmluY2x1ZGVzKGwpKSB7XG4gICAgICAgICAgY29uc3QgZiA9IGE7XG4gICAgICAgICAgZS5maXJlKG5ldyByZShuLCBlLCBudWxsLCBmKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHUgPSBuO1xuICAgICAgICBpZiAoWW8uaW5jbHVkZXModSkpIHtcbiAgICAgICAgICBjb25zdCBmID0gYTtcbiAgICAgICAgICBlLmZpcmUobmV3IHJlKG4sIGUsIGYub3JpZ2luYWxFdmVudCwgZikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjID0gbjtcbiAgICAgICAgaWYgKGVpLmluY2x1ZGVzKGMpKSB7XG4gICAgICAgICAgY29uc3QgZiA9IGE7XG4gICAgICAgICAgZS5maXJlKG5ldyByZShuLCBlLCBudWxsLCBmKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSBuO1xuICAgICAgICBpZiAoUW8uaW5jbHVkZXMocCkpIHtcbiAgICAgICAgICBjb25zdCBmID0gYTtcbiAgICAgICAgICBlLmZpcmUobmV3IHJlKG4sIGUsIG51bGwsIGYpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZCA9IG47XG4gICAgICAgIGlmIChaby5pbmNsdWRlcyhkKSkge1xuICAgICAgICAgIGUuZmlyZShuZXcgcmUobiwgZSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZm9yd2FyZGluZyBldmVudCB0byBJbWFnZVZpZXdlciwgZXZlbnQgb2YgdHlwZSBcIiR7bn1cIiBpcyBub3Qgc3VwcG9ydGVkYCwgYSk7XG4gICAgfVxuICB9KTtcbn1cbmNsYXNzIHBjIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0LCBuLCBhKSB7XG4gICAgY29uc3QgbyA9IGBbJHthfV06IEZhaWxlZCB0byBmZXRjaCAke259IGF0ICR7dC51cmx9OiAke3Quc3RhdHVzLnRvU3RyaW5nKCl9OiAke3Quc3RhdHVzVGV4dH1gO1xuICAgIHN1cGVyKG8pO1xuICAgIGcodGhpcywgXCJzdGF0dXNcIik7XG4gICAgZyh0aGlzLCBcInN0YXR1c1RleHRcIik7XG4gICAgdGhpcy5uYW1lID0gXCJGZXRjaEVycm9yXCIsIHRoaXMubWVzc2FnZSA9IG8sIHRoaXMuc3RhdHVzID0gdC5zdGF0dXMsIHRoaXMuc3RhdHVzVGV4dCA9IHQuc3RhdHVzVGV4dDtcbiAgfVxufVxuY29uc3QgZmMgPSA4NS4wNTExMjk7XG5mdW5jdGlvbiBkYyhyLCBlKSB7XG4gIHJldHVybiBuZXcgZm4oZS54IC8gciwgZS55IC8gcikudG9MbmdMYXQoKTtcbn1cbmZ1bmN0aW9uIGhjKHIpIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIHIpO1xufVxuZnVuY3Rpb24gbWMocikge1xuICByZXR1cm4gTWF0aC5sb2cocikgLyBNYXRoLkxOMjtcbn1cbmZ1bmN0aW9uIHRpKHIsIGUsIHQpIHtcbiAgcmV0dXJuIE1hdGgubWluKHQsIE1hdGgubWF4KGUsIHIpKTtcbn1cbmZ1bmN0aW9uIG5uKHIpIHtcbiAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyByICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIGFuKHIpIHtcbiAgcmV0dXJuICgxODAgKyByKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIEJhKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHQgLSBlLCBhID0gKChyIC0gZSkgJSBuICsgbikgJSBuICsgZTtcbiAgcmV0dXJuIGEgPT09IGUgPyB0IDogYTtcbn1cbmZ1bmN0aW9uIHljKHIsIGUpIHtcbiAgY29uc3QgdCA9IHRpKGUubGF0LCAtODUuMDUxMTI5LCBmYyk7XG4gIHJldHVybiBuZXcgYmkoYW4oZS5sbmcpICogciwgbm4odCkgKiByKTtcbn1cbmZ1bmN0aW9uIGdjKHIpIHtcbiAgci50cmFuc2Zvcm0uZ2V0Q29uc3RyYWluZWQgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgdCA9IHRpKCt0LCB0aGlzLm1pblpvb20sIHRoaXMubWF4Wm9vbSk7XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIGNlbnRlcjogbmV3IHZpKGUubG5nLCBlLmxhdCksXG4gICAgICB6b29tOiB0XG4gICAgfTtcbiAgICBsZXQgYSA9IHRoaXMuX2hlbHBlci5fbG5nUmFuZ2U7XG4gICAgYSA9PT0gbnVsbCAmJiAoYSA9IFstMTc5Ljk5OTk5OTk5OTksIDE3OS45OTk5OTk5OTk5XSk7XG4gICAgY29uc3QgbyA9IHRoaXMudGlsZVNpemUgKiBoYyhuLnpvb20pO1xuICAgIGxldCBpID0gMCwgcyA9IG8sIGwgPSAwLCB1ID0gbywgYyA9IDAsIHAgPSAwO1xuICAgIGNvbnN0IHsgeDogZCwgeTogZiB9ID0gdGhpcy5zaXplLCBoID0gMC41O1xuICAgIGlmICh0aGlzLl9oZWxwZXIuX2xhdFJhbmdlKSB7XG4gICAgICBjb25zdCBWID0gdGhpcy5faGVscGVyLl9sYXRSYW5nZTtcbiAgICAgIGkgPSBubihWWzFdKSAqIG8sIHMgPSBubihWWzBdKSAqIG8sIHMgLSBpIDwgaCAqIGYgJiYgKGMgPSBoICogZiAvIChzIC0gaSkpO1xuICAgIH1cbiAgICBhICYmIChsID0gQmEoYW4oYVswXSkgKiBvLCAwLCBvKSwgdSA9IEJhKGFuKGFbMV0pICogbywgMCwgbyksIHUgPCBsICYmICh1ICs9IG8pLCB1IC0gbCA8IGggKiBkICYmIChwID0gaCAqIGQgLyAodSAtIGwpKSk7XG4gICAgY29uc3QgeyB4OiBtLCB5IH0gPSB5YyhvLCBlKTtcbiAgICBsZXQgdywgdjtcbiAgICBjb25zdCB4ID0gTWF0aC5taW4ocCB8fCAwLCBjIHx8IDApO1xuICAgIGlmICh4KVxuICAgICAgcmV0dXJuIG4uem9vbSArPSBtYyh4KSwgbjtcbiAgICBsZXQgQSA9IDAsIEUgPSAwO1xuICAgIGNvbnN0IEMgPSAxLCBOID0gMSAtIChzIC0gaSkgLyBmLCBlZSA9IDEgLSAodSAtIGwpIC8gZDtcbiAgICBBID0gTWF0aC5tYXgoZWUsIEMpLCBFID0gTWF0aC5tYXgoTiwgQyk7XG4gICAgY29uc3QgTGUgPSAxIC0gQSwgRWUgPSAxIC0gRTtcbiAgICBpZiAodGhpcy5faGVscGVyLl9sYXRSYW5nZSkge1xuICAgICAgY29uc3QgViA9IEVlICogZiAvIDI7XG4gICAgICB5IC0gViA8IGkgJiYgKHYgPSBpICsgViksIHkgKyBWID4gcyAmJiAodiA9IHMgLSBWKTtcbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIGNvbnN0IFYgPSBtLCBiZSA9IExlICogZCAvIDI7XG4gICAgICBWIC0gYmUgPCBsICYmICh3ID0gbCArIGJlKSwgViArIGJlID4gdSAmJiAodyA9IHUgLSBiZSk7XG4gICAgfVxuICAgIGlmICh3ICE9PSB2b2lkIDAgfHwgdiAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBWID0gbmV3IGJpKHcgPz8gbSwgdiA/PyB5KTtcbiAgICAgIG4uY2VudGVyID0gZGMobywgVikud3JhcCgpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfTtcbn1cbmNvbnN0IHZjID0ge1xuICBjZW50ZXI6IFwidHJhbnNsYXRlKC01MCUsLTUwJSlcIixcbiAgdG9wOiBcInRyYW5zbGF0ZSgtNTAlLDApXCIsXG4gIFwidG9wLWxlZnRcIjogXCJ0cmFuc2xhdGUoMCwwKVwiLFxuICBcInRvcC1yaWdodFwiOiBcInRyYW5zbGF0ZSgtMTAwJSwwKVwiLFxuICBib3R0b206IFwidHJhbnNsYXRlKC01MCUsLTEwMCUpXCIsXG4gIFwiYm90dG9tLWxlZnRcIjogXCJ0cmFuc2xhdGUoMCwtMTAwJSlcIixcbiAgXCJib3R0b20tcmlnaHRcIjogXCJ0cmFuc2xhdGUoLTEwMCUsLTEwMCUpXCIsXG4gIGxlZnQ6IFwidHJhbnNsYXRlKDAsLTUwJSlcIixcbiAgcmlnaHQ6IFwidHJhbnNsYXRlKC0xMDAlLC01MCUpXCJcbn07XG5mdW5jdGlvbiBiYyhyKSB7XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIGlmICghdGhpcy5fbWFwKSByZXR1cm47XG4gICAgY29uc3QgbiA9IHRoaXMuX21hcC5sb2FkZWQoKSAmJiAhdGhpcy5fbWFwLmlzTW92aW5nKCk7XG4gICAgKCh0ID09IG51bGwgPyB2b2lkIDAgOiB0LnR5cGUpID09PSBcInRlcnJhaW5cIiB8fCAodCA9PSBudWxsID8gdm9pZCAwIDogdC50eXBlKSA9PT0gXCJyZW5kZXJcIiAmJiAhbikgJiYgdGhpcy5fbWFwLm9uY2UoXCJyZW5kZXJcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fZmxhdFBvcyA9IHRoaXMuX3BvcyA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2xuZ0xhdCkuX2FkZCh0aGlzLl9vZmZzZXQpLCB0aGlzLl9tYXAudGVycmFpbiAmJiAodGhpcy5fZmxhdFBvcyA9IHRoaXMuX21hcC50cmFuc2Zvcm0ubG9jYXRpb25Ub1NjcmVlblBvaW50KHRoaXMuX2xuZ0xhdCkuX2FkZCh0aGlzLl9vZmZzZXQpKTtcbiAgICBsZXQgYSA9IFwiXCI7XG4gICAgdGhpcy5fcm90YXRpb25BbGlnbm1lbnQgPT09IFwidmlld3BvcnRcIiB8fCB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCA9PT0gXCJhdXRvXCIgPyBhID0gYHJvdGF0ZVooJHt0aGlzLl9yb3RhdGlvbn1kZWcpYCA6IHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50ID09PSBcIm1hcFwiICYmIChhID0gYHJvdGF0ZVooJHt0aGlzLl9yb3RhdGlvbiAtIHRoaXMuX21hcC5nZXRCZWFyaW5nKCl9ZGVnKWApO1xuICAgIGxldCBvID0gXCJcIjtcbiAgICB0aGlzLl9waXRjaEFsaWdubWVudCA9PT0gXCJ2aWV3cG9ydFwiIHx8IHRoaXMuX3BpdGNoQWxpZ25tZW50ID09PSBcImF1dG9cIiA/IG8gPSBcInJvdGF0ZVgoMGRlZylcIiA6IHRoaXMuX3BpdGNoQWxpZ25tZW50ID09PSBcIm1hcFwiICYmIChvID0gYHJvdGF0ZVgoJHt0aGlzLl9tYXAuZ2V0UGl0Y2goKX1kZWcpYCksICF0aGlzLl9zdWJwaXhlbFBvc2l0aW9uaW5nICYmICghdCB8fCB0LnR5cGUgPT09IFwibW92ZWVuZFwiKSAmJiAodGhpcy5fcG9zID0gdGhpcy5fcG9zLnJvdW5kKCkpO1xuICAgIGNvbnN0IGkgPSBgJHt2Y1t0aGlzLl9hbmNob3JdfSB0cmFuc2xhdGUoJHt0aGlzLl9wb3MueH1weCwgJHt0aGlzLl9wb3MueX1weCkgJHtvfSAke2F9YDtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGk7XG4gIH1cbiAgci5fdXBkYXRlID0gZS5iaW5kKHIpO1xufVxuY2xhc3Mgd2Mge1xuICBjb25zdHJ1Y3Rvcih7IGltYWdlVmlld2VyOiBlIH0pIHtcbiAgICBnKHRoaXMsIFwidmlld2VyXCIpO1xuICAgIGcodGhpcywgXCJjb250YWluZXJcIik7XG4gICAgZyh0aGlzLCBcImhhbmRsZUNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlld2VyLmZpdEltYWdlVG9WaWV3cG9ydCh7IGVhc2U6ICEwIH0pO1xuICAgIH0pO1xuICAgIGlmICghZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlVmlld2VyRml0SW1hZ2VUb0JvdW5kc0NvbnRyb2w6IGFuIGluc3RhbmNlIG9mICdJbWFnZVZpZXdlcicgaXMgcmVxdWlyZWRcIik7XG4gICAgdGhpcy52aWV3ZXIgPSBlO1xuICB9XG4gIG9uQWRkKGUpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmxcIiwgXCJtYXBsaWJyZWdsLWN0cmwtZ3JvdXBcIiksIHQuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1maXQtaW1hZ2UtdG8tYm91bmRzXCIpO1xuICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICByZXR1cm4gbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWljb25cIiksIHQudGl0bGUgPSBcIlpvb20gaW1hZ2UgdG8gdmlld3BvcnQgYm91bmRzXCIsIHQuYXBwZW5kQ2hpbGQobiksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlQ2xpY2spLCB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0KSwgdGhpcy5jb250YWluZXI7XG4gIH1cbiAgb25SZW1vdmUoKSB7XG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gIH1cbn1cbmNvbnN0IHJpID0gU3ltYm9sKFwiTWFwVGlsZXI6SW1hZ2VWaWV3ZXI6SW50ZXJuYWw6bG5nTGF0VG9QeEludGVybmFsXCIpLCBuaSA9IFN5bWJvbChcIk1hcFRpbGVyOkltYWdlVmlld2VyOkludGVybmFsOnB4VG9MbmdMYXRJbnRlcm5hbFwiKSwgeyBFdmVudGVkOiBTYyB9ID0gTCwgeGMgPSB7XG4gIHN0eWxlOiB7XG4gICAgdmVyc2lvbjogOCxcbiAgICBzb3VyY2VzOiB7fSxcbiAgICBsYXllcnM6IFtdXG4gIH0sXG4gIG1pblBpdGNoOiAwLFxuICBtYXhQaXRjaDogMCxcbiAgcGl0Y2g6IDAsXG4gIGJlYXJpbmc6IDAsXG4gIHByb2plY3Rpb246IFwibWVyY2F0b3JcIixcbiAgZ2VvbG9jYXRlQ29udHJvbDogITEsXG4gIG5hdmlnYXRpb25Db250cm9sOiAhMSxcbiAgcHJvamVjdGlvbkNvbnRyb2w6ICExLFxuICBoYXNoOiAhMSxcbiAgcmVuZGVyV29ybGRDb3BpZXM6ICExLFxuICB0ZXJyYWluOiAhMSxcbiAgc3BhY2U6ICExLFxuICBoYWxvOiAhMVxufSwga2MgPSB7XG4gIGRlYnVnOiAhMSxcbiAgZml0VG9Cb3VuZHNDb250cm9sOiAhMCxcbiAgbmF2aWdhdGlvbkNvbnRyb2w6ICEwXG59O1xudmFyIEthLCBYYSwgWWE7XG5jbGFzcyBMYyBleHRlbmRzIChZYSA9IFNjLCBYYSA9IHJpLCBLYSA9IG5pLCBZYSkge1xuICAvLyNyZWdpb24gY29uc3RydWN0b3JcbiAgLyoqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIEltYWdlVmlld2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8SW1hZ2VWaWV3ZXJDb25zdHJ1Y3Rvck9wdGlvbnM+fSBpbWFnZVZpZXdlckNvbnN0cnVjdG9yT3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgSW1hZ2VWaWV3ZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBcIkBtYXB0aWxlci9zZGsvZGlzdC9tYXB0aWxlci1zZGsuY3NzXCI7IC8vIGltcG9ydCBjc3NcbiAgICogaW1wb3J0IHsgSW1hZ2VWaWV3ZXIgfSBmcm9tIFwiQG1hcHRpbGVyL3Nka1wiOyAvLyBpbXBvcnQgdGhlIHNka1xuICAgKlxuICAgKiBjb25zdCBpbWFnZVZpZXdlciA9IG5ldyBJbWFnZVZpZXdlcih7XG4gICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1hcFwiKSxcbiAgICogICBpbWFnZVVVSUQ6IFwiMDE5ODYwMjUtY2ViOS03NDg3LTllYTYtN2E4NjM3ZGNjMWExXCIsXG4gICAqICAgZGVidWc6IHRydWUsIC8vIHNob3cgdGlsZSBib3VuZGFyaWVzLCBwYWRkaW5nLCBjb2xsaXNpb24gYm94ZXMgZXRjXG4gICAqICAgZml0VG9Cb3VuZHNDb250cm9sOiB0cnVlLCAvLyBzaG93IGEgY29udHJvbCB0byBmaXQgdGhlIGltYWdlIHRvIHRoZSB2aWV3cG9ydFxuICAgKiAgIG5hdmlnYXRpb25Db250cm9sOiB0cnVlLCAvLyBzaG93IGEgbmF2aWdhdGlvbiBjb250cm9sXG4gICAqICAgY2VudGVyOiBbMCwgMF0sIC8vIGNlbnRlciBpbiBwaXhlbHNcbiAgICogICB6b29tOiAxLCAvLyB6b29tIGxldmVsXG4gICAqICAgYmVhcmluZzogMCwgLy8gYmVhcmluZ1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgVVVJRCBvZiB0aGUgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwiaW1hZ2VVVUlEXCIpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIG1vZGUuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnKHRoaXMsIFwiZGVidWdcIik7XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGFkYXRhIG9mIHRoZSBpbWFnZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGcodGhpcywgXCJpbWFnZU1ldGFkYXRhXCIpO1xuICAgIC8qKlxuICAgICAqIFdoeSBub3QgZXh0ZW5kIHRoZSBNYXAgY2xhc3M/XG4gICAgICogQmVjYXVzZSBJbWFnZVZpZXdlciB0ZWNobmljYWxseSBvcGVyYXRlcyBpbiBzY3JlZW4gc3BhY2UgYW5kIG5vdCBpbiBtYXAgc3BhY2UuXG4gICAgICogV2Ugd3JhcCBtYXAgYW5kIHBlcmZvcm0gY2FsY3VsYXRpb25zIGluIHNjcmVlbiBzcGFjZS5cbiAgICAgKiBXZSBkbyBub3Qgd2FudCB0byBoYXZlIHRvIGV4dGVuZCB0aGUgTWFwIGNsYXNzIGFuZCBnaXZlIGFjY2VzcyB0b1xuICAgICAqIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBvcGVyYXRlIGluIExuZ0xhdCBzcGFjZS4gICAqXG4gICAgICovXG4gICAgZyh0aGlzLCBcInNka1wiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBmb3IgdGhlIEltYWdlVmlld2VyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZyh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgb2YgdGhlIGltYWdlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZyh0aGlzLCBcImltYWdlU2l6ZVwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFkZGVkIHNpemUgbWF4LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZyh0aGlzLCBcInBhZGRlZFNpemVNYXhcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgdG8gZml0IHRoZSBpbWFnZSB0byB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgZyh0aGlzLCBcImZpdFRvQm91bmRzQ29udHJvbEluc3RhbmNlXCIpO1xuICAgIC8vIHRoaXMgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgaW1hZ2Ugc2hvdWxkIGJlIGZpdCB0byB0aGUgdmlld3BvcnRcbiAgICAvLyB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZFxuICAgIGcodGhpcywgXCJzaG91bGRGaXRJbWFnZVRvVmlld3BvcnRcIiwgITApO1xuICAgIC8vIGFsaWFzZXMgZm9yIG1ldGhvZHMgdGhhdCBhcmUgbm90IGV4cG9zZWQgYnkgdGhlIFNES1xuICAgIC8vIGJ1dCB1c2VkIGludGVybmFsbHkgKEltYWdlTWFya2VycylcbiAgICBnKHRoaXMsIFhhLCB0aGlzLmxuZ0xhdFRvUHguYmluZCh0aGlzKSk7XG4gICAgZyh0aGlzLCBLYSwgdGhpcy5weFRvTG5nTGF0LmJpbmQodGhpcykpO1xuICAgIGlmICghdC5pbWFnZVVVSUQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJdOiBgaW1hZ2VVVUlEYCBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAodHlwZW9mIHQuY29udGFpbmVyICE9IFwic3RyaW5nXCIgJiYgISh0LmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltJbWFnZVZpZXdlcl06IGBjb250YWluZXJgIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nIG9yIEhUTUxFbGVtZW50XCIpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmtjLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLnhjXG4gICAgfTtcbiAgICBkZWxldGUgbi5jZW50ZXIsIHRoaXMuc2RrID0gbmV3IEdvKG4pLCB0aGlzLnNkay50ZWxlbWV0cnkucmVnaXN0ZXJWaWV3ZXJUeXBlKFwiSW1hZ2VWaWV3ZXJcIik7XG4gICAgY29uc3QgeyBpbWFnZVVVSUQ6IGEsIGRlYnVnOiBvIH0gPSB0O1xuICAgIHRoaXMuaW1hZ2VVVUlEID0gYSwgdGhpcy5kZWJ1ZyA9IG8gPz8gITEsIHRoaXMuZGVidWcgJiYgKHRoaXMuc2RrLnNob3dUaWxlQm91bmRhcmllcyA9IHRoaXMuZGVidWcsIHRoaXMuc2RrLnNob3dQYWRkaW5nID0gdGhpcy5kZWJ1ZywgdGhpcy5zZGsuc2hvd0NvbGxpc2lvbkJveGVzID0gdGhpcy5kZWJ1ZywgdGhpcy5zZGsucmVwYWludCA9IHRoaXMuZGVidWcpLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIEltYWdlVmlld2VyIC8gU0RLLlxuICAgKi9cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnZlcnNpb247XG4gIH1cbiAgLy8jcmVnaW9uIG9uUmVhZHlBc3luY1xuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBJbWFnZVZpZXdlciB0byBiZSByZWFkeS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBvblJlYWR5QXN5bmMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2RrLm9uUmVhZHlBc3luYygpLCBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZSgodCwgbikgPT4ge1xuICAgICAgICAgIHRoaXMub25jZShcImltYWdldmlld2VycmVhZHlcIiwgKGEpID0+IHtcbiAgICAgICAgICAgIHQoYSk7XG4gICAgICAgICAgfSksIHRoaXMub25jZShcImltYWdldmlld2VyaW5pdGVycm9yXCIsIChhKSA9PiB7XG4gICAgICAgICAgICBuKGEuZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb21pc2UoKHQsIG4pID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG4obmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciBpbWFnZSB2aWV3ZXIgdG8gYmUgcmVhZHlcIikpO1xuICAgICAgICAgIH0sIDVlMyk7XG4gICAgICAgIH0pXG4gICAgICBdKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICB0aHJvdyB0O1xuICAgIH1cbiAgfVxuICAvLyNyZWdpb24gaW5pdFxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEltYWdlVmlld2VyXG4gICAqICAtIGZldGNoZXMgdGhlIGltYWdlIG1ldGFkYXRhXG4gICAqICAtIGFkZHMgdGhlIGltYWdlIHNvdXJjZSB0byB0aGUgc2RrIGluc3RhbmNlXG4gICAqICAtIHNldHMgdGhlIGNlbnRlciB0byB0aGUgbWlkZGxlIG9mIHRoZSBpbWFnZSAoaWYgY2VudGVyIGlzIG5vdCBwcm92aWRlZClcbiAgICogIC0gbW9ua2V5cGF0Y2hlcyB0aGUgbWFwbGlicmUtZ2wgc2RrIHRyYW5zZm9ybSBtZXRob2QgdG8gYWxsb3cgZm9yIG92ZXJwYW5uaW5nIGFuZCB1bmRlcnpvb21pbmcuXG4gICAqICAtIHNldHMgdXAgZ2xvYmFsIGV2ZW50IGZvcndhcmRpbmcgLyBpbnRlcmNlcHRpbmcgZnJvbSB0aGUgbWFwIGluc3RhbmNlXG4gICAqICAtIHNldHMgdGhlIGNlbnRlciB0byB0aGUgbWlkZGxlIG9mIHRoZSBpbWFnZSAoaWYgY2VudGVyIGlzIG5vdCBwcm92aWRlZClcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB2YXIgdCwgbiwgYTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5mZXRjaEltYWdlTWV0YWRhdGEoKSwgdGhpcy5hZGRJbWFnZVNvdXJjZSgpLCB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbkNvbnRyb2wgJiYgdGhpcy5zZGsuYWRkQ29udHJvbChcbiAgICAgICAgbmV3IFdhKHtcbiAgICAgICAgICB2aXN1YWxpemVQaXRjaDogITEsXG4gICAgICAgICAgdmlzdWFsaXplUm9sbDogITFcbiAgICAgICAgfSlcbiAgICAgICksIHRoaXMuZml0VG9Cb3VuZHNDb250cm9sSW5zdGFuY2UgPSBuZXcgd2MoeyBpbWFnZVZpZXdlcjogdGhpcyB9KSwgdGhpcy5vcHRpb25zLmZpdFRvQm91bmRzQ29udHJvbCAmJiB0aGlzLnNkay5hZGRDb250cm9sKHRoaXMuZml0VG9Cb3VuZHNDb250cm9sSW5zdGFuY2UpLCBjYyh7XG4gICAgICAgIG1hcDogdGhpcy5zZGssXG4gICAgICAgIHZpZXdlcjogdGhpcyxcbiAgICAgICAgbG5nTGF0VG9QeDogKHUpID0+IHRoaXMubG5nTGF0VG9QeCh1KVxuICAgICAgfSksIGdjKHRoaXMuc2RrKTtcbiAgICAgIGNvbnN0IHsgY2VudGVyOiBvLCB6b29tOiBpLCBiZWFyaW5nOiBzIH0gPSB0aGlzLm9wdGlvbnMsIGwgPSBvID8/IFsoKCh0ID0gdGhpcy5pbWFnZU1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogdC53aWR0aCkgPz8gMCkgLyAyLCAoKChuID0gdGhpcy5pbWFnZU1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogbi5oZWlnaHQpID8/IDApIC8gMl07XG4gICAgICB0aGlzLnNldENlbnRlcihsKSwgdGhpcy5zZXRCZWFyaW5nKHMgPz8gMCksIHRoaXMub3B0aW9ucy56b29tID8gdGhpcy5zZXRab29tKGkgPz8gKChhID0gdGhpcy5pbWFnZU1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogYS5tYXh6b29tKSA/PyA1KSA6IHRoaXMuZml0SW1hZ2VUb1ZpZXdwb3J0KCksIHRoaXMuc2RrLm9uKFwid2hlZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNob3VsZEZpdEltYWdlVG9WaWV3cG9ydCA9ICExO1xuICAgICAgfSksIHRoaXMuc2RrLm9uKFwidG91Y2hzdGFydFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvdWxkRml0SW1hZ2VUb1ZpZXdwb3J0ID0gITE7XG4gICAgICB9KSwgdGhpcy5zZGsub24oXCJkcmFnXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zaG91bGRGaXRJbWFnZVRvVmlld3BvcnQgPSAhMTtcbiAgICAgIH0pLCB0aGlzLnNkay5vbihcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICAgIHZhciBkLCBmO1xuICAgICAgICBjb25zdCB1ID0gdGhpcy5nZXRDZW50ZXIoKSwgYyA9ICgoZCA9IHRoaXMuaW1hZ2VNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQud2lkdGgpID8/IDAsIHAgPSAoKGYgPSB0aGlzLmltYWdlTWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBmLmhlaWdodCkgPz8gMDtcbiAgICAgICAgdGhpcy5zaG91bGRGaXRJbWFnZVRvVmlld3BvcnQgJiYgdGhpcy5maXRJbWFnZVRvVmlld3BvcnQoKSwgKHVbMF0gIT09IGMgLyAyIHx8IHVbMV0gIT09IHAgLyAyKSAmJiB0aGlzLnNldENlbnRlcih1KTtcbiAgICAgIH0pLCB0aGlzLmZpcmUoXCJpbWFnZXZpZXdlcnJlYWR5XCIsIG5ldyByZShcImltYWdldmlld2VycmVhZHlcIiwgdGhpcykpO1xuICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgIHRoaXMuZmlyZShcImltYWdldmlld2VyaW5pdGVycm9yXCIsIHsgZXJyb3I6IG8gfSk7XG4gICAgfVxuICB9XG4gIC8vI3JlZ2lvbiBmaXRJbWFnZVRvVmlld3BvcnRcbiAgLyoqXG4gICAqIEZpdHMgdGhlIGltYWdlIHRvIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGZpdCBpbWFnZSB0byB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmVhc2UgLSBXaGV0aGVyIHRvIGVhc2UgdG8gdGhlIHZpZXdwb3J0IGJvdW5kcy5cbiAgICovXG4gIGZpdEltYWdlVG9WaWV3cG9ydCh7IGVhc2U6IHQgPSAhMSB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VNZXRhZGF0YSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltJbWFnZVZpZXdlcl06IEltYWdlIG1ldGFkYXRhIG5vdCBmb3VuZFwiKTtcbiAgICBjb25zdCBuID0gdGhpcy5weFRvTG5nTGF0KFswLCAwXSksIGEgPSB0aGlzLnB4VG9MbmdMYXQoW3RoaXMuaW1hZ2VNZXRhZGF0YS53aWR0aCA/PyAwLCB0aGlzLmltYWdlTWV0YWRhdGEuaGVpZ2h0ID8/IDBdKSwgbyA9IHRoaXMuc2RrLmNhbWVyYUZvckJvdW5kcyhbbiwgYV0sIHsgcGFkZGluZzogNTAgfSk7XG4gICAgbyAmJiAodCA/IHRoaXMuc2RrLmVhc2VUbyh7IC4uLm8sIHBpdGNoOiAwIH0sIG51bGwpIDogdGhpcy5zZGsuanVtcFRvKHsgLi4ubywgcGl0Y2g6IDAgfSwgbnVsbCkpLCB0aGlzLnNob3VsZEZpdEltYWdlVG9WaWV3cG9ydCA9ICEwO1xuICB9XG4gIC8vI3JlZ2lvbiBmZXRjaEltYWdlTWV0YWRhdGFcbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIGltYWdlIG1ldGFkYXRhIGZyb20gdGhlIEFQSS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hJbWFnZU1ldGFkYXRhKCkge1xuICAgIGNvbnN0IHQgPSBFYyh0aGlzLmltYWdlVVVJRCksIG4gPSBhd2FpdCBmZXRjaCh0KTtcbiAgICBpZiAoIW4ub2spXG4gICAgICB0aHJvdyBuZXcgcGMobiwgXCJpbWFnZSBtZXRhZGF0YVwiLCBcIkltYWdlVmlld2VyXCIpO1xuICAgIGNvbnN0IGEgPSBhd2FpdCBuLmpzb24oKTtcbiAgICB0aGlzLmltYWdlTWV0YWRhdGEgPSBhLCBPYmplY3QuZnJlZXplKHRoaXMuaW1hZ2VNZXRhZGF0YSk7XG4gIH1cbiAgLy8jcmVnaW9uIGFkZEltYWdlU291cmNlXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBpbWFnZSBzb3VyY2UgdG8gdGhlIHNkayBpbnN0YW5jZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkSW1hZ2VTb3VyY2UoKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlTWV0YWRhdGEpXG4gICAgICB0aHJvdyB0aGlzLmZpcmUoXCJlcnJvclwiLCBuZXcgcmUoXCJlcnJvclwiLCB0aGlzLCBudWxsLCB7IGVycm9yOiBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJdOiBJbWFnZSBtZXRhZGF0YSBub3QgZm91bmRcIikgfSkpLCBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJdOiBJbWFnZSBtZXRhZGF0YSBub3QgZm91bmRcIik7XG4gICAgY29uc3QgdCA9IENjKHRoaXMuaW1hZ2VVVUlEKSwgbiA9IChzKSA9PiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cocykgLyBNYXRoLkxOMikpO1xuICAgIHRoaXMuaW1hZ2VTaXplID0gW3RoaXMuaW1hZ2VNZXRhZGF0YS53aWR0aCwgdGhpcy5pbWFnZU1ldGFkYXRhLmhlaWdodF0sIHRoaXMucGFkZGVkU2l6ZU1heCA9IE1hdGgubWF4KG4odGhpcy5pbWFnZVNpemVbMF0pLCBuKHRoaXMuaW1hZ2VTaXplWzFdKSk7XG4gICAgY29uc3QgYSA9IHRoaXMucHhUb0xuZ0xhdChbMCwgMF0pLCBvID0gdGhpcy5weFRvTG5nTGF0KHRoaXMuaW1hZ2VTaXplKSwgaSA9IFthLmxuZywgby5sYXQsIG8ubG5nLCBhLmxhdF07XG4gICAgdGhpcy5zZGsuYWRkU291cmNlKFwiaW1hZ2VcIiwge1xuICAgICAgLi4udGhpcy5pbWFnZU1ldGFkYXRhLFxuICAgICAgdHlwZTogXCJyYXN0ZXJcIixcbiAgICAgIGJvdW5kczogaSxcbiAgICAgIHRpbGVzOiBbdF1cbiAgICB9KSwgdGhpcy5zZGsuYWRkTGF5ZXIoe1xuICAgICAgaWQ6IFwiaW1hZ2VcIixcbiAgICAgIHR5cGU6IFwicmFzdGVyXCIsXG4gICAgICBzb3VyY2U6IFwiaW1hZ2VcIlxuICAgIH0pO1xuICB9XG4gIC8vI3JlZ2lvbiBTREsgbWFwcGluZ3NcbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgcmVwYWludCBvZiB0aGUgSW1hZ2VWaWV3ZXIuIFNhbWUgYXMgbWFwLnRyaWdnZXJSZXBhaW50KCkuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHRyaWdnZXJSZXBhaW50KCkge1xuICAgIHRoaXMuc2RrLnRyaWdnZXJSZXBhaW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JvbGwgem9vbSBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1Njcm9sbFpvb21IYW5kbGVyfVxuICAgKi9cbiAgZ2V0IHNjcm9sbFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnNjcm9sbFpvb207XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JvbGwgem9vbSBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtTY3JvbGxab29tSGFuZGxlcn0gdmFsdWUgLSBUaGUgc2Nyb2xsIHpvb20gaGFuZGxlci5cbiAgICovXG4gIHNldCBzY3JvbGxab29tKHQpIHtcbiAgICB0aGlzLnNkay5zY3JvbGxab29tID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJveCB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7Qm94Wm9vbUhhbmRsZXJ9XG4gICAqL1xuICBnZXQgYm94Wm9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsuYm94Wm9vbTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJveCB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge0JveFpvb21IYW5kbGVyfSB2YWx1ZSAtIFRoZSBib3ggem9vbSBoYW5kbGVyLlxuICAgKi9cbiAgc2V0IGJveFpvb20odCkge1xuICAgIHRoaXMuc2RrLmJveFpvb20gPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZHJhZyBwYW4gaGFuZGxlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtEcmFnUGFuSGFuZGxlcn1cbiAgICovXG4gIGdldCBkcmFnUGFuKCkge1xuICAgIHJldHVybiB0aGlzLnNkay5kcmFnUGFuO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZHJhZyBwYW4gaGFuZGxlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7RHJhZ1BhbkhhbmRsZXJ9IHZhbHVlIC0gVGhlIGRyYWcgcGFuIGhhbmRsZXIuXG4gICAqL1xuICBzZXQgZHJhZ1Bhbih0KSB7XG4gICAgdGhpcy5zZGsuZHJhZ1BhbiA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXlib2FyZCBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge0tleWJvYXJkSGFuZGxlcn1cbiAgICovXG4gIGdldCBrZXlib2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsua2V5Ym9hcmQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXlib2FyZCBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtLZXlib2FyZEhhbmRsZXJ9IHZhbHVlIC0gVGhlIGtleWJvYXJkIGhhbmRsZXIuXG4gICAqL1xuICBzZXQga2V5Ym9hcmQodCkge1xuICAgIHRoaXMuc2RrLmtleWJvYXJkID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGRvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7RG91YmxlQ2xpY2tab29tSGFuZGxlcn1cbiAgICovXG4gIGdldCBkb3VibGVDbGlja1pvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmRvdWJsZUNsaWNrWm9vbTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge0RvdWJsZUNsaWNrWm9vbUhhbmRsZXJ9IHZhbHVlIC0gVGhlIGRvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gICAqL1xuICBzZXQgZG91YmxlQ2xpY2tab29tKHQpIHtcbiAgICB0aGlzLnNkay5kb3VibGVDbGlja1pvb20gPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG91Y2ggem9vbSByb3RhdGUgaGFuZGxlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtUd29GaW5nZXJzVG91Y2hab29tUm90YXRlSGFuZGxlcn1cbiAgICovXG4gIGdldCB0b3VjaFpvb21Sb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnRvdWNoWm9vbVJvdGF0ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRvdWNoIHpvb20gcm90YXRlIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1R3b0ZpbmdlcnNUb3VjaFpvb21Sb3RhdGVIYW5kbGVyfSB2YWx1ZSAtIFRoZSB0b3VjaCB6b29tIHJvdGF0ZSBoYW5kbGVyLlxuICAgKi9cbiAgc2V0IHRvdWNoWm9vbVJvdGF0ZSh0KSB7XG4gICAgdGhpcy5zZGsudG91Y2hab29tUm90YXRlID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvb3BlcmF0aXZlIGdlc3R1cmVzIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7Q29vcGVyYXRpdmVHZXN0dXJlc0hhbmRsZXJ9XG4gICAqL1xuICBnZXQgY29vcGVyYXRpdmVHZXN0dXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsuY29vcGVyYXRpdmVHZXN0dXJlcztcbiAgfVxuICAvKipcbiAgICogVGhlIGNvb3BlcmF0aXZlIGdlc3R1cmVzIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge0Nvb3BlcmF0aXZlR2VzdHVyZXNIYW5kbGVyfSB2YWx1ZSAtIFRoZSBjb29wZXJhdGl2ZSBnZXN0dXJlcyBoYW5kbGVyLlxuICAgKi9cbiAgc2V0IGNvb3BlcmF0aXZlR2VzdHVyZXModCkge1xuICAgIHRoaXMuc2RrLmNvb3BlcmF0aXZlR2VzdHVyZXMgPSB0O1xuICB9XG4gIC8vI2VuZHJlZ2lvbiBTREsgTWFwcGluZ3NcbiAgLy8jcmVnaW9uIGxuZ0xhdFRvUHhcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgTG5nTGF0IHRvIGEgcHggY29vcmRpbmF0ZSwgYmFzZWQgb24gdGhlIGltYWdlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtMbmdMYXR9IGxuZ0xhdCAtIFRoZSBMbmdMYXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFRoZSBweCBjb29yZGluYXRlLlxuICAgKi9cbiAgbG5nTGF0VG9QeCh0KSB7XG4gICAgaWYgKCF0aGlzLnBhZGRlZFNpemVNYXgpIHtcbiAgICAgIGNvbnN0IGEgPSBcIltJbWFnZVZpZXdlcl06IFVuYWJsZSB0byBjb252ZXJ0IExuZ0xhdCB0byBweCwgcGFkZGVkIHNpemUgbWF4IG5vdCBzZXRcIjtcbiAgICAgIHRocm93IHRoaXMuZmlyZShcImVycm9yXCIsIG5ldyByZShcImVycm9yXCIsIHRoaXMsIG51bGwsIHsgZXJyb3I6IG5ldyBFcnJvcihhKSB9KSksIG5ldyBFcnJvcihhKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IGZuLmZyb21MbmdMYXQodCk7XG4gICAgcmV0dXJuIFtuLnggKiB0aGlzLnBhZGRlZFNpemVNYXgsIG4ueSAqIHRoaXMucGFkZGVkU2l6ZU1heF07XG4gIH1cbiAgLy8jcmVnaW9uIHB4VG9MbmdMYXRcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcHggY29vcmRpbmF0ZSB0byBhIExuZ0xhdCwgYmFzZWQgb24gdGhlIGltYWdlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtMbmdMYXR9IGxuZ0xhdCAtIFRoZSBMbmdMYXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFRoZSBweCBjb29yZGluYXRlLlxuICAgKi9cbiAgcHhUb0xuZ0xhdCh0KSB7XG4gICAgaWYgKCF0aGlzLnBhZGRlZFNpemVNYXgpIHtcbiAgICAgIGNvbnN0IGEgPSBcIltJbWFnZVZpZXdlcl06IFVuYWJsZSB0byBjb252ZXJ0IHB4IHRvIExuZ0xhdCwgcGFkZGVkIHNpemUgbWF4IG5vdCBzZXRcIjtcbiAgICAgIHRocm93IHRoaXMuZmlyZShcImVycm9yXCIsIG5ldyByZShcImVycm9yXCIsIHRoaXMsIG51bGwsIHsgZXJyb3I6IG5ldyBFcnJvcihhKSB9KSksIG5ldyBFcnJvcihhKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBmbih0WzBdIC8gdGhpcy5wYWRkZWRTaXplTWF4LCB0WzFdIC8gdGhpcy5wYWRkZWRTaXplTWF4KS50b0xuZ0xhdCgpO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRTREtJbnRlcm5hbFxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcm5hbCBTREsgaW5zdGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtNYXB9IFRoZSBpbnRlcm5hbCBTREsgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0U0RLSW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbnZhcyBvZiB0aGUgaW50ZXJuYWwgU0RLIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSBjYW52YXMgb2YgdGhlIGludGVybmFsIFNESyBpbnN0YW5jZS5cbiAgICovXG4gIGdldENhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsuZ2V0Q2FudmFzKCk7XG4gIH1cbiAgLy8jcmVnaW9uIGZseVRvXG4gIC8qKlxuICAgKiBGbHkgdG8gYSBnaXZlbiBjZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7SW1hZ2VWaWV3ZXJGbHlUb09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGZseSB0by5cbiAgICogQHBhcmFtIHtNYXBEYXRhRXZlbnR9IGV2ZW50RGF0YSAtIFRoZSBldmVudCBkYXRhLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJ9IFRoZSBJbWFnZVZpZXdlciBpbnN0YW5jZS5cbiAgICovXG4gIGZseVRvKHQsIG4pIHtcbiAgICBjb25zdCBhID0gdGhpcy5weFRvTG5nTGF0KHQuY2VudGVyKTtcbiAgICByZXR1cm4gdGhpcy5zZGsuZmx5VG8oeyAuLi50LCBwaXRjaDogMCwgY2VudGVyOiBhIH0sIG4pLCB0aGlzO1xuICB9XG4gIC8vI3JlZ2lvbiBqdW1wVG9cbiAgLyoqXG4gICAqIEp1bXAgdG8gYSBnaXZlbiBjZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7SW1hZ2VWaWV3ZXJKdW1wVG9PcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBqdW1wIHRvLlxuICAgKiBAcGFyYW0ge01hcERhdGFFdmVudH0gZXZlbnREYXRhIC0gVGhlIGV2ZW50IGRhdGEuXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlcn0gVGhlIEltYWdlVmlld2VyIGluc3RhbmNlLlxuICAgKi9cbiAganVtcFRvKHQsIG4pIHtcbiAgICBjb25zdCBhID0gdGhpcy5weFRvTG5nTGF0KHQuY2VudGVyKTtcbiAgICByZXR1cm4gdGhpcy5zZGsuanVtcFRvKHsgLi4udCwgcGl0Y2g6IDAsIGNlbnRlcjogYSB9LCBuKSwgdGhpcztcbiAgfVxuICAvLyNyZWdpb24gc2V0Wm9vbVxuICAvKipcbiAgICogU2V0IHRoZSB6b29tIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJ9IFRoZSBJbWFnZVZpZXdlciBpbnN0YW5jZS5cbiAgICovXG4gIHNldFpvb20odCkge1xuICAgIHJldHVybiB0aGlzLnNkay5zZXRab29tKHQpLCB0aGlzO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRab29tXG4gIC8qKlxuICAgKiBHZXQgdGhlIHpvb20gbGV2ZWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0Wm9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsuZ2V0Wm9vbSgpO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRDZW50ZXJcbiAgLyoqXG4gICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZVZpZXdlciBpbiBwaXhlbHMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyXX0gVGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VWaWV3ZXIuXG4gICAqL1xuICBnZXRDZW50ZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc2RrLmdldENlbnRlcigpO1xuICAgIHJldHVybiB0aGlzLmxuZ0xhdFRvUHgodCk7XG4gIH1cbiAgLy8jcmVnaW9uIHNldENlbnRlclxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgb2YgdGhlIEltYWdlVmlld2VyIGluIHBpeGVscy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlciAtIFRoZSBjZW50ZXIgb2YgdGhlIEltYWdlVmlld2VyLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJ9IFRoZSBJbWFnZVZpZXdlciBpbnN0YW5jZS5cbiAgICovXG4gIHNldENlbnRlcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnNldENlbnRlcih0aGlzLnB4VG9MbmdMYXQodCkpLCB0aGlzO1xuICB9XG4gIC8vI3JlZ2lvbiBzZXRCZWFyaW5nXG4gIC8qKlxuICAgKiBTZXQgdGhlIGJlYXJpbmcgb2YgdGhlIEltYWdlVmlld2VyIGluIGRlZ3JlZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIC0gVGhlIGJlYXJpbmcgb2YgdGhlIEltYWdlVmlld2VyLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJ9IFRoZSBJbWFnZVZpZXdlciBpbnN0YW5jZS5cbiAgICovXG4gIHNldEJlYXJpbmcodCkge1xuICAgIHJldHVybiB0aGlzLnNkay5zZXRCZWFyaW5nKHQpLCB0aGlzO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRCZWFyaW5nXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJlYXJpbmcgb2YgdGhlIEltYWdlVmlld2VyIGluIGRlZ3JlZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBiZWFyaW5nIG9mIHRoZSBJbWFnZVZpZXdlci5cbiAgICovXG4gIGdldEJlYXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmdldEJlYXJpbmcoKTtcbiAgfVxuICAvLyNyZWdpb24gcGFuQnlcbiAgLyoqXG4gICAqIFBhbiBieSBhIGdpdmVuIGRlbHRhIGluIHBpeGVscy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludExpa2V9IGRlbHRhIC0gVGhlIGRlbHRhIHRvIHBhbiBieS5cbiAgICogQHBhcmFtIHtJbWFnZVZpZXdlckVhc2VUb09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBhbi5cbiAgICogQHBhcmFtIHthbnl9IGV2ZW50RGF0YSAtIFRoZSBldmVudCBkYXRhLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJ9IFRoZSBJbWFnZVZpZXdlciBpbnN0YW5jZS5cbiAgICovXG4gIHBhbkJ5KHQsIG4sIGEpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsucGFuQnkodCwgeyAuLi5uLCBwaXRjaDogMCB9LCBhKSwgdGhpcztcbiAgfVxuICAvLyNyZWdpb24gcGFuVG9cbiAgLyoqXG4gICAqIFBhbiB0byBhIGdpdmVuIGNlbnRlciBpbiBwaXhlbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXIgLSBUaGUgY2VudGVyIHRvIHBhbiB0by5cbiAgICogQHBhcmFtIHtJbWFnZVZpZXdlckVhc2VUb09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBhbi5cbiAgICogQHBhcmFtIHthbnl9IGV2ZW50RGF0YSAtIFRoZSBldmVudCBkYXRhLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJ9IFRoZSBJbWFnZVZpZXdlciBpbnN0YW5jZS5cbiAgICovXG4gIHBhblRvKHQsIG4sIGEpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsucGFuVG8odGhpcy5weFRvTG5nTGF0KHQpLCB7IC4uLm4sIHBpdGNoOiAwIH0sIGEpLCB0aGlzO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRJbWFnZU1ldGFkYXRhXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SW1hZ2VNZXRhZGF0YX0gVGhlIGltYWdlIG1ldGFkYXRhLlxuICAgKi9cbiAgZ2V0SW1hZ2VNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZU1ldGFkYXRhO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRJbWFnZUJvdW5kc1xuICAvKipcbiAgICogR2V0IHRoZSB2aXNpYmxlIGJvdW5kcyBvZiB0aGUgaW1hZ2UgaW4gdGhlIHZpZXdwb3J0IGluIGltYWdlUGl4ZWxzLlxuICAgKiBbdG9wTGVmdCwgYm90dG9tUmlnaHRdXG4gICAqXG4gICAqIEByZXR1cm5zIHtbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV19IFRoZSB2aXNpYmxlIGJvdW5kcyBvZiB0aGUgaW1hZ2UuXG4gICAqL1xuICBnZXRJbWFnZUJvdW5kcygpIHtcbiAgICBjb25zdCBuID0gdGhpcy5zZGsuZ2V0Qm91bmRzKCkudG9BcnJheSgpLm1hcCgoaSkgPT4gdGhpcy5sbmdMYXRUb1B4KHZpLmNvbnZlcnQoaSkpKSwgYSA9IFtuWzBdWzBdLCBuWzFdWzFdXSwgbyA9IFtuWzFdWzBdLCBuWzBdWzFdXTtcbiAgICByZXR1cm4gW2EsIG9dO1xuICB9XG4gIC8vI3JlZ2lvbiBmaXRJbWFnZUJvdW5kc1xuICAvKipcbiAgICogU2V0IHRoZSBib3VuZHMgb2YgdGhlIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1tbbnVtYmVyLCBudW1iZXJdLCBbbnVtYmVyLCBudW1iZXJdXX0gYm91bmRzIC0gVGhlIGJvdW5kcyBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlcn0gVGhlIEltYWdlVmlld2VyIGluc3RhbmNlLlxuICAgKi9cbiAgZml0SW1hZ2VCb3VuZHMoW3QsIG5dKSB7XG4gICAgY29uc3QgYSA9IHRoaXMucHhUb0xuZ0xhdCh0KSwgbyA9IHRoaXMucHhUb0xuZ0xhdChuKSwgaSA9IFhjLmNvbnZlcnQoW2EsIG9dKTtcbiAgICByZXR1cm4gdGhpcy5zZGsuZml0Qm91bmRzKGkpLCB0aGlzO1xuICB9XG4gIC8vI3JlZ2lvbiByZW1vdmVcbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBJbWFnZVZpZXdlciwgcmVtb3ZlcyB0aGUgbWFwIGluc3RhbmNlIGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzLiBVc2VmdWwgZm9yIGNsZWFudXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlcn0gVGhlIEltYWdlVmlld2VyIGluc3RhbmNlLlxuICAgKi9cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuZmlyZShcImJlZm9yZXJlbW92ZVwiLCBuZXcgcmUoXCJiZWZvcmVyZW1vdmVcIiwgdGhpcykpLCB0aGlzLnNkay5yZW1vdmUoKSwgdGhpcy5fbGlzdGVuZXJzICYmIE9iamVjdC5lbnRyaWVzKHRoaXMuX2xpc3RlbmVycykuZm9yRWFjaCgoW3QsIG5dKSA9PiB7XG4gICAgICBuLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgdGhpcy5vZmYodCwgYSk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5fb25lVGltZUxpc3RlbmVycyAmJiBPYmplY3QuZW50cmllcyh0aGlzLl9vbmVUaW1lTGlzdGVuZXJzKS5mb3JFYWNoKChbdCwgbl0pID0+IHtcbiAgICAgIG4uZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICB0aGlzLm9mZih0LCBhKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHBvaW50SXNXaXRoaW5JbWFnZUJvdW5kcyh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0SW1hZ2VNZXRhZGF0YSgpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBhID0gW1xuICAgICAgWzAsIDBdLFxuICAgICAgW24ud2lkdGgsIG4uaGVpZ2h0XVxuICAgIF07XG4gICAgcmV0dXJuIHRbMF0gPj0gYVswXVswXSAmJiB0WzBdIDw9IGFbMV1bMF0gJiYgdFsxXSA+PSBhWzBdWzFdICYmIHRbMV0gPD0gYVsxXVsxXTtcbiAgfVxufVxuZnVuY3Rpb24gRWMocikge1xuICByZXR1cm4gYCR7YWkoKX0vJHtyfS9pbWFnZS5qc29uP2tleT0ke2ouYXBpS2V5fWA7XG59XG5mdW5jdGlvbiBDYyhyKSB7XG4gIHJldHVybiBgJHthaSgpfS8ke3J9L3t6fS97eH0ve3l9P2tleT0ke2ouYXBpS2V5fWA7XG59XG5mdW5jdGlvbiBhaSgpIHtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL2ltYWdlc1wiO1xufVxuY29uc3QgeyBFdmVudGVkOiBBYyB9ID0gTDtcbmNsYXNzIGtwIGV4dGVuZHMgQWMge1xuICBjb25zdHJ1Y3Rvcih7IC4uLnQgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgZyh0aGlzLCBcInZpZXdlclwiKTtcbiAgICBnKHRoaXMsIFwibWFya2VyXCIpO1xuICAgIGcodGhpcywgXCJwb3NpdGlvblwiLCBbMCwgMF0pO1xuICAgIHRoaXMubWFya2VyID0gbmV3IE1pKHQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBJbWFnZVZpZXdlck1hcmtlciB0byBhbiBpbnN0YW5jZSBvZiBJbWFnZVZpZXdlci5cbiAgICpcbiAgICogQHBhcmFtIHtJbWFnZVZpZXdlcn0gdmlld2VyIC0gVGhlIGluc3RhbmNlIG9mIEltYWdlVmlld2VyIHRvIGFkZCB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIgdG8uXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlck1hcmtlcn0gVGhlIEltYWdlVmlld2VyTWFya2VyIGluc3RhbmNlLlxuICAgKi9cbiAgYWRkVG8odCkge1xuICAgIGlmICghKHQgaW5zdGFuY2VvZiBMYykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJNYXJrZXJdOiBhbiBJbWFnZVZpZXdlck1hcmtlciBtdXN0IGJlIGFkZGVkIHRvIGFuIGluc3RhbmNlIG9mIEltYWdlVmlld2VyXCIpO1xuICAgIHRoaXMudmlld2VyID0gdCwgTWModGhpcy5tYXJrZXIsIHRoaXMsIHRoaXMudmlld2VyW3JpXSk7XG4gICAgY29uc3QgbiA9IHRoaXMudmlld2VyLmdldFNES0ludGVybmFsKCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0UG9zaXRpb24odGhpcy5wb3NpdGlvbiksIGJjKHRoaXMubWFya2VyKSwgdGhpcy5tYXJrZXIuYWRkVG8obiksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyBuYW1lIHRvIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBjbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlck1hcmtlcn0gVGhlIEltYWdlVmlld2VyTWFya2VyIGluc3RhbmNlLlxuICAgKi9cbiAgYWRkQ2xhc3NOYW1lKHQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIuYWRkQ2xhc3NOYW1lKHQpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbGVtZW50IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5nZXRFbGVtZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHJldHVybnMge1BvaW50TGlrZX0gVGhlIHBvc2l0aW9uIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHNlZSAgW1BvaW50TGlrZV0oaHR0cHM6Ly9kb2NzLm1hcHRpbGVyLmNvbS9zZGstanMvYXBpL2dlb2dyYXBoeS8jcG9pbnRsaWtlKVxuICAgKlxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG9mZnNldCBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQb2ludExpa2V9IFRoZSBvZmZzZXQgb2YgdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKiBAc2VlICBbUG9pbnRMaWtlXShodHRwczovL2RvY3MubWFwdGlsZXIuY29tL3Nkay1qcy9hcGkvZ2VvZ3JhcGh5LyNwb2ludGxpa2UpXG4gICAqL1xuICBnZXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2VyLmdldE9mZnNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwaXRjaCBhbGlnbm1lbnQgb2YgdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QWxpZ25tZW50fSBUaGUgcGl0Y2ggYWxpZ25tZW50IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHNlZSAgW01hcExpYnJlR0wuQWxpZ25tZW50XShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1nbC1qcy9kb2NzL0FQSS90eXBlLWFsaWFzZXMvQWxpZ25tZW50LylcbiAgICovXG4gIGdldFBpdGNoQWxpZ25tZW50KCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5nZXRQaXRjaEFsaWdubWVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwb3B1cCBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQb3B1cH0gVGhlIHBvcHVwIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHNlZSBbUG9wdXBdKGh0dHBzOi8vZG9jcy5tYXB0aWxlci5jb20vc2RrLWpzL2FwaS9tYXJrZXJzLyNwb3B1cClcbiAgICovXG4gIGdldFBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5nZXRQb3B1cCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3RhdGlvbiBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqL1xuICBnZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIuZ2V0Um90YXRpb24oKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcm90YXRpb24gYWxpZ25tZW50IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHJldHVybnMge0FsaWdubWVudH0gVGhlIHJvdGF0aW9uIGFsaWdubWVudCBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqIEBzZWUgIFtNYXBMaWJyZUdMLkFsaWdubWVudF0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtZ2wtanMvZG9jcy9BUEkvdHlwZS1hbGlhc2VzL0FsaWdubWVudC8pXG4gICAqL1xuICBnZXRSb3RhdGlvbkFsaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIuZ2V0Um90YXRpb25BbGlnbm1lbnQoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBJbWFnZVZpZXdlck1hcmtlciBpcyBkcmFnZ2FibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBJbWFnZVZpZXdlck1hcmtlciBpcyBkcmFnZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5pc0RyYWdnYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJlcyBhbiBldmVudCBvbiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFya2VyRXZlbnRUeXBlcyB8IEV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBmaXJlLlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGRhdGEgLSBUaGUgZGF0YSB0byBmaXJlIHRoZSBldmVudCB3aXRoLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJNYXJrZXJ9IFRoZSBJbWFnZVZpZXdlck1hcmtlciBpbnN0YW5jZS5cbiAgICovXG4gIGZpcmUodCwgbikge1xuICAgIHJldHVybiBzdXBlci5maXJlKHQsIG4pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge01hcmtlckV2ZW50VHlwZXN9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbS5cbiAgICogQHBhcmFtIHtJbWFnZVZpZXdlck1hcmtlckV2ZW50fSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlck1hcmtlcn0gVGhlIEltYWdlVmlld2VyTWFya2VyIGluc3RhbmNlLlxuICAgKi9cbiAgb2ZmKHQsIG4pIHtcbiAgICByZXR1cm4gc3VwZXIub2ZmKHQsIG4pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZXJFdmVudFR5cGVzfSBldmVudCAtIFRoZSBldmVudCB0byBhZGQgdGhlIGxpc3RlbmVyIHRvLlxuICAgKiBAcGFyYW0ge0ltYWdlVmlld2VyTWFya2VyRXZlbnR9IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIHRvIGFkZC5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICBvbih0LCBuKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uKHQsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIEltYWdlVmlld2VyTWFya2VyIGlzIHdpdGhpbiB0aGUgaW1hZ2UgYm91bmRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaXMgd2l0aGluIHRoZSBpbWFnZSBib3VuZHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzV2l0aGluSW1hZ2VCb3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld2VyLnBvaW50SXNXaXRoaW5JbWFnZUJvdW5kcyh0aGlzLnBvc2l0aW9uKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIgZnJvbSB0aGUgSW1hZ2VWaWV3ZXIgYW5kIGNsZWFucyB1cCB0aGUgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJNYXJrZXJ9IFRoZSBJbWFnZVZpZXdlck1hcmtlciBpbnN0YW5jZS5cbiAgICovXG4gIHJlbW92ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIucmVtb3ZlKCksIHRoaXMubWFya2VyLl9saXN0ZW5lcnMgJiYgT2JqZWN0LmVudHJpZXModGhpcy5tYXJrZXIuX2xpc3RlbmVycykuZm9yRWFjaCgoW3QsIG5dKSA9PiB7XG4gICAgICBuLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgdGhpcy5vZmYodCwgYSk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5tYXJrZXIuX29uZVRpbWVMaXN0ZW5lcnMgJiYgT2JqZWN0LmVudHJpZXModGhpcy5tYXJrZXIuX29uZVRpbWVMaXN0ZW5lcnMpLmZvckVhY2goKFt0LCBuXSkgPT4ge1xuICAgICAgbi5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKHQsIGEpO1xuICAgICAgfSk7XG4gICAgfSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBuYW1lIGZyb20gdGhlIEltYWdlVmlld2VyTWFya2VyIGRvbSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlIGZyb20gdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJNYXJrZXJ9IFRoZSBJbWFnZVZpZXdlck1hcmtlciBpbnN0YW5jZS5cbiAgICovXG4gIHJlbW92ZUNsYXNzTmFtZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2VyLnJlbW92ZUNsYXNzTmFtZSh0KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZHJhZ2dhYmxlIHN0YXRlIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBkcmFnZ2FibGUgLSBUaGUgZHJhZ2dhYmxlIHN0YXRlIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzZXREcmFnZ2FibGUodCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5zZXREcmFnZ2FibGUodCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBweCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW4gaW1hZ2UgcGl4ZWxzLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJNYXJrZXJ9IFRoZSBJbWFnZVZpZXdlck1hcmtlciBpbnN0YW5jZS5cbiAgICovXG4gIHNldFBvc2l0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvblswXSA9IHRbMF0sIHRoaXMucG9zaXRpb25bMV0gPSB0WzFdLCAhdGhpcy52aWV3ZXIpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBuID0gdGhpcy52aWV3ZXJbbmldKHQpO1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5zZXRMbmdMYXQobiksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9mZnNldCBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnRMaWtlfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRPZmZzZXQodCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci5zZXRPZmZzZXQodCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BhY2l0eSAtIFRoZSBvcGFjaXR5IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wYWNpdHlXaGVuQ292ZXJlZCAtIFRoZSBvcGFjaXR5IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlciB3aGVuIGNvdmVyZWQuXG4gICAqIEByZXR1cm5zIHtJbWFnZVZpZXdlck1hcmtlcn0gVGhlIEltYWdlVmlld2VyTWFya2VyIGluc3RhbmNlLlxuICAgKi9cbiAgc2V0T3BhY2l0eSh0LCBuKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2VyLnNldE9wYWNpdHkodCwgbiksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBpdGNoIGFsaWdubWVudCBvZiB0aGUgSW1hZ2VWaWV3ZXJNYXJrZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QWxpZ25tZW50fSBwaXRjaEFsaWdubWVudCAtIFRoZSBwaXRjaCBhbGlnbm1lbnQgb2YgdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJNYXJrZXJ9IFRoZSBJbWFnZVZpZXdlck1hcmtlciBpbnN0YW5jZS5cbiAgICogQHNlZSAgW01hcExpYnJlR0wuQWxpZ25tZW50XShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1nbC1qcy9kb2NzL0FQSS90eXBlLWFsaWFzZXMvQWxpZ25tZW50LylcbiAgICovXG4gIHNldFBpdGNoQWxpZ25tZW50KHQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIuc2V0UGl0Y2hBbGlnbm1lbnQodCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvcHVwIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtQb3B1cH0gcG9wdXAgLSBUaGUgcG9wdXAgb2YgdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKiBAcmV0dXJucyB7SW1hZ2VWaWV3ZXJNYXJrZXJ9IFRoZSBJbWFnZVZpZXdlck1hcmtlciBpbnN0YW5jZS5cbiAgICogQHNlZSBbUG9wdXBdKGh0dHBzOi8vZG9jcy5tYXB0aWxlci5jb20vc2RrLWpzL2FwaS9tYXJrZXJzLyNwb3B1cClcbiAgICovXG4gIHNldFBvcHVwKHQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIuc2V0UG9wdXAodCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRSb3RhdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2VyLnNldFJvdGF0aW9uKHQpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSByb3RhdGlvbiBhbGlnbm1lbnQgb2YgdGhlIEltYWdlVmlld2VyTWFya2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FsaWdubWVudH0gcm90YXRpb25BbGlnbm1lbnQgLSBUaGUgcm90YXRpb24gYWxpZ25tZW50IG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqIEBzZWUgIFtNYXBMaWJyZUdMLkFsaWdubWVudF0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtZ2wtanMvZG9jcy9BUEkvdHlwZS1hbGlhc2VzL0FsaWdubWVudC8pXG4gICAqL1xuICBzZXRSb3RhdGlvbkFsaWdubWVudCh0KSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2VyLnNldFJvdGF0aW9uQWxpZ25tZW50KHQpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGlmIHN1YnBpeGVsIHBvc2l0aW9uaW5nIGlzIGVuYWJsZWQgZm9yIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdWJwaXhlbFBvc2l0aW9uaW5nIC0gVGhlIHN1YnBpeGVsIHBvc2l0aW9uaW5nIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRTdWJwaXhlbFBvc2l0aW9uaW5nKHQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIuc2V0U3VicGl4ZWxQb3NpdGlvbmluZyh0KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBhIGNsYXNzIG5hbWUgb24gdGhlIEltYWdlVmlld2VyTWFya2VyIGRvbSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIGNsYXNzIG5hbWUgdG8gdG9nZ2xlIG9uIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICB0b2dnbGVDbGFzc05hbWUodCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlci50b2dnbGVDbGFzc05hbWUodCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHBvcHVwIG9mIHRoZSBJbWFnZVZpZXdlck1hcmtlci5cbiAgICpcbiAgICogQHJldHVybnMge0ltYWdlVmlld2VyTWFya2VyfSBUaGUgSW1hZ2VWaWV3ZXJNYXJrZXIgaW5zdGFuY2UuXG4gICAqL1xuICB0b2dnbGVQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXIudG9nZ2xlUG9wdXAoKSwgdGhpcztcbiAgfVxufVxuY29uc3QgVGMgPSBbXCJkcmFnc3RhcnRcIiwgXCJkcmFnXCIsIFwiZHJhZ2VuZFwiXSwgX2MgPSBbXCJsbmdMYXRcIiwgXCJfZGVmYXVsdFByZXZlbnRlZFwiLCBcInRhcmdldFwiXTtcbmNsYXNzIEljIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIGcodGhpcywgXCJ0eXBlXCIpO1xuICAgIGcodGhpcywgXCJ0YXJnZXRcIik7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy50YXJnZXQgPSB0LCBPYmplY3QuYXNzaWduKHRoaXMsIG4pO1xuICB9XG59XG5mdW5jdGlvbiBNYyhyLCBlLCB0KSB7XG4gIFRjLmZvckVhY2goKG4pID0+IHtcbiAgICByLm9uKG4sIChhKSA9PiB7XG4gICAgICB2YXIgaSwgcztcbiAgICAgIGlmICgoaSA9IGEudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogaS5nZXRMbmdMYXQoKSkge1xuICAgICAgICBjb25zdCBsID0gdCgocyA9IGEudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogcy5nZXRMbmdMYXQoKSk7XG4gICAgICAgIGUuc2V0UG9zaXRpb24obCk7XG4gICAgICB9XG4gICAgICBlLmZpcmUoXG4gICAgICAgIG4sXG4gICAgICAgIG5ldyBJYyhuLCBlLCB7XG4gICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGEpLmZpbHRlcigoW2xdKSA9PiAhX2MuaW5jbHVkZXMobCkpKVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkbihyKSB7XG4gIGlmICh0eXBlb2YgRE9NUGFyc2VyIDwgXCJ1XCIpIHtcbiAgICBjb25zdCBlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhyLCBcImFwcGxpY2F0aW9uL3htbFwiKTtcbiAgICBpZiAoZS5xdWVyeVNlbGVjdG9yKFwicGFyc2VyZXJyb3JcIikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgc3RyaW5nIGlzIG5vdCB2YWxpZCBYTUxcIik7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gWE1MIHBhcnNlciBmb3VuZFwiKTtcbn1cbmZ1bmN0aW9uIG9pKHIsIGUpIHtcbiAgaWYgKCFyLmhhc0NoaWxkTm9kZXMoKSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAoY29uc3QgdCBvZiBBcnJheS5mcm9tKHIuY2hpbGROb2RlcykpIHtcbiAgICBjb25zdCBuID0gdC5ub2RlTmFtZTtcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiBuLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBlLnRvTG93ZXJDYXNlKCkpXG4gICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcWEocikge1xuICBpZiAodHlwZW9mIFhNTFNlcmlhbGl6ZXIgPCBcInVcIilcbiAgICByZXR1cm4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhyKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gWE1MIHNlcmlhbGl6ZXIgZm91bmRcIik7XG59XG5mdW5jdGlvbiBpaShyKSB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gJG4ocikgOiByO1xuICBpZiAoIW9pKGUsIFwiZ3B4XCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBYTUwgZG9jdW1lbnQgaXMgbm90IHZhbGlkIEdQWFwiKTtcbiAgY29uc3QgdCA9IEgoZSwgXCJ0cmtcIiksIG4gPSBIKGUsIFwicnRlXCIpLCBhID0gSChlLCBcIndwdFwiKSwgbyA9IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgZmVhdHVyZXM6IFtdXG4gIH07XG4gIGZvciAoY29uc3QgaSBvZiBBcnJheS5mcm9tKHQpKSB7XG4gICAgY29uc3QgcyA9IE9jKGkpO1xuICAgIHMgJiYgby5mZWF0dXJlcy5wdXNoKHMpO1xuICB9XG4gIGZvciAoY29uc3QgaSBvZiBBcnJheS5mcm9tKG4pKSB7XG4gICAgY29uc3QgcyA9ICRjKGkpO1xuICAgIHMgJiYgby5mZWF0dXJlcy5wdXNoKHMpO1xuICB9XG4gIGZvciAoY29uc3QgaSBvZiBBcnJheS5mcm9tKGEpKVxuICAgIG8uZmVhdHVyZXMucHVzaChGYyhpKSk7XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gc2kociwgZSkge1xuICBsZXQgdCA9IHI7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gJG4odCkpLCAhb2kodCwgXCJrbWxcIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFhNTCBkb2N1bWVudCBpcyBub3QgdmFsaWQgS01MXCIpO1xuICBjb25zdCBuID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICBmZWF0dXJlczogW11cbiAgfSwgYSA9IHt9LCBvID0ge30sIGkgPSB7fSwgcyA9IEgodCwgXCJQbGFjZW1hcmtcIiksIGwgPSBIKHQsIFwiU3R5bGVcIiksIHUgPSBIKHQsIFwiU3R5bGVNYXBcIik7XG4gIGZvciAoY29uc3QgYyBvZiBBcnJheS5mcm9tKGwpKSB7XG4gICAgY29uc3QgcCA9IEdhKGUgIT09IHZvaWQgMCA/IGUoYykgOiBxYShjKSkudG9TdHJpbmcoMTYpO1xuICAgIGFbYCMke1hlKGMsIFwiaWRcIil9YF0gPSBwLCBvW3BdID0gYztcbiAgfVxuICBmb3IgKGNvbnN0IGMgb2YgQXJyYXkuZnJvbSh1KSkge1xuICAgIGFbYCMke1hlKGMsIFwiaWRcIil9YF0gPSBHYShlICE9PSB2b2lkIDAgPyBlKGMpIDogcWEoYykpLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBwID0gSChjLCBcIlBhaXJcIiksIGQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgQXJyYXkuZnJvbShwKSlcbiAgICAgIGRbRihfKGYsIFwia2V5XCIpKSA/PyBcIlwiXSA9IEYoXyhmLCBcInN0eWxlVXJsXCIpKTtcbiAgICBpW2AjJHtYZShjLCBcImlkXCIpfWBdID0gZDtcbiAgfVxuICBmb3IgKGNvbnN0IGMgb2YgQXJyYXkuZnJvbShzKSlcbiAgICBuLmZlYXR1cmVzID0gbi5mZWF0dXJlcy5jb25jYXQoemMoYywgYSwgbywgaSkpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFZhKHIpIHtcbiAgaWYgKHIgPT09IG51bGwpIHJldHVybiBbXCIjMDAwMDAwXCIsIDFdO1xuICBsZXQgZSA9IFwiXCIsIHQgPSAxLCBuID0gcjtcbiAgcmV0dXJuIG4uc3RhcnRzV2l0aChcIiNcIikgJiYgKG4gPSBuLnN1YnN0cmluZygxKSksIChuLmxlbmd0aCA9PT0gNiB8fCBuLmxlbmd0aCA9PT0gMykgJiYgKGUgPSBuKSwgbi5sZW5ndGggPT09IDggJiYgKHQgPSBOdW1iZXIucGFyc2VJbnQobi5zdWJzdHJpbmcoMCwgMiksIDE2KSAvIDI1NSwgZSA9IGAjJHtuLnN1YnN0cmluZyg2LCA4KX0ke24uc3Vic3RyaW5nKDQsIDYpfSR7bi5zdWJzdHJpbmcoMiwgNCl9YCksIFtlID8/IFwiIzAwMDAwMFwiLCB0ID8/IDFdO1xufVxuZnVuY3Rpb24gUGMocikge1xuICByZXR1cm4gY2koci5zcGxpdChcIiBcIikpO1xufVxuZnVuY3Rpb24gUmMocikge1xuICBsZXQgZSA9IEgociwgXCJjb29yZFwiKTtcbiAgY29uc3QgdCA9IFtdLCBuID0gW107XG4gIGUubGVuZ3RoID09PSAwICYmIChlID0gSChyLCBcImd4OmNvb3JkXCIpKTtcbiAgZm9yIChjb25zdCBvIG9mIEFycmF5LmZyb20oZSkpXG4gICAgdC5wdXNoKFBjKEYobykgPz8gXCJcIikpO1xuICBjb25zdCBhID0gSChyLCBcIndoZW5cIik7XG4gIGZvciAoY29uc3QgbyBvZiBBcnJheS5mcm9tKGEpKSBuLnB1c2goRihvKSk7XG4gIHJldHVybiB7XG4gICAgY29vcmRzOiB0LFxuICAgIHRpbWVzOiBuXG4gIH07XG59XG5mdW5jdGlvbiBYdChyKSB7XG4gIGNvbnN0IGUgPSBbXCJQb2x5Z29uXCIsIFwiTGluZVN0cmluZ1wiLCBcIlBvaW50XCIsIFwiVHJhY2tcIiwgXCJneDpUcmFja1wiXTtcbiAgbGV0IHQsIG4sIGEsIG8sIGk7XG4gIGNvbnN0IHMgPSBbXSwgbCA9IFtdO1xuICBpZiAoXyhyLCBcIk11bHRpR2VvbWV0cnlcIikgIT09IG51bGwpXG4gICAgcmV0dXJuIFh0KF8ociwgXCJNdWx0aUdlb21ldHJ5XCIpKTtcbiAgaWYgKF8ociwgXCJNdWx0aVRyYWNrXCIpICE9PSBudWxsKVxuICAgIHJldHVybiBYdChfKHIsIFwiTXVsdGlUcmFja1wiKSk7XG4gIGlmIChfKHIsIFwiZ3g6TXVsdGlUcmFja1wiKSAhPT0gbnVsbClcbiAgICByZXR1cm4gWHQoXyhyLCBcImd4Ok11bHRpVHJhY2tcIikpO1xuICBmb3IgKGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKylcbiAgICBpZiAobiA9IEgociwgZVthXSksIG4pIHtcbiAgICAgIGZvciAobyA9IDA7IG8gPCBuLmxlbmd0aDsgbysrKVxuICAgICAgICBpZiAodCA9IG5bb10sIGVbYV0gPT09IFwiUG9pbnRcIilcbiAgICAgICAgICBzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHBpKEYoXyh0LCBcImNvb3JkaW5hdGVzXCIpKSA/PyBcIlwiKVxuICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChlW2FdID09PSBcIkxpbmVTdHJpbmdcIilcbiAgICAgICAgICBzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogWmEoRihfKHQsIFwiY29vcmRpbmF0ZXNcIikpID8/IFwiXCIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKGVbYV0gPT09IFwiUG9seWdvblwiKSB7XG4gICAgICAgICAgY29uc3QgdSA9IEgodCwgXCJMaW5lYXJSaW5nXCIpLCBjID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjLnB1c2goWmEoRihfKHVbaV0sIFwiY29vcmRpbmF0ZXNcIikpID8/IFwiXCIpKTtcbiAgICAgICAgICBzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVbYV0gPT09IFwiVHJhY2tcIiB8fCBlW2FdID09PSBcImd4OlRyYWNrXCIpIHtcbiAgICAgICAgICBjb25zdCB1ID0gUmModCk7XG4gICAgICAgICAgcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHUuY29vcmRzXG4gICAgICAgICAgfSksIHUudGltZXMubGVuZ3RoICYmIGwucHVzaCh1LnRpbWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIHsgZ2VvbXM6IHMsIGNvb3JkVGltZXM6IGwgfTtcbn1cbmZ1bmN0aW9uIHpjKHIsIGUsIHQsIG4pIHtcbiAgY29uc3QgYSA9IFh0KHIpLCBvID0ge30sIGkgPSBGKF8ociwgXCJuYW1lXCIpKSwgcyA9IEYoXyhyLCBcImFkZHJlc3NcIikpLCBsID0gRihfKHIsIFwiZGVzY3JpcHRpb25cIikpLCB1ID0gXyhyLCBcIlRpbWVTcGFuXCIpLCBjID0gXyhyLCBcIlRpbWVTdGFtcFwiKSwgcCA9IF8ociwgXCJFeHRlbmRlZERhdGFcIiksIGQgPSBfKHIsIFwidmlzaWJpbGl0eVwiKTtcbiAgbGV0IGYsIGggPSBGKF8ociwgXCJzdHlsZVVybFwiKSksIG0gPSBfKHIsIFwiTGluZVN0eWxlXCIpLCB5ID0gXyhyLCBcIlBvbHlTdHlsZVwiKTtcbiAgaWYgKCFhLmdlb21zLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBpZiAoaSAmJiAoby5uYW1lID0gaSksIHMgJiYgKG8uYWRkcmVzcyA9IHMpLCBoKSB7XG4gICAgaC5zdGFydHNXaXRoKFwiI1wiKSB8fCAoaCA9IGAjJHtofWApLCBvLnN0eWxlVXJsID0gaCwgZVtoXSAmJiAoby5zdHlsZUhhc2ggPSBlW2hdKSwgbltoXSAmJiAoby5zdHlsZU1hcEhhc2ggPSBuW2hdLCBvLnN0eWxlSGFzaCA9IGVbbltoXS5ub3JtYWwgPz8gXCJcIl0pO1xuICAgIGNvbnN0IHYgPSB0W28uc3R5bGVIYXNoID8/IFwiXCJdO1xuICAgIGlmICh2KSB7XG4gICAgICBtIHx8IChtID0gXyh2LCBcIkxpbmVTdHlsZVwiKSksIHkgfHwgKHkgPSBfKHYsIFwiUG9seVN0eWxlXCIpKTtcbiAgICAgIGNvbnN0IHggPSBfKHYsIFwiSWNvblN0eWxlXCIpO1xuICAgICAgaWYgKHgpIHtcbiAgICAgICAgY29uc3QgQSA9IF8oeCwgXCJJY29uXCIpO1xuICAgICAgICBpZiAoQSkge1xuICAgICAgICAgIGNvbnN0IEUgPSBGKF8oQSwgXCJocmVmXCIpKTtcbiAgICAgICAgICBFICYmIChvLmljb24gPSBFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobCAmJiAoby5kZXNjcmlwdGlvbiA9IGwpLCB1KSB7XG4gICAgY29uc3QgdiA9IEYoXyh1LCBcImJlZ2luXCIpKSwgeCA9IEYoXyh1LCBcImVuZFwiKSk7XG4gICAgdiAmJiB4ICYmIChvLnRpbWVzcGFuID0geyBiZWdpbjogdiwgZW5kOiB4IH0pO1xuICB9XG4gIGlmIChjICE9PSBudWxsICYmIChvLnRpbWVzdGFtcCA9IEYoXyhjLCBcIndoZW5cIikpID8/ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSksIG0gIT09IG51bGwpIHtcbiAgICBjb25zdCB2ID0gVmEoRihfKG0sIFwiY29sb3JcIikpKSwgeCA9IHZbMF0sIEEgPSB2WzFdLCBFID0gTnVtYmVyLnBhcnNlRmxvYXQoRihfKG0sIFwid2lkdGhcIikpID8/IFwiXCIpO1xuICAgIHggJiYgKG8uc3Ryb2tlID0geCksIE51bWJlci5pc05hTihBKSB8fCAob1tcInN0cm9rZS1vcGFjaXR5XCJdID0gQSksIE51bWJlci5pc05hTihFKSB8fCAob1tcInN0cm9rZS13aWR0aFwiXSA9IEUpO1xuICB9XG4gIGlmICh5KSB7XG4gICAgY29uc3QgdiA9IFZhKEYoXyh5LCBcImNvbG9yXCIpKSksIHggPSB2WzBdLCBBID0gdlsxXSwgRSA9IEYoXyh5LCBcImZpbGxcIikpLCBDID0gRihfKHksIFwib3V0bGluZVwiKSk7XG4gICAgeCAmJiAoby5maWxsID0geCksIE51bWJlci5pc05hTihBKSB8fCAob1tcImZpbGwtb3BhY2l0eVwiXSA9IEEpLCBFICYmIChvW1wiZmlsbC1vcGFjaXR5XCJdID0gRSA9PT0gXCIxXCIgPyBvW1wiZmlsbC1vcGFjaXR5XCJdIHx8IDEgOiAwKSwgQyAmJiAob1tcInN0cm9rZS1vcGFjaXR5XCJdID0gQyA9PT0gXCIxXCIgPyBvW1wic3Ryb2tlLW9wYWNpdHlcIl0gfHwgMSA6IDApO1xuICB9XG4gIGlmIChwKSB7XG4gICAgY29uc3QgdiA9IEgocCwgXCJEYXRhXCIpLCB4ID0gSChwLCBcIlNpbXBsZURhdGFcIik7XG4gICAgZm9yIChmID0gMDsgZiA8IHYubGVuZ3RoOyBmKyspXG4gICAgICBvW3ZbZl0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA/PyBcIlwiXSA9IEYoXyh2W2ZdLCBcInZhbHVlXCIpKSA/PyBcIlwiO1xuICAgIGZvciAoZiA9IDA7IGYgPCB4Lmxlbmd0aDsgZisrKVxuICAgICAgb1t4W2ZdLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPz8gXCJcIl0gPSBGKHhbZl0pID8/IFwiXCI7XG4gIH1cbiAgZCAhPT0gbnVsbCAmJiAoby52aXNpYmlsaXR5ID0gRihkKSA/PyBcIlwiKSwgYS5jb29yZFRpbWVzLmxlbmd0aCAhPT0gMCAmJiAoby5jb29yZFRpbWVzID0gYS5jb29yZFRpbWVzLmxlbmd0aCA9PT0gMSA/IGEuY29vcmRUaW1lc1swXSA6IGEuY29vcmRUaW1lcyk7XG4gIGNvbnN0IHcgPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgZ2VvbWV0cnk6IGEuZ2VvbXMubGVuZ3RoID09PSAxID8gYS5nZW9tc1swXSA6IHtcbiAgICAgIHR5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgICBnZW9tZXRyaWVzOiBhLmdlb21zXG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiBvXG4gIH07XG4gIHJldHVybiBYZShyLCBcImlkXCIpICYmICh3LmlkID0gWGUociwgXCJpZFwiKSA/PyB2b2lkIDApLCBbd107XG59XG5mdW5jdGlvbiBsaShyLCBlKSB7XG4gIGNvbnN0IHQgPSBIKHIsIGUpLCBuID0gW10sIGEgPSBbXTtcbiAgbGV0IG8gPSBbXTtcbiAgY29uc3QgaSA9IHQubGVuZ3RoO1xuICBpZiAoIShpIDwgMikpIHtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IGk7IHMrKykge1xuICAgICAgY29uc3QgbCA9IGZpKHRbc10pO1xuICAgICAgbi5wdXNoKGwuY29vcmRpbmF0ZXMpLCBsLnRpbWUgJiYgYS5wdXNoKGwudGltZSksIChsLmhlYXJ0UmF0ZSB8fCBvLmxlbmd0aCkgJiYgKG8ubGVuZ3RoID09PSAwICYmIChvID0gbmV3IEFycmF5KHMpLmZpbGwobnVsbCkpLCBvLnB1c2gobC5oZWFydFJhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG4sXG4gICAgICB0aW1lczogYSxcbiAgICAgIGhlYXJ0UmF0ZXM6IG9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBPYyhyKSB7XG4gIGNvbnN0IGUgPSBIKHIsIFwidHJrc2VnXCIpLCB0ID0gW10sIG4gPSBbXSwgYSA9IFtdO1xuICBsZXQgbztcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcysrKVxuICAgIGlmIChvID0gbGkoZVtzXSwgXCJ0cmtwdFwiKSwgbyAhPT0gdm9pZCAwICYmIChvLmxpbmUgJiYgdC5wdXNoKG8ubGluZSksIG8udGltZXMgJiYgby50aW1lcy5sZW5ndGggJiYgbi5wdXNoKG8udGltZXMpLCBhLmxlbmd0aCB8fCBvLmhlYXJ0UmF0ZXMgJiYgby5oZWFydFJhdGVzLmxlbmd0aCkpIHtcbiAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgczsgbCsrKVxuICAgICAgICAgIGEucHVzaChuZXcgQXJyYXkodFtsXS5sZW5ndGgpLmZpbGwobnVsbCkpO1xuICAgICAgby5oZWFydFJhdGVzICYmIG8uaGVhcnRSYXRlcy5sZW5ndGggPyBhLnB1c2goby5oZWFydFJhdGVzKSA6IGEucHVzaChuZXcgQXJyYXkoby5saW5lLmxlbmd0aCkuZmlsbChudWxsKSk7XG4gICAgfVxuICBpZiAodC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgY29uc3QgaSA9IHtcbiAgICAuLi5GbihyKSxcbiAgICAuLi51aShfKHIsIFwiZXh0ZW5zaW9uc1wiKSlcbiAgfTtcbiAgcmV0dXJuIG4ubGVuZ3RoICE9PSAwICYmIChpLmNvb3JkVGltZXMgPSB0Lmxlbmd0aCA9PT0gMSA/IG5bMF0gOiBuKSwgYS5sZW5ndGggIT09IDAgJiYgKGkuaGVhcnRSYXRlcyA9IHQubGVuZ3RoID09PSAxID8gYVswXSA6IGEpLCB0Lmxlbmd0aCA9PT0gMSA/IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBwcm9wZXJ0aWVzOiBpLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgIGNvb3JkaW5hdGVzOiB0WzBdXG4gICAgfVxuICB9IDoge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgIHByb3BlcnRpZXM6IGksXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgICBjb29yZGluYXRlczogdFxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uICRjKHIpIHtcbiAgY29uc3QgZSA9IGxpKHIsIFwicnRlcHRcIik7XG4gIHJldHVybiBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgLi4uRm4ociksXG4gICAgICAuLi51aShfKHIsIFwiZXh0ZW5zaW9uc1wiKSlcbiAgICB9LFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgIGNvb3JkaW5hdGVzOiBlLmxpbmVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBGYyhyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgcHJvcGVydGllczogeyAuLi5GbihyKSwgLi4ub24ociwgW1wic3ltXCJdKSB9LFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICBjb29yZGluYXRlczogZmkocikuY29vcmRpbmF0ZXNcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1aShyKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgaWYgKHIpIHtcbiAgICBjb25zdCB0ID0gXyhyLCBcImxpbmVcIik7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IG4gPSBGKF8odCwgXCJjb2xvclwiKSksIGEgPSBOdW1iZXIucGFyc2VGbG9hdChGKF8odCwgXCJvcGFjaXR5XCIpKSA/PyBcIjBcIiksIG8gPSBOdW1iZXIucGFyc2VGbG9hdChGKF8odCwgXCJ3aWR0aFwiKSkgPz8gXCIwXCIpO1xuICAgICAgbiAmJiAoZS5zdHJva2UgPSBuKSwgTnVtYmVyLmlzTmFOKGEpIHx8IChlW1wic3Ryb2tlLW9wYWNpdHlcIl0gPSBhKSwgTnVtYmVyLmlzTmFOKG8pIHx8IChlW1wic3Ryb2tlLXdpZHRoXCJdID0gbyAqIDk2IC8gMjUuNCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gRm4ocikge1xuICBjb25zdCBlID0gb24ociwgW1wibmFtZVwiLCBcImNtdFwiLCBcImRlc2NcIiwgXCJ0eXBlXCIsIFwidGltZVwiLCBcImtleXdvcmRzXCJdKSwgdCA9IEgociwgXCJsaW5rXCIpO1xuICBpZiAodC5sZW5ndGggIT09IDApIHtcbiAgICBlLmxpbmtzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIEFycmF5LmZyb20odCkpIHtcbiAgICAgIGNvbnN0IGEgPSB7XG4gICAgICAgIGhyZWY6IFhlKG4sIFwiaHJlZlwiKSxcbiAgICAgICAgLi4ub24obiwgW1widGV4dFwiLCBcInR5cGVcIl0pXG4gICAgICB9O1xuICAgICAgZS5saW5rcy5wdXNoKGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEdhKHIpIHtcbiAgbGV0IGUgPSAwO1xuICBpZiAoIXIgfHwgIXIubGVuZ3RoKSByZXR1cm4gZTtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKVxuICAgIGUgPSAoZSA8PCA1KSAtIGUgKyByLmNoYXJDb2RlQXQodCkgfCAwO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEgociwgZSkge1xuICByZXR1cm4gci5nZXRFbGVtZW50c0J5VGFnTmFtZShlKTtcbn1cbmZ1bmN0aW9uIFhlKHIsIGUpIHtcbiAgcmV0dXJuIHIuZ2V0QXR0cmlidXRlKGUpO1xufVxuZnVuY3Rpb24gSGEociwgZSkge1xuICByZXR1cm4gTnVtYmVyLnBhcnNlRmxvYXQoWGUociwgZSkgPz8gXCIwXCIpO1xufVxuZnVuY3Rpb24gXyhyLCBlKSB7XG4gIGNvbnN0IHQgPSBIKHIsIGUpO1xuICByZXR1cm4gdC5sZW5ndGggPyB0WzBdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIE5jKHIpIHtcbiAgcmV0dXJuIHIubm9ybWFsaXplICYmIHIubm9ybWFsaXplKCksIHI7XG59XG5mdW5jdGlvbiBjaShyKSB7XG4gIHJldHVybiByLm1hcChOdW1iZXIucGFyc2VGbG9hdCkubWFwKChlKSA9PiBOdW1iZXIuaXNOYU4oZSkgPyBudWxsIDogZSk7XG59XG5mdW5jdGlvbiBGKHIpIHtcbiAgcmV0dXJuIHIgJiYgTmMociksIHIgJiYgci50ZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIG9uKHIsIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICBsZXQgbiwgYTtcbiAgZm9yIChhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspXG4gICAgbiA9IF8ociwgZVthXSksIG4gJiYgKHRbZVthXV0gPSBGKG4pID8/IFwiXCIpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHBpKHIpIHtcbiAgcmV0dXJuIGNpKHIucmVwbGFjZSgvXFxzKi9nLCBcIlwiKS5zcGxpdChcIixcIikpO1xufVxuZnVuY3Rpb24gWmEocikge1xuICBjb25zdCBlID0gci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCBcIlwiKS5zcGxpdCgvXFxzKy8pLCB0ID0gW107XG4gIGZvciAoY29uc3QgbiBvZiBlKSB0LnB1c2gocGkobikpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGZpKHIpIHtcbiAgY29uc3QgZSA9IFtIYShyLCBcImxvblwiKSwgSGEociwgXCJsYXRcIildLCB0ID0gXyhyLCBcImVsZVwiKSwgbiA9IF8ociwgXCJncHh0cHg6aHJcIikgfHwgXyhyLCBcImhyXCIpLCBhID0gXyhyLCBcInRpbWVcIik7XG4gIGxldCBvO1xuICByZXR1cm4gdCAmJiAobyA9IE51bWJlci5wYXJzZUZsb2F0KEYodCkgPz8gXCIwXCIpLCBOdW1iZXIuaXNOYU4obykgfHwgZS5wdXNoKG8pKSwge1xuICAgIGNvb3JkaW5hdGVzOiBlLFxuICAgIHRpbWU6IGEgPyBGKGEpIDogbnVsbCxcbiAgICBoZWFydFJhdGU6IG4gIT09IG51bGwgPyBOdW1iZXIucGFyc2VGbG9hdChGKG4pID8/IFwiMFwiKSA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGpjKHIpIHtcbiAgbGV0IGUgPSByO1xuICB0cnkge1xuICAgIHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgKGUgPSAkbihlKSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGlpKGUpO1xuICB9IGNhdGNoIHtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBzaShlKTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBEYyhyLCBlID0ge30pIHtcbiAgY29uc3QgdCA9IGUuZG93bmxvYWQgPz8gITEsIG4gPSBhd2FpdCBVYyhyKTtcbiAgaWYgKHQpIHtcbiAgICBjb25zdCBhID0gZS5maWxlbmFtZSA/PyBcIm1hcHRpbGVyX3NjcmVlbnNob3QucG5nXCIsIG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBvLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvKSwgby5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuKSwgby5kb3dubG9hZCA9IGEsIG8uY2xpY2soKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG8pLCBVUkwucmV2b2tlT2JqZWN0VVJMKG8uaHJlZik7XG4gICAgfSwgMCk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBVYyhyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSwgdCkgPT4ge1xuICAgIHIucmVkcmF3KCksIHIub25jZShcImlkbGVcIiwgKCkgPT4ge1xuICAgICAgci5nZXRDYW52YXMoKS50b0Jsb2IoKG4pID0+IHtcbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgdChFcnJvcihcIlNjcmVlbnNob3QgY291bGQgbm90IGJlIGNyZWF0ZWQuXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZShuKTtcbiAgICAgIH0sIFwiaW1hZ2UvcG5nXCIpO1xuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IHNuID0gW1xuICAvLyBodHRwczovL2NvbG9yaHVudC5jby9wYWxldHRlLzFkNWI3OTQ2OGI5N2VmNjI2MmYzYWE2MFxuICBbXCIjMUQ1Qjc5XCIsIFwiIzQ2OEI5N1wiLCBcIiNFRjYyNjJcIiwgXCIjRjNBQTYwXCJdLFxuICAvLyBodHRwczovL2NvbG9yaHVudC5jby9wYWxldHRlLzYxNGJjMzMzYmJjNTg1ZTZjNWM4ZmZlMFxuICBbXCIjNjE0QkMzXCIsIFwiIzMzQkJDNVwiLCBcIiM4NUU2QzVcIiwgXCIjQzhGRkUwXCJdLFxuICAvLyBodHRwczovL2NvbG9yaHVudC5jby9wYWxldHRlLzQ2MTk1OTdhMzE2ZmNkNjY4OGFlZDhjY1xuICBbXCIjNDYxOTU5XCIsIFwiIzdBMzE2RlwiLCBcIiNDRDY2ODhcIiwgXCIjQUVEOENDXCJdLFxuICAvLyBodHRwczovL2NvbG9yaHVudC5jby9wYWxldHRlLzAwNzlmZjAwZGZhMmY2ZmE3MGZmMDA2MFxuICBbXCIjMDA3OUZGXCIsIFwiIzAwREZBMlwiLCBcIiNGNkZBNzBcIiwgXCIjRkYwMDYwXCJdLFxuICAvL2h0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMzliNWUwYTMxYWNiZmY3OGYwZjVlYTVhXG4gIFtcIiMzOUI1RTBcIiwgXCIjQTMxQUNCXCIsIFwiI0ZGNzhGMFwiLCBcIiNGNUVBNUFcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMzdlMmQ1NTkwNjk2YzcwYTgwZmJjYjBhXG4gIFtcIiMzN0UyRDVcIiwgXCIjNTkwNjk2XCIsIFwiI0M3MEE4MFwiLCBcIiNGQkNCMEFcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvZmZkMzZlZmZmNTZkOTlmZmNkOWZiNGZmXG4gIFtcIiNGRkQzNkVcIiwgXCIjRkZGNTZEXCIsIFwiIzk5RkZDRFwiLCBcIiM5RkI0RkZcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMDBlYWQzZmZmNWI3ZmY0NDlmMDA1Zjk5XG4gIFtcIiMwMEVBRDNcIiwgXCIjRkZGNUI3XCIsIFwiI0ZGNDQ5RlwiLCBcIiMwMDVGOTlcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMTBhMTlkNTQwMzc1ZmY3MDAwZmZiZjAwXG4gIFtcIiMxMEExOURcIiwgXCIjNTQwMzc1XCIsIFwiI0ZGNzAwMFwiLCBcIiNGRkJGMDBcIl1cbl07XG5mdW5jdGlvbiBrcigpIHtcbiAgcmV0dXJuIHNuW35+KE1hdGgucmFuZG9tKCkgKiBzbi5sZW5ndGgpXVt+fihNYXRoLnJhbmRvbSgpICogNCldO1xufVxuZnVuY3Rpb24gUHQoKSB7XG4gIHJldHVybiBgbWFwdGlsZXJfc291cmNlXyR7UWEoKX1gO1xufVxuZnVuY3Rpb24gUnQoKSB7XG4gIHJldHVybiBgbWFwdGlsZXJfbGF5ZXJfJHtRYSgpfWA7XG59XG5mdW5jdGlvbiBsbihyLCBlKSB7XG4gIGlmIChlIDw9IHJbMF0uem9vbSlcbiAgICByZXR1cm4gclswXS52YWx1ZTtcbiAgaWYgKGUgPj0gcltyLmxlbmd0aCAtIDFdLnpvb20pXG4gICAgcmV0dXJuIHJbci5sZW5ndGggLSAxXS52YWx1ZTtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCByLmxlbmd0aCAtIDE7IHQgKz0gMSlcbiAgICBpZiAoZSA+PSByW3RdLnpvb20gJiYgZSA8IHJbdCArIDFdLnpvb20pIHtcbiAgICAgIGNvbnN0IG4gPSByW3QgKyAxXS56b29tIC0gclt0XS56b29tLCBhID0gKGUgLSByW3RdLnpvb20pIC8gbjtcbiAgICAgIHJldHVybiBhICogclt0ICsgMV0udmFsdWUgKyAoMSAtIGEpICogclt0XS52YWx1ZTtcbiAgICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gamUocikge1xuICByZXR1cm4gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAuLi5yLmZsYXRNYXAoKGUpID0+IFtlLnpvb20sIGUudmFsdWVdKV07XG59XG5mdW5jdGlvbiBPKHIpIHtcbiAgcmV0dXJuIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiem9vbVwiXSwgLi4uci5mbGF0TWFwKChlKSA9PiBbZS56b29tLCBlLnZhbHVlXSldO1xufVxuZnVuY3Rpb24gZGkociwgZSkge1xuICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgciA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiAyICogZSArIHI7XG4gIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiICYmIEFycmF5LmlzQXJyYXkocikpXG4gICAgcmV0dXJuIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiem9vbVwiXSwgLi4uci5mbGF0TWFwKCh0KSA9PiBbdC56b29tLCAyICogZSArIHQudmFsdWVdKV07XG4gIGlmICh0eXBlb2YgciA9PSBcIm51bWJlclwiICYmIEFycmF5LmlzQXJyYXkoZSkpXG4gICAgcmV0dXJuIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiem9vbVwiXSwgLi4uZS5mbGF0TWFwKCh0KSA9PiBbdC56b29tLCAyICogdC52YWx1ZSArIHJdKV07XG4gIGlmIChBcnJheS5pc0FycmF5KHIpICYmIEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICBjb25zdCB0ID0gQXJyYXkuZnJvbSgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uci5tYXAoKG4pID0+IG4uem9vbSksIC4uLmUubWFwKChuKSA9PiBuLnpvb20pXSkpLnNvcnQoKG4sIGEpID0+IG4gPCBhID8gLTEgOiAxKTtcbiAgICByZXR1cm4gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAuLi50LmZsYXRNYXAoKG4pID0+IFtuLCAyICogbG4oZSwgbikgKyBsbihyLCBuKV0pXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGhpKHIsIGUpIHtcbiAgcmV0dXJuIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKHQpID0+IFt0LnByb3BlcnR5VmFsdWUsIHQudmFsdWVdKV07XG59XG5mdW5jdGlvbiBObihyKSB7XG4gIGNvbnN0IGUgPSByLnRyaW1TdGFydCgpLCB0ID0gYCR7ZX0ke1wiIFwiLnJlcGVhdChyLmxlbmd0aCAtIGUubGVuZ3RoKX1gLCBuID0gQXJyYXkuZnJvbSh0KTtcbiAgaWYgKCFuLmV2ZXJ5KChzKSA9PiBzID09PSBcIiBcIiB8fCBzID09PSBcIl9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBkYXNoIHBhdHRlcm4gbXVzdCBiZSBjb21wb3NlZCBvbmx5IG9mIHdoaXRlc3BhY2UgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycy5cIik7XG4gIGlmICghKG4uc29tZSgocykgPT4gcyA9PT0gXCJfXCIpICYmIG4uc29tZSgocykgPT4gcyA9PT0gXCIgXCIpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGRhc2ggcGF0dGVybiBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHVuZGVyc2NvcmUgYW5kIG9uZSB3aGl0ZXNwYWNlIGNoYXJhY3RlclwiKTtcbiAgY29uc3QgaSA9IFsxXTtcbiAgZm9yIChsZXQgcyA9IDE7IHMgPCBuLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgY29uc3QgbCA9IG5bcyAtIDFdLCB1ID0gbltzXTtcbiAgICBsID09PSB1ID8gaVtpLmxlbmd0aCAtIDFdICs9IDEgOiBpLnB1c2goMSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB1bihyLCBlKSB7XG4gIHJldHVybiBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKCh0KSA9PiBbdC52YWx1ZSwgdC5jb2xvcl0pXTtcbn1cbmZ1bmN0aW9uIGNuKHIsIGUsIHQgPSAhMCkge1xuICByZXR1cm4gdCA/IFtcbiAgICBcImludGVycG9sYXRlXCIsXG4gICAgW1wibGluZWFyXCJdLFxuICAgIFtcInpvb21cIl0sXG4gICAgMCxcbiAgICBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKChuKSA9PiBbbi52YWx1ZSwgbi5wb2ludFJhZGl1cyAqIDAuMDI1XSldLFxuICAgIDIsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24udmFsdWUsIG4ucG9pbnRSYWRpdXMgKiAwLjA1XSldLFxuICAgIDQsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24udmFsdWUsIG4ucG9pbnRSYWRpdXMgKiAwLjFdKV0sXG4gICAgOCxcbiAgICBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKChuKSA9PiBbbi52YWx1ZSwgbi5wb2ludFJhZGl1cyAqIDAuMjVdKV0sXG4gICAgMTYsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24udmFsdWUsIG4ucG9pbnRSYWRpdXNdKV1cbiAgXSA6IFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnZhbHVlLCBuLnBvaW50UmFkaXVzXSldO1xufVxuZnVuY3Rpb24gbWkociwgZSwgdCA9ICEwKSB7XG4gIHJldHVybiB0ID8gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiem9vbVwiXSxcbiAgICAwLFxuICAgIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnByb3BlcnR5VmFsdWUsIG4udmFsdWUgKiAwLjAyNV0pXSxcbiAgICAyLFxuICAgIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnByb3BlcnR5VmFsdWUsIG4udmFsdWUgKiAwLjA1XSldLFxuICAgIDQsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24ucHJvcGVydHlWYWx1ZSwgbi52YWx1ZSAqIDAuMV0pXSxcbiAgICA4LFxuICAgIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnByb3BlcnR5VmFsdWUsIG4udmFsdWUgKiAwLjI1XSldLFxuICAgIDE2LFxuICAgIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnByb3BlcnR5VmFsdWUsIG4udmFsdWVdKV1cbiAgXSA6IFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnByb3BlcnR5VmFsdWUsIG4udmFsdWVdKV07XG59XG5mdW5jdGlvbiBwbihyLCBlKSB7XG4gIHJldHVybiByLmV2ZXJ5KCh0KSA9PiB0LmNvbG9yWzNdID09PSByWzBdLmNvbG9yWzNdKSA/IHJbMF0uY29sb3JbM10gPyByWzBdLmNvbG9yWzNdIC8gMjU1IDogMSA6IFtcbiAgICBcImludGVycG9sYXRlXCIsXG4gICAgW1wibGluZWFyXCJdLFxuICAgIFtcImdldFwiLCBlXSxcbiAgICAuLi5yLmdldFJhd0NvbG9yU3RvcHMoKS5mbGF0TWFwKCh0KSA9PiB7XG4gICAgICBjb25zdCBuID0gdC52YWx1ZSwgYSA9IHQuY29sb3I7XG4gICAgICByZXR1cm4gW24sIGEubGVuZ3RoID09PSA0ID8gYVszXSAvIDI1NSA6IDFdO1xuICAgIH0pXG4gIF07XG59XG5mdW5jdGlvbiB5aShyLCBlID0gMTApIHtcbiAgcmV0dXJuIFtcbiAgICBcImludGVycG9sYXRlXCIsXG4gICAgW1wibGluZWFyXCJdLFxuICAgIFtcImhlYXRtYXAtZGVuc2l0eVwiXSxcbiAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiBlICsgMSB9LCAodCwgbikgPT4ge1xuICAgICAgY29uc3QgYSA9IG4gLyBlO1xuICAgICAgcmV0dXJuIFthLCByLmdldENvbG9ySGV4KGEpXTtcbiAgICB9KS5mbGF0KClcbiAgXTtcbn1cbmZ1bmN0aW9uIEd0KHIpIHtcbiAgY29uc3QgZSA9IHIudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gZS5sZW5ndGggPT09IDEgPyBgMCR7ZX1gIDogZTtcbn1cbmZ1bmN0aW9uIEJjKHIpIHtcbiAgcmV0dXJuIGAjJHtHdChyWzBdKX0ke0d0KHJbMV0pfSR7R3QoclsyXSl9JHtyLmxlbmd0aCA9PT0gNCA/IEd0KHJbM10pIDogXCJcIn1gO1xufVxuY2xhc3MgVCBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IodCA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBnKHRoaXMsIFwibWluXCIsIDApO1xuICAgIGcodGhpcywgXCJtYXhcIiwgMSk7XG4gICAgXCJtaW5cIiBpbiB0ICYmICh0aGlzLm1pbiA9IHQubWluKSwgXCJtYXhcIiBpbiB0ICYmICh0aGlzLm1heCA9IHQubWF4KSwgXCJzdG9wc1wiIGluIHQgJiYgdGhpcy5zZXRTdG9wcyh0LnN0b3BzLCB7IGNsb25lOiAhMSB9KTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYSBhcnJheS1kZWZpbml0aW9uIGNvbG9yIHJhbXAgZGVmaW5pdGlvbiBpbnRvIGEgdXNhYmxlIENvbG9yUmFtcCBpbnN0YW5jZS5cbiAgICogTm90ZTogdW5pdHMgYXJlIG5vdCBjb252ZXJ0ZWQgYW5kIG1heSBuZWVkIHRvIHRvIGJlIGNvbnZlcnRlZCBiZWZvcmVoYW5kIChlZy4ga2VsdmluIHRvIGNlbnRpZ3JhZGUpXG4gICAqIEBwYXJhbSBjclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGZyb21BcnJheURlZmluaXRpb24odCkge1xuICAgIHJldHVybiBuZXcgVCh7XG4gICAgICBzdG9wczogdC5tYXAoKG4pID0+ICh7XG4gICAgICAgIHZhbHVlOiBuWzBdLFxuICAgICAgICBjb2xvcjogblsxXVxuICAgICAgfSkpXG4gICAgfSk7XG4gIH1cbiAgc2V0U3RvcHModCwgbiA9IHsgY2xvbmU6ICEwIH0pIHtcbiAgICBjb25zdCBhID0gbi5jbG9uZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXM7XG4gICAgYS5sZW5ndGggPSAwO1xuICAgIGxldCBvID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBpID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMgKz0gMSlcbiAgICAgIG8gPSBNYXRoLm1pbihvLCB0W3NdLnZhbHVlKSwgaSA9IE1hdGgubWF4KGksIHRbc10udmFsdWUpLCBhLnB1c2goe1xuICAgICAgICB2YWx1ZTogdFtzXS52YWx1ZSxcbiAgICAgICAgY29sb3I6IHRbc10uY29sb3Iuc2xpY2UoKVxuICAgICAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBhIGRlZXAgY29weSBhbmQgbm90IGEgcmVmZXJlbmNlXG4gICAgICB9KTtcbiAgICByZXR1cm4gYS5zb3J0KChzLCBsKSA9PiBzLnZhbHVlIDwgbC52YWx1ZSA/IC0xIDogMSksIHRoaXMubWluID0gbywgdGhpcy5tYXggPSBpLCBhO1xuICB9XG4gIHNjYWxlKHQsIG4sIGEgPSB7IGNsb25lOiAhMCB9KSB7XG4gICAgY29uc3QgbyA9IGEuY2xvbmUsIGkgPSB0aGlzWzBdLnZhbHVlLCBsID0gdGhpcy5hdCgtMSkudmFsdWUgLSBpLCB1ID0gbiAtIHQsIGMgPSBbXTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IHRoaXMubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgIGNvbnN0IGggPSAodGhpc1twXS52YWx1ZSAtIGkpIC8gbCAqIHUgKyB0O1xuICAgICAgbyA/IGMucHVzaCh7XG4gICAgICAgIHZhbHVlOiBoLFxuICAgICAgICBjb2xvcjogdGhpc1twXS5jb2xvci5zbGljZSgpXG4gICAgICB9KSA6IHRoaXNbcF0udmFsdWUgPSBoO1xuICAgIH1cbiAgICByZXR1cm4gbyA/IG5ldyBUKHsgc3RvcHM6IGMgfSkgOiB0aGlzO1xuICB9XG4gIC8vIGZvciBzb21lIHJlYXNvbiwgSSBoYWQgdG8gcmVpbXBsZW1lbnQgdGhpc1xuICBhdCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwID8gdGhpc1t0aGlzLmxlbmd0aCArIHRdIDogdGhpc1t0XTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFQoeyBzdG9wczogdGhpcy5nZXRSYXdDb2xvclN0b3BzKCkgfSk7XG4gIH1cbiAgZ2V0UmF3Q29sb3JTdG9wcygpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLmxlbmd0aDsgbiArPSAxKVxuICAgICAgdC5wdXNoKHsgdmFsdWU6IHRoaXNbbl0udmFsdWUsIGNvbG9yOiB0aGlzW25dLmNvbG9yIH0pO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHJldmVyc2UodCA9IHsgY2xvbmU6ICEwIH0pIHtcbiAgICBjb25zdCBuID0gdC5jbG9uZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXM7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCB+fihuLmxlbmd0aCAvIDIpOyBhICs9IDEpIHtcbiAgICAgIGNvbnN0IG8gPSBuW2FdLmNvbG9yO1xuICAgICAgblthXS5jb2xvciA9IG4uYXQoLShhICsgMSkpLmNvbG9yLCBuLmF0KC0oYSArIDEpKS5jb2xvciA9IG87XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4geyBtaW46IHRoaXMubWluLCBtYXg6IHRoaXMubWF4IH07XG4gIH1cbiAgZ2V0Q29sb3IodCwgbiA9IHsgc21vb3RoOiAhMCB9KSB7XG4gICAgaWYgKHQgPD0gdGhpc1swXS52YWx1ZSlcbiAgICAgIHJldHVybiB0aGlzWzBdLmNvbG9yO1xuICAgIGlmICh0ID49IHRoaXMuYXQoLTEpLnZhbHVlKVxuICAgICAgcmV0dXJuIHRoaXMuYXQoLTEpLmNvbG9yO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5sZW5ndGggLSAxOyBhICs9IDEpIHtcbiAgICAgIGlmICh0ID4gdGhpc1thICsgMV0udmFsdWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbyA9IHRoaXNbYV0uY29sb3I7XG4gICAgICBpZiAoIW4uc21vb3RoKVxuICAgICAgICByZXR1cm4gby5zbGljZSgpO1xuICAgICAgY29uc3QgaSA9IHRoaXNbYV0udmFsdWUsIHMgPSB0aGlzW2EgKyAxXS52YWx1ZSwgbCA9IHRoaXNbYSArIDFdLmNvbG9yLCB1ID0gKHMgLSB0KSAvIChzIC0gaSk7XG4gICAgICByZXR1cm4gby5tYXAoKGMsIHApID0+IE1hdGgucm91bmQoYyAqIHUgKyBsW3BdICogKDEgLSB1KSkpO1xuICAgIH1cbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIGFzIGFuIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgZ2V0Q29sb3JIZXgodCwgbiA9IHtcbiAgICBzbW9vdGg6ICEwLFxuICAgIHdpdGhBbHBoYTogITFcbiAgfSkge1xuICAgIHJldHVybiBCYyh0aGlzLmdldENvbG9yKHQsIG4pKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciBvZiB0aGUgY29sb3IgcmFtcCBhdCBhIHJlbGF0aXZlIHBvc2l0aW9uIGluIFswLCAxXVxuICAgKi9cbiAgZ2V0Q29sb3JSZWxhdGl2ZSh0LCBuID0geyBzbW9vdGg6ICEwIH0pIHtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5nZXRDb2xvcihhLm1pbiArIHQgKiAoYS5tYXggLSBhLm1pbiksIG4pO1xuICB9XG4gIGdldENhbnZhc1N0cmlwKHQgPSB7XG4gICAgaG9yaXpvbnRhbDogITAsXG4gICAgc2l6ZTogNTEyLFxuICAgIHNtb290aDogITBcbiAgfSkge1xuICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIG4ud2lkdGggPSB0Lmhvcml6b250YWwgPyB0LnNpemUgOiAxLCBuLmhlaWdodCA9IHQuaG9yaXpvbnRhbCA/IDEgOiB0LnNpemU7XG4gICAgY29uc3QgYSA9IG4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghYSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FudnMgY29udGV4dCBpcyBtaXNzaW5nXCIpO1xuICAgIGNvbnN0IG8gPSBhLmdldEltYWdlRGF0YSgwLCAwLCBuLndpZHRoLCBuLmhlaWdodCksIGkgPSBvLmRhdGEsIHMgPSB0LnNpemUsIGwgPSB0aGlzWzBdLnZhbHVlLCBwID0gKHRoaXMuYXQoLTEpLnZhbHVlIC0gbCkgLyBzO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgczsgZCArPSAxKSB7XG4gICAgICBjb25zdCBmID0gdGhpcy5nZXRDb2xvcihsICsgZCAqIHAsIHtcbiAgICAgICAgc21vb3RoOiB0LnNtb290aFxuICAgICAgfSk7XG4gICAgICBpW2QgKiA0XSA9IGZbMF0sIGlbZCAqIDQgKyAxXSA9IGZbMV0sIGlbZCAqIDQgKyAyXSA9IGZbMl0sIGlbZCAqIDQgKyAzXSA9IGYubGVuZ3RoID4gMyA/IGZbM10gOiAyNTU7XG4gICAgfVxuICAgIHJldHVybiBhLnB1dEltYWdlRGF0YShvLCAwLCAwKSwgbjtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgYSBub24tbGluZWFyIHJlc3NhbXBsaW5nLiBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yUmFtcCB3aXRoIHRoZSBzYW1lIGJvdW5kcy5cbiAgICovXG4gIHJlc2FtcGxlKHQsIG4gPSAxNSkge1xuICAgIGNvbnN0IGEgPSB0aGlzLmdldEJvdW5kcygpLCBvID0gdGhpcy5zY2FsZSgwLCAxKSwgaSA9IDEgLyAobiAtIDEpO1xuICAgIGxldCBzO1xuICAgIGlmICh0ID09PSBcImVhc2UtaW4tc3F1YXJlXCIpXG4gICAgICBzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoYywgcCkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcCAqIGksIGYgPSBkICoqIDIsIGggPSBvLmdldENvbG9yKGYpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgY29sb3I6IGggfTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKHQgPT09IFwiZWFzZS1vdXQtc3F1YXJlXCIpXG4gICAgICBzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoYywgcCkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcCAqIGksIGYgPSAxIC0gKDEgLSBkKSAqKiAyLCBoID0gby5nZXRDb2xvcihmKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGQsIGNvbG9yOiBoIH07XG4gICAgICB9KTtcbiAgICBlbHNlIGlmICh0ID09PSBcImVhc2Utb3V0LXNxcnRcIilcbiAgICAgIHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChjLCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBwICogaSwgZiA9IGQgKiogMC41LCBoID0gby5nZXRDb2xvcihmKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGQsIGNvbG9yOiBoIH07XG4gICAgICB9KTtcbiAgICBlbHNlIGlmICh0ID09PSBcImVhc2UtaW4tc3FydFwiKVxuICAgICAgcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKGMsIHApID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHAgKiBpLCBmID0gMSAtICgxIC0gZCkgKiogMC41LCBoID0gby5nZXRDb2xvcihmKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGQsIGNvbG9yOiBoIH07XG4gICAgICB9KTtcbiAgICBlbHNlIGlmICh0ID09PSBcImVhc2Utb3V0LWV4cFwiKVxuICAgICAgcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKGMsIHApID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHAgKiBpLCBmID0gMSAtIDIgKiogKC0xMCAqIGQpLCBoID0gby5nZXRDb2xvcihmKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGQsIGNvbG9yOiBoIH07XG4gICAgICB9KTtcbiAgICBlbHNlIGlmICh0ID09PSBcImVhc2UtaW4tZXhwXCIpXG4gICAgICBzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoYywgcCkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcCAqIGksIGYgPSAyICoqICgxMCAqIGQgLSAxMCksIGggPSBvLmdldENvbG9yKGYpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgY29sb3I6IGggfTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzc2FtcGxpbmcgbWV0aG9kLlwiKTtcbiAgICByZXR1cm4gbmV3IFQoeyBzdG9wczogcyB9KS5zY2FsZShhLm1pbiwgYS5tYXgpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIGNsb25lIG9mIHRoaXMgY29sb3IgcmFtcCB0aGF0IGlzIGZ1bGx5IHRyYW5zcGFyYW50IGF0IHRoZSBiZWdpbmluZyBvZiB0aGVpciByYW5nZVxuICAgKi9cbiAgdHJhbnNwYXJlbnRTdGFydCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRSYXdDb2xvclN0b3BzKCk7XG4gICAgdC51bnNoaWZ0KHtcbiAgICAgIHZhbHVlOiB0WzBdLnZhbHVlLFxuICAgICAgY29sb3I6IHRbMF0uY29sb3Iuc2xpY2UoKVxuICAgIH0pLCB0WzFdLnZhbHVlICs9IDFlLTM7XG4gICAgZm9yIChjb25zdCBuIG9mIHQpXG4gICAgICBuLmNvbG9yLmxlbmd0aCA9PT0gMyAmJiBuLmNvbG9yLnB1c2goMjU1KTtcbiAgICByZXR1cm4gdFswXS5jb2xvclszXSA9IDAsIG5ldyBUKHsgc3RvcHM6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgY29sb3IgcmFtcCBoYXMgYSB0cmFuc3BhcmVudCBzdGFydFxuICAgKi9cbiAgaGFzVHJhbnNwYXJlbnRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpc1swXS5jb2xvci5sZW5ndGggPT09IDQgJiYgdGhpc1swXS5jb2xvclszXSA9PT0gMDtcbiAgfVxufVxuY29uc3QgZ2kgPSB7XG4gIC8qKlxuICAgKiBBIGZ1bGx5IHRyYW5zcGFyZW50IFswLCAwLCAwLCAwXSBjb2xvcnJhbXAgdG8gaGlkZSBkYXRhLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgTlVMTDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzAsIDAsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICBHUkFZOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGpldCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgSkVUOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMTMxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbMCwgNjAsIDE3MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzUsIDI1NSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MjUsIGNvbG9yOiBbMjU1LCAyNTUsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyNTAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzEyOCwgMCwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIEhTViBjb2xvciByYW1wIChodWUsIHNhdHVyYXRpb24sIHZhbHVlKS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEhTVjogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzI1NSwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTY5LCBjb2xvcjogWzI1MywgMjU1LCAyXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xNzMsIGNvbG9yOiBbMjQ3LCAyNTUsIDJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjMzNywgY29sb3I6IFswLCAyNTIsIDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM0MSwgY29sb3I6IFswLCAyNTIsIDEwXSB9LFxuICAgICAgeyB2YWx1ZTogMC41MDYsIGNvbG9yOiBbMSwgMjQ5LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjY3MSwgY29sb3I6IFsyLCAwLCAyNTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjY3NSwgY29sb3I6IFs4LCAwLCAyNTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgzOSwgY29sb3I6IFsyNTUsIDAsIDI1MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODQzLCBjb2xvcjogWzI1NSwgMCwgMjQ1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDAsIDZdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBob3QgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEhPVDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjMsIGNvbG9yOiBbMjMwLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzI1NSwgMjEwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgc3ByaW5nIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBTUFJJTkc6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsyNTUsIDAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTUsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBzdW1tZXIgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFNVTU1FUjogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDEyOCwgMTAyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMTAyXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYXV0b21tbiBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQVVUT01OOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMjU1LCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHdpbnRlciBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgV0lOVEVSOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFswLCAyNTUsIDEyOF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGJvbmUgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEJPTkU6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzYsIGNvbG9yOiBbODQsIDg0LCAxMTZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1MywgY29sb3I6IFsxNjksIDIwMCwgMjAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY29wcGVyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBDT1BQRVI6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44MDQsIGNvbG9yOiBbMjU1LCAxNjAsIDEwMl0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAxOTksIDEyN10gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGdyZXlzIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBHUkVZUzogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyB5aWduYnUgY29sb3IgcmFtcCAoYmx1ZSB0byBsaWdodCB5ZWxsb3cpLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgWUlHTkJVOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbOCwgMjksIDg4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbMzcsIDUyLCAxNDhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzM0LCA5NCwgMTY4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbMjksIDE0NSwgMTkyXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzY1LCAxODIsIDE5Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzEyNywgMjA1LCAxODddIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE5OSwgMjMzLCAxODBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyMzcsIDI0OCwgMjE3XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjE3XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZ3JlZW5zIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBHUkVFTlM6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCA2OCwgMjddIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFswLCAxMDksIDQ0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFszNSwgMTM5LCA2OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzY1LCAxNzEsIDkzXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzExNiwgMTk2LCAxMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFsxNjEsIDIxNywgMTU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxOTksIDIzMywgMTkyXSB9LFxuICAgICAgeyB2YWx1ZTogMC44NzUsIGNvbG9yOiBbMjI5LCAyNDUsIDIyNF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjQ3LCAyNTIsIDI0NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHlpb3JyZCBjb2xvciByYW1wIChyZWQgdG8gbGlnaHQgeWVsbG93KS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFlJT1JSRDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzEyOCwgMCwgMzhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFsxODksIDAsIDM4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsyMjcsIDI2LCAyOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzI1MiwgNzgsIDQyXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzI1MywgMTQxLCA2MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzI1NCwgMTc4LCA3Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjU0LCAyMTcsIDExOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzI1NSwgMjM3LCAxNjBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyMDRdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBibHVlLXJlZCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQkxVRVJFRDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAwLCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcmRidSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUkRCVTogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzUsIDEwLCAxNzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM1LCBjb2xvcjogWzEwNiwgMTM3LCAyNDddIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTkwLCAxOTAsIDE5MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNiwgY29sb3I6IFsyMjAsIDE3MCwgMTMyXSB9LFxuICAgICAgeyB2YWx1ZTogMC43LCBjb2xvcjogWzIzMCwgMTQ1LCA5MF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTc4LCAxMCwgMjhdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBwaWNuaWMgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFBJQ05JQzogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMSwgY29sb3I6IFs1MSwgMTUzLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjIsIGNvbG9yOiBbMTAyLCAyMDQsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMywgY29sb3I6IFsxNTMsIDIwNCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzIwNCwgMjA0LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNiwgY29sb3I6IFsyNTUsIDIwNCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43LCBjb2xvcjogWzI1NSwgMTUzLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgsIGNvbG9yOiBbMjU1LCAxMDIsIDIwNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOSwgY29sb3I6IFsyNTUsIDEwMiwgMTAyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyByYWluYm93IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBSQUlOQk9XOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTUwLCAwLCA5MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzAsIDAsIDIwMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMCwgMjUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzAsIDE1MiwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzQ0LCAyNTUsIDE1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzE1MSwgMjU1LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNTUsIDIzNCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzI1NSwgMTExLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBQb3J0bGFuZCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUE9SVExBTkQ6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMiwgNTEsIDEzMV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTAsIDEzNiwgMTg2XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzI0MiwgMjExLCA1Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjQyLCAxNDMsIDU2XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyMTcsIDMwLCAzMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGJsYWNrYm9keSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQkxBQ0tCT0RZOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMiwgY29sb3I6IFsyMzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMjMwLCAyMTAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjcsIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTYwLCAyMDAsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGVhcnRoIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBFQVJUSDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDEzMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMSwgY29sb3I6IFswLCAxODAsIDE4MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMiwgY29sb3I6IFs0MCwgMjEwLCA0MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyMzAsIDIzMCwgNTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMTIwLCA3MCwgMjBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBlbGVjdHJpYyBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgRUxFQ1RSSUM6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xNSwgY29sb3I6IFszMCwgMCwgMTAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzEyMCwgMCwgMTAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzE2MCwgOTAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgsIGNvbG9yOiBbMjMwLCAyMDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjUwLCAyMjBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyB2aXJpZGlzIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBWSVJJRElTOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNjgsIDEsIDg0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs3MSwgNDQsIDEyMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNTksIDgxLCAxMzldIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzQ0LCAxMTMsIDE0Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFszMywgMTQ0LCAxNDFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzM5LCAxNzMsIDEyOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbOTIsIDIwMCwgOTldIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzE3MCwgMjIwLCA1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUzLCAyMzEsIDM3XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgaW5mZXJubyBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgSU5GRVJOTzogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzMxLCAxMiwgNzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzg1LCAxNSwgMTA5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMzYsIDM0LCAxMDZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTg2LCA1NCwgODVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIyNywgODksIDUxXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDksIDE0MCwgMTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzI0OSwgMjAxLCA1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUyLCAyNTUsIDE2NF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIG1hZ21hIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBNQUdNQTogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzI4LCAxNiwgNjhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzc5LCAxOCwgMTIzXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMjksIDM3LCAxMjldIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTgxLCA1NCwgMTIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMjksIDgwLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzI1MSwgMTM1LCA5N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjU0LCAxOTQsIDEzNV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUyLCAyNTMsIDE5MV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHBsYXNtYSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUExBU01BOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTMsIDgsIDEzNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNzUsIDMsIDE2MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTI1LCAzLCAxNjhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzE2OCwgMzQsIDE1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyMDMsIDcwLCAxMjFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIyOSwgMTA3LCA5M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjQ4LCAxNDgsIDY1XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyNTMsIDE5NSwgNDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI0MCwgMjQ5LCAzM10gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHdhcm0gY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFdBUk06IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMjUsIDAsIDE3OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMTcyLCAwLCAxODddIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzIxOSwgMCwgMTcwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsyNTUsIDAsIDEzMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyNTUsIDYzLCA3NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjU1LCAxMjMsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIzNCwgMTc2LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxOTAsIDIyOCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTQ3LCAyNTUsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBjb29sIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBDT09MOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTI1LCAwLCAxNzldIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzExNiwgMCwgMjE4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs5OCwgNzQsIDIzN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbNjgsIDE0NiwgMjMxXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzAsIDIwNCwgMTk3XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFswLCAyNDcsIDE0Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMCwgMjU1LCA4OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbNDAsIDI1NSwgOF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTQ3LCAyNTUsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyByYWluYm96IHNvZnQgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFJBSU5CT1dfU09GVDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzEyNSwgMCwgMTc5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xLCBjb2xvcjogWzE5OSwgMCwgMTgwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yLCBjb2xvcjogWzI1NSwgMCwgMTIxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zLCBjb2xvcjogWzI1NSwgMTA4LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzIyMiwgMTk0LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE1MCwgMjU1LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzAsIDI1NSwgNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjcsIGNvbG9yOiBbMCwgMjQ2LCAxNTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgsIGNvbG9yOiBbNTAsIDE2NywgMjIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC45LCBjb2xvcjogWzEwMywgNTEsIDIzNV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTI0LCAwLCAxODZdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBiYXRoeW1ldHJ5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBCQVRIWU1FVFJZOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNDAsIDI2LCA0NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNTksIDQ5LCA5MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNjQsIDc2LCAxMzldIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzYzLCAxMTAsIDE1MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs3MiwgMTQyLCAxNThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzg1LCAxNzQsIDE2M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTIwLCAyMDYsIDE2M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMTg3LCAyMzAsIDE3Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUzLCAyNTQsIDIwNF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGNkb20gY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENET006IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0NywgMTUsIDYyXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs4NywgMjMsIDg2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMzAsIDI4LCA5OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTcxLCA0MSwgOTZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMjA2LCA2NywgODZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIzMCwgMTA2LCA4NF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjQyLCAxNDksIDEwM10gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjQ5LCAxOTMsIDEzNV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU0LCAyMzcsIDE3Nl0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGNobG9yb3BoeWxsIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBDSExPUk9QSFlMTDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzE4LCAzNiwgMjBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzI1LCA2MywgNDFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzI0LCA5MSwgNTldIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEzLCAxMTksIDcyXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE4LCAxNDgsIDgwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFs4MCwgMTczLCA4OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTMyLCAxOTYsIDEyMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMTc1LCAyMjEsIDE2Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjE1LCAyNDksIDIwOF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGRlbnNpdHkgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIERFTlNJVFk6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs1NCwgMTQsIDM2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs4OSwgMjMsIDgwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMTAsIDQ1LCAxMzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEyMCwgNzcsIDE3OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxMjAsIDExMywgMjEzXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsxMTUsIDE1MSwgMjI4XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxMzQsIDE4NSwgMjI3XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxNzcsIDIxNCwgMjI3XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyMzAsIDI0MSwgMjQxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZnJlZXN1cmZhY2UgYmx1ZSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgRlJFRVNVUkZBQ0VfQkxVRTogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzMwLCA0LCAxMTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzQ3LCAxNCwgMTc2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs0MSwgNDUsIDIzNl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMjUsIDk5LCAyMTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNjgsIDEzMSwgMjAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsxMTQsIDE1NiwgMTk3XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxNTcsIDE4MSwgMjAzXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMDAsIDIwOCwgMjE2XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDEsIDIzNywgMjM2XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZnJlZXN1cmZhY2UgcmVkIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBGUkVFU1VSRkFDRV9SRUQ6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs2MCwgOSwgMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzEwMCwgMTcsIDI3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxNDIsIDIwLCAyOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTc3LCA0MywgMjddIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTkyLCA4NywgNjNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIwNSwgMTI1LCAxMDVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIxNiwgMTYyLCAxNDhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzIyNywgMTk5LCAxOTNdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI0MSwgMjM3LCAyMzZdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBveHlnZW4gY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIE9YWUdFTjogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzY0LCA1LCA1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFsxMDYsIDYsIDE1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxNDQsIDI2LCA3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNjgsIDY0LCAzXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE4OCwgMTAwLCA0XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMDYsIDEzNiwgMTFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIyMCwgMTc0LCAyNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjMxLCAyMTUsIDQ0XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDgsIDI1NCwgMTA1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcGFyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBQQVI6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs1MSwgMjAsIDI0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs5MCwgMzIsIDM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMjksIDQ0LCAzNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTU5LCA2OCwgMjVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTgyLCA5OSwgMTldIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzE5OSwgMTM0LCAyMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjEyLCAxNzEsIDM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMjEsIDIxMCwgNTRdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIyNSwgMjUzLCA3NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHBoYXNlIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBQSEFTRTogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzE0NSwgMTA1LCAxOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMTg0LCA3MSwgMzhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzE4NiwgNTgsIDExNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTYwLCA3MSwgMTg1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzExMCwgOTcsIDIxOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbNTAsIDEyMywgMTY0XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFszMSwgMTMxLCAxMTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzc3LCAxMjksIDM0XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNDUsIDEwNSwgMThdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBzYWxpbml0eSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgU0FMSU5JVFk6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0MiwgMjQsIDEwOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMzMsIDUwLCAxNjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzE1LCA5MCwgMTQ1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFs0MCwgMTE4LCAxMzddIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNTksIDE0NiwgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFs3OSwgMTc1LCAxMjZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzEyMCwgMjAzLCAxMDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzE5MywgMjIxLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1MywgMjM5LCAxNTRdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyB0ZW1wZXJhdHVyZSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgVEVNUEVSQVRVUkU6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0LCAzNSwgNTFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzIzLCA1MSwgMTIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs4NSwgNTksIDE1N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTI5LCA3OSwgMTQzXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzE3NSwgOTUsIDEzMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjIyLCAxMTIsIDEwMV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjQ5LCAxNDYsIDY2XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyNDksIDE5NiwgNjVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIzMiwgMjUwLCA5MV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHR1cmJpZGl0eSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgVFVSQklESVRZOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMzQsIDMxLCAyN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNjUsIDUwLCA0MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbOTgsIDY5LCA1Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTMxLCA4OSwgNTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTYxLCAxMTIsIDU5XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsxODUsIDE0MCwgNjZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIwMiwgMTc0LCA4OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjE2LCAyMDksIDEyNl0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjMzLCAyNDYsIDE3MV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHZlbG9jaXR5IGJsdWUgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFZFTE9DSVRZX0JMVUU6IG5ldyBUKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxNywgMzIsIDY0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFszNSwgNTIsIDExNl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMjksIDgxLCAxNTZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzMxLCAxMTMsIDE2Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs1MCwgMTQ0LCAxNjldIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzg3LCAxNzMsIDE3Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTQ5LCAxOTYsIDE4OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjAzLCAyMjEsIDIxMV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU0LCAyNTEsIDIzMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHZlbG9jaXR5IGdyZWVuIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBWRUxPQ0lUWV9HUkVFTjogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzIzLCAzNSwgMTldIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzI0LCA2NCwgMzhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzExLCA5NSwgNDVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzM5LCAxMjMsIDM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzk1LCAxNDYsIDEyXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsxNTIsIDE2NSwgMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzIwMSwgMTg2LCA2OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjMzLCAyMTYsIDEzN10gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTMsIDIwNV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGN1YmUgaGVsaXggY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENVQkVIRUxJWDogbmV3IFQoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjA3LCBjb2xvcjogWzIyLCA1LCA1OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNjAsIDQsIDEwNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMiwgY29sb3I6IFsxMDksIDEsIDEzNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjcsIGNvbG9yOiBbMTYxLCAwLCAxNDddIH0sXG4gICAgICB7IHZhbHVlOiAwLjMzLCBjb2xvcjogWzIxMCwgMiwgMTQyXSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzI1MSwgMTEsIDEyM10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNDcsIGNvbG9yOiBbMjU1LCAyOSwgOTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjUzLCBjb2xvcjogWzI1NSwgNTQsIDY5XSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzI1NSwgODUsIDQ2XSB9LFxuICAgICAgeyB2YWx1ZTogMC42NywgY29sb3I6IFsyNTUsIDEyMCwgMzRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjczLCBjb2xvcjogWzI1NSwgMTU3LCAzN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuOCwgY29sb3I6IFsyNDEsIDE5MSwgNTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3LCBjb2xvcjogWzIyNCwgMjIwLCA5M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuOTMsIGNvbG9yOiBbMjE4LCAyNDEsIDE0Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjI3LCAyNTMsIDE5OF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgY2l2aWRpcyBjb2xvciByYW1wIGlzIGNvbG9yIGJsaW5kIGZyaWVuZGx5LlxuICAgKiBSZWFkIG1vcmUgaGVyZSBodHRwczovL2pvdXJuYWxzLnBsb3Mub3JnL3Bsb3NvbmUvYXJ0aWNsZT9pZD0xMC4xMzcxL2pvdXJuYWwucG9uZS4wMTk5MjM5XG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBDSVZJRElTOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMzIsIDc3LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFs1LCA1NCwgMTEwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzY1LCA3NywgMTA4LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFs5NywgMTAwLCAxMTEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxMjUsIDEyNCwgMTIxLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFsxNTYsIDE0OSwgMTIwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE5MCwgMTc1LCAxMTEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzIyNSwgMjA0LCA5NCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDIzNSwgNzAsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHR1cmJvIGNvbG9yIHJhbXAuXG4gICAqIFRoaXMgaXMgYSBsdW1pbmFuY2UtY29uc3RhbnQgYWx0ZXJuYXRpdmUgdG8gdGhlIGpldCwgbWFraW5nIGl0IG1vcmVcbiAgICogY2xvci1ibGluZCBmcmllbmRseS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFRVUkJPOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNDgsIDE4LCA1OSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbNzAsIDEwNywgMjI3LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzQwLCAxODcsIDIzNiwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbNDksIDI0MiwgMTUzLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTYyLCAyNTIsIDYwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFsyMzcsIDIwOCwgNTgsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjUxLCAxMjgsIDM0LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyMTAsIDQ5LCA1LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzEyMiwgNCwgMywgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSByb2NrZXQgY29sb3IgcmFtcCBpcyBwZXJjZXB0dWFsbHkgdW5pZm9ybSwgd2hpY2ggbWFrZXMgaXQgbW9yZVxuICAgKiBjb2xvciBibGllbmQgZnJpZW5kbHkgdGhhbiB0aGUgY2xhc3NpYyBtYWdtYSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUk9DS0VUOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMjUwLCAyMzUsIDIyMSwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMzLCBjb2xvcjogWzI1MCwgMjM1LCAyMjEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjY2LCBjb2xvcjogWzI0NiwgMTcwLCAxMzAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyNDAsIDk2LCA2NywgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41MzMsIGNvbG9yOiBbMjAzLCAyNywgNzksIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjY2LCBjb2xvcjogWzEzMiwgMzAsIDkwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgsIGNvbG9yOiBbNjMsIDI3LCA2OCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFszLCA1LCAyNiwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBtYWtvIGNvbG9yIHJhbXAgaXMgcGVyY2VwdHVhbGx5IHVuaWZvcm0gYW5kIGNhbiBiZSBzZWVuIGFzXG4gICAqIGEgY29sb3IgYmxpbmQgZnJpZW5kbHkgYWx0ZXJuYXRpdmUgdG8gYmF0aHltZXRyeSBvciB5aWduYnUuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBNQUtPOiBuZXcgVCh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTEsIDQsIDUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzQzLCAyOCwgNTMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNjIsIDUzLCAxMDcsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzU5LCA4NiwgMTUyLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNTMsIDEyMywgMTYyLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFs1MywgMTU4LCAxNzAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbNzMsIDE5MywgMTczLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsxNTAsIDIyMSwgMTgxLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIyMiwgMjQ1LCAyMjksIDI1NV0gfVxuICAgIF1cbiAgfSlcbn07XG5hc3luYyBmdW5jdGlvbiBxYyhyLCBlLCB0ID0ge30pIHtcbiAgdmFyIGEsIG87XG4gIGlmICghZS5zb3VyY2VJZCAmJiAhZS5kYXRhKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNyZWF0aW5nIGEgcG9seWxpbmUgbGF5ZXIgcmVxdWlyZXMgYW4gZXhpc3RpbmcgLnNvdXJjZUlkIG9yIGEgdmFsaWQgLmRhdGEgcHJvcGVydHlcIik7XG4gIGxldCBuID0gZS5kYXRhO1xuICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpcihuKSlcbiAgICAgIG4gPSBgaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL2RhdGEvJHtlLmRhdGF9L2ZlYXR1cmVzLmpzb24/a2V5PSR7ai5hcGlLZXl9YDtcbiAgICBlbHNlIGlmICgoKGEgPSBuLnNwbGl0KFwiLlwiKS5wb3AoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGEudG9Mb3dlckNhc2UoKS50cmltKCkpID09PSBcImdweFwiKSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgKGF3YWl0IGZldGNoKG4sIHQpKS50ZXh0KCk7XG4gICAgICBuID0gaWkocyk7XG4gICAgfSBlbHNlIGlmICgoKG8gPSBuLnNwbGl0KFwiLlwiKS5wb3AoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8udG9Mb3dlckNhc2UoKS50cmltKCkpID09PSBcImttbFwiKSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgKGF3YWl0IGZldGNoKG4sIHQpKS50ZXh0KCk7XG4gICAgICBuID0gc2kocyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGkgPSBWaShuKSA/PyBqYyhuKTtcbiAgICAgIGkgJiYgKG4gPSBpKTtcbiAgICB9XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seWxpbmUgZGF0YSB3YXMgcHJvdmlkZWQgYXMgc3RyaW5nIGJ1dCBpcyBpbmNvbXBhdGlibGUgd2l0aCB2YWxpZCBmb3JtYXRzLlwiKTtcbiAgfVxuICByZXR1cm4gVmMociwge1xuICAgIC4uLmUsXG4gICAgZGF0YTogblxuICB9KTtcbn1cbmZ1bmN0aW9uIFZjKHIsIGUpIHtcbiAgaWYgKGUubGF5ZXJJZCAmJiByLmdldExheWVyKGUubGF5ZXJJZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIGxheWVyIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIGxheWVyIGlkOiAke2UubGF5ZXJJZH1gKTtcbiAgY29uc3QgdCA9IGUuc291cmNlSWQgPz8gUHQoKSwgbiA9IGUubGF5ZXJJZCA/PyBSdCgpLCBhID0ge1xuICAgIHBvbHlsaW5lTGF5ZXJJZDogbixcbiAgICBwb2x5bGluZU91dGxpbmVMYXllcklkOiBcIlwiLFxuICAgIHBvbHlsaW5lU291cmNlSWQ6IHRcbiAgfTtcbiAgZS5kYXRhICYmICFyLmdldFNvdXJjZSh0KSAmJiByLmFkZFNvdXJjZSh0LCB7XG4gICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgZGF0YTogZS5kYXRhXG4gIH0pO1xuICBjb25zdCBvID0gZS5saW5lV2lkdGggPz8gMywgaSA9IGUubGluZUNvbG9yID8/IGtyKCksIHMgPSBlLmxpbmVPcGFjaXR5ID8/IDEsIGwgPSBlLmxpbmVCbHVyID8/IDAsIHUgPSBlLmxpbmVHYXBXaWR0aCA/PyAwO1xuICBsZXQgYyA9IGUubGluZURhc2hBcnJheSA/PyBudWxsO1xuICBjb25zdCBwID0gZS5vdXRsaW5lV2lkdGggPz8gMSwgZCA9IGUub3V0bGluZUNvbG9yID8/IFwiI0ZGRkZGRlwiLCBmID0gZS5vdXRsaW5lT3BhY2l0eSA/PyAxLCBoID0gZS5vdXRsaW5lQmx1ciA/PyAwO1xuICBpZiAodHlwZW9mIGMgPT0gXCJzdHJpbmdcIiAmJiAoYyA9IE5uKGMpKSwgZS5vdXRsaW5lID09PSAhMCkge1xuICAgIGNvbnN0IG0gPSBgJHtufV9vdXRsaW5lYDtcbiAgICBhLnBvbHlsaW5lT3V0bGluZUxheWVySWQgPSBtLCByLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogbSxcbiAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgIHNvdXJjZTogdCxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgXCJsaW5lLWpvaW5cIjogZS5saW5lSm9pbiA/PyBcInJvdW5kXCIsXG4gICAgICAgICAgXCJsaW5lLWNhcFwiOiBlLmxpbmVDYXAgPz8gXCJyb3VuZFwiXG4gICAgICAgIH0sXG4gICAgICAgIG1pbnpvb206IGUubWluem9vbSA/PyAwLFxuICAgICAgICBtYXh6b29tOiBlLm1heHpvb20gPz8gMjMsXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgXCJsaW5lLW9wYWNpdHlcIjogdHlwZW9mIGYgPT0gXCJudW1iZXJcIiA/IGYgOiBPKGYpLFxuICAgICAgICAgIFwibGluZS1jb2xvclwiOiB0eXBlb2YgZCA9PSBcInN0cmluZ1wiID8gZCA6IGplKGQpLFxuICAgICAgICAgIFwibGluZS13aWR0aFwiOiBkaShvLCBwKSxcbiAgICAgICAgICBcImxpbmUtYmx1clwiOiB0eXBlb2YgaCA9PSBcIm51bWJlclwiID8gaCA6IE8oaClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGUuYmVmb3JlSWRcbiAgICApO1xuICB9XG4gIHJldHVybiByLmFkZExheWVyKFxuICAgIHtcbiAgICAgIGlkOiBuLFxuICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICBzb3VyY2U6IHQsXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgXCJsaW5lLWpvaW5cIjogZS5saW5lSm9pbiA/PyBcInJvdW5kXCIsXG4gICAgICAgIFwibGluZS1jYXBcIjogZS5saW5lQ2FwID8/IFwicm91bmRcIlxuICAgICAgfSxcbiAgICAgIG1pbnpvb206IGUubWluem9vbSA/PyAwLFxuICAgICAgbWF4em9vbTogZS5tYXh6b29tID8/IDIzLFxuICAgICAgcGFpbnQ6IHtcbiAgICAgICAgXCJsaW5lLW9wYWNpdHlcIjogdHlwZW9mIHMgPT0gXCJudW1iZXJcIiA/IHMgOiBPKHMpLFxuICAgICAgICBcImxpbmUtY29sb3JcIjogdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IGkgOiBqZShpKSxcbiAgICAgICAgXCJsaW5lLXdpZHRoXCI6IHR5cGVvZiBvID09IFwibnVtYmVyXCIgPyBvIDogTyhvKSxcbiAgICAgICAgXCJsaW5lLWJsdXJcIjogdHlwZW9mIGwgPT0gXCJudW1iZXJcIiA/IGwgOiBPKGwpLFxuICAgICAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHR5cGVvZiB1ID09IFwibnVtYmVyXCIgPyB1IDogTyh1KSxcbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29ucyBwYXNzaW5nIFwibGluZS1kYXNoYXJyYXlcIiB3aXRoIHRoZSB2YWx1ZSBcInVuZGVmaW5lZFwiXG4gICAgICAgIC8vIHJlc3VsdHMgaW4gbm8gc2hvd2luZyB0aGUgbGluZSB3aGlsZSBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBiZWhhdmlvclxuICAgICAgICAvLyBvZiBub3QgYWRkaW5nIHRoZSBwcm9wZXJ0eSBcImxpbmUtZGFzaGFycmF5XCIgYXMgYWxsLlxuICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQsIHdlIGFyZSBpbmxpbmluZyB0aGUgYWRkaXRpb24gb2YgdGhlIHByb3Agd2l0aCBhIGNvbmRpdGlvbmFsXG4gICAgICAgIC8vIHdoaWNoIGlzIGxlc3MgcmVhZGFibGUuXG4gICAgICAgIC4uLmMgJiYgeyBcImxpbmUtZGFzaGFycmF5XCI6IGMgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZS5iZWZvcmVJZFxuICApLCBhO1xufVxuZnVuY3Rpb24gR2MociwgZSkge1xuICBpZiAoZS5sYXllcklkICYmIHIuZ2V0TGF5ZXIoZS5sYXllcklkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbGF5ZXIgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgbGF5ZXIgaWQ6ICR7ZS5sYXllcklkfWApO1xuICBjb25zdCB0ID0gZS5zb3VyY2VJZCA/PyBQdCgpLCBuID0gZS5sYXllcklkID8/IFJ0KCksIGEgPSB7XG4gICAgcG9seWdvbkxheWVySWQ6IG4sXG4gICAgcG9seWdvbk91dGxpbmVMYXllcklkOiBlLm91dGxpbmUgPyBgJHtufV9vdXRsaW5lYCA6IFwiXCIsXG4gICAgcG9seWdvblNvdXJjZUlkOiB0XG4gIH07XG4gIGlmIChlLmRhdGEgJiYgIXIuZ2V0U291cmNlKHQpKSB7XG4gICAgbGV0IG0gPSBlLmRhdGE7XG4gICAgdHlwZW9mIG0gPT0gXCJzdHJpbmdcIiAmJiBpcihtKSAmJiAobSA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vZGF0YS8ke219L2ZlYXR1cmVzLmpzb24/a2V5PSR7ai5hcGlLZXl9YCksIHIuYWRkU291cmNlKHQsIHtcbiAgICAgIHR5cGU6IFwiZ2VvanNvblwiLFxuICAgICAgZGF0YTogbVxuICAgIH0pO1xuICB9XG4gIGxldCBvID0gZS5vdXRsaW5lRGFzaEFycmF5ID8/IG51bGw7XG4gIGNvbnN0IGkgPSBlLm91dGxpbmVXaWR0aCA/PyAxLCBzID0gZS5vdXRsaW5lQ29sb3IgPz8gXCIjRkZGRkZGXCIsIGwgPSBlLm91dGxpbmVPcGFjaXR5ID8/IDEsIHUgPSBlLm91dGxpbmVCbHVyID8/IDAsIGMgPSBlLmZpbGxDb2xvciA/PyBrcigpLCBwID0gZS5maWxsT3BhY2l0eSA/PyAxLCBkID0gZS5vdXRsaW5lUG9zaXRpb24gPz8gXCJjZW50ZXJcIiwgZiA9IGUucGF0dGVybiA/PyBudWxsO1xuICB0eXBlb2YgbyA9PSBcInN0cmluZ1wiICYmIChvID0gTm4obykpO1xuICBjb25zdCBoID0gKG0gPSBudWxsKSA9PiB7XG4gICAgaWYgKHIuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBuLFxuICAgICAgICB0eXBlOiBcImZpbGxcIixcbiAgICAgICAgc291cmNlOiB0LFxuICAgICAgICBtaW56b29tOiBlLm1pbnpvb20gPz8gMCxcbiAgICAgICAgbWF4em9vbTogZS5tYXh6b29tID8/IDIzLFxuICAgICAgICBwYWludDoge1xuICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiB0eXBlb2YgYyA9PSBcInN0cmluZ1wiID8gYyA6IGplKGMpLFxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHR5cGVvZiBwID09IFwibnVtYmVyXCIgPyBwIDogTyhwKSxcbiAgICAgICAgICAvLyBBZGRpbmcgYSBwYXR0ZXJuIGlmIHByb3ZpZGVkXG4gICAgICAgICAgLi4ubSAmJiB7IFwiZmlsbC1wYXR0ZXJuXCI6IG0gfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZS5iZWZvcmVJZFxuICAgICksIGUub3V0bGluZSA9PT0gITApIHtcbiAgICAgIGxldCB5O1xuICAgICAgZCA9PT0gXCJpbnNpZGVcIiA/IHR5cGVvZiBpID09IFwibnVtYmVyXCIgPyB5ID0gMC41ICogaSA6IHkgPSBPKFxuICAgICAgICBpLm1hcCgoeyB6b29tOiB3LCB2YWx1ZTogdiB9KSA9PiAoe1xuICAgICAgICAgIHpvb206IHcsXG4gICAgICAgICAgdmFsdWU6IDAuNSAqIHZcbiAgICAgICAgfSkpXG4gICAgICApIDogZCA9PT0gXCJvdXRzaWRlXCIgPyB0eXBlb2YgaSA9PSBcIm51bWJlclwiID8geSA9IC0wLjUgKiBpIDogeSA9IE8oXG4gICAgICAgIGkubWFwKCh3KSA9PiAoe1xuICAgICAgICAgIHpvb206IHcuem9vbSxcbiAgICAgICAgICB2YWx1ZTogLTAuNSAqIHcudmFsdWVcbiAgICAgICAgfSkpXG4gICAgICApIDogeSA9IDAsIHIuYWRkTGF5ZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogYS5wb2x5Z29uT3V0bGluZUxheWVySWQsXG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgc291cmNlOiB0LFxuICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgXCJsaW5lLWpvaW5cIjogZS5vdXRsaW5lSm9pbiA/PyBcInJvdW5kXCIsXG4gICAgICAgICAgICBcImxpbmUtY2FwXCI6IGUub3V0bGluZUNhcCA/PyBcImJ1dHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWluem9vbTogZS5taW56b29tID8/IDAsXG4gICAgICAgICAgbWF4em9vbTogZS5tYXh6b29tID8/IDIzLFxuICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICBcImxpbmUtb3BhY2l0eVwiOiB0eXBlb2YgbCA9PSBcIm51bWJlclwiID8gbCA6IE8obCksXG4gICAgICAgICAgICBcImxpbmUtY29sb3JcIjogdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBqZShzKSxcbiAgICAgICAgICAgIFwibGluZS13aWR0aFwiOiB0eXBlb2YgaSA9PSBcIm51bWJlclwiID8gaSA6IE8oaSksXG4gICAgICAgICAgICBcImxpbmUtYmx1clwiOiB0eXBlb2YgdSA9PSBcIm51bWJlclwiID8gdSA6IE8odSksXG4gICAgICAgICAgICBcImxpbmUtb2Zmc2V0XCI6IHksXG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb25zIHBhc3NpbmcgXCJsaW5lLWRhc2hhcnJheVwiIHdpdGggdGhlIHZhbHVlIFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgIC8vIHJlc3VsdHMgaW4gbm8gc2hvd2luZyB0aGUgbGluZSB3aGlsZSBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBiZWhhdmlvclxuICAgICAgICAgICAgLy8gb2Ygbm90IGFkZGluZyB0aGUgcHJvcGVydHkgXCJsaW5lLWRhc2hhcnJheVwiIGFzIGFsbC5cbiAgICAgICAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCwgd2UgYXJlIGlubGluaW5nIHRoZSBhZGRpdGlvbiBvZiB0aGUgcHJvcCB3aXRoIGEgY29uZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGxlc3MgcmVhZGFibGUuXG4gICAgICAgICAgICAuLi5vICYmIHtcbiAgICAgICAgICAgICAgXCJsaW5lLWRhc2hhcnJheVwiOiBvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlLmJlZm9yZUlkXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGYgPyByLmhhc0ltYWdlKGYpID8gaChmKSA6IHIubG9hZEltYWdlKGYpLnRoZW4oKG0pID0+IHtcbiAgICByLmFkZEltYWdlKGYsIG0uZGF0YSksIGgoZik7XG4gIH0pLmNhdGNoKChtKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIHRoZSBwYXR0ZXJuIGltYWdlLlwiLCBtLm1lc3NhZ2UpLCBoKCk7XG4gIH0pIDogaCgpLCBhO1xufVxuZnVuY3Rpb24gSGMociwgZSkge1xuICBpZiAoZS5sYXllcklkICYmIHIuZ2V0TGF5ZXIoZS5sYXllcklkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbGF5ZXIgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgbGF5ZXIgaWQ6ICR7ZS5sYXllcklkfWApO1xuICBjb25zdCB0ID0gZS5taW5Qb2ludFJhZGl1cyA/PyAxMCwgbiA9IGUubWF4UG9pbnRSYWRpdXMgPz8gNTAsIGEgPSBlLmNsdXN0ZXIgPz8gITEsIG8gPSAyMCwgaSA9IEFycmF5LmlzQXJyYXkoZS5wb2ludENvbG9yKSA/IGUucG9pbnRDb2xvciA6IGdpLlRVUkJPLnNjYWxlKDEwLCBlLmNsdXN0ZXIgPyAxZTQgOiAxZTMpLnJlc2FtcGxlKFwiZWFzZS1vdXQtc3F1YXJlXCIpLCBzID0gaS5nZXRCb3VuZHMoKSwgbCA9IGUuc291cmNlSWQgPz8gUHQoKSwgdSA9IGUubGF5ZXJJZCA/PyBSdCgpLCBjID0gZS5zaG93TGFiZWwgPz8gYSwgcCA9IGUuYWxpZ25PblZpZXdwb3J0ID8/ICEwLCBkID0gZS5vdXRsaW5lID8/ICExLCBmID0gZS5vdXRsaW5lT3BhY2l0eSA/PyAxLCBoID0gZS5vdXRsaW5lV2lkdGggPz8gMSwgbSA9IGUub3V0bGluZUNvbG9yID8/IFwiI0ZGRkZGRlwiO1xuICBsZXQgeTtcbiAgY29uc3QgdyA9IGUuem9vbUNvbXBlbnNhdGlvbiA/PyAhMCwgdiA9IGUubWluem9vbSA/PyAwLCB4ID0gZS5tYXh6b29tID8/IDIzO1xuICB0eXBlb2YgZS5wb2ludE9wYWNpdHkgPT0gXCJudW1iZXJcIiA/IHkgPSBlLnBvaW50T3BhY2l0eSA6IEFycmF5LmlzQXJyYXkoZS5wb2ludE9wYWNpdHkpID8geSA9IE8oZS5wb2ludE9wYWNpdHkpIDogZS5jbHVzdGVyID8geSA9IHBuKGksIFwicG9pbnRfY291bnRcIikgOiBlLnByb3BlcnR5ID8geSA9IHBuKGksIGUucHJvcGVydHkpIDogeSA9IE8oW1xuICAgIHsgem9vbTogdiwgdmFsdWU6IDAgfSxcbiAgICB7IHpvb206IHYgKyAwLjI1LCB2YWx1ZTogMSB9LFxuICAgIHsgem9vbTogeCAtIDAuMjUsIHZhbHVlOiAxIH0sXG4gICAgeyB6b29tOiB4LCB2YWx1ZTogMCB9XG4gIF0pO1xuICBjb25zdCBBID0ge1xuICAgIHBvaW50TGF5ZXJJZDogdSxcbiAgICBjbHVzdGVyTGF5ZXJJZDogXCJcIixcbiAgICBsYWJlbExheWVySWQ6IFwiXCIsXG4gICAgcG9pbnRTb3VyY2VJZDogbFxuICB9O1xuICBpZiAoZS5kYXRhICYmICFyLmdldFNvdXJjZShsKSkge1xuICAgIGxldCBFID0gZS5kYXRhO1xuICAgIHR5cGVvZiBFID09IFwic3RyaW5nXCIgJiYgaXIoRSkgJiYgKEUgPSBgaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL2RhdGEvJHtFfS9mZWF0dXJlcy5qc29uP2tleT0ke2ouYXBpS2V5fWApLCByLmFkZFNvdXJjZShsLCB7XG4gICAgICB0eXBlOiBcImdlb2pzb25cIixcbiAgICAgIGRhdGE6IEUsXG4gICAgICBjbHVzdGVyOiBhXG4gICAgfSk7XG4gIH1cbiAgaWYgKGEpIHtcbiAgICBBLmNsdXN0ZXJMYXllcklkID0gYCR7dX1fY2x1c3RlcmA7XG4gICAgY29uc3QgRSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG8gfSwgKEMsIE4pID0+IHtcbiAgICAgIGNvbnN0IGVlID0gcy5taW4gKyBOICogKHMubWF4IC0gcy5taW4pIC8gKG8gLSAxKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBlZSxcbiAgICAgICAgcG9pbnRSYWRpdXM6IHQgKyAobiAtIHQpICogKE4gLyAobyAtIDEpKSAqKiAwLjUsXG4gICAgICAgIGNvbG9yOiBpLmdldENvbG9ySGV4KGVlKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogQS5jbHVzdGVyTGF5ZXJJZCxcbiAgICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc291cmNlOiBsLFxuICAgICAgICBmaWx0ZXI6IFtcImhhc1wiLCBcInBvaW50X2NvdW50XCJdLFxuICAgICAgICBwYWludDoge1xuICAgICAgICAgIC8vICdjaXJjbGUtY29sb3InOiBvcHRpb25zLnBvaW50Q29sb3IgPz8gY29sb3JEcml2ZW5CeVByb3BlcnR5KGNsdXN0ZXJTdHlsZSwgXCJwb2ludF9jb3VudFwiKSxcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiB0eXBlb2YgZS5wb2ludENvbG9yID09IFwic3RyaW5nXCIgPyBlLnBvaW50Q29sb3IgOiB1bihFLCBcInBvaW50X2NvdW50XCIpLFxuICAgICAgICAgIFwiY2lyY2xlLXJhZGl1c1wiOiB0eXBlb2YgZS5wb2ludFJhZGl1cyA9PSBcIm51bWJlclwiID8gZS5wb2ludFJhZGl1cyA6IEFycmF5LmlzQXJyYXkoZS5wb2ludFJhZGl1cykgPyBPKGUucG9pbnRSYWRpdXMpIDogY24oRSwgXCJwb2ludF9jb3VudFwiLCAhMSksXG4gICAgICAgICAgXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IHAgPyBcInZpZXdwb3J0XCIgOiBcIm1hcFwiLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IFwibWFwXCIsXG4gICAgICAgICAgLy8gc2NhbGUgd2l0aCBjYW1lcmEgZGlzdGFuY2UgcmVnYXJkbGVzcyBvZiB2aWV3cG9ydC9iaWV3cG9ydCBhbGlnbmVtZW50XG4gICAgICAgICAgXCJjaXJjbGUtb3BhY2l0eVwiOiB5LFxuICAgICAgICAgIC4uLmQgJiYge1xuICAgICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjogdHlwZW9mIGYgPT0gXCJudW1iZXJcIiA/IGYgOiBPKGYpLFxuICAgICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IHR5cGVvZiBoID09IFwibnVtYmVyXCIgPyBoIDogTyhoKSxcbiAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB0eXBlb2YgbSA9PSBcInN0cmluZ1wiID8gbSA6IGplKG0pXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiB2LFxuICAgICAgICBtYXh6b29tOiB4XG4gICAgICB9LFxuICAgICAgZS5iZWZvcmVJZFxuICAgICksIHIuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBBLnBvaW50TGF5ZXJJZCxcbiAgICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc291cmNlOiBsLFxuICAgICAgICBmaWx0ZXI6IFtcIiFcIiwgW1wiaGFzXCIsIFwicG9pbnRfY291bnRcIl1dLFxuICAgICAgICBwYWludDoge1xuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiBwID8gXCJ2aWV3cG9ydFwiIDogXCJtYXBcIixcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1zY2FsZVwiOiBcIm1hcFwiLFxuICAgICAgICAgIC8vIHNjYWxlIHdpdGggY2FtZXJhIGRpc3RhbmNlIHJlZ2FyZGxlc3Mgb2Ygdmlld3BvcnQvYmlld3BvcnQgYWxpZ25lbWVudFxuICAgICAgICAgIC8vICdjaXJjbGUtY29sb3InOiAgb3B0aW9ucy5wb2ludENvbG9yID8/IGNsdXN0ZXJTdHlsZVswXS5jb2xvcixcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiB0eXBlb2YgZS5wb2ludENvbG9yID09IFwic3RyaW5nXCIgPyBlLnBvaW50Q29sb3IgOiBpLmdldENvbG9ySGV4KGkuZ2V0Qm91bmRzKCkubWluKSxcbiAgICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogdHlwZW9mIGUucG9pbnRSYWRpdXMgPT0gXCJudW1iZXJcIiA/IGUucG9pbnRSYWRpdXMgOiBBcnJheS5pc0FycmF5KGUucG9pbnRSYWRpdXMpID8gTyhlLnBvaW50UmFkaXVzKSA6IEVbMF0ucG9pbnRSYWRpdXMgKiAwLjc1LFxuICAgICAgICAgIFwiY2lyY2xlLW9wYWNpdHlcIjogeSxcbiAgICAgICAgICAuLi5kICYmIHtcbiAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHR5cGVvZiBmID09IFwibnVtYmVyXCIgPyBmIDogTyhmKSxcbiAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB0eXBlb2YgaCA9PSBcIm51bWJlclwiID8gaCA6IE8oaCksXG4gICAgICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjogdHlwZW9mIG0gPT0gXCJzdHJpbmdcIiA/IG0gOiBqZShtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWluem9vbTogdixcbiAgICAgICAgbWF4em9vbTogeFxuICAgICAgfSxcbiAgICAgIGUuYmVmb3JlSWRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCBFID0gdHlwZW9mIGUucG9pbnRDb2xvciA9PSBcInN0cmluZ1wiID8gZS5wb2ludENvbG9yIDogQXJyYXkuaXNBcnJheShlLnBvaW50Q29sb3IpID8gZS5wb2ludENvbG9yLmdldENvbG9ySGV4KGUucG9pbnRDb2xvci5nZXRCb3VuZHMoKS5taW4pIDoga3IoKSwgQyA9IHR5cGVvZiBlLnBvaW50UmFkaXVzID09IFwibnVtYmVyXCIgPyB3ID8gTyhbXG4gICAgICB7IHpvb206IDAsIHZhbHVlOiBlLnBvaW50UmFkaXVzICogMC4wMjUgfSxcbiAgICAgIHsgem9vbTogMiwgdmFsdWU6IGUucG9pbnRSYWRpdXMgKiAwLjA1IH0sXG4gICAgICB7IHpvb206IDQsIHZhbHVlOiBlLnBvaW50UmFkaXVzICogMC4xIH0sXG4gICAgICB7IHpvb206IDgsIHZhbHVlOiBlLnBvaW50UmFkaXVzICogMC4yNSB9LFxuICAgICAgeyB6b29tOiAxNiwgdmFsdWU6IGUucG9pbnRSYWRpdXMgKiAxIH1cbiAgICBdKSA6IGUucG9pbnRSYWRpdXMgOiBBcnJheS5pc0FycmF5KGUucG9pbnRSYWRpdXMpID8gTyhlLnBvaW50UmFkaXVzKSA6IHcgPyBPKFtcbiAgICAgIHsgem9vbTogMCwgdmFsdWU6IHQgKiAwLjA1IH0sXG4gICAgICB7IHpvb206IDIsIHZhbHVlOiB0ICogMC4xIH0sXG4gICAgICB7IHpvb206IDQsIHZhbHVlOiB0ICogMC4yIH0sXG4gICAgICB7IHpvb206IDgsIHZhbHVlOiB0ICogMC41IH0sXG4gICAgICB7IHpvb206IDE2LCB2YWx1ZTogdCAqIDEgfVxuICAgIF0pIDogdDtcbiAgICBpZiAoZS5wcm9wZXJ0eSAmJiBBcnJheS5pc0FycmF5KGUucG9pbnRDb2xvcikpIHtcbiAgICAgIGNvbnN0IE4gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBvIH0sIChlZSwgTGUpID0+IHtcbiAgICAgICAgY29uc3QgRWUgPSBzLm1pbiArIExlICogKHMubWF4IC0gcy5taW4pIC8gKG8gLSAxKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogRWUsXG4gICAgICAgICAgcG9pbnRSYWRpdXM6IHR5cGVvZiBlLnBvaW50UmFkaXVzID09IFwibnVtYmVyXCIgPyBlLnBvaW50UmFkaXVzIDogdCArIChuIC0gdCkgKiAoTGUgLyAobyAtIDEpKSAqKiAwLjUsXG4gICAgICAgICAgY29sb3I6IHR5cGVvZiBlLnBvaW50Q29sb3IgPT0gXCJzdHJpbmdcIiA/IGUucG9pbnRDb2xvciA6IGkuZ2V0Q29sb3JIZXgoRWUpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIEUgPSB1bihOLCBlLnByb3BlcnR5KSwgQyA9IGNuKE4sIGUucHJvcGVydHksIHcpO1xuICAgIH1cbiAgICByLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogQS5wb2ludExheWVySWQsXG4gICAgICAgIHR5cGU6IFwiY2lyY2xlXCIsXG4gICAgICAgIHNvdXJjZTogbCxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgLy8gQ29udHJhcnkgdG8gbGFiZWxzLCB3ZSB3YW50IHRvIHNlZSB0aGUgc21hbGwgb25lIGluIGZyb250LiBXZWlyZGx5IFwiY2lyY2xlLXNvcnQta2V5XCIgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBhcyBcInN5bWJvbC1zb3J0LWtleVwiLlxuICAgICAgICAgIFwiY2lyY2xlLXNvcnQta2V5XCI6IGUucHJvcGVydHkgPyBbXCIvXCIsIDEsIFtcImdldFwiLCBlLnByb3BlcnR5XV0gOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IHAgPyBcInZpZXdwb3J0XCIgOiBcIm1hcFwiLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IFwibWFwXCIsXG4gICAgICAgICAgLy8gc2NhbGUgd2l0aCBjYW1lcmEgZGlzdGFuY2UgcmVnYXJkbGVzcyBvZiB2aWV3cG9ydC9iaWV3cG9ydCBhbGlnbmVtZW50XG4gICAgICAgICAgXCJjaXJjbGUtY29sb3JcIjogRSxcbiAgICAgICAgICBcImNpcmNsZS1vcGFjaXR5XCI6IHksXG4gICAgICAgICAgXCJjaXJjbGUtcmFkaXVzXCI6IEMsXG4gICAgICAgICAgLi4uZCAmJiB7XG4gICAgICAgICAgICBcImNpcmNsZS1zdHJva2Utb3BhY2l0eVwiOiB0eXBlb2YgZiA9PSBcIm51bWJlclwiID8gZiA6IE8oZiksXG4gICAgICAgICAgICBcImNpcmNsZS1zdHJva2Utd2lkdGhcIjogdHlwZW9mIGggPT0gXCJudW1iZXJcIiA/IGggOiBPKGgpLFxuICAgICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCI6IHR5cGVvZiBtID09IFwic3RyaW5nXCIgPyBtIDogamUobSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1pbnpvb206IHYsXG4gICAgICAgIG1heHpvb206IHhcbiAgICAgIH0sXG4gICAgICBlLmJlZm9yZUlkXG4gICAgKTtcbiAgfVxuICBpZiAoYyAhPT0gITEgJiYgKGUuY2x1c3RlciB8fCBlLnByb3BlcnR5KSkge1xuICAgIEEubGFiZWxMYXllcklkID0gYCR7dX1fbGFiZWxgO1xuICAgIGNvbnN0IEUgPSBlLmxhYmVsQ29sb3IgPz8gXCIjZmZmXCIsIEMgPSBlLmxhYmVsU2l6ZSA/PyAxMjtcbiAgICByLmFkZExheWVyKFxuICAgICAge1xuICAgICAgICBpZDogQS5sYWJlbExheWVySWQsXG4gICAgICAgIHR5cGU6IFwic3ltYm9sXCIsXG4gICAgICAgIHNvdXJjZTogbCxcbiAgICAgICAgZmlsdGVyOiBbXCJoYXNcIiwgZS5jbHVzdGVyID8gXCJwb2ludF9jb3VudFwiIDogZS5wcm9wZXJ0eV0sXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIFwidGV4dC1maWVsZFwiOiBlLmNsdXN0ZXIgPyBcIntwb2ludF9jb3VudF9hYmJyZXZpYXRlZH1cIiA6IGB7JHtlLnByb3BlcnR5fX1gLFxuICAgICAgICAgIFwidGV4dC1mb250XCI6IFtcIk5vdG8gU2FucyBSZWd1bGFyXCJdLFxuICAgICAgICAgIFwidGV4dC1zaXplXCI6IEMsXG4gICAgICAgICAgXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOiBwID8gXCJ2aWV3cG9ydFwiIDogXCJtYXBcIixcbiAgICAgICAgICBcInN5bWJvbC1zb3J0LWtleVwiOiBbXCIvXCIsIDEsIFtcImdldFwiLCBlLmNsdXN0ZXIgPyBcInBvaW50X2NvdW50XCIgOiBlLnByb3BlcnR5XV1cbiAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBsYXJnZXN0IHZhbHVlIGdvZXMgb24gdG9wXG4gICAgICAgIH0sXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgXCJ0ZXh0LWNvbG9yXCI6IEUsXG4gICAgICAgICAgXCJ0ZXh0LW9wYWNpdHlcIjogeVxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiB2LFxuICAgICAgICBtYXh6b29tOiB4XG4gICAgICB9LFxuICAgICAgZS5iZWZvcmVJZFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIEE7XG59XG5mdW5jdGlvbiBaYyhyLCBlKSB7XG4gIGlmIChlLmxheWVySWQgJiYgci5nZXRMYXllcihlLmxheWVySWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihgQSBsYXllciBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBsYXllciBpZDogJHtlLmxheWVySWR9YCk7XG4gIGNvbnN0IHQgPSBlLnNvdXJjZUlkID8/IFB0KCksIG4gPSBlLmxheWVySWQgPz8gUnQoKSwgYSA9IGUubWluem9vbSA/PyAwLCBvID0gZS5tYXh6b29tID8/IDIzLCBpID0gZS56b29tQ29tcGVuc2F0aW9uID8/ICEwLCBzID0gZS5vcGFjaXR5ID8/IFtcbiAgICB7IHpvb206IGEsIHZhbHVlOiAwIH0sXG4gICAgeyB6b29tOiBhICsgMC4yNSwgdmFsdWU6IDEgfSxcbiAgICB7IHpvb206IG8gLSAwLjI1LCB2YWx1ZTogMSB9LFxuICAgIHsgem9vbTogbywgdmFsdWU6IDAgfVxuICBdO1xuICBsZXQgbCA9IEFycmF5LmlzQXJyYXkoZS5jb2xvclJhbXApID8gZS5jb2xvclJhbXAgOiBnaS5UVVJCTy50cmFuc3BhcmVudFN0YXJ0KCk7XG4gIGNvbnN0IHUgPSBsLmdldEJvdW5kcygpO1xuICAodS5taW4gIT09IDAgfHwgdS5tYXggIT09IDEpICYmIChsID0gbC5zY2FsZSgwLCAxKSksIGwuaGFzVHJhbnNwYXJlbnRTdGFydCgpIHx8IChsID0gbC50cmFuc3BhcmVudFN0YXJ0KCkpO1xuICBjb25zdCBjID0gZS5pbnRlbnNpdHkgPz8gW1xuICAgIHsgem9vbTogMCwgdmFsdWU6IDAuMDEgfSxcbiAgICB7IHpvb206IDQsIHZhbHVlOiAwLjIgfSxcbiAgICB7IHpvb206IDE2LCB2YWx1ZTogMSB9XG4gIF0sIHAgPSBlLnByb3BlcnR5ID8/IG51bGwsIGQgPSBlLndlaWdodCA/PyAxO1xuICBsZXQgZiA9IDE7XG4gIHAgPyB0eXBlb2YgZCA9PSBcIm51bWJlclwiID8gKGYgPSBkLCB0eXBlb2YgZS53ZWlnaHQgPT0gXCJudW1iZXJcIiAmJiBjb25zb2xlLndhcm4oXCJUaGUgb3B0aW9uIGAucHJvcGVydHlgIGlzIGlnbm9yZWQgd2hlbiBgLnByb3BlcnR5VmFsdWVXZWlnaHRzYCBpcyBub3Qgb2YgdHlwZSBgUHJvcGVydHlWYWx1ZVdlaWdodHNgXCIpKSA6IEFycmF5LmlzQXJyYXkoZCkgPyBmID0gaGkoZCwgcCkgOiBjb25zb2xlLndhcm4oXCJUaGUgb3B0aW9uIGAucHJvcGVydHlgIGlzIGlnbm9yZWQgd2hlbiBgLnByb3BlcnR5VmFsdWVXZWlnaHRzYCBpcyBub3Qgb2YgdHlwZSBgUHJvcGVydHlWYWx1ZVdlaWdodHNgXCIpIDogdHlwZW9mIGQgPT0gXCJudW1iZXJcIiA/IGYgPSBkIDogQXJyYXkuaXNBcnJheShkKSAmJiBjb25zb2xlLndhcm4oXCJUaGUgb3B0aW9ucyBgLnByb3BlcnR5VmFsdWVXZWlnaHRzYCBjYW4gb25seSBiZSB1c2VkIHdoZW4gYC5wcm9wZXJ0eWAgaXMgcHJvdmlkZWQuXCIpO1xuICBjb25zdCBoID0gW1xuICAgIHsgem9vbTogMCwgdmFsdWU6IDUwICogMC4wMjUgfSxcbiAgICB7IHpvb206IDIsIHZhbHVlOiA1MCAqIDAuMDUgfSxcbiAgICB7IHpvb206IDQsIHZhbHVlOiA1MCAqIDAuMSB9LFxuICAgIHsgem9vbTogOCwgdmFsdWU6IDUwICogMC4yNSB9LFxuICAgIHsgem9vbTogMTYsIHZhbHVlOiA1MCB9XG4gIF0sIG0gPSBlLnJhZGl1cyA/PyAoaSA/IGggOiAxMCk7XG4gIGxldCB5ID0gMTtcbiAgdHlwZW9mIG0gPT0gXCJudW1iZXJcIiA/IHkgPSBtIDogQXJyYXkuaXNBcnJheShtKSAmJiBcInpvb21cIiBpbiBtWzBdID8geSA9IE8obSkgOiBwICYmIEFycmF5LmlzQXJyYXkobSkgJiYgXCJwcm9wZXJ0eVZhbHVlXCIgaW4gbVswXSA/IHkgPSBtaShtLCBwLCBpKSA6ICFwICYmIEFycmF5LmlzQXJyYXkobSkgJiYgXCJwcm9wZXJ0eVZhbHVlXCIgaW4gbVswXSA/ICh5ID0gTyhoKSwgY29uc29sZS53YXJuKFwiVGhlIG9wdGlvbiBgLnJhZGl1c2AgY2FuIG9ubHkgYmUgcHJvcGVydHktZHJpdmVuIGlmIHRoZSBvcHRpb24gYC5wcm9wZXJ0eWAgaXMgcHJvdmlkZWQuXCIpKSA6IHkgPSBPKGgpO1xuICBjb25zdCB3ID0ge1xuICAgIGhlYXRtYXBMYXllcklkOiBuLFxuICAgIGhlYXRtYXBTb3VyY2VJZDogdFxuICB9O1xuICBpZiAoZS5kYXRhICYmICFyLmdldFNvdXJjZSh0KSkge1xuICAgIGxldCB2ID0gZS5kYXRhO1xuICAgIHR5cGVvZiB2ID09IFwic3RyaW5nXCIgJiYgaXIodikgJiYgKHYgPSBgaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL2RhdGEvJHt2fS9mZWF0dXJlcy5qc29uP2tleT0ke2ouYXBpS2V5fWApLCByLmFkZFNvdXJjZSh0LCB7XG4gICAgICB0eXBlOiBcImdlb2pzb25cIixcbiAgICAgIGRhdGE6IHZcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gci5hZGRMYXllcihcbiAgICB7XG4gICAgICBpZDogbixcbiAgICAgIHR5cGU6IFwiaGVhdG1hcFwiLFxuICAgICAgc291cmNlOiB0LFxuICAgICAgbWluem9vbTogYSxcbiAgICAgIG1heHpvb206IG8sXG4gICAgICBwYWludDoge1xuICAgICAgICBcImhlYXRtYXAtd2VpZ2h0XCI6IGYsXG4gICAgICAgIFwiaGVhdG1hcC1pbnRlbnNpdHlcIjogdHlwZW9mIGMgPT0gXCJudW1iZXJcIiA/IGMgOiBPKGMpLFxuICAgICAgICBcImhlYXRtYXAtY29sb3JcIjogeWkobCksXG4gICAgICAgIFwiaGVhdG1hcC1yYWRpdXNcIjogeSxcbiAgICAgICAgXCJoZWF0bWFwLW9wYWNpdHlcIjogdHlwZW9mIHMgPT0gXCJudW1iZXJcIiA/IHMgOiBPKHMpXG4gICAgICB9XG4gICAgfSxcbiAgICBlLmJlZm9yZUlkXG4gICksIHc7XG59XG5jb25zdCBMcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFkZEhlYXRtYXA6IFpjLFxuICBhZGRQb2ludDogSGMsXG4gIGFkZFBvbHlnb246IEdjLFxuICBhZGRQb2x5bGluZTogcWMsXG4gIGNvbG9yRHJpdmVuQnlQcm9wZXJ0eTogdW4sXG4gIGNvbG9yUGFsZXR0ZXM6IHNuLFxuICBjb21wdXRlUmFtcGVkT3V0bGluZVdpZHRoOiBkaSxcbiAgZGFzaEFycmF5TWFrZXI6IE5uLFxuICBnZW5lcmF0ZVJhbmRvbUxheWVyTmFtZTogUnQsXG4gIGdlbmVyYXRlUmFuZG9tU291cmNlTmFtZTogUHQsXG4gIGdldFJhbmRvbUNvbG9yOiBrcixcbiAgaGVhdG1hcEludGVuc2l0eUZyb21Db2xvclJhbXA6IHlpLFxuICBsZXJwWm9vbU51bWJlclZhbHVlczogbG4sXG4gIG9wYWNpdHlEcml2ZW5CeVByb3BlcnR5OiBwbixcbiAgcGFpbnRDb2xvck9wdGlvbnNUb1BhaW50U3BlYzogamUsXG4gIHJhZGl1c0RyaXZlbkJ5UHJvcGVydHk6IGNuLFxuICByYWRpdXNEcml2ZW5CeVByb3BlcnR5SGVhdG1hcDogbWksXG4gIHJhbXBlZE9wdGlvbnNUb0xheWVyUGFpbnRTcGVjOiBPLFxuICByYW1wZWRQcm9wZXJ0eVZhbHVlV2VpZ2h0OiBoaSxcbiAgdGFrZVNjcmVlbnNob3Q6IERjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gS2MoKSB7XG4gIHJldHVybiBcIjMuOS4wXCI7XG59XG5jb25zdCBFcCA9IEwuTWFwLCBDcCA9IEwuTWFya2VyLCBBcCA9IEwuUG9wdXAsIFRwID0gTC5TdHlsZSwgX3AgPSBMLkNhbnZhc1NvdXJjZSwgSXAgPSBMLkdlb0pTT05Tb3VyY2UsIE1wID0gTC5JbWFnZVNvdXJjZSwgUHAgPSBMLlJhc3RlclRpbGVTb3VyY2UsIFJwID0gTC5SYXN0ZXJERU1UaWxlU291cmNlLCB6cCA9IEwuVmVjdG9yVGlsZVNvdXJjZSwgT3AgPSBMLlZpZGVvU291cmNlLCAkcCA9IEwuTmF2aWdhdGlvbkNvbnRyb2wsIEZwID0gTC5HZW9sb2NhdGVDb250cm9sLCBOcCA9IEwuQXR0cmlidXRpb25Db250cm9sLCBqcCA9IEwuTG9nb0NvbnRyb2wsIERwID0gTC5TY2FsZUNvbnRyb2wsIFVwID0gTC5GdWxsc2NyZWVuQ29udHJvbCwgQnAgPSBMLlRlcnJhaW5Db250cm9sLCBxcCA9IEwuQm94Wm9vbUhhbmRsZXIsIFZwID0gTC5TY3JvbGxab29tSGFuZGxlciwgR3AgPSBMLkNvb3BlcmF0aXZlR2VzdHVyZXNIYW5kbGVyLCBIcCA9IEwuS2V5Ym9hcmRIYW5kbGVyLCBacCA9IEwuVHdvRmluZ2Vyc1RvdWNoUGl0Y2hIYW5kbGVyLCBLcCA9IEwuTWFwV2hlZWxFdmVudCwgWHAgPSBMLk1hcFRvdWNoRXZlbnQsIFlwID0gTC5NYXBNb3VzZUV2ZW50LCBXcCA9IEwuY29uZmlnLCBKcCA9IEwuZ2V0VmVyc2lvbiwge1xuICBzZXRSVExUZXh0UGx1Z2luOiBRcCxcbiAgZ2V0UlRMVGV4dFBsdWdpblN0YXR1czogZWYsXG4gIExuZ0xhdDogdmksXG4gIExuZ0xhdEJvdW5kczogWGMsXG4gIE1lcmNhdG9yQ29vcmRpbmF0ZTogZm4sXG4gIEV2ZW50ZWQ6IHRmLFxuICBBSkFYRXJyb3I6IHJmLFxuICBwcmV3YXJtOiBuZixcbiAgY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXM6IGFmLFxuICBIYXNoOiBvZixcbiAgUG9pbnQ6IGJpLFxuICBFZGdlSW5zZXRzOiBzZixcbiAgRHJhZ1JvdGF0ZUhhbmRsZXI6IGxmLFxuICBEcmFnUGFuSGFuZGxlcjogdWYsXG4gIFR3b0ZpbmdlcnNUb3VjaFpvb21Sb3RhdGVIYW5kbGVyOiBjZixcbiAgRG91YmxlQ2xpY2tab29tSGFuZGxlcjogcGYsXG4gIFR3b0ZpbmdlcnNUb3VjaFpvb21IYW5kbGVyOiBmZixcbiAgVHdvRmluZ2Vyc1RvdWNoUm90YXRlSGFuZGxlcjogZGYsXG4gIGdldFdvcmtlckNvdW50OiBoZixcbiAgc2V0V29ya2VyQ291bnQ6IG1mLFxuICBnZXRNYXhQYXJhbGxlbEltYWdlUmVxdWVzdHM6IHlmLFxuICBzZXRNYXhQYXJhbGxlbEltYWdlUmVxdWVzdHM6IGdmLFxuICBnZXRXb3JrZXJVcmw6IHZmLFxuICBzZXRXb3JrZXJVcmw6IGJmLFxuICBhZGRTb3VyY2VUeXBlOiB3ZixcbiAgaW1wb3J0U2NyaXB0SW5Xb3JrZXJzOiBTZixcbiAgYWRkUHJvdG9jb2w6IHhmLFxuICByZW1vdmVQcm90b2NvbDoga2Zcbn0gPSBMO1xuZXhwb3J0IHtcbiAgcmYgYXMgQUpBWEVycm9yLFxuICBmcCBhcyBBdHRyaWJ1dGlvbkNvbnRyb2wsXG4gIE5wIGFzIEF0dHJpYnV0aW9uQ29udHJvbE1MR0wsXG4gIGhwIGFzIEJveFpvb21IYW5kbGVyLFxuICBxcCBhcyBCb3hab29tSGFuZGxlck1MR0wsXG4gIG9wIGFzIENhbnZhc1NvdXJjZSxcbiAgX3AgYXMgQ2FudmFzU291cmNlTUxHTCxcbiAgVCBhcyBDb2xvclJhbXAsXG4gIGdpIGFzIENvbG9yUmFtcENvbGxlY3Rpb24sXG4gIHlwIGFzIENvb3BlcmF0aXZlR2VzdHVyZXNIYW5kbGVyLFxuICBHcCBhcyBDb29wZXJhdGl2ZUdlc3R1cmVzSGFuZGxlck1MR0wsXG4gIEJlIGFzIEN1YmVtYXBGYWNlTmFtZXMsXG4gIFp1IGFzIEN1YmVtYXBJbWFnZXNQcmVzZXRzLFxuICBCciBhcyBDdWJlbWFwTGF5ZXIsXG4gIFRlIGFzIERPTWNyZWF0ZSxcbiAgRXQgYXMgRE9NcmVtb3ZlLFxuICBwZiBhcyBEb3VibGVDbGlja1pvb21IYW5kbGVyLFxuICB1ZiBhcyBEcmFnUGFuSGFuZGxlcixcbiAgbGYgYXMgRHJhZ1JvdGF0ZUhhbmRsZXIsXG4gIHNmIGFzIEVkZ2VJbnNldHMsXG4gIHRmIGFzIEV2ZW50ZWQsXG4gIE9pIGFzIEZ1bGxzY3JlZW5Db250cm9sLFxuICBVcCBhcyBGdWxsc2NyZWVuQ29udHJvbE1MR0wsXG4gIGlwIGFzIEdlb0pTT05Tb3VyY2UsXG4gIElwIGFzIEdlb0pTT05Tb3VyY2VNTEdMLFxuICBQaSBhcyBHZW9sb2NhdGVDb250cm9sLFxuICBGcCBhcyBHZW9sb2NhdGVDb250cm9sTUxHTCxcbiAgc2MgYXMgR2VvbG9jYXRpb25UeXBlLFxuICBvZiBhcyBIYXNoLFxuICBzcCBhcyBJbWFnZVNvdXJjZSxcbiAgTXAgYXMgSW1hZ2VTb3VyY2VNTEdMLFxuICBMYyBhcyBJbWFnZVZpZXdlcixcbiAgcmUgYXMgSW1hZ2VWaWV3ZXJFdmVudCxcbiAga3AgYXMgSW1hZ2VWaWV3ZXJNYXJrZXIsXG4gIEljIGFzIEltYWdlVmlld2VyTWFya2VyRXZlbnQsXG4gIGdwIGFzIEtleWJvYXJkSGFuZGxlcixcbiAgSHAgYXMgS2V5Ym9hcmRIYW5kbGVyTUxHTCxcbiAgeiBhcyBMYW5ndWFnZSxcbiAgdmkgYXMgTG5nTGF0LFxuICBYYyBhcyBMbmdMYXRCb3VuZHMsXG4gIFJpIGFzIExvZ29Db250cm9sLFxuICBqcCBhcyBMb2dvQ29udHJvbE1MR0wsXG4gIEdvIGFzIE1hcCxcbiAgRXAgYXMgTWFwTUxHTCxcbiAgU3AgYXMgTWFwTW91c2VFdmVudCxcbiAgWXAgYXMgTWFwTW91c2VFdmVudE1MR0wsXG4gIENmIGFzIE1hcFN0eWxlLFxuICBBZiBhcyBNYXBTdHlsZVZhcmlhbnQsXG4gIHdwIGFzIE1hcFRvdWNoRXZlbnQsXG4gIFhwIGFzIE1hcFRvdWNoRXZlbnRNTEdMLFxuICBicCBhcyBNYXBXaGVlbEV2ZW50LFxuICBLcCBhcyBNYXBXaGVlbEV2ZW50TUxHTCxcbiAgYnUgYXMgTWFwdGlsZXJDdXN0b21Db250cm9sLFxuICB0biBhcyBNYXB0aWxlckV4dGVybmFsQ29udHJvbCxcbiAgdnUgYXMgTWFwdGlsZXJHZW9sb2NhdGVDb250cm9sLFxuICBXbiBhcyBNYXB0aWxlckxvZ29Db250cm9sLFxuICB5dSBhcyBNYXB0aWxlck5hdmlnYXRpb25Db250cm9sLFxuICB3dSBhcyBNYXB0aWxlclByb2plY3Rpb25Db250cm9sLFxuICBtdSBhcyBNYXB0aWxlclRlcnJhaW5Db250cm9sLFxuICBNaSBhcyBNYXJrZXIsXG4gIENwIGFzIE1hcmtlck1MR0wsXG4gIGZuIGFzIE1lcmNhdG9yQ29vcmRpbmF0ZSxcbiAgJHAgYXMgTmF2aWdhdGlvbkNvbnRyb01MR0wsXG4gIFdhIGFzIE5hdmlnYXRpb25Db250cm9sLFxuICBiaSBhcyBQb2ludCxcbiAgbnAgYXMgUG9wdXAsXG4gIEFwIGFzIFBvcHVwTUxHTCxcbiAgcXIgYXMgUmFkaWFsR3JhZGllbnRMYXllcixcbiAgdXAgYXMgUmFzdGVyREVNVGlsZVNvdXJjZSxcbiAgUnAgYXMgUmFzdGVyREVNVGlsZVNvdXJjZU1MR0wsXG4gIGxwIGFzIFJhc3RlclRpbGVTb3VyY2UsXG4gIFBwIGFzIFJhc3RlclRpbGVTb3VyY2VNTEdMLFxuICBUZiBhcyBSZWZlcmVuY2VNYXBTdHlsZSxcbiAgemkgYXMgU2NhbGVDb250cm9sLFxuICBEcCBhcyBTY2FsZUNvbnRyb2xNTEdMLFxuICBtcCBhcyBTY3JvbGxab29tSGFuZGxlcixcbiAgVnAgYXMgU2Nyb2xsWm9vbUhhbmRsZXJNTEdMLFxuICAkaSBhcyBTZGtDb25maWcsXG4gIF9mIGFzIFNlcnZpY2VFcnJvcixcbiAgYXAgYXMgU3R5bGUsXG4gIFRwIGFzIFN0eWxlTUxHTCxcbiAgQnAgYXMgVGVycmFpbkNvbnRyb01MR0wsXG4gIGRwIGFzIFRlcnJhaW5Db250cm9sLFxuICB2cCBhcyBUd29GaW5nZXJzVG91Y2hQaXRjaEhhbmRsZXIsXG4gIFpwIGFzIFR3b0ZpbmdlcnNUb3VjaFBpdGNoSGFuZGxlck1MR0wsXG4gIGRmIGFzIFR3b0ZpbmdlcnNUb3VjaFJvdGF0ZUhhbmRsZXIsXG4gIGZmIGFzIFR3b0ZpbmdlcnNUb3VjaFpvb21IYW5kbGVyLFxuICBjZiBhcyBUd29GaW5nZXJzVG91Y2hab29tUm90YXRlSGFuZGxlcixcbiAgY3AgYXMgVmVjdG9yVGlsZVNvdXJjZSxcbiAgenAgYXMgVmVjdG9yVGlsZVNvdXJjZU1MR0wsXG4gIHBwIGFzIFZpZGVvU291cmNlLFxuICBPcCBhcyBWaWRlb1NvdXJjZU1MR0wsXG4gIHhmIGFzIGFkZFByb3RvY29sLFxuICB3ZiBhcyBhZGRTb3VyY2VUeXBlLFxuICBJZiBhcyBhcmVTYW1lTGFuZ3VhZ2VzLFxuICBNZiBhcyBidWZmZXJUb1BpeGVsRGF0YUJyb3dzZXIsXG4gIFBmIGFzIGNhblBhcnNlUGl4ZWxEYXRhLFxuICBSZiBhcyBjaXJjdW1mZXJlbmNlQXRMYXRpdHVkZSxcbiAgYWYgYXMgY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXMsXG4gIGogYXMgY29uZmlnLFxuICBXcCBhcyBjb25maWdNTEdMLFxuICB6ZiBhcyBjb29yZGluYXRlcyxcbiAgS2UgYXMgY3ViZW1hcFByZXNldHMsXG4gIE9mIGFzIGRhdGEsXG4gIHhwIGFzIGRpc3BsYXlXZWJHTENvbnRleHRMb3N0V2FybmluZyxcbiAgJGYgYXMgZWxldmF0aW9uLFxuICBGZiBhcyBleHBhbmRNYXBTdHlsZSxcbiAgTmYgYXMgZ2VvY29kaW5nLFxuICBqZiBhcyBnZW9sb2NhdGlvbixcbiAgRGYgYXMgZ2V0QXV0b0xhbmd1YWdlLFxuICBZbiBhcyBnZXRCcm93c2VyTGFuZ3VhZ2UsXG4gIFVmIGFzIGdldEJ1ZmZlclRvUGl4ZWxEYXRhUGFyc2VyLFxuICBCZiBhcyBnZXRMYW5ndWFnZUluZm9Gcm9tQ29kZSxcbiAgcWYgYXMgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUZsYWcsXG4gIFZmIGFzIGdldExhbmd1YWdlSW5mb0Zyb21LZXksXG4gIEpwIGFzIGdldE1hcExpYnJlVmVyc2lvbixcbiAgeWYgYXMgZ2V0TWF4UGFyYWxsZWxJbWFnZVJlcXVlc3RzLFxuICBlZiBhcyBnZXRSVExUZXh0UGx1Z2luU3RhdHVzLFxuICBHZiBhcyBnZXRUaWxlQ2FjaGUsXG4gIEtjIGFzIGdldFZlcnNpb24sXG4gIEdpIGFzIGdldFdlYkdMU3VwcG9ydEVycm9yLFxuICBoZiBhcyBnZXRXb3JrZXJDb3VudCxcbiAgdmYgYXMgZ2V0V29ya2VyVXJsLFxuICBpaSBhcyBncHgsXG4gIGpjIGFzIGdweE9yS21sLFxuICBvaSBhcyBoYXNDaGlsZE5vZGVXaXRoTmFtZSxcbiAgTHAgYXMgaGVscGVycyxcbiAgU2YgYXMgaW1wb3J0U2NyaXB0SW5Xb3JrZXJzLFxuICBIZiBhcyBpc0xhbmd1YWdlSW5mbyxcbiAgc2kgYXMga21sLFxuICBaZiBhcyBtYXBTdHlsZVByZXNldExpc3QsXG4gIEtmIGFzIG1hdGgsXG4gIFhmIGFzIG1pc2MsXG4gIG5mIGFzIHByZXdhcm0sXG4gIGtmIGFzIHJlbW92ZVByb3RvY29sLFxuICBnZiBhcyBzZXRNYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMsXG4gIFFwIGFzIHNldFJUTFRleHRQbHVnaW4sXG4gIG1mIGFzIHNldFdvcmtlckNvdW50LFxuICBiZiBhcyBzZXRXb3JrZXJVcmwsXG4gIFlmIGFzIHN0YXRpY01hcHMsXG4gICRuIGFzIHN0cjJ4bWwsXG4gIFdmIGFzIHN0eWxlVG9TdHlsZSxcbiAgSmYgYXMgdG9MYW5ndWFnZUluZm8sXG4gIERvIGFzIHRvZ2dsZVByb2plY3Rpb24sXG4gIGpvIGFzIHRvZ2dsZVRlcnJhaW4sXG4gIHFhIGFzIHhtbDJzdHJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXB0aWxlci1zZGsubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs\n");

/***/ })

};
;