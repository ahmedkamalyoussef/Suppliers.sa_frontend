"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@maptiler";
exports.ids = ["vendor-chunks/@maptiler"];
exports.modules = {

/***/ "(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@maptiler/client/dist/maptiler-client.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientConfig: () => (/* binding */ ClientConfig),\n/* harmony export */   ISOLanguage: () => (/* binding */ ISOLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   MapStyle: () => (/* binding */ MapStyle),\n/* harmony export */   MapStyleVariant: () => (/* binding */ MapStyleVariant),\n/* harmony export */   NonISOLanguage: () => (/* binding */ NonISOLanguage),\n/* harmony export */   ReferenceMapStyle: () => (/* binding */ ReferenceMapStyle),\n/* harmony export */   ServiceError: () => (/* binding */ ServiceError),\n/* harmony export */   areSameLanguages: () => (/* binding */ areSameLanguages),\n/* harmony export */   bufferToPixelDataBrowser: () => (/* binding */ bufferToPixelDataBrowser),\n/* harmony export */   canParsePixelData: () => (/* binding */ canParsePixelData),\n/* harmony export */   circumferenceAtLatitude: () => (/* binding */ circumferenceAtLatitude),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   coordinates: () => (/* binding */ coordinates),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   elevation: () => (/* binding */ elevation),\n/* harmony export */   expandMapStyle: () => (/* binding */ expandMapStyle),\n/* harmony export */   geocoding: () => (/* binding */ geocoding),\n/* harmony export */   geolocation: () => (/* binding */ geolocation),\n/* harmony export */   getAutoLanguage: () => (/* binding */ getAutoLanguage),\n/* harmony export */   getBufferToPixelDataParser: () => (/* binding */ getBufferToPixelDataParser),\n/* harmony export */   getLanguageInfoFromCode: () => (/* binding */ getLanguageInfoFromCode),\n/* harmony export */   getLanguageInfoFromFlag: () => (/* binding */ getLanguageInfoFromFlag),\n/* harmony export */   getLanguageInfoFromKey: () => (/* binding */ getLanguageInfoFromKey),\n/* harmony export */   getTileCache: () => (/* binding */ getTileCache),\n/* harmony export */   isLanguageInfo: () => (/* binding */ isLanguageInfo),\n/* harmony export */   mapStylePresetList: () => (/* binding */ mapStylePresetList),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   misc: () => (/* binding */ misc),\n/* harmony export */   staticMaps: () => (/* binding */ staticMaps),\n/* harmony export */   styleToStyle: () => (/* binding */ styleToStyle),\n/* harmony export */   toLanguageInfo: () => (/* binding */ toLanguageInfo)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\n\n\nfunction tryGettingFetch() {\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n  return null;\n}\nclass ClientConfig {\n  constructor() {\n    /**\n     * MapTiler Cloud API key\n     */\n    this._apiKey = \"\";\n    /**\n     * The fetch function. To be set if in Node < 18, otherwise\n     * will be automatically resolved.\n     */\n    this._fetch = tryGettingFetch();\n    /**\n     * Number of tiles to keep in cache\n     */\n    this.tileCacheSize = 200;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k) {\n    this._apiKey = k;\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f) {\n    this._fetch = f;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return this._fetch;\n  }\n}\nconst config = new ClientConfig();\n\nconst NonISOLanguage = {\n  /**\n   * Language mode to display the labels in the end user's device language.\n   */\n  AUTO: {\n    code: null,\n    flag: \"auto\",\n    name: \"Auto\",\n    latin: false,\n    isMode: true,\n    geocoding: true\n  },\n  /**\n   * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback. This is not to be confused with the \"Classical Latin\" language, which is available under the tag `.CLASSICAL_LATIN`.\n   */\n  LATIN: {\n    code: \"latin\",\n    flag: \"name:latin\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,\n   * though it can be an handy fallback.\n   */\n  NON_LATIN: {\n    code: \"nonlatin\",\n    flag: \"name:nonlatin\",\n    name: \"Non Latin\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.\n   */\n  LOCAL: {\n    code: null,\n    flag: \"name\",\n    name: \"Local\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  }\n};\nconst ISOLanguage = {\n  /**\n   * Albanian language\n   */\n  ALBANIAN: {\n    code: \"sq\",\n    flag: \"name:sq\",\n    name: \"Albanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Amharic language\n   */\n  AMHARIC: {\n    code: \"am\",\n    flag: \"name:am\",\n    name: \"Amharic\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Arabic language (right-to-left script)\n   */\n  ARABIC: {\n    code: \"ar\",\n    flag: \"name:ar\",\n    name: \"Arabic\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Armenian language\n   */\n  ARMENIAN: {\n    code: \"hy\",\n    flag: \"name:hy\",\n    name: \"Armenian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Azerbaijani language\n   */\n  AZERBAIJANI: {\n    code: \"az\",\n    flag: \"name:az\",\n    name: \"Azerbaijani\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Basque language\n   */\n  BASQUE: {\n    code: \"eu\",\n    flag: \"name:eu\",\n    name: \"Basque\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Belarusian langauge\n   */\n  BELARUSIAN: {\n    code: \"be\",\n    flag: \"name:be\",\n    name: \"Belarusian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bengali language\n   */\n  BENGALI: {\n    code: \"bn\",\n    flag: \"name:bn\",\n    name: \"Bengali\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bosnian language\n   */\n  BOSNIAN: {\n    code: \"bs\",\n    flag: \"name:bs\",\n    name: \"Bosnian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Breton language\n   */\n  BRETON: {\n    code: \"br\",\n    flag: \"name:br\",\n    name: \"Breton\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Bulgarian language\n   */\n  BULGARIAN: {\n    code: \"bg\",\n    flag: \"bg\",\n    name: \"Bulgarian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Catalan language\n   */\n  CATALAN: {\n    code: \"ca\",\n    flag: \"name:ca\",\n    name: \"Catalan\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Chinese language\n   */\n  CHINESE: {\n    code: \"zh\",\n    flag: \"name:zh\",\n    name: \"Chinese\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Traditional Chinese language\n   */\n  TRADITIONAL_CHINESE: {\n    code: \"zh-Hant\",\n    flag: \"name:zh-Hant\",\n    name: \"Chinese (traditional)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Simplified Chinese language\n   */\n  SIMPLIFIED_CHINESE: {\n    code: \"zh-Hans\",\n    flag: \"name:zh-Hans\",\n    name: \"Chinese (simplified)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Corsican language\n   */\n  CORSICAN: {\n    code: \"co\",\n    flag: \"name:co\",\n    name: \"Corsican\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Croatian language\n   */\n  CROATIAN: {\n    code: \"hr\",\n    flag: \"name:hr\",\n    name: \"Croatian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Czech language\n   */\n  CZECH: {\n    code: \"cs\",\n    flag: \"name:cs\",\n    name: \"Czech\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Danish language\n   */\n  DANISH: {\n    code: \"da\",\n    flag: \"name:da\",\n    name: \"Danish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Dutch language\n   */\n  DUTCH: {\n    code: \"nl\",\n    flag: \"name:nl\",\n    name: \"Dutch\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * German language\n   */\n  GERMAN: {\n    code: \"de\",\n    flag: \"name:de\",\n    name: \"German\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Greek language\n   */\n  GREEK: {\n    code: \"el\",\n    flag: \"name:el\",\n    name: \"Greek\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * English language\n   */\n  ENGLISH: {\n    code: \"en\",\n    flag: \"name:en\",\n    name: \"English\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Esperanto language\n   */\n  ESPERANTO: {\n    code: \"eo\",\n    flag: \"name:eo\",\n    name: \"Esperanto\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Estonian language\n   */\n  ESTONIAN: {\n    code: \"et\",\n    flag: \"name:et\",\n    name: \"Estonian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Finnish language\n   */\n  FINNISH: {\n    code: \"fi\",\n    flag: \"name:fi\",\n    name: \"Finnish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * French language\n   */\n  FRENCH: {\n    code: \"fr\",\n    flag: \"name:fr\",\n    name: \"French\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Frisian language\n   */\n  FRISIAN: {\n    code: \"fy\",\n    flag: \"name:fy\",\n    name: \"Frisian (West)\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Georgian language\n   */\n  GEORGIAN: {\n    code: \"ka\",\n    flag: \"name:ka\",\n    name: \"Georgian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hebrew language (right-to-left non-latin script)\n   */\n  HEBREW: {\n    code: \"he\",\n    flag: \"name:he\",\n    name: \"Hebrew\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hindi language\n   */\n  HINDI: {\n    code: \"hi\",\n    flag: \"name:hi\",\n    name: \"Hindi\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Hungarian language\n   */\n  HUNGARIAN: {\n    code: \"hu\",\n    flag: \"name:hu\",\n    name: \"Hungarian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Icelandic language\n   */\n  ICELANDIC: {\n    code: \"is\",\n    flag: \"name:is\",\n    name: \"Icelandic\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Indonesian language\n   */\n  INDONESIAN: {\n    code: \"id\",\n    flag: \"name:id\",\n    name: \"Indonesian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Irish language\n   */\n  IRISH: {\n    code: \"ga\",\n    flag: \"name:ga\",\n    name: \"Irish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Italian language\n   */\n  ITALIAN: {\n    code: \"it\",\n    flag: \"name:it\",\n    name: \"Italian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Japanese language\n   */\n  JAPANESE: {\n    code: \"ja\",\n    flag: \"name:ja\",\n    name: \"Japanese\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Japanese language in Hiragana form\n   */\n  JAPANESE_HIRAGANA: {\n    code: \"ja-Hira\",\n    flag: \"name:ja-Hira\",\n    name: \"Japanese Hiragana form\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanese language (latin script)\n   */\n  JAPANESE_2018: {\n    code: \"ja-Latn\",\n    flag: \"name:ja-Latn\",\n    name: \"Japanese (Latin 2018)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanese language in Kana form (non-latin script)\n   */\n  JAPANESE_KANA: {\n    code: \"ja_kana\",\n    flag: \"name:ja_kana\",\n    name: \"Japanese (Kana)\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Japanse language, romanized (latin script)\n   */\n  JAPANESE_LATIN: {\n    code: \"ja_rm\",\n    flag: \"name:ja_rm\",\n    name: \"Japanese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Kannada language\n   */\n  KANNADA: {\n    code: \"kn\",\n    flag: \"name:kn\",\n    name: \"Kannada\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Kazakh language\n   */\n  KAZAKH: {\n    code: \"kk\",\n    flag: \"name:kk\",\n    name: \"Kazakh\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Korean language\n   */\n  KOREAN: {\n    code: \"ko\",\n    flag: \"name:ko\",\n    name: \"Korean\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Korean language (latin script)\n   */\n  KOREAN_LATIN: {\n    code: \"ko-Latn\",\n    flag: \"name:ko-Latn\",\n    name: \"Korean (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Kurdish language\n   */\n  KURDISH: {\n    code: \"ku\",\n    flag: \"name:ku\",\n    name: \"Kurdish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Classical Latin language\n   */\n  CLASSICAL_LATIN: {\n    code: \"la\",\n    flag: \"name:la\",\n    name: \"Latin\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Latvian language\n   */\n  LATVIAN: {\n    code: \"lv\",\n    flag: \"name:lv\",\n    name: \"Latvian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Lithuanian language\n   */\n  LITHUANIAN: {\n    code: \"lt\",\n    flag: \"name:lt\",\n    name: \"Lithuanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Luxembourgish language\n   */\n  LUXEMBOURGISH: {\n    code: \"lb\",\n    flag: \"name:lb\",\n    name: \"Luxembourgish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Macedonian language\n   */\n  MACEDONIAN: {\n    code: \"mk\",\n    flag: \"name:mk\",\n    name: \"Macedonian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Malayalm language\n   */\n  MALAYALAM: {\n    code: \"ml\",\n    flag: \"name:ml\",\n    name: \"Malayalam\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Maltese language\n   */\n  MALTESE: {\n    code: \"mt\",\n    flag: \"name:mt\",\n    name: \"Maltese\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Norwegian language\n   */\n  NORWEGIAN: {\n    code: \"no\",\n    flag: \"name:no\",\n    name: \"Norwegian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Occitan language\n   */\n  OCCITAN: {\n    code: \"oc\",\n    flag: \"name:oc\",\n    name: \"Occitan\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Persian language\n   */\n  PERSIAN: {\n    code: \"fa\",\n    flag: \"name:fa\",\n    name: \"Persian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Polish language\n   */\n  POLISH: {\n    code: \"pl\",\n    flag: \"name:pl\",\n    name: \"Polish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Portuguese language\n   */\n  PORTUGUESE: {\n    code: \"pt\",\n    flag: \"name:pt\",\n    name: \"Portuguese\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Punjabi language\n   */\n  PUNJABI: {\n    code: \"pa\",\n    flag: \"name:pa\",\n    name: \"Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Western Punjabi language\n   */\n  WESTERN_PUNJABI: {\n    code: \"pnb\",\n    flag: \"name:pnb\",\n    name: \"Western Punjabi\",\n    latin: false,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Romanian language\n   */\n  ROMANIAN: {\n    code: \"ro\",\n    flag: \"name:ro\",\n    name: \"Romanian\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Romansh language\n   */\n  ROMANSH: {\n    code: \"rm\",\n    flag: \"name:rm\",\n    name: \"Romansh\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Russian language\n   */\n  RUSSIAN: {\n    code: \"ru\",\n    flag: \"name:ru\",\n    name: \"Russian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Serbian language (cyrillic script)\n   */\n  SERBIAN_CYRILLIC: {\n    code: \"sr\",\n    flag: \"name:sr\",\n    name: \"Serbian (Cyrillic script)\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Serbian language (latin script)\n   */\n  SERBIAN_LATIN: {\n    code: \"sr-Latn\",\n    flag: \"name:sr-Latn\",\n    name: \"Serbian (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: false\n  },\n  /**\n   * Scottish Gaelic language\n   */\n  SCOTTISH_GAELIC: {\n    code: \"gd\",\n    flag: \"name:gd\",\n    name: \"Scottish Gaelic\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Slovak language\n   */\n  SLOVAK: {\n    code: \"sk\",\n    flag: \"name:sk\",\n    name: \"Slovak\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Slovene language\n   */\n  SLOVENE: {\n    code: \"sl\",\n    flag: \"name:sl\",\n    name: \"Slovene\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Spanish language\n   */\n  SPANISH: {\n    code: \"es\",\n    flag: \"name:es\",\n    name: \"Spanish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Swedish language\n   */\n  SWEDISH: {\n    code: \"sv\",\n    flag: \"name:sv\",\n    name: \"Swedish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Tamil language\n   */\n  TAMIL: {\n    code: \"ta\",\n    flag: \"name:ta\",\n    name: \"Tamil\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Telugu language\n   */\n  TELUGU: {\n    code: \"te\",\n    flag: \"name:te\",\n    name: \"Telugu\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Thai language\n   */\n  THAI: {\n    code: \"th\",\n    flag: \"name:th\",\n    name: \"Thai\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Turkish language\n   */\n  TURKISH: {\n    code: \"tr\",\n    flag: \"name:tr\",\n    name: \"Turkish\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Ukrainian language\n   */\n  UKRAINIAN: {\n    code: \"uk\",\n    flag: \"name:uk\",\n    name: \"Ukrainian\",\n    latin: false,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Vietnamese language (latin script)\n   */\n  VIETNAMESE: {\n    code: \"vi\",\n    flag: \"name:vi\",\n    name: \"Vietnamese (Latin script)\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  },\n  /**\n   * Welsh language\n   */\n  WELSH: {\n    code: \"cy\",\n    flag: \"name:cy\",\n    name: \"Welsh\",\n    latin: true,\n    isMode: false,\n    geocoding: true\n  }\n};\nconst Language = {\n  ...NonISOLanguage,\n  ...ISOLanguage\n};\nfunction getLanguageInfoFromKey(languageKey, languageDictionary = Language) {\n  if (languageKey in languageDictionary) {\n    return languageKey[languageKey];\n  }\n  return null;\n}\nfunction getLanguageInfoFromCode(languageCode, languageDictionary = Language) {\n  for (const lang of Object.values(languageDictionary)) {\n    if (lang.code === languageCode) {\n      return lang;\n    }\n  }\n  return null;\n}\nfunction getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {\n  for (const lang of Object.values(languageDictionary)) {\n    if (lang.flag === languageFlag) {\n      return lang;\n    }\n  }\n  return null;\n}\nfunction getAutoLanguage() {\n  if (typeof navigator === \"undefined\") {\n    const code = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n    const langInfo = getLanguageInfoFromCode(code);\n    return langInfo ?? Language.ENGLISH;\n  }\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).map((code) => getLanguageInfoFromCode(code)).filter((li) => li);\n  return canditatelangs[0] ?? Language.ENGLISH;\n}\nfunction isLanguageInfo(obj) {\n  return obj !== null && typeof obj === \"object\" && \"code\" in obj && \"flag\" in obj && \"name\" in obj && \"latin\" in obj && \"isMode\" in obj && \"geocoding\" in obj && (typeof obj.code === \"string\" || obj.code === null) && typeof obj.flag === \"string\" && typeof obj.name === \"string\" && typeof obj.latin === \"boolean\" && typeof obj.isMode === \"boolean\" && typeof obj.geocoding === \"boolean\";\n}\nfunction toLanguageInfo(lang, languageDictionary = Language) {\n  if (isLanguageInfo(lang)) {\n    return getLanguageInfoFromFlag(lang.flag, languageDictionary);\n  }\n  if (typeof lang !== \"string\") {\n    return null;\n  }\n  return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;\n}\nfunction areSameLanguages(langA, langB, languageDictionary = Language) {\n  const langAObj = toLanguageInfo(langA, languageDictionary);\n  const langBObj = toLanguageInfo(langB, languageDictionary);\n  return langAObj && langBObj && langAObj.flag === langBObj.flag;\n}\n\nasync function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\"\n    );\n  }\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\n      \"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\"\n    );\n  }\n  return config.fetch(resource, options);\n}\n\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\"\n};\nObject.freeze(defaults);\n\nclass ServiceError extends Error {\n  constructor(res, customMessage = \"\") {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`\n    );\n    this.res = res;\n  }\n}\n\nconst customMessages$4 = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\"\n};\nfunction addLanguageGeocodingOptions(searchParams, options) {\n  const { language } = options;\n  if (language === void 0) {\n    return;\n  }\n  const languageCodes = (Array.isArray(language) ? language : [language]).map((elem) => toValidGeocodingLanguageCode(elem)).filter((elem) => elem);\n  const languages = Array.from(new Set(languageCodes)).join(\",\");\n  searchParams.set(\"language\", languages);\n}\nfunction toValidGeocodingLanguageCode(lang) {\n  const langInfo = lang === Language.AUTO.flag ? getAutoLanguage() : typeof lang === \"string\" ? getLanguageInfoFromCode(lang) : isLanguageInfo(lang) ? lang.flag === Language.AUTO.flag ? getAutoLanguage() : getLanguageInfoFromFlag(lang.flag) : null;\n  return langInfo?.geocoding ? langInfo.code : null;\n}\nfunction addCommonForwardAndReverseGeocodingOptions(searchParams, options) {\n  const { apiKey, limit, types, excludeTypes } = options;\n  searchParams.set(\"key\", apiKey ?? config.apiKey);\n  if (limit !== void 0) {\n    searchParams.set(\"limit\", String(limit));\n  }\n  if (types !== void 0) {\n    searchParams.set(\"types\", types.join(\",\"));\n  }\n  if (excludeTypes !== void 0) {\n    searchParams.set(\"excludeTypes\", String(excludeTypes));\n  }\n  addLanguageGeocodingOptions(searchParams, options);\n}\nfunction addForwardGeocodingOptions(searchParams, options) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n  const { bbox, proximity, country, fuzzyMatch, autocomplete } = options;\n  if (bbox !== void 0) {\n    searchParams.set(\"bbox\", bbox.join(\",\"));\n  }\n  if (proximity !== void 0) {\n    searchParams.set(\n      \"proximity\",\n      proximity === \"ip\" ? proximity : proximity.join(\",\")\n    );\n  }\n  if (country !== void 0) {\n    searchParams.set(\"country\", country.join(\",\"));\n  }\n  if (fuzzyMatch !== void 0) {\n    searchParams.set(\"fuzzyMatch\", fuzzyMatch ? \"true\" : \"false\");\n  }\n  if (autocomplete !== void 0) {\n    searchParams.set(\"autocomplete\", autocomplete ? \"true\" : \"false\");\n  }\n}\nasync function forward(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL\n  );\n  addForwardGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  return await res.json();\n}\nasync function reverse(position, options = {}) {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n  const endpoint = new URL(\n    `geocoding/${position[0]},${position[1]}.json`,\n    defaults.maptilerApiURL\n  );\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  return await res.json();\n}\nasync function byId(id, options = {}) {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  return await res.json();\n}\nasync function batch$1(queries, options = {}) {\n  if (!queries.length) {\n    return [];\n  }\n  const joinedQuery = queries.map((query) => encodeURIComponent(query)).join(\";\");\n  const endpoint = new URL(\n    `geocoding/${joinedQuery}.json`,\n    defaults.maptilerApiURL\n  );\n  addForwardGeocodingOptions(endpoint.searchParams, options);\n  const res = await callFetch(endpoint.toString());\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages$4[res.status] ?? \"\");\n  }\n  const obj = await res.json();\n  return queries.length === 1 ? [obj] : obj;\n}\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch: batch$1\n};\n\nconst customMessages$3 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function info(options = {}) {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"elevation\" in options) {\n    endpoint.searchParams.set(\n      \"elevation\",\n      options.elevation ? \"true\" : \"false\"\n    );\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$3 ? customMessages$3[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst geolocation = {\n  info\n};\n\nconst customMessages$2 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function search(query, options = {}) {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString()\n    );\n  }\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$2 ? customMessages$2[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nasync function transform(positions, options = {}) {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions]).map((coord) => `${coord[0]},${coord[1]}`).join(\";\");\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations) ? options.operations : [options.operations]).join(\"|\")\n    );\n  }\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$2 ? customMessages$2[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst coordinates = {\n  search,\n  transform\n};\n\nconst customMessages$1 = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function get(dataId, options = {}) {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages$1 ? customMessages$1[res.status] : \"\"\n    );\n  }\n  const obj = await res.json();\n  return obj;\n}\nconst data = {\n  get\n};\n\nfunction expandMapStyle(style) {\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n  return expandedStyle;\n}\nclass MapStyleVariant {\n  constructor(name, variantType, id, referenceStyle, description, imageURL, deprecated = false) {\n    this.name = name;\n    this.variantType = variantType;\n    this.id = id;\n    this.referenceStyle = referenceStyle;\n    this.description = description;\n    this.imageURL = imageURL;\n    this.deprecated = deprecated;\n  }\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  getFullName() {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType() {\n    return this.variantType;\n  }\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Get the human-friendly description\n   */\n  getDescription() {\n    return this.description;\n  }\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle() {\n    return this.referenceStyle;\n  }\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    const variant = this.referenceStyle.getVariant(variantType);\n    this.warnIfDeprecated(variant);\n    return variant;\n  }\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants() {\n    return this.referenceStyle.getVariants().filter((v) => v !== this).map((v) => {\n      this.warnIfDeprecated(v);\n      return v;\n    });\n  }\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL() {\n    return this.imageURL;\n  }\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL() {\n    return expandMapStyle(this.getId());\n  }\n  warnIfDeprecated(variant = this) {\n    if (!variant.deprecated)\n      return variant;\n    const name = variant.getFullName();\n    console.warn(\n      `Style \"${name}\" is deprecated and will be removed in a future version.`\n    );\n    return variant;\n  }\n}\nclass ReferenceMapStyle {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Variants that belong to this reference style, key being the reference type\n     */\n    this.variants = {};\n    /**\n     * Variants that belong to this reference style, ordered by relevance\n     */\n    this.orderedVariants = [];\n  }\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName() {\n    return this.name;\n  }\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId() {\n    return this.id;\n  }\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType) {\n    return variantType in this.variants;\n  }\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType) {\n    return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];\n  }\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants() {\n    return Object.values(this.variants);\n  }\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant() {\n    return this.orderedVariants[0].warnIfDeprecated();\n  }\n}\nconst mapStylePresetList = [\n  {\n    referenceStyleID: \"STREETS\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-night\",\n        name: \"Night\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"streets-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OUTDOOR\",\n    name: \"Outdoor\",\n    description: \"\",\n    variants: [\n      {\n        id: \"outdoor-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"outdoor-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"WINTER\",\n    name: \"Winter\",\n    description: \"\",\n    variants: [\n      {\n        id: \"winter-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"winter-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"SATELLITE\",\n    name: \"Satellite\",\n    description: \"\",\n    variants: [\n      {\n        id: \"satellite\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"HYBRID\",\n    name: \"Hybrid\",\n    description: \"\",\n    variants: [\n      {\n        id: \"hybrid\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BASIC\",\n    name: \"Basic\",\n    description: \"\",\n    variants: [\n      {\n        id: \"basic-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"basic-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"basic-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BRIGHT\",\n    name: \"Bright\",\n    description: \"\",\n    variants: [\n      {\n        id: \"bright-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"bright-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OPENSTREETMAP\",\n    name: \"OpenStreetMap\",\n    description: \"\",\n    variants: [\n      {\n        id: \"openstreetmap\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"TOPO\",\n    name: \"Topo\",\n    description: \"\",\n    variants: [\n      {\n        id: \"topo-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-shiny\",\n        name: \"Shiny\",\n        deprecated: true,\n        variantType: \"SHINY\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"topo-v2-topographique\",\n        name: \"Topographique\",\n        variantType: \"TOPOGRAPHIQUE\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"VOYAGER\",\n    name: \"Voyager\",\n    description: \"\",\n    variants: [\n      {\n        id: \"voyager-v2\",\n        name: \"Default\",\n        deprecated: true,\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-darkmatter\",\n        name: \"Darkmatter\",\n        deprecated: true,\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-positron\",\n        name: \"Positron\",\n        deprecated: true,\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"voyager-v2-vintage\",\n        name: \"Vintage\",\n        deprecated: true,\n        variantType: \"VINTAGE\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"TONER\",\n    name: \"Toner\",\n    description: \"\",\n    variants: [\n      {\n        id: \"toner-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-background\",\n        name: \"Background\",\n        variantType: \"BACKGROUND\",\n        deprecated: true,\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-lite\",\n        name: \"Lite\",\n        variantType: \"LITE\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"toner-v2-lines\",\n        name: \"Lines\",\n        variantType: \"LINES\",\n        deprecated: true,\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"DATAVIZ\",\n    name: \"Dataviz\",\n    description: \"\",\n    variants: [\n      {\n        id: \"dataviz\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"dataviz-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"dataviz-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"BACKDROP\",\n    name: \"Backdrop\",\n    description: \"\",\n    variants: [\n      {\n        id: \"backdrop\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"backdrop-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"backdrop-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"OCEAN\",\n    name: \"Ocean\",\n    description: \"\",\n    variants: [\n      {\n        id: \"ocean\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"AQUARELLE\",\n    name: \"Aquarelle\",\n    description: \"Watercolor map for creative use\",\n    variants: [\n      {\n        id: \"aquarelle\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"aquarelle-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"aquarelle-vivid\",\n        name: \"Vivid\",\n        variantType: \"VIVID\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  },\n  {\n    referenceStyleID: \"LANDSCAPE\",\n    name: \"Landscape\",\n    description: \"Terrain map for data overlays and visualisations\",\n    variants: [\n      {\n        id: \"landscape\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"landscape-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\"\n      },\n      {\n        id: \"landscape-vivid\",\n        name: \"Vivid\",\n        variantType: \"VIVID\",\n        description: \"\",\n        imageURL: \"\"\n      }\n    ]\n  }\n];\nfunction makeReferenceStyleProxy(referenceStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop)) {\n        return target.getVariant(prop);\n      }\n      if (prop.toString().toUpperCase() === prop) {\n        return referenceStyle.getDefaultVariant();\n      }\n      const style = Reflect.get(target, prop, receiver);\n      return style;\n    }\n  });\n}\nfunction buildMapStyles() {\n  const mapStyle = {};\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n    const refStyle = makeReferenceStyleProxy(\n      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)\n    );\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(\n        variantInfo.name,\n        // name\n        variantInfo.variantType,\n        // variantType\n        variantInfo.id,\n        // id\n        refStyle,\n        // referenceStyle\n        variantInfo.description,\n        variantInfo.imageURL,\n        // imageURL\n        variantInfo.deprecated\n        // deprecated\n      );\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle;\n}\nfunction styleToStyle(style) {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getId();\n  }\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\nconst MapStyle = buildMapStyles();\n\nfunction extractLineStrings(geoJson) {\n  const lineStrings = [];\n  function extractFromGeometry(geometry) {\n    if (geometry.type === \"LineString\" || geometry.type === \"MultiLineString\") {\n      lineStrings.push(geometry);\n    }\n  }\n  function extractFromFeature(feature) {\n    if (feature.geometry) {\n      extractFromGeometry(feature.geometry);\n    }\n  }\n  function extractFromFeatureCollection(collection) {\n    for (const feature of collection.features) {\n      if (feature.type === \"Feature\") {\n        extractFromFeature(feature);\n      } else if (feature.type === \"FeatureCollection\") {\n        extractFromFeatureCollection(feature);\n      }\n    }\n  }\n  if (geoJson.type === \"Feature\") {\n    extractFromFeature(geoJson);\n  } else if (geoJson.type === \"FeatureCollection\") {\n    extractFromFeatureCollection(geoJson);\n  } else {\n    extractFromGeometry(geoJson);\n  }\n  return lineStrings;\n}\nfunction getSqSegDist(p, p1, p2) {\n  let x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  let maxSqDist = sqTolerance, index;\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance) {\n  if (points.length <= 2) {\n    return points;\n  }\n  const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\nconst misc = {\n  extractLineStrings,\n  simplify\n};\n\nfunction staticMapMarkerToString(marker, includeColor = true) {\n  let str = `${marker[0]},${marker[1]}`;\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n  return str;\n}\nfunction simplifyAndStringify(path, maxNbChar = 3e3) {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 5e-6;\n  const toleranceStep = 1e-5;\n  while (str.length > maxNbChar) {\n    const simplerPath = misc.simplify(path, tolerance);\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n  return str;\n}\nfunction centered(center, zoom, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center[0]},${center[1]},${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction bounded(boundingBox, options = {}) {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${boundingBox[1]},${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nfunction automatic(options = {}) {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\"\n    );\n  }\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n    const hasIcon = \"markerIcon\" in options;\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n    const markerList = Array.isArray(options.markers[0]) ? options.markers : [options.markers];\n    markerStr += markerList.map((m) => staticMapMarkerToString(m, !hasIcon)).join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n  if (\"path\" in options) {\n    let pathStr = \"\";\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  return endpoint.toString();\n}\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic\n};\n\nconst EARTH_RADIUS = 63710088e-1;\nconst EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;\nfunction longitudeToMercatorX(lng) {\n  return (180 + lng) / 360;\n}\nfunction latitudeToMercatorY(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nfunction wgs84ToMercator(position) {\n  const wrappedPos = wrapWgs84(position);\n  return [\n    longitudeToMercatorX(wrappedPos[0]),\n    latitudeToMercatorY(wrappedPos[1])\n  ];\n}\nfunction mercatorXToLongitude(x) {\n  return x * 360 - 180;\n}\nfunction mercatorYToLatitude(y) {\n  const y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nfunction mercatorToWgs84(position) {\n  return [mercatorXToLongitude(position[0]), mercatorYToLatitude(position[1])];\n}\nfunction haversineDistanceWgs84(from, to) {\n  const rad = Math.PI / 180;\n  const lat1 = from[1] * rad;\n  const lat2 = to[1] * rad;\n  const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((to[0] - from[0]) * rad);\n  const maxMeters = EARTH_RADIUS * Math.acos(Math.min(a, 1));\n  return maxMeters;\n}\nfunction haversineCumulatedDistanceWgs84(positions) {\n  const cumulatedDistance = Array(positions.length);\n  cumulatedDistance[0] = 0;\n  const l = cumulatedDistance.length;\n  for (let i = 1; i < l; i++) {\n    cumulatedDistance[i] = haversineDistanceWgs84(positions[i - 1], positions[i]) + cumulatedDistance[i - 1];\n  }\n  return cumulatedDistance;\n}\nfunction wrapWgs84(position) {\n  const lng = position[0];\n  const lat = position[1];\n  const d = 360;\n  const w = ((lng + 180) % d + d) % d - 180;\n  const wrapLong = w === -180 ? 180 : w;\n  return [wrapLong, lat];\n}\nfunction circumferenceAtLatitude(latitude) {\n  return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);\n}\nfunction mercatorToTileIndex(position, zoom, strict = true) {\n  const numberOfTilePerAxis = 2 ** zoom;\n  const fIndex = [\n    position[0] * numberOfTilePerAxis,\n    position[1] * numberOfTilePerAxis\n  ];\n  return strict ? [~~fIndex[0], ~~fIndex[1]] : fIndex;\n}\nfunction wgs84ToTileIndex(position, zoom, strict = true) {\n  const merc = wgs84ToMercator(position);\n  return mercatorToTileIndex(merc, zoom, strict);\n}\nfunction toRadians(degrees) {\n  return degrees * Math.PI / 180;\n}\nfunction toDegrees(radians) {\n  return radians * 180 / Math.PI;\n}\nfunction haversineIntermediateWgs84(pos1, pos2, ratio) {\n  const d = haversineDistanceWgs84(pos1, pos2);\n  const \\u03BB1 = toRadians(pos1[0]);\n  const \\u03C61 = toRadians(pos1[1]);\n  const \\u03BB2 = toRadians(pos2[0]);\n  const \\u03C62 = toRadians(pos2[1]);\n  const \\u03B4 = d / EARTH_RADIUS;\n  const a = Math.sin((1 - ratio) * \\u03B4) / Math.sin(\\u03B4);\n  const b = Math.sin(ratio * \\u03B4) / Math.sin(\\u03B4);\n  const x = a * Math.cos(\\u03C61) * Math.cos(\\u03BB1) + b * Math.cos(\\u03C62) * Math.cos(\\u03BB2);\n  const y = a * Math.cos(\\u03C61) * Math.sin(\\u03BB1) + b * Math.cos(\\u03C62) * Math.sin(\\u03BB2);\n  const z = a * Math.sin(\\u03C61) + b * Math.sin(\\u03C62);\n  const \\u03C63 = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const \\u03BB3 = Math.atan2(y, x);\n  return [toDegrees(\\u03BB3), toDegrees(\\u03C63)];\n}\nconst math = {\n  EARTH_RADIUS,\n  EARTH_CIRCUMFERENCE,\n  longitudeToMercatorX,\n  latitudeToMercatorY,\n  wgs84ToMercator,\n  mercatorXToLongitude,\n  mercatorYToLatitude,\n  mercatorToWgs84,\n  haversineDistanceWgs84,\n  wrapWgs84,\n  circumferenceAtLatitude,\n  mercatorToTileIndex,\n  wgs84ToTileIndex,\n  toRadians,\n  toDegrees,\n  haversineIntermediateWgs84,\n  haversineCumulatedDistanceWgs84\n};\n\nlet tileCache = null;\nfunction getTileCache() {\n  if (!tileCache) {\n    tileCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ maxSize: config.tileCacheSize });\n  }\n  return tileCache;\n}\nasync function bufferToPixelDataBrowser(buff) {\n  const blob = new Blob([buff]);\n  const imageBitmap = await createImageBitmap(blob);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = imageBitmap.width;\n  canvas.height = imageBitmap.height;\n  ctx.drawImage(imageBitmap, 0, 0);\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  return {\n    pixels: imageData.data,\n    width: canvas.width,\n    height: canvas.height,\n    components: imageData.data.length / (canvas.width * canvas.height)\n  };\n}\nfunction getBufferToPixelDataParser() {\n  if (config.bufferToPixelData) {\n    return config.bufferToPixelData;\n  }\n  if (typeof window !== \"undefined\") {\n    return bufferToPixelDataBrowser;\n  }\n  throw new Error(\n    \"An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`\"\n  );\n}\nfunction canParsePixelData() {\n  return !!config.bufferToPixelData || typeof window !== \"undefined\";\n}\n\nconst TERRAIN_TILESET = \"terrain-rgb-v2\";\nconst API_BATCH_SIZE = 50;\nconst API_WARN_SIZE = 1e3;\nlet terrainTileJson = null;\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\"\n};\nasync function computeOnServer(positions, apiKey) {\n  if (positions.length > API_WARN_SIZE) {\n    console.warn(\n      \"Computing elevation for complex geometries is discouraged - simplify the geometry before proceeding\"\n    );\n  }\n  const parts = Math.ceil(positions.length / API_BATCH_SIZE);\n  const respPromises = Array.from({ length: parts }, () => null).map(\n    (_, part) => {\n      const startPos = part * API_BATCH_SIZE;\n      const batch2 = positions.slice(startPos, startPos + API_BATCH_SIZE);\n      const batchEncoded = batch2.map((pos) => pos.join(\",\")).join(\";\");\n      const endpoint = new URL(\n        `elevation/${batchEncoded}.json`,\n        defaults.maptilerApiURL\n      );\n      endpoint.searchParams.set(\"key\", apiKey);\n      return callFetch(endpoint.toString());\n    }\n  );\n  const resps = await Promise.allSettled(respPromises);\n  const jsons = await Promise.all(\n    resps.map(async (resp) => {\n      if (resp.status === \"rejected\") {\n        throw new Error(\n          `Some segments could not be fetched, error: ${resp.reason}`\n        );\n      }\n      if (!resp.value.ok) {\n        throw new Error(\n          `Some segments could not be fetched, response: ${resp.value.status} ${await resp.value.text()}, url: ${resp.value.url}`\n        );\n      }\n      return resp.value.json();\n    })\n  );\n  return jsons.flat();\n}\nasync function computeOnClient(positions, apiKey, zoom) {\n  if (!terrainTileJson) {\n    const endpoint = new URL(\n      `tiles/${TERRAIN_TILESET}/tiles.json`,\n      defaults.maptilerApiURL\n    );\n    endpoint.searchParams.set(\"key\", apiKey);\n    const urlWithParams = endpoint.toString();\n    const res = await callFetch(urlWithParams);\n    if (res.ok) {\n      terrainTileJson = await res.json();\n    } else {\n      throw new ServiceError(res, customMessages[res.status] ?? \"\");\n    }\n  }\n  const tileParser = getBufferToPixelDataParser();\n  const tileURLSchema = terrainTileJson.tiles[0];\n  const cache = getTileCache();\n  const maxZoom = terrainTileJson.maxzoom;\n  let usedZoom = ~~(zoom ?? maxZoom);\n  if (usedZoom > maxZoom || usedZoom < 0) {\n    usedZoom = maxZoom;\n  }\n  const tileIndicesFloats = positions.map(\n    (position) => math.wgs84ToTileIndex(position, usedZoom, false)\n  );\n  const tileIndicesInteger = tileIndicesFloats.map((index) => [\n    ~~index[0],\n    ~~index[1]\n  ]);\n  const tileIDs = tileIndicesInteger.map(\n    (index) => `terrain_${usedZoom.toString()}_${index[0].toString()}_${index[1].toString()}`\n  );\n  const uniqueTilesToFetch = Array.from(\n    new Set(tileIDs.filter((tileID) => !cache.has(tileID)))\n  ).map((tileID) => tileID.split(\"_\").slice(1));\n  const tileURLs = uniqueTilesToFetch.map(\n    (zxy) => tileURLSchema.replace(\"{x}\", zxy[1].toString()).replace(\"{y}\", zxy[2].toString()).replace(\"{z}\", zxy[0].toString())\n  );\n  const promisesFetchTiles = tileURLs.map((url) => callFetch(url));\n  const resTiles = await Promise.allSettled(promisesFetchTiles);\n  const fulfilledRes = resTiles.map(\n    (el) => el.status === \"fulfilled\" ? el.value : null\n  ).filter((res) => res);\n  const fulfilledRButNotOkRes = fulfilledRes.filter((res) => !res.ok);\n  if (fulfilledRes.length !== promisesFetchTiles.length) {\n    throw new Error(\"Some tiles could not be fetched.\");\n  }\n  if (fulfilledRButNotOkRes.length) {\n    throw new ServiceError(\n      fulfilledRButNotOkRes[0],\n      customMessages[fulfilledRButNotOkRes[0].status] ?? \"\"\n    );\n  }\n  const tileArrayBuffers = await Promise.all(\n    fulfilledRes.map((res) => res.arrayBuffer())\n  );\n  if (!tileArrayBuffers.every((buff) => buff.byteLength > 0)) {\n    throw new Error(\"Some tiles are not available.\");\n  }\n  const tilePixelDatas = await Promise.all(\n    tileArrayBuffers.map((buff) => tileParser(buff))\n  );\n  tilePixelDatas.forEach((tilePixelData, i) => {\n    const zxy = uniqueTilesToFetch[i];\n    const tileID = `terrain_${zxy[0].toString()}_${zxy[1].toString()}_${zxy[2].toString()}`;\n    cache.set(tileID, tilePixelData);\n  });\n  const elevatedPositions = positions.map((position, i) => {\n    const tileID = tileIDs[i];\n    const tileIndexFloat = tileIndicesFloats[i];\n    const tilePixelData = cache.get(tileID);\n    const pixelX = Math.min(\n      Math.round(tilePixelData.width * (tileIndexFloat[0] % 1)),\n      tilePixelData.width - 1\n    );\n    const pixelY = Math.min(\n      Math.round(tilePixelData.height * (tileIndexFloat[1] % 1)),\n      tilePixelData.height - 1\n    );\n    const pixelDataIndex = (pixelY * tilePixelData.width + pixelX) * tilePixelData.components;\n    const R = tilePixelData.pixels[pixelDataIndex];\n    const G = tilePixelData.pixels[pixelDataIndex + 1];\n    const B = tilePixelData.pixels[pixelDataIndex + 2];\n    const elevation2 = -1e4 + (R * 256 * 256 + G * 256 + B) * 0.1;\n    return [position[0], position[1], ~~(elevation2 * 1e3) / 1e3];\n  });\n  return elevatedPositions;\n}\nasync function at(position, options = {}) {\n  const elevatedPositions = await batch([position], options);\n  return elevatedPositions[0];\n}\nasync function batch(positions, options = {}) {\n  if (positions.length === 0)\n    return [];\n  const apiKey = options.apiKey ?? config.apiKey;\n  const elevatedPositions = options.computeOn === \"client\" ? await computeOnClient(positions, apiKey, options.zoom) : await computeOnServer(positions, apiKey);\n  if (options.smoothingKernelSize) {\n    const kernelSize = ~~(options.smoothingKernelSize / 2) * 2 + 1;\n    const elevations = elevatedPositions.map((pos) => pos[2]);\n    const kernelSpan = ~~(kernelSize / 2);\n    for (let i = kernelSpan; i < elevations.length - kernelSpan - 1; i += 1) {\n      let sum = 0;\n      for (let j = 0; j < kernelSize; j += 1) {\n        const elev = elevations[i - kernelSpan + j];\n        sum += elev;\n      }\n      sum /= kernelSize;\n      elevatedPositions[i][2] = sum;\n    }\n  }\n  return elevatedPositions;\n}\nasync function fromLineString(ls, options = {}) {\n  if (ls.type !== \"LineString\") {\n    throw new Error(\"The provided object is not a GeoJSON LineString\");\n  }\n  options.computeOn ?? (options.computeOn = canParsePixelData() ? \"client\" : \"server\");\n  const clone = structuredClone(ls);\n  const elevatedPositions = await batch(clone.coordinates, options);\n  clone.coordinates = elevatedPositions;\n  return clone;\n}\nasync function fromMultiLineString(ls, options = {}) {\n  if (ls.type !== \"MultiLineString\") {\n    throw new Error(\"The provided object is not a GeoJSON MultiLineString\");\n  }\n  options.computeOn ?? (options.computeOn = canParsePixelData() ? \"client\" : \"server\");\n  const clone = structuredClone(ls);\n  const multiLengths = clone.coordinates.map((poss) => poss.length);\n  const flattenPositions = clone.coordinates.flat();\n  const flattenPositionsElevated = await batch(flattenPositions, options);\n  const result = [];\n  let index = 0;\n  for (const length of multiLengths) {\n    result.push(flattenPositionsElevated.slice(index, index + length));\n    index += length;\n  }\n  clone.coordinates = result;\n  return clone;\n}\nconst elevation = {\n  at,\n  batch,\n  fromLineString,\n  fromMultiLineString\n};\n\n\n//# sourceMappingURL=maptiler-client.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2NsaWVudC9kaXN0L21hcHRpbGVyLWNsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0oscURBQXFELFNBQVM7QUFDOUQsSUFBSTtBQUNKLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCLEVBQUUsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdnQjtBQUNoZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBwbGllci1kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2NsaWVudC9kaXN0L21hcHRpbGVyLWNsaWVudC5tanM/MTkwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUXVpY2tMUlUgZnJvbSAncXVpY2stbHJ1JztcblxuZnVuY3Rpb24gdHJ5R2V0dGluZ0ZldGNoKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmV0Y2guYmluZChzZWxmKTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuZmV0Y2gpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmZldGNoO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgQ2xpZW50Q29uZmlnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogTWFwVGlsZXIgQ2xvdWQgQVBJIGtleVxuICAgICAqL1xuICAgIHRoaXMuX2FwaUtleSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZldGNoIGZ1bmN0aW9uLiBUbyBiZSBzZXQgaWYgaW4gTm9kZSA8IDE4LCBvdGhlcndpc2VcbiAgICAgKiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgdGhpcy5fZmV0Y2ggPSB0cnlHZXR0aW5nRmV0Y2goKTtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGlsZXMgdG8ga2VlcCBpbiBjYWNoZVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNhY2hlU2l6ZSA9IDIwMDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBNYXBUaWxlciBDbG91ZCBBUEkga2V5XG4gICAqL1xuICBzZXQgYXBpS2V5KGspIHtcbiAgICB0aGlzLl9hcGlLZXkgPSBrO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIENsb3VkIEFQSSBrZXlcbiAgICovXG4gIGdldCBhcGlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwaUtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgdGhlIGN1c3RvbSBmZXRjaCBmdW5jdGlvbiB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG9uZVxuICAgKi9cbiAgc2V0IGZldGNoKGYpIHtcbiAgICB0aGlzLl9mZXRjaCA9IGY7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmV0Y2ggZnVjbnRpb25cbiAgICovXG4gIGdldCBmZXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2g7XG4gIH1cbn1cbmNvbnN0IGNvbmZpZyA9IG5ldyBDbGllbnRDb25maWcoKTtcblxuY29uc3QgTm9uSVNPTGFuZ3VhZ2UgPSB7XG4gIC8qKlxuICAgKiBMYW5ndWFnZSBtb2RlIHRvIGRpc3BsYXkgdGhlIGxhYmVscyBpbiB0aGUgZW5kIHVzZXIncyBkZXZpY2UgbGFuZ3VhZ2UuXG4gICAqL1xuICBBVVRPOiB7XG4gICAgY29kZTogbnVsbCxcbiAgICBmbGFnOiBcImF1dG9cIixcbiAgICBuYW1lOiBcIkF1dG9cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiB0cnVlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVGhlIE9TTSBsYW5ndWFnZSB1c2luZyBsYXRpbiBzY3JpcHQuIE1hcFRpbGVyIGRpc2NvdXJhZ2VzIGl0cyB1c2UgYXMgYSBwcmltYXJ5IGxhbmd1YWdlIHNldHRpbmcgZHVlIHRvIHRoZSBsYWNrIG9mIGFjdHVhbCBsaW5ndWlzdGljIHNwZWNpZmljaXR5LFxuICAgKiB0aG91Z2ggaXQgY2FuIGJlIGFuIGhhbmR5IGZhbGxiYWNrLiBUaGlzIGlzIG5vdCB0byBiZSBjb25mdXNlZCB3aXRoIHRoZSBcIkNsYXNzaWNhbCBMYXRpblwiIGxhbmd1YWdlLCB3aGljaCBpcyBhdmFpbGFibGUgdW5kZXIgdGhlIHRhZyBgLkNMQVNTSUNBTF9MQVRJTmAuXG4gICAqL1xuICBMQVRJTjoge1xuICAgIGNvZGU6IFwibGF0aW5cIixcbiAgICBmbGFnOiBcIm5hbWU6bGF0aW5cIixcbiAgICBuYW1lOiBcIkxhdGluXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgT1NNIGxhbmd1YWdlIHVzaW5nIG5vbi1sYXRpbiBzY3JpcHQuIE1hcFRpbGVyIGRpc2NvdXJhZ2VzIGl0cyB1c2UgYXMgYSBwcmltYXJ5IGxhbmd1YWdlIHNldHRpbmcgZHVlIHRvIHRoZSBsYWNrIG9mIGFjdHVhbCBsaW5ndWlzdGljIHNwZWNpZmljaXR5LFxuICAgKiB0aG91Z2ggaXQgY2FuIGJlIGFuIGhhbmR5IGZhbGxiYWNrLlxuICAgKi9cbiAgTk9OX0xBVElOOiB7XG4gICAgY29kZTogXCJub25sYXRpblwiLFxuICAgIGZsYWc6IFwibmFtZTpub25sYXRpblwiLFxuICAgIG5hbWU6IFwiTm9uIExhdGluXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogVXNpbmcgdGhlIGxvY2FsIGxhbmd1YWdlIGdlbmVyYWx5IChidXQgbm90IGFsd2F5cykgbWVhbnMgdGhhdCBldmVyeSBsYWJlbHMgb2YgYSBnaXZlbiByZWdpb24gd2lsbCB1c2UgdGhlIGRvbWluYW50IGxvY2FsIGxhbmd1YWdlLlxuICAgKi9cbiAgTE9DQUw6IHtcbiAgICBjb2RlOiBudWxsLFxuICAgIGZsYWc6IFwibmFtZVwiLFxuICAgIG5hbWU6IFwiTG9jYWxcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfVxufTtcbmNvbnN0IElTT0xhbmd1YWdlID0ge1xuICAvKipcbiAgICogQWxiYW5pYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEFMQkFOSUFOOiB7XG4gICAgY29kZTogXCJzcVwiLFxuICAgIGZsYWc6IFwibmFtZTpzcVwiLFxuICAgIG5hbWU6IFwiQWxiYW5pYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQW1oYXJpYyBsYW5ndWFnZVxuICAgKi9cbiAgQU1IQVJJQzoge1xuICAgIGNvZGU6IFwiYW1cIixcbiAgICBmbGFnOiBcIm5hbWU6YW1cIixcbiAgICBuYW1lOiBcIkFtaGFyaWNcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEFyYWJpYyBsYW5ndWFnZSAocmlnaHQtdG8tbGVmdCBzY3JpcHQpXG4gICAqL1xuICBBUkFCSUM6IHtcbiAgICBjb2RlOiBcImFyXCIsXG4gICAgZmxhZzogXCJuYW1lOmFyXCIsXG4gICAgbmFtZTogXCJBcmFiaWNcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEFybWVuaWFuIGxhbmd1YWdlXG4gICAqL1xuICBBUk1FTklBTjoge1xuICAgIGNvZGU6IFwiaHlcIixcbiAgICBmbGFnOiBcIm5hbWU6aHlcIixcbiAgICBuYW1lOiBcIkFybWVuaWFuXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBBemVyYmFpamFuaSBsYW5ndWFnZVxuICAgKi9cbiAgQVpFUkJBSUpBTkk6IHtcbiAgICBjb2RlOiBcImF6XCIsXG4gICAgZmxhZzogXCJuYW1lOmF6XCIsXG4gICAgbmFtZTogXCJBemVyYmFpamFuaVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBCYXNxdWUgbGFuZ3VhZ2VcbiAgICovXG4gIEJBU1FVRToge1xuICAgIGNvZGU6IFwiZXVcIixcbiAgICBmbGFnOiBcIm5hbWU6ZXVcIixcbiAgICBuYW1lOiBcIkJhc3F1ZVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBCZWxhcnVzaWFuIGxhbmdhdWdlXG4gICAqL1xuICBCRUxBUlVTSUFOOiB7XG4gICAgY29kZTogXCJiZVwiLFxuICAgIGZsYWc6IFwibmFtZTpiZVwiLFxuICAgIG5hbWU6IFwiQmVsYXJ1c2lhblwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQmVuZ2FsaSBsYW5ndWFnZVxuICAgKi9cbiAgQkVOR0FMSToge1xuICAgIGNvZGU6IFwiYm5cIixcbiAgICBmbGFnOiBcIm5hbWU6Ym5cIixcbiAgICBuYW1lOiBcIkJlbmdhbGlcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQm9zbmlhbiBsYW5ndWFnZVxuICAgKi9cbiAgQk9TTklBTjoge1xuICAgIGNvZGU6IFwiYnNcIixcbiAgICBmbGFnOiBcIm5hbWU6YnNcIixcbiAgICBuYW1lOiBcIkJvc25pYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQnJldG9uIGxhbmd1YWdlXG4gICAqL1xuICBCUkVUT046IHtcbiAgICBjb2RlOiBcImJyXCIsXG4gICAgZmxhZzogXCJuYW1lOmJyXCIsXG4gICAgbmFtZTogXCJCcmV0b25cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQnVsZ2FyaWFuIGxhbmd1YWdlXG4gICAqL1xuICBCVUxHQVJJQU46IHtcbiAgICBjb2RlOiBcImJnXCIsXG4gICAgZmxhZzogXCJiZ1wiLFxuICAgIG5hbWU6IFwiQnVsZ2FyaWFuXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBDYXRhbGFuIGxhbmd1YWdlXG4gICAqL1xuICBDQVRBTEFOOiB7XG4gICAgY29kZTogXCJjYVwiLFxuICAgIGZsYWc6IFwibmFtZTpjYVwiLFxuICAgIG5hbWU6IFwiQ2F0YWxhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBDaGluZXNlIGxhbmd1YWdlXG4gICAqL1xuICBDSElORVNFOiB7XG4gICAgY29kZTogXCJ6aFwiLFxuICAgIGZsYWc6IFwibmFtZTp6aFwiLFxuICAgIG5hbWU6IFwiQ2hpbmVzZVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVHJhZGl0aW9uYWwgQ2hpbmVzZSBsYW5ndWFnZVxuICAgKi9cbiAgVFJBRElUSU9OQUxfQ0hJTkVTRToge1xuICAgIGNvZGU6IFwiemgtSGFudFwiLFxuICAgIGZsYWc6IFwibmFtZTp6aC1IYW50XCIsXG4gICAgbmFtZTogXCJDaGluZXNlICh0cmFkaXRpb25hbClcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBTaW1wbGlmaWVkIENoaW5lc2UgbGFuZ3VhZ2VcbiAgICovXG4gIFNJTVBMSUZJRURfQ0hJTkVTRToge1xuICAgIGNvZGU6IFwiemgtSGFuc1wiLFxuICAgIGZsYWc6IFwibmFtZTp6aC1IYW5zXCIsXG4gICAgbmFtZTogXCJDaGluZXNlIChzaW1wbGlmaWVkKVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIENvcnNpY2FuIGxhbmd1YWdlXG4gICAqL1xuICBDT1JTSUNBTjoge1xuICAgIGNvZGU6IFwiY29cIixcbiAgICBmbGFnOiBcIm5hbWU6Y29cIixcbiAgICBuYW1lOiBcIkNvcnNpY2FuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIENyb2F0aWFuIGxhbmd1YWdlXG4gICAqL1xuICBDUk9BVElBTjoge1xuICAgIGNvZGU6IFwiaHJcIixcbiAgICBmbGFnOiBcIm5hbWU6aHJcIixcbiAgICBuYW1lOiBcIkNyb2F0aWFuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEN6ZWNoIGxhbmd1YWdlXG4gICAqL1xuICBDWkVDSDoge1xuICAgIGNvZGU6IFwiY3NcIixcbiAgICBmbGFnOiBcIm5hbWU6Y3NcIixcbiAgICBuYW1lOiBcIkN6ZWNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIERhbmlzaCBsYW5ndWFnZVxuICAgKi9cbiAgREFOSVNIOiB7XG4gICAgY29kZTogXCJkYVwiLFxuICAgIGZsYWc6IFwibmFtZTpkYVwiLFxuICAgIG5hbWU6IFwiRGFuaXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIER1dGNoIGxhbmd1YWdlXG4gICAqL1xuICBEVVRDSDoge1xuICAgIGNvZGU6IFwibmxcIixcbiAgICBmbGFnOiBcIm5hbWU6bmxcIixcbiAgICBuYW1lOiBcIkR1dGNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEdlcm1hbiBsYW5ndWFnZVxuICAgKi9cbiAgR0VSTUFOOiB7XG4gICAgY29kZTogXCJkZVwiLFxuICAgIGZsYWc6IFwibmFtZTpkZVwiLFxuICAgIG5hbWU6IFwiR2VybWFuXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEdyZWVrIGxhbmd1YWdlXG4gICAqL1xuICBHUkVFSzoge1xuICAgIGNvZGU6IFwiZWxcIixcbiAgICBmbGFnOiBcIm5hbWU6ZWxcIixcbiAgICBuYW1lOiBcIkdyZWVrXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBFbmdsaXNoIGxhbmd1YWdlXG4gICAqL1xuICBFTkdMSVNIOiB7XG4gICAgY29kZTogXCJlblwiLFxuICAgIGZsYWc6IFwibmFtZTplblwiLFxuICAgIG5hbWU6IFwiRW5nbGlzaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBFc3BlcmFudG8gbGFuZ3VhZ2VcbiAgICovXG4gIEVTUEVSQU5UTzoge1xuICAgIGNvZGU6IFwiZW9cIixcbiAgICBmbGFnOiBcIm5hbWU6ZW9cIixcbiAgICBuYW1lOiBcIkVzcGVyYW50b1wiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBFc3RvbmlhbiBsYW5ndWFnZVxuICAgKi9cbiAgRVNUT05JQU46IHtcbiAgICBjb2RlOiBcImV0XCIsXG4gICAgZmxhZzogXCJuYW1lOmV0XCIsXG4gICAgbmFtZTogXCJFc3RvbmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBGaW5uaXNoIGxhbmd1YWdlXG4gICAqL1xuICBGSU5OSVNIOiB7XG4gICAgY29kZTogXCJmaVwiLFxuICAgIGZsYWc6IFwibmFtZTpmaVwiLFxuICAgIG5hbWU6IFwiRmlubmlzaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBGcmVuY2ggbGFuZ3VhZ2VcbiAgICovXG4gIEZSRU5DSDoge1xuICAgIGNvZGU6IFwiZnJcIixcbiAgICBmbGFnOiBcIm5hbWU6ZnJcIixcbiAgICBuYW1lOiBcIkZyZW5jaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBGcmlzaWFuIGxhbmd1YWdlXG4gICAqL1xuICBGUklTSUFOOiB7XG4gICAgY29kZTogXCJmeVwiLFxuICAgIGZsYWc6IFwibmFtZTpmeVwiLFxuICAgIG5hbWU6IFwiRnJpc2lhbiAoV2VzdClcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogR2VvcmdpYW4gbGFuZ3VhZ2VcbiAgICovXG4gIEdFT1JHSUFOOiB7XG4gICAgY29kZTogXCJrYVwiLFxuICAgIGZsYWc6IFwibmFtZTprYVwiLFxuICAgIG5hbWU6IFwiR2VvcmdpYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEhlYnJldyBsYW5ndWFnZSAocmlnaHQtdG8tbGVmdCBub24tbGF0aW4gc2NyaXB0KVxuICAgKi9cbiAgSEVCUkVXOiB7XG4gICAgY29kZTogXCJoZVwiLFxuICAgIGZsYWc6IFwibmFtZTpoZVwiLFxuICAgIG5hbWU6IFwiSGVicmV3XCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBIaW5kaSBsYW5ndWFnZVxuICAgKi9cbiAgSElOREk6IHtcbiAgICBjb2RlOiBcImhpXCIsXG4gICAgZmxhZzogXCJuYW1lOmhpXCIsXG4gICAgbmFtZTogXCJIaW5kaVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSHVuZ2FyaWFuIGxhbmd1YWdlXG4gICAqL1xuICBIVU5HQVJJQU46IHtcbiAgICBjb2RlOiBcImh1XCIsXG4gICAgZmxhZzogXCJuYW1lOmh1XCIsXG4gICAgbmFtZTogXCJIdW5nYXJpYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSWNlbGFuZGljIGxhbmd1YWdlXG4gICAqL1xuICBJQ0VMQU5ESUM6IHtcbiAgICBjb2RlOiBcImlzXCIsXG4gICAgZmxhZzogXCJuYW1lOmlzXCIsXG4gICAgbmFtZTogXCJJY2VsYW5kaWNcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSW5kb25lc2lhbiBsYW5ndWFnZVxuICAgKi9cbiAgSU5ET05FU0lBTjoge1xuICAgIGNvZGU6IFwiaWRcIixcbiAgICBmbGFnOiBcIm5hbWU6aWRcIixcbiAgICBuYW1lOiBcIkluZG9uZXNpYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSXJpc2ggbGFuZ3VhZ2VcbiAgICovXG4gIElSSVNIOiB7XG4gICAgY29kZTogXCJnYVwiLFxuICAgIGZsYWc6IFwibmFtZTpnYVwiLFxuICAgIG5hbWU6IFwiSXJpc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSXRhbGlhbiBsYW5ndWFnZVxuICAgKi9cbiAgSVRBTElBTjoge1xuICAgIGNvZGU6IFwiaXRcIixcbiAgICBmbGFnOiBcIm5hbWU6aXRcIixcbiAgICBuYW1lOiBcIkl0YWxpYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogSmFwYW5lc2UgbGFuZ3VhZ2VcbiAgICovXG4gIEpBUEFORVNFOiB7XG4gICAgY29kZTogXCJqYVwiLFxuICAgIGZsYWc6IFwibmFtZTpqYVwiLFxuICAgIG5hbWU6IFwiSmFwYW5lc2VcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEphcGFuZXNlIGxhbmd1YWdlIGluIEhpcmFnYW5hIGZvcm1cbiAgICovXG4gIEpBUEFORVNFX0hJUkFHQU5BOiB7XG4gICAgY29kZTogXCJqYS1IaXJhXCIsXG4gICAgZmxhZzogXCJuYW1lOmphLUhpcmFcIixcbiAgICBuYW1lOiBcIkphcGFuZXNlIEhpcmFnYW5hIGZvcm1cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBKYXBhbmVzZSBsYW5ndWFnZSAobGF0aW4gc2NyaXB0KVxuICAgKi9cbiAgSkFQQU5FU0VfMjAxODoge1xuICAgIGNvZGU6IFwiamEtTGF0blwiLFxuICAgIGZsYWc6IFwibmFtZTpqYS1MYXRuXCIsXG4gICAgbmFtZTogXCJKYXBhbmVzZSAoTGF0aW4gMjAxOClcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIEphcGFuZXNlIGxhbmd1YWdlIGluIEthbmEgZm9ybSAobm9uLWxhdGluIHNjcmlwdClcbiAgICovXG4gIEpBUEFORVNFX0tBTkE6IHtcbiAgICBjb2RlOiBcImphX2thbmFcIixcbiAgICBmbGFnOiBcIm5hbWU6amFfa2FuYVwiLFxuICAgIG5hbWU6IFwiSmFwYW5lc2UgKEthbmEpXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogSmFwYW5zZSBsYW5ndWFnZSwgcm9tYW5pemVkIChsYXRpbiBzY3JpcHQpXG4gICAqL1xuICBKQVBBTkVTRV9MQVRJTjoge1xuICAgIGNvZGU6IFwiamFfcm1cIixcbiAgICBmbGFnOiBcIm5hbWU6amFfcm1cIixcbiAgICBuYW1lOiBcIkphcGFuZXNlIChMYXRpbiBzY3JpcHQpXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBLYW5uYWRhIGxhbmd1YWdlXG4gICAqL1xuICBLQU5OQURBOiB7XG4gICAgY29kZTogXCJrblwiLFxuICAgIGZsYWc6IFwibmFtZTprblwiLFxuICAgIG5hbWU6IFwiS2FubmFkYVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBLYXpha2ggbGFuZ3VhZ2VcbiAgICovXG4gIEtBWkFLSDoge1xuICAgIGNvZGU6IFwia2tcIixcbiAgICBmbGFnOiBcIm5hbWU6a2tcIixcbiAgICBuYW1lOiBcIkthemFraFwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogS29yZWFuIGxhbmd1YWdlXG4gICAqL1xuICBLT1JFQU46IHtcbiAgICBjb2RlOiBcImtvXCIsXG4gICAgZmxhZzogXCJuYW1lOmtvXCIsXG4gICAgbmFtZTogXCJLb3JlYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIEtvcmVhbiBsYW5ndWFnZSAobGF0aW4gc2NyaXB0KVxuICAgKi9cbiAgS09SRUFOX0xBVElOOiB7XG4gICAgY29kZTogXCJrby1MYXRuXCIsXG4gICAgZmxhZzogXCJuYW1lOmtvLUxhdG5cIixcbiAgICBuYW1lOiBcIktvcmVhbiAoTGF0aW4gc2NyaXB0KVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogS3VyZGlzaCBsYW5ndWFnZVxuICAgKi9cbiAgS1VSRElTSDoge1xuICAgIGNvZGU6IFwia3VcIixcbiAgICBmbGFnOiBcIm5hbWU6a3VcIixcbiAgICBuYW1lOiBcIkt1cmRpc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogQ2xhc3NpY2FsIExhdGluIGxhbmd1YWdlXG4gICAqL1xuICBDTEFTU0lDQUxfTEFUSU46IHtcbiAgICBjb2RlOiBcImxhXCIsXG4gICAgZmxhZzogXCJuYW1lOmxhXCIsXG4gICAgbmFtZTogXCJMYXRpblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBMYXR2aWFuIGxhbmd1YWdlXG4gICAqL1xuICBMQVRWSUFOOiB7XG4gICAgY29kZTogXCJsdlwiLFxuICAgIGZsYWc6IFwibmFtZTpsdlwiLFxuICAgIG5hbWU6IFwiTGF0dmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBMaXRodWFuaWFuIGxhbmd1YWdlXG4gICAqL1xuICBMSVRIVUFOSUFOOiB7XG4gICAgY29kZTogXCJsdFwiLFxuICAgIGZsYWc6IFwibmFtZTpsdFwiLFxuICAgIG5hbWU6IFwiTGl0aHVhbmlhblwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBMdXhlbWJvdXJnaXNoIGxhbmd1YWdlXG4gICAqL1xuICBMVVhFTUJPVVJHSVNIOiB7XG4gICAgY29kZTogXCJsYlwiLFxuICAgIGZsYWc6IFwibmFtZTpsYlwiLFxuICAgIG5hbWU6IFwiTHV4ZW1ib3VyZ2lzaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBNYWNlZG9uaWFuIGxhbmd1YWdlXG4gICAqL1xuICBNQUNFRE9OSUFOOiB7XG4gICAgY29kZTogXCJta1wiLFxuICAgIGZsYWc6IFwibmFtZTpta1wiLFxuICAgIG5hbWU6IFwiTWFjZWRvbmlhblwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogTWFsYXlhbG0gbGFuZ3VhZ2VcbiAgICovXG4gIE1BTEFZQUxBTToge1xuICAgIGNvZGU6IFwibWxcIixcbiAgICBmbGFnOiBcIm5hbWU6bWxcIixcbiAgICBuYW1lOiBcIk1hbGF5YWxhbVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogTWFsdGVzZSBsYW5ndWFnZVxuICAgKi9cbiAgTUFMVEVTRToge1xuICAgIGNvZGU6IFwibXRcIixcbiAgICBmbGFnOiBcIm5hbWU6bXRcIixcbiAgICBuYW1lOiBcIk1hbHRlc2VcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogTm9yd2VnaWFuIGxhbmd1YWdlXG4gICAqL1xuICBOT1JXRUdJQU46IHtcbiAgICBjb2RlOiBcIm5vXCIsXG4gICAgZmxhZzogXCJuYW1lOm5vXCIsXG4gICAgbmFtZTogXCJOb3J3ZWdpYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogT2NjaXRhbiBsYW5ndWFnZVxuICAgKi9cbiAgT0NDSVRBTjoge1xuICAgIGNvZGU6IFwib2NcIixcbiAgICBmbGFnOiBcIm5hbWU6b2NcIixcbiAgICBuYW1lOiBcIk9jY2l0YW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogUGVyc2lhbiBsYW5ndWFnZVxuICAgKi9cbiAgUEVSU0lBTjoge1xuICAgIGNvZGU6IFwiZmFcIixcbiAgICBmbGFnOiBcIm5hbWU6ZmFcIixcbiAgICBuYW1lOiBcIlBlcnNpYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFBvbGlzaCBsYW5ndWFnZVxuICAgKi9cbiAgUE9MSVNIOiB7XG4gICAgY29kZTogXCJwbFwiLFxuICAgIGZsYWc6IFwibmFtZTpwbFwiLFxuICAgIG5hbWU6IFwiUG9saXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFBvcnR1Z3Vlc2UgbGFuZ3VhZ2VcbiAgICovXG4gIFBPUlRVR1VFU0U6IHtcbiAgICBjb2RlOiBcInB0XCIsXG4gICAgZmxhZzogXCJuYW1lOnB0XCIsXG4gICAgbmFtZTogXCJQb3J0dWd1ZXNlXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFB1bmphYmkgbGFuZ3VhZ2VcbiAgICovXG4gIFBVTkpBQkk6IHtcbiAgICBjb2RlOiBcInBhXCIsXG4gICAgZmxhZzogXCJuYW1lOnBhXCIsXG4gICAgbmFtZTogXCJQdW5qYWJpXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBXZXN0ZXJuIFB1bmphYmkgbGFuZ3VhZ2VcbiAgICovXG4gIFdFU1RFUk5fUFVOSkFCSToge1xuICAgIGNvZGU6IFwicG5iXCIsXG4gICAgZmxhZzogXCJuYW1lOnBuYlwiLFxuICAgIG5hbWU6IFwiV2VzdGVybiBQdW5qYWJpXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiBmYWxzZVxuICB9LFxuICAvKipcbiAgICogUm9tYW5pYW4gbGFuZ3VhZ2VcbiAgICovXG4gIFJPTUFOSUFOOiB7XG4gICAgY29kZTogXCJyb1wiLFxuICAgIGZsYWc6IFwibmFtZTpyb1wiLFxuICAgIG5hbWU6IFwiUm9tYW5pYW5cIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogUm9tYW5zaCBsYW5ndWFnZVxuICAgKi9cbiAgUk9NQU5TSDoge1xuICAgIGNvZGU6IFwicm1cIixcbiAgICBmbGFnOiBcIm5hbWU6cm1cIixcbiAgICBuYW1lOiBcIlJvbWFuc2hcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogUnVzc2lhbiBsYW5ndWFnZVxuICAgKi9cbiAgUlVTU0lBTjoge1xuICAgIGNvZGU6IFwicnVcIixcbiAgICBmbGFnOiBcIm5hbWU6cnVcIixcbiAgICBuYW1lOiBcIlJ1c3NpYW5cIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFNlcmJpYW4gbGFuZ3VhZ2UgKGN5cmlsbGljIHNjcmlwdClcbiAgICovXG4gIFNFUkJJQU5fQ1lSSUxMSUM6IHtcbiAgICBjb2RlOiBcInNyXCIsXG4gICAgZmxhZzogXCJuYW1lOnNyXCIsXG4gICAgbmFtZTogXCJTZXJiaWFuIChDeXJpbGxpYyBzY3JpcHQpXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBTZXJiaWFuIGxhbmd1YWdlIChsYXRpbiBzY3JpcHQpXG4gICAqL1xuICBTRVJCSUFOX0xBVElOOiB7XG4gICAgY29kZTogXCJzci1MYXRuXCIsXG4gICAgZmxhZzogXCJuYW1lOnNyLUxhdG5cIixcbiAgICBuYW1lOiBcIlNlcmJpYW4gKExhdGluIHNjcmlwdClcIixcbiAgICBsYXRpbjogdHJ1ZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogZmFsc2VcbiAgfSxcbiAgLyoqXG4gICAqIFNjb3R0aXNoIEdhZWxpYyBsYW5ndWFnZVxuICAgKi9cbiAgU0NPVFRJU0hfR0FFTElDOiB7XG4gICAgY29kZTogXCJnZFwiLFxuICAgIGZsYWc6IFwibmFtZTpnZFwiLFxuICAgIG5hbWU6IFwiU2NvdHRpc2ggR2FlbGljXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFNsb3ZhayBsYW5ndWFnZVxuICAgKi9cbiAgU0xPVkFLOiB7XG4gICAgY29kZTogXCJza1wiLFxuICAgIGZsYWc6IFwibmFtZTpza1wiLFxuICAgIG5hbWU6IFwiU2xvdmFrXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFNsb3ZlbmUgbGFuZ3VhZ2VcbiAgICovXG4gIFNMT1ZFTkU6IHtcbiAgICBjb2RlOiBcInNsXCIsXG4gICAgZmxhZzogXCJuYW1lOnNsXCIsXG4gICAgbmFtZTogXCJTbG92ZW5lXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFNwYW5pc2ggbGFuZ3VhZ2VcbiAgICovXG4gIFNQQU5JU0g6IHtcbiAgICBjb2RlOiBcImVzXCIsXG4gICAgZmxhZzogXCJuYW1lOmVzXCIsXG4gICAgbmFtZTogXCJTcGFuaXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFN3ZWRpc2ggbGFuZ3VhZ2VcbiAgICovXG4gIFNXRURJU0g6IHtcbiAgICBjb2RlOiBcInN2XCIsXG4gICAgZmxhZzogXCJuYW1lOnN2XCIsXG4gICAgbmFtZTogXCJTd2VkaXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFRhbWlsIGxhbmd1YWdlXG4gICAqL1xuICBUQU1JTDoge1xuICAgIGNvZGU6IFwidGFcIixcbiAgICBmbGFnOiBcIm5hbWU6dGFcIixcbiAgICBuYW1lOiBcIlRhbWlsXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBUZWx1Z3UgbGFuZ3VhZ2VcbiAgICovXG4gIFRFTFVHVToge1xuICAgIGNvZGU6IFwidGVcIixcbiAgICBmbGFnOiBcIm5hbWU6dGVcIixcbiAgICBuYW1lOiBcIlRlbHVndVwiLFxuICAgIGxhdGluOiBmYWxzZSxcbiAgICBpc01vZGU6IGZhbHNlLFxuICAgIGdlb2NvZGluZzogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVGhhaSBsYW5ndWFnZVxuICAgKi9cbiAgVEhBSToge1xuICAgIGNvZGU6IFwidGhcIixcbiAgICBmbGFnOiBcIm5hbWU6dGhcIixcbiAgICBuYW1lOiBcIlRoYWlcIixcbiAgICBsYXRpbjogZmFsc2UsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFR1cmtpc2ggbGFuZ3VhZ2VcbiAgICovXG4gIFRVUktJU0g6IHtcbiAgICBjb2RlOiBcInRyXCIsXG4gICAgZmxhZzogXCJuYW1lOnRyXCIsXG4gICAgbmFtZTogXCJUdXJraXNoXCIsXG4gICAgbGF0aW46IHRydWUsXG4gICAgaXNNb2RlOiBmYWxzZSxcbiAgICBnZW9jb2Rpbmc6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFVrcmFpbmlhbiBsYW5ndWFnZVxuICAgKi9cbiAgVUtSQUlOSUFOOiB7XG4gICAgY29kZTogXCJ1a1wiLFxuICAgIGZsYWc6IFwibmFtZTp1a1wiLFxuICAgIG5hbWU6IFwiVWtyYWluaWFuXCIsXG4gICAgbGF0aW46IGZhbHNlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBWaWV0bmFtZXNlIGxhbmd1YWdlIChsYXRpbiBzY3JpcHQpXG4gICAqL1xuICBWSUVUTkFNRVNFOiB7XG4gICAgY29kZTogXCJ2aVwiLFxuICAgIGZsYWc6IFwibmFtZTp2aVwiLFxuICAgIG5hbWU6IFwiVmlldG5hbWVzZSAoTGF0aW4gc2NyaXB0KVwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBXZWxzaCBsYW5ndWFnZVxuICAgKi9cbiAgV0VMU0g6IHtcbiAgICBjb2RlOiBcImN5XCIsXG4gICAgZmxhZzogXCJuYW1lOmN5XCIsXG4gICAgbmFtZTogXCJXZWxzaFwiLFxuICAgIGxhdGluOiB0cnVlLFxuICAgIGlzTW9kZTogZmFsc2UsXG4gICAgZ2VvY29kaW5nOiB0cnVlXG4gIH1cbn07XG5jb25zdCBMYW5ndWFnZSA9IHtcbiAgLi4uTm9uSVNPTGFuZ3VhZ2UsXG4gIC4uLklTT0xhbmd1YWdlXG59O1xuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VJbmZvRnJvbUtleShsYW5ndWFnZUtleSwgbGFuZ3VhZ2VEaWN0aW9uYXJ5ID0gTGFuZ3VhZ2UpIHtcbiAgaWYgKGxhbmd1YWdlS2V5IGluIGxhbmd1YWdlRGljdGlvbmFyeSkge1xuICAgIHJldHVybiBsYW5ndWFnZUtleVtsYW5ndWFnZUtleV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRMYW5ndWFnZUluZm9Gcm9tQ29kZShsYW5ndWFnZUNvZGUsIGxhbmd1YWdlRGljdGlvbmFyeSA9IExhbmd1YWdlKSB7XG4gIGZvciAoY29uc3QgbGFuZyBvZiBPYmplY3QudmFsdWVzKGxhbmd1YWdlRGljdGlvbmFyeSkpIHtcbiAgICBpZiAobGFuZy5jb2RlID09PSBsYW5ndWFnZUNvZGUpIHtcbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExhbmd1YWdlSW5mb0Zyb21GbGFnKGxhbmd1YWdlRmxhZywgbGFuZ3VhZ2VEaWN0aW9uYXJ5ID0gTGFuZ3VhZ2UpIHtcbiAgZm9yIChjb25zdCBsYW5nIG9mIE9iamVjdC52YWx1ZXMobGFuZ3VhZ2VEaWN0aW9uYXJ5KSkge1xuICAgIGlmIChsYW5nLmZsYWcgPT09IGxhbmd1YWdlRmxhZykge1xuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0QXV0b0xhbmd1YWdlKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IGNvZGUgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnNwbGl0KFwiLVwiKVswXTtcbiAgICBjb25zdCBsYW5nSW5mbyA9IGdldExhbmd1YWdlSW5mb0Zyb21Db2RlKGNvZGUpO1xuICAgIHJldHVybiBsYW5nSW5mbyA/PyBMYW5ndWFnZS5FTkdMSVNIO1xuICB9XG4gIGNvbnN0IGNhbmRpdGF0ZWxhbmdzID0gQXJyYXkuZnJvbShcbiAgICBuZXcgU2V0KG5hdmlnYXRvci5sYW5ndWFnZXMubWFwKChsKSA9PiBsLnNwbGl0KFwiLVwiKVswXSkpXG4gICkubWFwKChjb2RlKSA9PiBnZXRMYW5ndWFnZUluZm9Gcm9tQ29kZShjb2RlKSkuZmlsdGVyKChsaSkgPT4gbGkpO1xuICByZXR1cm4gY2FuZGl0YXRlbGFuZ3NbMF0gPz8gTGFuZ3VhZ2UuRU5HTElTSDtcbn1cbmZ1bmN0aW9uIGlzTGFuZ3VhZ2VJbmZvKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgXCJjb2RlXCIgaW4gb2JqICYmIFwiZmxhZ1wiIGluIG9iaiAmJiBcIm5hbWVcIiBpbiBvYmogJiYgXCJsYXRpblwiIGluIG9iaiAmJiBcImlzTW9kZVwiIGluIG9iaiAmJiBcImdlb2NvZGluZ1wiIGluIG9iaiAmJiAodHlwZW9mIG9iai5jb2RlID09PSBcInN0cmluZ1wiIHx8IG9iai5jb2RlID09PSBudWxsKSAmJiB0eXBlb2Ygb2JqLmZsYWcgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iai5uYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmoubGF0aW4gPT09IFwiYm9vbGVhblwiICYmIHR5cGVvZiBvYmouaXNNb2RlID09PSBcImJvb2xlYW5cIiAmJiB0eXBlb2Ygb2JqLmdlb2NvZGluZyA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiB0b0xhbmd1YWdlSW5mbyhsYW5nLCBsYW5ndWFnZURpY3Rpb25hcnkgPSBMYW5ndWFnZSkge1xuICBpZiAoaXNMYW5ndWFnZUluZm8obGFuZykpIHtcbiAgICByZXR1cm4gZ2V0TGFuZ3VhZ2VJbmZvRnJvbUZsYWcobGFuZy5mbGFnLCBsYW5ndWFnZURpY3Rpb25hcnkpO1xuICB9XG4gIGlmICh0eXBlb2YgbGFuZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRMYW5ndWFnZUluZm9Gcm9tS2V5KGxhbmcsIGxhbmd1YWdlRGljdGlvbmFyeSkgfHwgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUNvZGUobGFuZywgbGFuZ3VhZ2VEaWN0aW9uYXJ5KSB8fCBnZXRMYW5ndWFnZUluZm9Gcm9tRmxhZyhsYW5nLCBsYW5ndWFnZURpY3Rpb25hcnkpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBhcmVTYW1lTGFuZ3VhZ2VzKGxhbmdBLCBsYW5nQiwgbGFuZ3VhZ2VEaWN0aW9uYXJ5ID0gTGFuZ3VhZ2UpIHtcbiAgY29uc3QgbGFuZ0FPYmogPSB0b0xhbmd1YWdlSW5mbyhsYW5nQSwgbGFuZ3VhZ2VEaWN0aW9uYXJ5KTtcbiAgY29uc3QgbGFuZ0JPYmogPSB0b0xhbmd1YWdlSW5mbyhsYW5nQiwgbGFuZ3VhZ2VEaWN0aW9uYXJ5KTtcbiAgcmV0dXJuIGxhbmdBT2JqICYmIGxhbmdCT2JqICYmIGxhbmdBT2JqLmZsYWcgPT09IGxhbmdCT2JqLmZsYWc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxGZXRjaChyZXNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChjb25maWcuZmV0Y2ggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBmZXRjaCBmdW5jdGlvbiB3YXMgbm90IGZvdW5kLiBJZiBvbiBOb2RlSlMgPCAxOCBwbGVhc2Ugc3BlY2lmeSB0aGUgZmV0Y2ggZnVuY3Rpb24gd2l0aCBjb25maWcuZmV0Y2hcIlxuICAgICk7XG4gIH1cbiAgaWYgKG5ldyBVUkwocmVzb3VyY2UpLnNlYXJjaFBhcmFtcy5nZXQoXCJrZXlcIikudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgTWFwVGlsZXIgQ2xvdWQgQVBJIGtleSBpcyBtaXNzaW5nLiBTZXQgaXQgaW4gYGNvbmZpZy5hcGlLZXlgIG9yIGdldCBvbmUgZm9yIGZyZWUgYXQgaHR0cHM6Ly9tYXB0aWxlci5jb21cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5mZXRjaChyZXNvdXJjZSwgb3B0aW9ucyk7XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBtYXB0aWxlckFwaVVSTDogXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vXCIsXG4gIG1hcFN0eWxlOiBcInN0cmVldHMtdjJcIlxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdHMpO1xuXG5jbGFzcyBTZXJ2aWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcywgY3VzdG9tTWVzc2FnZSA9IFwiXCIpIHtcbiAgICBzdXBlcihcbiAgICAgIGBDYWxsIHRvIGVucG9pbnQgJHtyZXMudXJsfSBmYWlsZWQgd2l0aCB0aGUgc3RhdHVzIGNvZGUgJHtyZXMuc3RhdHVzfS4gJHtjdXN0b21NZXNzYWdlfWBcbiAgICApO1xuICAgIHRoaXMucmVzID0gcmVzO1xuICB9XG59XG5cbmNvbnN0IGN1c3RvbU1lc3NhZ2VzJDQgPSB7XG4gIDQwMDogXCJRdWVyeSB0b28gbG9uZyAvIEludmFsaWQgcGFyYW1ldGVyc1wiLFxuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VHZW9jb2RpbmdPcHRpb25zKHNlYXJjaFBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCB7IGxhbmd1YWdlIH0gPSBvcHRpb25zO1xuICBpZiAobGFuZ3VhZ2UgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsYW5ndWFnZUNvZGVzID0gKEFycmF5LmlzQXJyYXkobGFuZ3VhZ2UpID8gbGFuZ3VhZ2UgOiBbbGFuZ3VhZ2VdKS5tYXAoKGVsZW0pID0+IHRvVmFsaWRHZW9jb2RpbmdMYW5ndWFnZUNvZGUoZWxlbSkpLmZpbHRlcigoZWxlbSkgPT4gZWxlbSk7XG4gIGNvbnN0IGxhbmd1YWdlcyA9IEFycmF5LmZyb20obmV3IFNldChsYW5ndWFnZUNvZGVzKSkuam9pbihcIixcIik7XG4gIHNlYXJjaFBhcmFtcy5zZXQoXCJsYW5ndWFnZVwiLCBsYW5ndWFnZXMpO1xufVxuZnVuY3Rpb24gdG9WYWxpZEdlb2NvZGluZ0xhbmd1YWdlQ29kZShsYW5nKSB7XG4gIGNvbnN0IGxhbmdJbmZvID0gbGFuZyA9PT0gTGFuZ3VhZ2UuQVVUTy5mbGFnID8gZ2V0QXV0b0xhbmd1YWdlKCkgOiB0eXBlb2YgbGFuZyA9PT0gXCJzdHJpbmdcIiA/IGdldExhbmd1YWdlSW5mb0Zyb21Db2RlKGxhbmcpIDogaXNMYW5ndWFnZUluZm8obGFuZykgPyBsYW5nLmZsYWcgPT09IExhbmd1YWdlLkFVVE8uZmxhZyA/IGdldEF1dG9MYW5ndWFnZSgpIDogZ2V0TGFuZ3VhZ2VJbmZvRnJvbUZsYWcobGFuZy5mbGFnKSA6IG51bGw7XG4gIHJldHVybiBsYW5nSW5mbz8uZ2VvY29kaW5nID8gbGFuZ0luZm8uY29kZSA6IG51bGw7XG59XG5mdW5jdGlvbiBhZGRDb21tb25Gb3J3YXJkQW5kUmV2ZXJzZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYXBpS2V5LCBsaW1pdCwgdHlwZXMsIGV4Y2x1ZGVUeXBlcyB9ID0gb3B0aW9ucztcbiAgc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBhcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGlmIChsaW1pdCAhPT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICB9XG4gIGlmICh0eXBlcyAhPT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcInR5cGVzXCIsIHR5cGVzLmpvaW4oXCIsXCIpKTtcbiAgfVxuICBpZiAoZXhjbHVkZVR5cGVzICE9PSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZXhjbHVkZVR5cGVzXCIsIFN0cmluZyhleGNsdWRlVHlwZXMpKTtcbiAgfVxuICBhZGRMYW5ndWFnZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGFkZEZvcndhcmRHZW9jb2RpbmdPcHRpb25zKHNlYXJjaFBhcmFtcywgb3B0aW9ucykge1xuICBhZGRDb21tb25Gb3J3YXJkQW5kUmV2ZXJzZUdlb2NvZGluZ09wdGlvbnMoc2VhcmNoUGFyYW1zLCBvcHRpb25zKTtcbiAgY29uc3QgeyBiYm94LCBwcm94aW1pdHksIGNvdW50cnksIGZ1enp5TWF0Y2gsIGF1dG9jb21wbGV0ZSB9ID0gb3B0aW9ucztcbiAgaWYgKGJib3ggIT09IHZvaWQgMCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJiYm94XCIsIGJib3guam9pbihcIixcIikpO1xuICB9XG4gIGlmIChwcm94aW1pdHkgIT09IHZvaWQgMCkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXG4gICAgICBcInByb3hpbWl0eVwiLFxuICAgICAgcHJveGltaXR5ID09PSBcImlwXCIgPyBwcm94aW1pdHkgOiBwcm94aW1pdHkuam9pbihcIixcIilcbiAgICApO1xuICB9XG4gIGlmIChjb3VudHJ5ICE9PSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiY291bnRyeVwiLCBjb3VudHJ5LmpvaW4oXCIsXCIpKTtcbiAgfVxuICBpZiAoZnV6enlNYXRjaCAhPT0gdm9pZCAwKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImZ1enp5TWF0Y2hcIiwgZnV6enlNYXRjaCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcbiAgfVxuICBpZiAoYXV0b2NvbXBsZXRlICE9PSB2b2lkIDApIHtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiYXV0b2NvbXBsZXRlXCIsIGF1dG9jb21wbGV0ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZm9yd2FyZChxdWVyeSwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgcXVlcnkgIT09IFwic3RyaW5nXCIgfHwgcXVlcnkudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBxdWVyeSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYGdlb2NvZGluZy8ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9Lmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGFkZEZvcndhcmRHZW9jb2RpbmdPcHRpb25zKGVuZHBvaW50LnNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxGZXRjaChlbmRwb2ludC50b1N0cmluZygpKTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKHJlcywgY3VzdG9tTWVzc2FnZXMkNFtyZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJldmVyc2UocG9zaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocG9zaXRpb24pIHx8IHBvc2l0aW9uLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcG9zaXRpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBmb3JtIFtsbmcsIGxhdF0uXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgZ2VvY29kaW5nLyR7cG9zaXRpb25bMF19LCR7cG9zaXRpb25bMV19Lmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGFkZENvbW1vbkZvcndhcmRBbmRSZXZlcnNlR2VvY29kaW5nT3B0aW9ucyhlbmRwb2ludC5zZWFyY2hQYXJhbXMsIG9wdGlvbnMpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2goZW5kcG9pbnQudG9TdHJpbmcoKSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihyZXMsIGN1c3RvbU1lc3NhZ2VzJDRbcmVzLnN0YXR1c10gPz8gXCJcIik7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG59XG5hc3luYyBmdW5jdGlvbiBieUlkKGlkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKGBnZW9jb2RpbmcvJHtpZH0uanNvbmAsIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMKTtcbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgYWRkTGFuZ3VhZ2VHZW9jb2RpbmdPcHRpb25zKGVuZHBvaW50LnNlYXJjaFBhcmFtcywgb3B0aW9ucyk7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxGZXRjaChlbmRwb2ludC50b1N0cmluZygpKTtcbiAgaWYgKCFyZXMub2spIHtcbiAgICB0aHJvdyBuZXcgU2VydmljZUVycm9yKHJlcywgY3VzdG9tTWVzc2FnZXMkNFtyZXMuc3RhdHVzXSA/PyBcIlwiKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJhdGNoJDEocXVlcmllcywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgam9pbmVkUXVlcnkgPSBxdWVyaWVzLm1hcCgocXVlcnkpID0+IGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSkpLmpvaW4oXCI7XCIpO1xuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYGdlb2NvZGluZy8ke2pvaW5lZFF1ZXJ5fS5qc29uYCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBhZGRGb3J3YXJkR2VvY29kaW5nT3B0aW9ucyhlbmRwb2ludC5zZWFyY2hQYXJhbXMsIG9wdGlvbnMpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2goZW5kcG9pbnQudG9TdHJpbmcoKSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihyZXMsIGN1c3RvbU1lc3NhZ2VzJDRbcmVzLnN0YXR1c10gPz8gXCJcIik7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIHF1ZXJpZXMubGVuZ3RoID09PSAxID8gW29ial0gOiBvYmo7XG59XG5jb25zdCBnZW9jb2RpbmcgPSB7XG4gIGZvcndhcmQsXG4gIHJldmVyc2UsXG4gIGJ5SWQsXG4gIGJhdGNoOiBiYXRjaCQxXG59O1xuXG5jb25zdCBjdXN0b21NZXNzYWdlcyQzID0ge1xuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gaW5mbyhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKGBnZW9sb2NhdGlvbi9pcC5qc29uYCwgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkwpO1xuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICBpZiAoXCJlbGV2YXRpb25cIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgIFwiZWxldmF0aW9uXCIsXG4gICAgICBvcHRpb25zLmVsZXZhdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCB1cmxXaXRoUGFyYW1zID0gZW5kcG9pbnQudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKHVybFdpdGhQYXJhbXMpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IoXG4gICAgICByZXMsXG4gICAgICByZXMuc3RhdHVzIGluIGN1c3RvbU1lc3NhZ2VzJDMgPyBjdXN0b21NZXNzYWdlcyQzW3Jlcy5zdGF0dXNdIDogXCJcIlxuICAgICk7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IGdlb2xvY2F0aW9uID0ge1xuICBpbmZvXG59O1xuXG5jb25zdCBjdXN0b21NZXNzYWdlcyQyID0ge1xuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gc2VhcmNoKHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gXCJzdHJpbmdcIiB8fCBxdWVyeS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHF1ZXJ5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgY29vcmRpbmF0ZXMvc2VhcmNoLyR7cXVlcnl9Lmpzb25gLFxuICAgIGRlZmF1bHRzLm1hcHRpbGVyQXBpVVJMXG4gICk7XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIGlmIChcImxpbWl0XCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJsaW1pdFwiLCBvcHRpb25zLmxpbWl0LnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcInRyYW5zZm9ybWF0aW9uc1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgXCJ0cmFuc2Zvcm1hdGlvbnNcIixcbiAgICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb25zLnRvU3RyaW5nKClcbiAgICApO1xuICB9XG4gIGlmIChcImV4cG9ydHNcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImV4cG9ydHNcIiwgb3B0aW9ucy5leHBvcnRzLnRvU3RyaW5nKCkpO1xuICB9XG4gIGNvbnN0IHVybFdpdGhQYXJhbXMgPSBlbmRwb2ludC50b1N0cmluZygpO1xuICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihcbiAgICAgIHJlcyxcbiAgICAgIHJlcy5zdGF0dXMgaW4gY3VzdG9tTWVzc2FnZXMkMiA/IGN1c3RvbU1lc3NhZ2VzJDJbcmVzLnN0YXR1c10gOiBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCByZXMuanNvbigpO1xuICByZXR1cm4gb2JqO1xufVxuYXN5bmMgZnVuY3Rpb24gdHJhbnNmb3JtKHBvc2l0aW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzU3RyID0gKEFycmF5LmlzQXJyYXkocG9zaXRpb25zWzBdKSA/IHBvc2l0aW9ucyA6IFtwb3NpdGlvbnNdKS5tYXAoKGNvb3JkKSA9PiBgJHtjb29yZFswXX0sJHtjb29yZFsxXX1gKS5qb2luKFwiO1wiKTtcbiAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgIGBjb29yZGluYXRlcy90cmFuc2Zvcm0vJHtjb29yZGluYXRlc1N0cn0uanNvbmAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImtleVwiLCBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5KTtcbiAgaWYgKFwic291cmNlQ3JzXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJzX3Nyc1wiLCBvcHRpb25zLnNvdXJjZUNycy50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoXCJ0YXJnZXRDcnNcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcInRfc3JzXCIsIG9wdGlvbnMudGFyZ2V0Q3JzLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChcIm9wZXJhdGlvbnNcIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgIFwib3BzXCIsXG4gICAgICAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9wZXJhdGlvbnMpID8gb3B0aW9ucy5vcGVyYXRpb25zIDogW29wdGlvbnMub3BlcmF0aW9uc10pLmpvaW4oXCJ8XCIpXG4gICAgKTtcbiAgfVxuICBjb25zdCB1cmxXaXRoUGFyYW1zID0gZW5kcG9pbnQudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKHVybFdpdGhQYXJhbXMpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IoXG4gICAgICByZXMsXG4gICAgICByZXMuc3RhdHVzIGluIGN1c3RvbU1lc3NhZ2VzJDIgPyBjdXN0b21NZXNzYWdlcyQyW3Jlcy5zdGF0dXNdIDogXCJcIlxuICAgICk7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IGNvb3JkaW5hdGVzID0ge1xuICBzZWFyY2gsXG4gIHRyYW5zZm9ybVxufTtcblxuY29uc3QgY3VzdG9tTWVzc2FnZXMkMSA9IHtcbiAgNDAzOiBcIktleSBpcyBtaXNzaW5nLCBpbnZhbGlkIG9yIHJlc3RyaWN0ZWRcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldChkYXRhSWQsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIGRhdGFJZCAhPT0gXCJzdHJpbmdcIiB8fCBkYXRhSWQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIElEIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgZGF0YS8ke2VuY29kZVVSSUNvbXBvbmVudChkYXRhSWQpfS9mZWF0dXJlcy5qc29uYCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICBjb25zdCB1cmxXaXRoUGFyYW1zID0gZW5kcG9pbnQudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgY2FsbEZldGNoKHVybFdpdGhQYXJhbXMpO1xuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IoXG4gICAgICByZXMsXG4gICAgICByZXMuc3RhdHVzIGluIGN1c3RvbU1lc3NhZ2VzJDEgPyBjdXN0b21NZXNzYWdlcyQxW3Jlcy5zdGF0dXNdIDogXCJcIlxuICAgICk7XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IGRhdGEgPSB7XG4gIGdldFxufTtcblxuZnVuY3Rpb24gZXhwYW5kTWFwU3R5bGUoc3R5bGUpIHtcbiAgY29uc3QgbWFwdGlsZXJEb21haW5SZWdleCA9IC9ebWFwdGlsZXI6XFwvXFwvKC4qKS87XG4gIGxldCBtYXRjaDtcbiAgY29uc3QgdHJpbW1lZCA9IHN0eWxlLnRyaW0oKTtcbiAgbGV0IGV4cGFuZGVkU3R5bGU7XG4gIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHRyaW1tZWQuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgZXhwYW5kZWRTdHlsZSA9IHRyaW1tZWQ7XG4gIH0gZWxzZSBpZiAoKG1hdGNoID0gbWFwdGlsZXJEb21haW5SZWdleC5leGVjKHRyaW1tZWQpKSAhPT0gbnVsbCkge1xuICAgIGV4cGFuZGVkU3R5bGUgPSBgaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL21hcHMvJHttYXRjaFsxXX0vc3R5bGUuanNvbmA7XG4gIH0gZWxzZSB7XG4gICAgZXhwYW5kZWRTdHlsZSA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vbWFwcy8ke3RyaW1tZWR9L3N0eWxlLmpzb25gO1xuICB9XG4gIHJldHVybiBleHBhbmRlZFN0eWxlO1xufVxuY2xhc3MgTWFwU3R5bGVWYXJpYW50IHtcbiAgY29uc3RydWN0b3IobmFtZSwgdmFyaWFudFR5cGUsIGlkLCByZWZlcmVuY2VTdHlsZSwgZGVzY3JpcHRpb24sIGltYWdlVVJMLCBkZXByZWNhdGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmFyaWFudFR5cGUgPSB2YXJpYW50VHlwZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5yZWZlcmVuY2VTdHlsZSA9IHJlZmVyZW5jZVN0eWxlO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB0aGlzLmltYWdlVVJMID0gaW1hZ2VVUkw7XG4gICAgdGhpcy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbi1mcmllbmRseSBuYW1lXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMucmVmZXJlbmNlU3R5bGUuZ2V0TmFtZSgpfSAke3RoaXMubmFtZX1gO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhcmlhbnQgdHlwZSAoZWcuIFwiREVGQVVMVFwiLCBcIkRBUktcIiwgXCJQQVNURUxcIiwgZXRjLilcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFudFR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgTWFwVGlsZXIgQ2xvdWQgaWRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuLWZyaWVuZGx5IGRlc2NyaXB0aW9uXG4gICAqL1xuICBnZXREZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSByZWZlcmVuY2Ugc3R5bGUgdGhpcyB2YXJpYW50IGJlbG9uZ3MgdG9cbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFJlZmVyZW5jZVN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZVN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHZhcmlhbnQgb2YgYSBnaXZlbiB0eXBlIGV4aXN0cyBmb3IgX3RoaXNfIHZhcmlhbnRzXG4gICAqIChlZy4gaWYgdGhpcyBpcyBhIFwiREFSS1wiLCB0aGVuIHdlIGNhbiBjaGVjayBpZiB0aGVyZSBpcyBhIFwiTElHSFRcIiB2YXJpYW50IG9mIGl0KVxuICAgKiBAcGFyYW0gdmFyaWFudFR5cGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1ZhcmlhbnQodmFyaWFudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VTdHlsZS5oYXNWYXJpYW50KHZhcmlhbnRUeXBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHZhcmlhbnQgb2YgYSBnaXZlbiB0eXBlLiBJZiBub3QgZm91bmQsIHdpbGwgcmV0dXJuIHRoZSBcIkRFRkFVTFRcIiB2YXJpYW50LlxuICAgKiAoZWcuIF90aGlzXyBcIkRBUktcIiB2YXJpYW50IGRvZXMgbm90IGhhdmUgYW55IFwiUEFTVEVMXCIgdmFyaWFudCwgdGhlbiB0aGUgXCJERUZBVUxUXCIgaXMgcmV0dXJuZWQpXG4gICAqIEBwYXJhbSB2YXJpYW50VHlwZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmFyaWFudCh2YXJpYW50VHlwZSkge1xuICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLnJlZmVyZW5jZVN0eWxlLmdldFZhcmlhbnQodmFyaWFudFR5cGUpO1xuICAgIHRoaXMud2FybklmRGVwcmVjYXRlZCh2YXJpYW50KTtcbiAgICByZXR1cm4gdmFyaWFudDtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgdmFyaWFudHMgZm9yIF90aGlzXyB2YXJpYW50cywgZXhjZXB0IF90aGlzXyBjdXJyZW50IG9uZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VmFyaWFudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlU3R5bGUuZ2V0VmFyaWFudHMoKS5maWx0ZXIoKHYpID0+IHYgIT09IHRoaXMpLm1hcCgodikgPT4ge1xuICAgICAgdGhpcy53YXJuSWZEZXByZWNhdGVkKHYpO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgVVJMIHRoYXQgcmVwcmVzZW50IF90aGlzXyB2YXJpYW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRJbWFnZVVSTCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVVSTDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBhcyB1c2FibGUgYnkgTWFwTGlicmUsIGEgc3RyaW5nIChVUkwpIG9yIGEgcGxhaW4gc3R5bGUgZGVzY3JpcHRpb24gKFN0eWxlU3BlY2lmaWNhdGlvbilcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldEV4cGFuZGVkU3R5bGVVUkwoKSB7XG4gICAgcmV0dXJuIGV4cGFuZE1hcFN0eWxlKHRoaXMuZ2V0SWQoKSk7XG4gIH1cbiAgd2FybklmRGVwcmVjYXRlZCh2YXJpYW50ID0gdGhpcykge1xuICAgIGlmICghdmFyaWFudC5kZXByZWNhdGVkKVxuICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgY29uc3QgbmFtZSA9IHZhcmlhbnQuZ2V0RnVsbE5hbWUoKTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgU3R5bGUgXCIke25hbWV9XCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYFxuICAgICk7XG4gICAgcmV0dXJuIHZhcmlhbnQ7XG4gIH1cbn1cbmNsYXNzIFJlZmVyZW5jZU1hcFN0eWxlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgaWQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICAvKipcbiAgICAgKiBWYXJpYW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIHJlZmVyZW5jZSBzdHlsZSwga2V5IGJlaW5nIHRoZSByZWZlcmVuY2UgdHlwZVxuICAgICAqL1xuICAgIHRoaXMudmFyaWFudHMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBWYXJpYW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIHJlZmVyZW5jZSBzdHlsZSwgb3JkZXJlZCBieSByZWxldmFuY2VcbiAgICAgKi9cbiAgICB0aGlzLm9yZGVyZWRWYXJpYW50cyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuLWZyaWVuZGx5IG5hbWUgb2YgdGhpcyByZWZlcmVuY2Ugc3R5bGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBpZCBvZiBfdGhpc18gcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgdmFyaWFudCB0byBfdGhpc18gcmVmZXJlbmNlIHN0eWxlXG4gICAqIEBwYXJhbSB2XG4gICAqL1xuICBhZGRWYXJpYW50KHYpIHtcbiAgICB0aGlzLnZhcmlhbnRzW3YuZ2V0VHlwZSgpXSA9IHY7XG4gICAgdGhpcy5vcmRlcmVkVmFyaWFudHMucHVzaCh2KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBnaXZlbiB2YXJpYW50IHR5cGUgZXhpc3RzIGZvciB0aGlzIHJlZmVyZW5jZSBzdHlsZVxuICAgKiBAcGFyYW0gdmFyaWFudFR5cGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1ZhcmlhbnQodmFyaWFudFR5cGUpIHtcbiAgICByZXR1cm4gdmFyaWFudFR5cGUgaW4gdGhpcy52YXJpYW50cztcbiAgfVxuICAvKipcbiAgICogR2V0IGEgZ2l2ZW4gdmFyaWFudC4gSWYgdGhlIGdpdmVuIHR5cGUgb2YgdmFyaWFudCBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyByZWZlcmVuY2Ugc3R5bGUsXG4gICAqIHRoZW4gdGhlIG1vc3QgcmVsZXZhbnQgZGVmYXVsdCB2YXJpYW50IGlzIHJldHVybmVkIGluc3RlYWRcbiAgICogQHBhcmFtIHZhcmlhbnRUeXBlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRWYXJpYW50KHZhcmlhbnRUeXBlKSB7XG4gICAgcmV0dXJuIHZhcmlhbnRUeXBlIGluIHRoaXMudmFyaWFudHMgPyB0aGlzLnZhcmlhbnRzW3ZhcmlhbnRUeXBlXSA6IHRoaXMub3JkZXJlZFZhcmlhbnRzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgdmFyaWFudHMgZm9yIHRoaXMgcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRWYXJpYW50cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLnZhcmlhbnRzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkZWZ1YWx0IHZhcmlhbnQgZm9yIHRoaXMgcmVmZXJlbmNlIHN0eWxlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXREZWZhdWx0VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmRlcmVkVmFyaWFudHNbMF0ud2FybklmRGVwcmVjYXRlZCgpO1xuICB9XG59XG5jb25zdCBtYXBTdHlsZVByZXNldExpc3QgPSBbXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlNUUkVFVFNcIixcbiAgICBuYW1lOiBcIlN0cmVldHNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJzdHJlZXRzLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1saWdodFwiLFxuICAgICAgICBuYW1lOiBcIkxpZ2h0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1uaWdodFwiLFxuICAgICAgICBuYW1lOiBcIk5pZ2h0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIk5JR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwic3RyZWV0cy12Mi1wYXN0ZWxcIixcbiAgICAgICAgbmFtZTogXCJQYXN0ZWxcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiUEFTVEVMXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiT1VURE9PUlwiLFxuICAgIG5hbWU6IFwiT3V0ZG9vclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcIm91dGRvb3ItdjJcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJvdXRkb29yLXYyLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJXSU5URVJcIixcbiAgICBuYW1lOiBcIldpbnRlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcIndpbnRlci12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcIndpbnRlci12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiU0FURUxMSVRFXCIsXG4gICAgbmFtZTogXCJTYXRlbGxpdGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJzYXRlbGxpdGVcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJIWUJSSURcIixcbiAgICBuYW1lOiBcIkh5YnJpZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImh5YnJpZFwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIkJBU0lDXCIsXG4gICAgbmFtZTogXCJCYXNpY1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhc2ljLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYmFzaWMtdjItZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhc2ljLXYyLWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJCUklHSFRcIixcbiAgICBuYW1lOiBcIkJyaWdodFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJyaWdodC12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJyaWdodC12Mi1kYXJrXCIsXG4gICAgICAgIG5hbWU6IFwiRGFya1wiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJEQVJLXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYnJpZ2h0LXYyLWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJicmlnaHQtdjItcGFzdGVsXCIsXG4gICAgICAgIG5hbWU6IFwiUGFzdGVsXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlBBU1RFTFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIk9QRU5TVFJFRVRNQVBcIixcbiAgICBuYW1lOiBcIk9wZW5TdHJlZXRNYXBcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJvcGVuc3RyZWV0bWFwXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiVE9QT1wiLFxuICAgIG5hbWU6IFwiVG9wb1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvcG8tdjJcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLXNoaW55XCIsXG4gICAgICAgIG5hbWU6IFwiU2hpbnlcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiU0hJTllcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLXBhc3RlbFwiLFxuICAgICAgICBuYW1lOiBcIlBhc3RlbFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJQQVNURUxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b3BvLXYyLXRvcG9ncmFwaGlxdWVcIixcbiAgICAgICAgbmFtZTogXCJUb3BvZ3JhcGhpcXVlXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlRPUE9HUkFQSElRVUVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJWT1lBR0VSXCIsXG4gICAgbmFtZTogXCJWb3lhZ2VyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidm95YWdlci12MlwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInZveWFnZXItdjItZGFya21hdHRlclwiLFxuICAgICAgICBuYW1lOiBcIkRhcmttYXR0ZXJcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInZveWFnZXItdjItcG9zaXRyb25cIixcbiAgICAgICAgbmFtZTogXCJQb3NpdHJvblwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJMSUdIVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInZveWFnZXItdjItdmludGFnZVwiLFxuICAgICAgICBuYW1lOiBcIlZpbnRhZ2VcIixcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiVklOVEFHRVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICByZWZlcmVuY2VTdHlsZUlEOiBcIlRPTkVSXCIsXG4gICAgbmFtZTogXCJUb25lclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvbmVyLXYyXCIsXG4gICAgICAgIG5hbWU6IFwiRGVmYXVsdFwiLFxuICAgICAgICB2YXJpYW50VHlwZTogXCJERUZBVUxUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwidG9uZXItdjItYmFja2dyb3VuZFwiLFxuICAgICAgICBuYW1lOiBcIkJhY2tncm91bmRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiQkFDS0dST1VORFwiLFxuICAgICAgICBkZXByZWNhdGVkOiB0cnVlLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcInRvbmVyLXYyLWxpdGVcIixcbiAgICAgICAgbmFtZTogXCJMaXRlXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJVEVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJ0b25lci12Mi1saW5lc1wiLFxuICAgICAgICBuYW1lOiBcIkxpbmVzXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJTkVTXCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiREFUQVZJWlwiLFxuICAgIG5hbWU6IFwiRGF0YXZpelwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImRhdGF2aXpcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJkYXRhdml6LWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJkYXRhdml6LWxpZ2h0XCIsXG4gICAgICAgIG5hbWU6IFwiTGlnaHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiTElHSFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJCQUNLRFJPUFwiLFxuICAgIG5hbWU6IFwiQmFja2Ryb3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJiYWNrZHJvcFwiLFxuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREVGQVVMVFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImJhY2tkcm9wLWRhcmtcIixcbiAgICAgICAgbmFtZTogXCJEYXJrXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRBUktcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJiYWNrZHJvcC1saWdodFwiLFxuICAgICAgICBuYW1lOiBcIkxpZ2h0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkxJR0hUXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiT0NFQU5cIixcbiAgICBuYW1lOiBcIk9jZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwib2NlYW5cIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgcmVmZXJlbmNlU3R5bGVJRDogXCJBUVVBUkVMTEVcIixcbiAgICBuYW1lOiBcIkFxdWFyZWxsZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIldhdGVyY29sb3IgbWFwIGZvciBjcmVhdGl2ZSB1c2VcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJhcXVhcmVsbGVcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJhcXVhcmVsbGUtZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImFxdWFyZWxsZS12aXZpZFwiLFxuICAgICAgICBuYW1lOiBcIlZpdmlkXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlZJVklEXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHJlZmVyZW5jZVN0eWxlSUQ6IFwiTEFORFNDQVBFXCIsXG4gICAgbmFtZTogXCJMYW5kc2NhcGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUZXJyYWluIG1hcCBmb3IgZGF0YSBvdmVybGF5cyBhbmQgdmlzdWFsaXNhdGlvbnNcIixcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBpZDogXCJsYW5kc2NhcGVcIixcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIkRFRkFVTFRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIGltYWdlVVJMOiBcIlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCJsYW5kc2NhcGUtZGFya1wiLFxuICAgICAgICBuYW1lOiBcIkRhcmtcIixcbiAgICAgICAgdmFyaWFudFR5cGU6IFwiREFSS1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgaW1hZ2VVUkw6IFwiXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImxhbmRzY2FwZS12aXZpZFwiLFxuICAgICAgICBuYW1lOiBcIlZpdmlkXCIsXG4gICAgICAgIHZhcmlhbnRUeXBlOiBcIlZJVklEXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICBpbWFnZVVSTDogXCJcIlxuICAgICAgfVxuICAgIF1cbiAgfVxuXTtcbmZ1bmN0aW9uIG1ha2VSZWZlcmVuY2VTdHlsZVByb3h5KHJlZmVyZW5jZVN0eWxlKSB7XG4gIHJldHVybiBuZXcgUHJveHkocmVmZXJlbmNlU3R5bGUsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHRhcmdldC5oYXNWYXJpYW50KHByb3ApKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuZ2V0VmFyaWFudChwcm9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKSA9PT0gcHJvcCkge1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlU3R5bGUuZ2V0RGVmYXVsdFZhcmlhbnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTWFwU3R5bGVzKCkge1xuICBjb25zdCBtYXBTdHlsZSA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcFN0eWxlUHJlc2V0TGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHJlZlN0eWxlSW5mbyA9IG1hcFN0eWxlUHJlc2V0TGlzdFtpXTtcbiAgICBjb25zdCByZWZTdHlsZSA9IG1ha2VSZWZlcmVuY2VTdHlsZVByb3h5KFxuICAgICAgbmV3IFJlZmVyZW5jZU1hcFN0eWxlKHJlZlN0eWxlSW5mby5uYW1lLCByZWZTdHlsZUluZm8ucmVmZXJlbmNlU3R5bGVJRClcbiAgICApO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVmU3R5bGVJbmZvLnZhcmlhbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBjb25zdCB2YXJpYW50SW5mbyA9IHJlZlN0eWxlSW5mby52YXJpYW50c1tqXTtcbiAgICAgIGNvbnN0IHZhcmlhbnQgPSBuZXcgTWFwU3R5bGVWYXJpYW50KFxuICAgICAgICB2YXJpYW50SW5mby5uYW1lLFxuICAgICAgICAvLyBuYW1lXG4gICAgICAgIHZhcmlhbnRJbmZvLnZhcmlhbnRUeXBlLFxuICAgICAgICAvLyB2YXJpYW50VHlwZVxuICAgICAgICB2YXJpYW50SW5mby5pZCxcbiAgICAgICAgLy8gaWRcbiAgICAgICAgcmVmU3R5bGUsXG4gICAgICAgIC8vIHJlZmVyZW5jZVN0eWxlXG4gICAgICAgIHZhcmlhbnRJbmZvLmRlc2NyaXB0aW9uLFxuICAgICAgICB2YXJpYW50SW5mby5pbWFnZVVSTCxcbiAgICAgICAgLy8gaW1hZ2VVUkxcbiAgICAgICAgdmFyaWFudEluZm8uZGVwcmVjYXRlZFxuICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICApO1xuICAgICAgcmVmU3R5bGUuYWRkVmFyaWFudCh2YXJpYW50KTtcbiAgICB9XG4gICAgbWFwU3R5bGVbcmVmU3R5bGVJbmZvLnJlZmVyZW5jZVN0eWxlSURdID0gcmVmU3R5bGU7XG4gIH1cbiAgcmV0dXJuIG1hcFN0eWxlO1xufVxuZnVuY3Rpb24gc3R5bGVUb1N0eWxlKHN0eWxlKSB7XG4gIGlmICghc3R5bGUpIHtcbiAgICByZXR1cm4gTWFwU3R5bGVbbWFwU3R5bGVQcmVzZXRMaXN0WzBdLnJlZmVyZW5jZVN0eWxlSURdLmdldERlZmF1bHRWYXJpYW50KCkuZ2V0SWQoKTtcbiAgfVxuICBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiIHx8IHN0eWxlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0eWxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGlmIChzdHlsZSBpbnN0YW5jZW9mIE1hcFN0eWxlVmFyaWFudCkge1xuICAgIHJldHVybiBzdHlsZS5nZXRJZCgpO1xuICB9XG4gIGlmIChzdHlsZSBpbnN0YW5jZW9mIFJlZmVyZW5jZU1hcFN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlLmdldERlZmF1bHRWYXJpYW50KCkuZ2V0SWQoKTtcbiAgfVxufVxuY29uc3QgTWFwU3R5bGUgPSBidWlsZE1hcFN0eWxlcygpO1xuXG5mdW5jdGlvbiBleHRyYWN0TGluZVN0cmluZ3MoZ2VvSnNvbikge1xuICBjb25zdCBsaW5lU3RyaW5ncyA9IFtdO1xuICBmdW5jdGlvbiBleHRyYWN0RnJvbUdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiIHx8IGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIHtcbiAgICAgIGxpbmVTdHJpbmdzLnB1c2goZ2VvbWV0cnkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0RnJvbUZlYXR1cmUoZmVhdHVyZSkge1xuICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5KSB7XG4gICAgICBleHRyYWN0RnJvbUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0RnJvbUZlYXR1cmVDb2xsZWN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgY29sbGVjdGlvbi5mZWF0dXJlcykge1xuICAgICAgaWYgKGZlYXR1cmUudHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICAgICAgZXh0cmFjdEZyb21GZWF0dXJlKGZlYXR1cmUpO1xuICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgICAgICBleHRyYWN0RnJvbUZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZ2VvSnNvbi50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgIGV4dHJhY3RGcm9tRmVhdHVyZShnZW9Kc29uKTtcbiAgfSBlbHNlIGlmIChnZW9Kc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgIGV4dHJhY3RGcm9tRmVhdHVyZUNvbGxlY3Rpb24oZ2VvSnNvbik7XG4gIH0gZWxzZSB7XG4gICAgZXh0cmFjdEZyb21HZW9tZXRyeShnZW9Kc29uKTtcbiAgfVxuICByZXR1cm4gbGluZVN0cmluZ3M7XG59XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG4gIGxldCB4ID0gcDFbMF0sIHkgPSBwMVsxXSwgZHggPSBwMlswXSAtIHgsIGR5ID0gcDJbMV0gLSB5O1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjb25zdCB0ID0gKChwWzBdIC0geCkgKiBkeCArIChwWzFdIC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmICh0ID4gMSkge1xuICAgICAgeCA9IHAyWzBdO1xuICAgICAgeSA9IHAyWzFdO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIHggKz0gZHggKiB0O1xuICAgICAgeSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIGR4ID0gcFswXSAtIHg7XG4gIGR5ID0gcFsxXSAtIHk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbmZ1bmN0aW9uIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG4gIGxldCBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSwgaW5kZXg7XG4gIGZvciAobGV0IGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICBjb25zdCBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgaWYgKGluZGV4IC0gZmlyc3QgPiAxKSB7XG4gICAgICBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBpbmRleCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIH1cbiAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2luZGV4XSk7XG4gICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHtcbiAgICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICBjb25zdCBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSBbcG9pbnRzWzBdXTtcbiAgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCAwLCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuICByZXR1cm4gc2ltcGxpZmllZDtcbn1cbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XG4gIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIGNvbnN0IHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB2b2lkIDAgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuICBjb25zdCBzaW1wbGVQb2ludHMgPSBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpO1xuICByZXR1cm4gc2ltcGxlUG9pbnRzO1xufVxuY29uc3QgbWlzYyA9IHtcbiAgZXh0cmFjdExpbmVTdHJpbmdzLFxuICBzaW1wbGlmeVxufTtcblxuZnVuY3Rpb24gc3RhdGljTWFwTWFya2VyVG9TdHJpbmcobWFya2VyLCBpbmNsdWRlQ29sb3IgPSB0cnVlKSB7XG4gIGxldCBzdHIgPSBgJHttYXJrZXJbMF19LCR7bWFya2VyWzFdfWA7XG4gIGlmIChtYXJrZXIubGVuZ3RoID09PSAzICYmIGluY2x1ZGVDb2xvcikge1xuICAgIHN0ciArPSBgLCR7bWFya2VyWzJdfWA7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHNpbXBsaWZ5QW5kU3RyaW5naWZ5KHBhdGgsIG1heE5iQ2hhciA9IDNlMykge1xuICBsZXQgc3RyID0gcGF0aC5tYXAoKHBvaW50KSA9PiBwb2ludC5qb2luKFwiLFwiKSkuam9pbihcInxcIik7XG4gIGxldCB0b2xlcmFuY2UgPSA1ZS02O1xuICBjb25zdCB0b2xlcmFuY2VTdGVwID0gMWUtNTtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPiBtYXhOYkNoYXIpIHtcbiAgICBjb25zdCBzaW1wbGVyUGF0aCA9IG1pc2Muc2ltcGxpZnkocGF0aCwgdG9sZXJhbmNlKTtcbiAgICBzdHIgPSBzaW1wbGVyUGF0aC5tYXAoKHBvaW50KSA9PiBgJHtwb2ludFswXX0sJHtwb2ludFsxXX1gKS5qb2luKFwifFwiKTtcbiAgICB0b2xlcmFuY2UgKz0gdG9sZXJhbmNlU3RlcDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY2VudGVyZWQoY2VudGVyLCB6b29tLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3R5bGUgPSBzdHlsZVRvU3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5oaURQSSA/IFwiQDJ4XCIgOiBcIlwiO1xuICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCA/PyBcInBuZ1wiO1xuICBsZXQgd2lkdGggPSB+fihvcHRpb25zLndpZHRoID8/IDEwMjQpO1xuICBsZXQgaGVpZ2h0ID0gfn4ob3B0aW9ucy5oZWlnaHQgPz8gMTAyNCk7XG4gIGlmIChvcHRpb25zLmhpRFBJKSB7XG4gICAgd2lkdGggPSB+fih3aWR0aCAvIDIpO1xuICAgIGhlaWdodCA9IH5+KGhlaWdodCAvIDIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gbmV3IFVSTChcbiAgICBgbWFwcy8ke2VuY29kZVVSSUNvbXBvbmVudChzdHlsZSl9L3N0YXRpYy8ke2NlbnRlclswXX0sJHtjZW50ZXJbMV19LCR7em9vbX0vJHt3aWR0aH14JHtoZWlnaHR9JHtzY2FsZX0uJHtmb3JtYXR9YCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBpZiAoXCJhdHRyaWJ1dGlvblwiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwiYXR0cmlidXRpb25cIiwgb3B0aW9ucy5hdHRyaWJ1dGlvbi50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoXCJtYXJrZXJzXCIgaW4gb3B0aW9ucykge1xuICAgIGxldCBtYXJrZXJTdHIgPSBcIlwiO1xuICAgIGNvbnN0IGhhc0ljb24gPSBcIm1hcmtlckljb25cIiBpbiBvcHRpb25zO1xuICAgIGlmIChoYXNJY29uKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYGljb246JHtvcHRpb25zLm1hcmtlckljb259fGA7XG4gICAgfVxuICAgIGlmIChoYXNJY29uICYmIFwibWFya2VyQW5jaG9yXCIgaW4gb3B0aW9ucykge1xuICAgICAgbWFya2VyU3RyICs9IGBhbmNob3I6JHtvcHRpb25zLm1hcmtlckFuY2hvcn18YDtcbiAgICB9XG4gICAgaWYgKGhhc0ljb24gJiYgb3B0aW9ucy5oaURQSSkge1xuICAgICAgbWFya2VyU3RyICs9IGBzY2FsZToyfGA7XG4gICAgfVxuICAgIGNvbnN0IG1hcmtlckxpc3QgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMubWFya2Vyc1swXSkgPyBvcHRpb25zLm1hcmtlcnMgOiBbb3B0aW9ucy5tYXJrZXJzXTtcbiAgICBtYXJrZXJTdHIgKz0gbWFya2VyTGlzdC5tYXAoKG0pID0+IHN0YXRpY01hcE1hcmtlclRvU3RyaW5nKG0sICFoYXNJY29uKSkuam9pbihcInxcIik7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcIm1hcmtlcnNcIiwgbWFya2VyU3RyKTtcbiAgfVxuICBpZiAoXCJwYXRoXCIgaW4gb3B0aW9ucykge1xuICAgIGxldCBwYXRoU3RyID0gXCJcIjtcbiAgICBwYXRoU3RyICs9IGBmaWxsOiR7b3B0aW9ucy5wYXRoRmlsbENvbG9yID8/IFwibm9uZVwifXxgO1xuICAgIGlmIChcInBhdGhTdHJva2VDb2xvclwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHBhdGhTdHIgKz0gYHN0cm9rZToke29wdGlvbnMucGF0aFN0cm9rZUNvbG9yfXxgO1xuICAgIH1cbiAgICBpZiAoXCJwYXRoV2lkdGhcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBwYXRoV2lkdGggPSBvcHRpb25zLnBhdGhXaWR0aCAvIChvcHRpb25zLmhpRFBJID8gMiA6IDEpO1xuICAgICAgcGF0aFN0ciArPSBgd2lkdGg6JHtwYXRoV2lkdGgudG9TdHJpbmcoKX18YDtcbiAgICB9XG4gICAgcGF0aFN0ciArPSBzaW1wbGlmeUFuZFN0cmluZ2lmeShvcHRpb25zLnBhdGgpO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJwYXRoXCIsIHBhdGhTdHIpO1xuICB9XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIHJldHVybiBlbmRwb2ludC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gYm91bmRlZChib3VuZGluZ0JveCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVUb1N0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuaGlEUEkgPyBcIkAyeFwiIDogXCJcIjtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgPz8gXCJwbmdcIjtcbiAgbGV0IHdpZHRoID0gfn4ob3B0aW9ucy53aWR0aCA/PyAxMDI0KTtcbiAgbGV0IGhlaWdodCA9IH5+KG9wdGlvbnMuaGVpZ2h0ID8/IDEwMjQpO1xuICBpZiAob3B0aW9ucy5oaURQSSkge1xuICAgIHdpZHRoID0gfn4od2lkdGggLyAyKTtcbiAgICBoZWlnaHQgPSB+fihoZWlnaHQgLyAyKTtcbiAgfVxuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYG1hcHMvJHtlbmNvZGVVUklDb21wb25lbnQoc3R5bGUpfS9zdGF0aWMvJHtib3VuZGluZ0JveFswXX0sJHtib3VuZGluZ0JveFsxXX0sJHtib3VuZGluZ0JveFsyXX0sJHtib3VuZGluZ0JveFszXX0vJHt3aWR0aH14JHtoZWlnaHR9JHtzY2FsZX0uJHtmb3JtYXR9YCxcbiAgICBkZWZhdWx0cy5tYXB0aWxlckFwaVVSTFxuICApO1xuICBpZiAoXCJhdHRyaWJ1dGlvblwiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwiYXR0cmlidXRpb25cIiwgb3B0aW9ucy5hdHRyaWJ1dGlvbi50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoXCJwYWRkaW5nXCIgaW4gb3B0aW9ucykge1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJwYWRkaW5nXCIsIG9wdGlvbnMucGFkZGluZy50b1N0cmluZygpKTtcbiAgfVxuICBpZiAoXCJtYXJrZXJzXCIgaW4gb3B0aW9ucykge1xuICAgIGxldCBtYXJrZXJTdHIgPSBcIlwiO1xuICAgIGNvbnN0IGhhc0ljb24gPSBcIm1hcmtlckljb25cIiBpbiBvcHRpb25zO1xuICAgIGlmIChoYXNJY29uKSB7XG4gICAgICBtYXJrZXJTdHIgKz0gYGljb246JHtvcHRpb25zLm1hcmtlckljb259fGA7XG4gICAgfVxuICAgIGlmIChoYXNJY29uICYmIFwibWFya2VyQW5jaG9yXCIgaW4gb3B0aW9ucykge1xuICAgICAgbWFya2VyU3RyICs9IGBhbmNob3I6JHtvcHRpb25zLm1hcmtlckFuY2hvcn18YDtcbiAgICB9XG4gICAgaWYgKGhhc0ljb24gJiYgb3B0aW9ucy5oaURQSSkge1xuICAgICAgbWFya2VyU3RyICs9IGBzY2FsZToyfGA7XG4gICAgfVxuICAgIGNvbnN0IG1hcmtlckxpc3QgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMubWFya2Vyc1swXSkgPyBvcHRpb25zLm1hcmtlcnMgOiBbb3B0aW9ucy5tYXJrZXJzXTtcbiAgICBtYXJrZXJTdHIgKz0gbWFya2VyTGlzdC5tYXAoKG0pID0+IHN0YXRpY01hcE1hcmtlclRvU3RyaW5nKG0sICFoYXNJY29uKSkuam9pbihcInxcIik7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcIm1hcmtlcnNcIiwgbWFya2VyU3RyKTtcbiAgfVxuICBpZiAoXCJwYXRoXCIgaW4gb3B0aW9ucykge1xuICAgIGxldCBwYXRoU3RyID0gXCJcIjtcbiAgICBwYXRoU3RyICs9IGBmaWxsOiR7b3B0aW9ucy5wYXRoRmlsbENvbG9yID8/IFwibm9uZVwifXxgO1xuICAgIGlmIChcInBhdGhTdHJva2VDb2xvclwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHBhdGhTdHIgKz0gYHN0cm9rZToke29wdGlvbnMucGF0aFN0cm9rZUNvbG9yfXxgO1xuICAgIH1cbiAgICBpZiAoXCJwYXRoV2lkdGhcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBwYXRoV2lkdGggPSBvcHRpb25zLnBhdGhXaWR0aCAvIChvcHRpb25zLmhpRFBJID8gMiA6IDEpO1xuICAgICAgcGF0aFN0ciArPSBgd2lkdGg6JHtwYXRoV2lkdGgudG9TdHJpbmcoKX18YDtcbiAgICB9XG4gICAgcGF0aFN0ciArPSBzaW1wbGlmeUFuZFN0cmluZ2lmeShvcHRpb25zLnBhdGgpO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJwYXRoXCIsIHBhdGhTdHIpO1xuICB9XG4gIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgb3B0aW9ucy5hcGlLZXkgPz8gY29uZmlnLmFwaUtleSk7XG4gIHJldHVybiBlbmRwb2ludC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gYXV0b21hdGljKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIShcIm1hcmtlcnNcIiBpbiBvcHRpb25zKSAmJiAhKFwicGF0aFwiIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBdXRvbWF0aWMgc3RhdGljIG1hcHMgcmVxdWlyZSBtYXJrZXJzIGFuZC9vciBwYXRoIHRvIGJlIGNyZWF0ZWQuXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVUb1N0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuaGlEUEkgPyBcIkAyeFwiIDogXCJcIjtcbiAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgPz8gXCJwbmdcIjtcbiAgbGV0IHdpZHRoID0gfn4ob3B0aW9ucy53aWR0aCA/PyAxMDI0KTtcbiAgbGV0IGhlaWdodCA9IH5+KG9wdGlvbnMuaGVpZ2h0ID8/IDEwMjQpO1xuICBpZiAob3B0aW9ucy5oaURQSSkge1xuICAgIHdpZHRoID0gfn4od2lkdGggLyAyKTtcbiAgICBoZWlnaHQgPSB+fihoZWlnaHQgLyAyKTtcbiAgfVxuICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgYG1hcHMvJHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBzdHlsZVxuICAgICl9L3N0YXRpYy9hdXRvLyR7d2lkdGh9eCR7aGVpZ2h0fSR7c2NhbGV9LiR7Zm9ybWF0fWAsXG4gICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgKTtcbiAgaWYgKFwiYXR0cmlidXRpb25cIiBpbiBvcHRpb25zKSB7XG4gICAgZW5kcG9pbnQuc2VhcmNoUGFyYW1zLnNldChcImF0dHJpYnV0aW9uXCIsIG9wdGlvbnMuYXR0cmlidXRpb24udG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwicGFkZGluZ1wiIGluIG9wdGlvbnMpIHtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwicGFkZGluZ1wiLCBvcHRpb25zLnBhZGRpbmcudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKFwibWFya2Vyc1wiIGluIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFya2VyU3RyID0gXCJcIjtcbiAgICBjb25zdCBoYXNJY29uID0gXCJtYXJrZXJJY29uXCIgaW4gb3B0aW9ucztcbiAgICBpZiAoaGFzSWNvbikge1xuICAgICAgbWFya2VyU3RyICs9IGBpY29uOiR7b3B0aW9ucy5tYXJrZXJJY29ufXxgO1xuICAgIH1cbiAgICBpZiAoaGFzSWNvbiAmJiBcIm1hcmtlckFuY2hvclwiIGluIG9wdGlvbnMpIHtcbiAgICAgIG1hcmtlclN0ciArPSBgYW5jaG9yOiR7b3B0aW9ucy5tYXJrZXJBbmNob3J9fGA7XG4gICAgfVxuICAgIGlmIChoYXNJY29uICYmIG9wdGlvbnMuaGlEUEkpIHtcbiAgICAgIG1hcmtlclN0ciArPSBgc2NhbGU6MnxgO1xuICAgIH1cbiAgICBjb25zdCBtYXJrZXJMaXN0ID0gQXJyYXkuaXNBcnJheShvcHRpb25zLm1hcmtlcnNbMF0pID8gb3B0aW9ucy5tYXJrZXJzIDogW29wdGlvbnMubWFya2Vyc107XG4gICAgbWFya2VyU3RyICs9IG1hcmtlckxpc3QubWFwKChtKSA9PiBzdGF0aWNNYXBNYXJrZXJUb1N0cmluZyhtLCAhaGFzSWNvbikpLmpvaW4oXCJ8XCIpO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJtYXJrZXJzXCIsIG1hcmtlclN0cik7XG4gIH1cbiAgaWYgKFwicGF0aFwiIGluIG9wdGlvbnMpIHtcbiAgICBsZXQgcGF0aFN0ciA9IFwiXCI7XG4gICAgcGF0aFN0ciArPSBgZmlsbDoke29wdGlvbnMucGF0aEZpbGxDb2xvciA/PyBcIm5vbmVcIn18YDtcbiAgICBpZiAoXCJwYXRoU3Ryb2tlQ29sb3JcIiBpbiBvcHRpb25zKSB7XG4gICAgICBwYXRoU3RyICs9IGBzdHJva2U6JHtvcHRpb25zLnBhdGhTdHJva2VDb2xvcn18YDtcbiAgICB9XG4gICAgaWYgKFwicGF0aFdpZHRoXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgcGF0aFdpZHRoID0gb3B0aW9ucy5wYXRoV2lkdGggLyAob3B0aW9ucy5oaURQSSA/IDIgOiAxKTtcbiAgICAgIHBhdGhTdHIgKz0gYHdpZHRoOiR7cGF0aFdpZHRoLnRvU3RyaW5nKCl9fGA7XG4gICAgfVxuICAgIHBhdGhTdHIgKz0gc2ltcGxpZnlBbmRTdHJpbmdpZnkob3B0aW9ucy5wYXRoKTtcbiAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwicGF0aFwiLCBwYXRoU3RyKTtcbiAgfVxuICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIG9wdGlvbnMuYXBpS2V5ID8/IGNvbmZpZy5hcGlLZXkpO1xuICByZXR1cm4gZW5kcG9pbnQudG9TdHJpbmcoKTtcbn1cbmNvbnN0IHN0YXRpY01hcHMgPSB7XG4gIGNlbnRlcmVkLFxuICBib3VuZGVkLFxuICBhdXRvbWF0aWNcbn07XG5cbmNvbnN0IEVBUlRIX1JBRElVUyA9IDYzNzEwMDg4ZS0xO1xuY29uc3QgRUFSVEhfQ0lSQ1VNRkVSRU5DRSA9IDIgKiBNYXRoLlBJICogRUFSVEhfUkFESVVTO1xuZnVuY3Rpb24gbG9uZ2l0dWRlVG9NZXJjYXRvclgobG5nKSB7XG4gIHJldHVybiAoMTgwICsgbG5nKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIGxhdGl0dWRlVG9NZXJjYXRvclkobGF0KSB7XG4gIHJldHVybiAoMTgwIC0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIHdnczg0VG9NZXJjYXRvcihwb3NpdGlvbikge1xuICBjb25zdCB3cmFwcGVkUG9zID0gd3JhcFdnczg0KHBvc2l0aW9uKTtcbiAgcmV0dXJuIFtcbiAgICBsb25naXR1ZGVUb01lcmNhdG9yWCh3cmFwcGVkUG9zWzBdKSxcbiAgICBsYXRpdHVkZVRvTWVyY2F0b3JZKHdyYXBwZWRQb3NbMV0pXG4gIF07XG59XG5mdW5jdGlvbiBtZXJjYXRvclhUb0xvbmdpdHVkZSh4KSB7XG4gIHJldHVybiB4ICogMzYwIC0gMTgwO1xufVxuZnVuY3Rpb24gbWVyY2F0b3JZVG9MYXRpdHVkZSh5KSB7XG4gIGNvbnN0IHkyID0gMTgwIC0geSAqIDM2MDtcbiAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbn1cbmZ1bmN0aW9uIG1lcmNhdG9yVG9XZ3M4NChwb3NpdGlvbikge1xuICByZXR1cm4gW21lcmNhdG9yWFRvTG9uZ2l0dWRlKHBvc2l0aW9uWzBdKSwgbWVyY2F0b3JZVG9MYXRpdHVkZShwb3NpdGlvblsxXSldO1xufVxuZnVuY3Rpb24gaGF2ZXJzaW5lRGlzdGFuY2VXZ3M4NChmcm9tLCB0bykge1xuICBjb25zdCByYWQgPSBNYXRoLlBJIC8gMTgwO1xuICBjb25zdCBsYXQxID0gZnJvbVsxXSAqIHJhZDtcbiAgY29uc3QgbGF0MiA9IHRvWzFdICogcmFkO1xuICBjb25zdCBhID0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcygodG9bMF0gLSBmcm9tWzBdKSAqIHJhZCk7XG4gIGNvbnN0IG1heE1ldGVycyA9IEVBUlRIX1JBRElVUyAqIE1hdGguYWNvcyhNYXRoLm1pbihhLCAxKSk7XG4gIHJldHVybiBtYXhNZXRlcnM7XG59XG5mdW5jdGlvbiBoYXZlcnNpbmVDdW11bGF0ZWREaXN0YW5jZVdnczg0KHBvc2l0aW9ucykge1xuICBjb25zdCBjdW11bGF0ZWREaXN0YW5jZSA9IEFycmF5KHBvc2l0aW9ucy5sZW5ndGgpO1xuICBjdW11bGF0ZWREaXN0YW5jZVswXSA9IDA7XG4gIGNvbnN0IGwgPSBjdW11bGF0ZWREaXN0YW5jZS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgY3VtdWxhdGVkRGlzdGFuY2VbaV0gPSBoYXZlcnNpbmVEaXN0YW5jZVdnczg0KHBvc2l0aW9uc1tpIC0gMV0sIHBvc2l0aW9uc1tpXSkgKyBjdW11bGF0ZWREaXN0YW5jZVtpIC0gMV07XG4gIH1cbiAgcmV0dXJuIGN1bXVsYXRlZERpc3RhbmNlO1xufVxuZnVuY3Rpb24gd3JhcFdnczg0KHBvc2l0aW9uKSB7XG4gIGNvbnN0IGxuZyA9IHBvc2l0aW9uWzBdO1xuICBjb25zdCBsYXQgPSBwb3NpdGlvblsxXTtcbiAgY29uc3QgZCA9IDM2MDtcbiAgY29uc3QgdyA9ICgobG5nICsgMTgwKSAlIGQgKyBkKSAlIGQgLSAxODA7XG4gIGNvbnN0IHdyYXBMb25nID0gdyA9PT0gLTE4MCA/IDE4MCA6IHc7XG4gIHJldHVybiBbd3JhcExvbmcsIGxhdF07XG59XG5mdW5jdGlvbiBjaXJjdW1mZXJlbmNlQXRMYXRpdHVkZShsYXRpdHVkZSkge1xuICByZXR1cm4gRUFSVEhfQ0lSQ1VNRkVSRU5DRSAqIE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG59XG5mdW5jdGlvbiBtZXJjYXRvclRvVGlsZUluZGV4KHBvc2l0aW9uLCB6b29tLCBzdHJpY3QgPSB0cnVlKSB7XG4gIGNvbnN0IG51bWJlck9mVGlsZVBlckF4aXMgPSAyICoqIHpvb207XG4gIGNvbnN0IGZJbmRleCA9IFtcbiAgICBwb3NpdGlvblswXSAqIG51bWJlck9mVGlsZVBlckF4aXMsXG4gICAgcG9zaXRpb25bMV0gKiBudW1iZXJPZlRpbGVQZXJBeGlzXG4gIF07XG4gIHJldHVybiBzdHJpY3QgPyBbfn5mSW5kZXhbMF0sIH5+ZkluZGV4WzFdXSA6IGZJbmRleDtcbn1cbmZ1bmN0aW9uIHdnczg0VG9UaWxlSW5kZXgocG9zaXRpb24sIHpvb20sIHN0cmljdCA9IHRydWUpIHtcbiAgY29uc3QgbWVyYyA9IHdnczg0VG9NZXJjYXRvcihwb3NpdGlvbik7XG4gIHJldHVybiBtZXJjYXRvclRvVGlsZUluZGV4KG1lcmMsIHpvb20sIHN0cmljdCk7XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59XG5mdW5jdGlvbiBoYXZlcnNpbmVJbnRlcm1lZGlhdGVXZ3M4NChwb3MxLCBwb3MyLCByYXRpbykge1xuICBjb25zdCBkID0gaGF2ZXJzaW5lRGlzdGFuY2VXZ3M4NChwb3MxLCBwb3MyKTtcbiAgY29uc3QgXFx1MDNCQjEgPSB0b1JhZGlhbnMocG9zMVswXSk7XG4gIGNvbnN0IFxcdTAzQzYxID0gdG9SYWRpYW5zKHBvczFbMV0pO1xuICBjb25zdCBcXHUwM0JCMiA9IHRvUmFkaWFucyhwb3MyWzBdKTtcbiAgY29uc3QgXFx1MDNDNjIgPSB0b1JhZGlhbnMocG9zMlsxXSk7XG4gIGNvbnN0IFxcdTAzQjQgPSBkIC8gRUFSVEhfUkFESVVTO1xuICBjb25zdCBhID0gTWF0aC5zaW4oKDEgLSByYXRpbykgKiBcXHUwM0I0KSAvIE1hdGguc2luKFxcdTAzQjQpO1xuICBjb25zdCBiID0gTWF0aC5zaW4ocmF0aW8gKiBcXHUwM0I0KSAvIE1hdGguc2luKFxcdTAzQjQpO1xuICBjb25zdCB4ID0gYSAqIE1hdGguY29zKFxcdTAzQzYxKSAqIE1hdGguY29zKFxcdTAzQkIxKSArIGIgKiBNYXRoLmNvcyhcXHUwM0M2MikgKiBNYXRoLmNvcyhcXHUwM0JCMik7XG4gIGNvbnN0IHkgPSBhICogTWF0aC5jb3MoXFx1MDNDNjEpICogTWF0aC5zaW4oXFx1MDNCQjEpICsgYiAqIE1hdGguY29zKFxcdTAzQzYyKSAqIE1hdGguc2luKFxcdTAzQkIyKTtcbiAgY29uc3QgeiA9IGEgKiBNYXRoLnNpbihcXHUwM0M2MSkgKyBiICogTWF0aC5zaW4oXFx1MDNDNjIpO1xuICBjb25zdCBcXHUwM0M2MyA9IE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcbiAgY29uc3QgXFx1MDNCQjMgPSBNYXRoLmF0YW4yKHksIHgpO1xuICByZXR1cm4gW3RvRGVncmVlcyhcXHUwM0JCMyksIHRvRGVncmVlcyhcXHUwM0M2MyldO1xufVxuY29uc3QgbWF0aCA9IHtcbiAgRUFSVEhfUkFESVVTLFxuICBFQVJUSF9DSVJDVU1GRVJFTkNFLFxuICBsb25naXR1ZGVUb01lcmNhdG9yWCxcbiAgbGF0aXR1ZGVUb01lcmNhdG9yWSxcbiAgd2dzODRUb01lcmNhdG9yLFxuICBtZXJjYXRvclhUb0xvbmdpdHVkZSxcbiAgbWVyY2F0b3JZVG9MYXRpdHVkZSxcbiAgbWVyY2F0b3JUb1dnczg0LFxuICBoYXZlcnNpbmVEaXN0YW5jZVdnczg0LFxuICB3cmFwV2dzODQsXG4gIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlLFxuICBtZXJjYXRvclRvVGlsZUluZGV4LFxuICB3Z3M4NFRvVGlsZUluZGV4LFxuICB0b1JhZGlhbnMsXG4gIHRvRGVncmVlcyxcbiAgaGF2ZXJzaW5lSW50ZXJtZWRpYXRlV2dzODQsXG4gIGhhdmVyc2luZUN1bXVsYXRlZERpc3RhbmNlV2dzODRcbn07XG5cbmxldCB0aWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0VGlsZUNhY2hlKCkge1xuICBpZiAoIXRpbGVDYWNoZSkge1xuICAgIHRpbGVDYWNoZSA9IG5ldyBRdWlja0xSVSh7IG1heFNpemU6IGNvbmZpZy50aWxlQ2FjaGVTaXplIH0pO1xuICB9XG4gIHJldHVybiB0aWxlQ2FjaGU7XG59XG5hc3luYyBmdW5jdGlvbiBidWZmZXJUb1BpeGVsRGF0YUJyb3dzZXIoYnVmZikge1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZdKTtcbiAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY2FudmFzLndpZHRoID0gaW1hZ2VCaXRtYXAud2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBpbWFnZUJpdG1hcC5oZWlnaHQ7XG4gIGN0eC5kcmF3SW1hZ2UoaW1hZ2VCaXRtYXAsIDAsIDApO1xuICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIHJldHVybiB7XG4gICAgcGl4ZWxzOiBpbWFnZURhdGEuZGF0YSxcbiAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICBjb21wb25lbnRzOiBpbWFnZURhdGEuZGF0YS5sZW5ndGggLyAoY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJ1ZmZlclRvUGl4ZWxEYXRhUGFyc2VyKCkge1xuICBpZiAoY29uZmlnLmJ1ZmZlclRvUGl4ZWxEYXRhKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5idWZmZXJUb1BpeGVsRGF0YTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBidWZmZXJUb1BpeGVsRGF0YUJyb3dzZXI7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiQW4gaW1hZ2UgZmlsZSBidWZmZXIgdG8gcGl4ZWwgZGF0YSBwYXJzZXIgaXMgbmVjZXNzYXJ5LiBTcGVjaWZ5IGl0IGluIGBjb25maWcuYnVmZmVyVG9QaXhlbERhdGFgXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIGNhblBhcnNlUGl4ZWxEYXRhKCkge1xuICByZXR1cm4gISFjb25maWcuYnVmZmVyVG9QaXhlbERhdGEgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuY29uc3QgVEVSUkFJTl9USUxFU0VUID0gXCJ0ZXJyYWluLXJnYi12MlwiO1xuY29uc3QgQVBJX0JBVENIX1NJWkUgPSA1MDtcbmNvbnN0IEFQSV9XQVJOX1NJWkUgPSAxZTM7XG5sZXQgdGVycmFpblRpbGVKc29uID0gbnVsbDtcbmNvbnN0IGN1c3RvbU1lc3NhZ2VzID0ge1xuICA0MDM6IFwiS2V5IGlzIG1pc3NpbmcsIGludmFsaWQgb3IgcmVzdHJpY3RlZFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gY29tcHV0ZU9uU2VydmVyKHBvc2l0aW9ucywgYXBpS2V5KSB7XG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoID4gQVBJX1dBUk5fU0laRSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiQ29tcHV0aW5nIGVsZXZhdGlvbiBmb3IgY29tcGxleCBnZW9tZXRyaWVzIGlzIGRpc2NvdXJhZ2VkIC0gc2ltcGxpZnkgdGhlIGdlb21ldHJ5IGJlZm9yZSBwcm9jZWVkaW5nXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHBhcnRzID0gTWF0aC5jZWlsKHBvc2l0aW9ucy5sZW5ndGggLyBBUElfQkFUQ0hfU0laRSk7XG4gIGNvbnN0IHJlc3BQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHBhcnRzIH0sICgpID0+IG51bGwpLm1hcChcbiAgICAoXywgcGFydCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBwYXJ0ICogQVBJX0JBVENIX1NJWkU7XG4gICAgICBjb25zdCBiYXRjaDIgPSBwb3NpdGlvbnMuc2xpY2Uoc3RhcnRQb3MsIHN0YXJ0UG9zICsgQVBJX0JBVENIX1NJWkUpO1xuICAgICAgY29uc3QgYmF0Y2hFbmNvZGVkID0gYmF0Y2gyLm1hcCgocG9zKSA9PiBwb3Muam9pbihcIixcIikpLmpvaW4oXCI7XCIpO1xuICAgICAgY29uc3QgZW5kcG9pbnQgPSBuZXcgVVJMKFxuICAgICAgICBgZWxldmF0aW9uLyR7YmF0Y2hFbmNvZGVkfS5qc29uYCxcbiAgICAgICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgICAgICk7XG4gICAgICBlbmRwb2ludC5zZWFyY2hQYXJhbXMuc2V0KFwia2V5XCIsIGFwaUtleSk7XG4gICAgICByZXR1cm4gY2FsbEZldGNoKGVuZHBvaW50LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgKTtcbiAgY29uc3QgcmVzcHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVzcFByb21pc2VzKTtcbiAgY29uc3QganNvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICByZXNwcy5tYXAoYXN5bmMgKHJlc3ApID0+IHtcbiAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgU29tZSBzZWdtZW50cyBjb3VsZCBub3QgYmUgZmV0Y2hlZCwgZXJyb3I6ICR7cmVzcC5yZWFzb259YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwLnZhbHVlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgU29tZSBzZWdtZW50cyBjb3VsZCBub3QgYmUgZmV0Y2hlZCwgcmVzcG9uc2U6ICR7cmVzcC52YWx1ZS5zdGF0dXN9ICR7YXdhaXQgcmVzcC52YWx1ZS50ZXh0KCl9LCB1cmw6ICR7cmVzcC52YWx1ZS51cmx9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3AudmFsdWUuanNvbigpO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiBqc29ucy5mbGF0KCk7XG59XG5hc3luYyBmdW5jdGlvbiBjb21wdXRlT25DbGllbnQocG9zaXRpb25zLCBhcGlLZXksIHpvb20pIHtcbiAgaWYgKCF0ZXJyYWluVGlsZUpzb24pIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IG5ldyBVUkwoXG4gICAgICBgdGlsZXMvJHtURVJSQUlOX1RJTEVTRVR9L3RpbGVzLmpzb25gLFxuICAgICAgZGVmYXVsdHMubWFwdGlsZXJBcGlVUkxcbiAgICApO1xuICAgIGVuZHBvaW50LnNlYXJjaFBhcmFtcy5zZXQoXCJrZXlcIiwgYXBpS2V5KTtcbiAgICBjb25zdCB1cmxXaXRoUGFyYW1zID0gZW5kcG9pbnQudG9TdHJpbmcoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxsRmV0Y2godXJsV2l0aFBhcmFtcyk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgdGVycmFpblRpbGVKc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFNlcnZpY2VFcnJvcihyZXMsIGN1c3RvbU1lc3NhZ2VzW3Jlcy5zdGF0dXNdID8/IFwiXCIpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aWxlUGFyc2VyID0gZ2V0QnVmZmVyVG9QaXhlbERhdGFQYXJzZXIoKTtcbiAgY29uc3QgdGlsZVVSTFNjaGVtYSA9IHRlcnJhaW5UaWxlSnNvbi50aWxlc1swXTtcbiAgY29uc3QgY2FjaGUgPSBnZXRUaWxlQ2FjaGUoKTtcbiAgY29uc3QgbWF4Wm9vbSA9IHRlcnJhaW5UaWxlSnNvbi5tYXh6b29tO1xuICBsZXQgdXNlZFpvb20gPSB+fih6b29tID8/IG1heFpvb20pO1xuICBpZiAodXNlZFpvb20gPiBtYXhab29tIHx8IHVzZWRab29tIDwgMCkge1xuICAgIHVzZWRab29tID0gbWF4Wm9vbTtcbiAgfVxuICBjb25zdCB0aWxlSW5kaWNlc0Zsb2F0cyA9IHBvc2l0aW9ucy5tYXAoXG4gICAgKHBvc2l0aW9uKSA9PiBtYXRoLndnczg0VG9UaWxlSW5kZXgocG9zaXRpb24sIHVzZWRab29tLCBmYWxzZSlcbiAgKTtcbiAgY29uc3QgdGlsZUluZGljZXNJbnRlZ2VyID0gdGlsZUluZGljZXNGbG9hdHMubWFwKChpbmRleCkgPT4gW1xuICAgIH5+aW5kZXhbMF0sXG4gICAgfn5pbmRleFsxXVxuICBdKTtcbiAgY29uc3QgdGlsZUlEcyA9IHRpbGVJbmRpY2VzSW50ZWdlci5tYXAoXG4gICAgKGluZGV4KSA9PiBgdGVycmFpbl8ke3VzZWRab29tLnRvU3RyaW5nKCl9XyR7aW5kZXhbMF0udG9TdHJpbmcoKX1fJHtpbmRleFsxXS50b1N0cmluZygpfWBcbiAgKTtcbiAgY29uc3QgdW5pcXVlVGlsZXNUb0ZldGNoID0gQXJyYXkuZnJvbShcbiAgICBuZXcgU2V0KHRpbGVJRHMuZmlsdGVyKCh0aWxlSUQpID0+ICFjYWNoZS5oYXModGlsZUlEKSkpXG4gICkubWFwKCh0aWxlSUQpID0+IHRpbGVJRC5zcGxpdChcIl9cIikuc2xpY2UoMSkpO1xuICBjb25zdCB0aWxlVVJMcyA9IHVuaXF1ZVRpbGVzVG9GZXRjaC5tYXAoXG4gICAgKHp4eSkgPT4gdGlsZVVSTFNjaGVtYS5yZXBsYWNlKFwie3h9XCIsIHp4eVsxXS50b1N0cmluZygpKS5yZXBsYWNlKFwie3l9XCIsIHp4eVsyXS50b1N0cmluZygpKS5yZXBsYWNlKFwie3p9XCIsIHp4eVswXS50b1N0cmluZygpKVxuICApO1xuICBjb25zdCBwcm9taXNlc0ZldGNoVGlsZXMgPSB0aWxlVVJMcy5tYXAoKHVybCkgPT4gY2FsbEZldGNoKHVybCkpO1xuICBjb25zdCByZXNUaWxlcyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlc0ZldGNoVGlsZXMpO1xuICBjb25zdCBmdWxmaWxsZWRSZXMgPSByZXNUaWxlcy5tYXAoXG4gICAgKGVsKSA9PiBlbC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgPyBlbC52YWx1ZSA6IG51bGxcbiAgKS5maWx0ZXIoKHJlcykgPT4gcmVzKTtcbiAgY29uc3QgZnVsZmlsbGVkUkJ1dE5vdE9rUmVzID0gZnVsZmlsbGVkUmVzLmZpbHRlcigocmVzKSA9PiAhcmVzLm9rKTtcbiAgaWYgKGZ1bGZpbGxlZFJlcy5sZW5ndGggIT09IHByb21pc2VzRmV0Y2hUaWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb21lIHRpbGVzIGNvdWxkIG5vdCBiZSBmZXRjaGVkLlwiKTtcbiAgfVxuICBpZiAoZnVsZmlsbGVkUkJ1dE5vdE9rUmVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBTZXJ2aWNlRXJyb3IoXG4gICAgICBmdWxmaWxsZWRSQnV0Tm90T2tSZXNbMF0sXG4gICAgICBjdXN0b21NZXNzYWdlc1tmdWxmaWxsZWRSQnV0Tm90T2tSZXNbMF0uc3RhdHVzXSA/PyBcIlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCB0aWxlQXJyYXlCdWZmZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgZnVsZmlsbGVkUmVzLm1hcCgocmVzKSA9PiByZXMuYXJyYXlCdWZmZXIoKSlcbiAgKTtcbiAgaWYgKCF0aWxlQXJyYXlCdWZmZXJzLmV2ZXJ5KChidWZmKSA9PiBidWZmLmJ5dGVMZW5ndGggPiAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWUgdGlsZXMgYXJlIG5vdCBhdmFpbGFibGUuXCIpO1xuICB9XG4gIGNvbnN0IHRpbGVQaXhlbERhdGFzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdGlsZUFycmF5QnVmZmVycy5tYXAoKGJ1ZmYpID0+IHRpbGVQYXJzZXIoYnVmZikpXG4gICk7XG4gIHRpbGVQaXhlbERhdGFzLmZvckVhY2goKHRpbGVQaXhlbERhdGEsIGkpID0+IHtcbiAgICBjb25zdCB6eHkgPSB1bmlxdWVUaWxlc1RvRmV0Y2hbaV07XG4gICAgY29uc3QgdGlsZUlEID0gYHRlcnJhaW5fJHt6eHlbMF0udG9TdHJpbmcoKX1fJHt6eHlbMV0udG9TdHJpbmcoKX1fJHt6eHlbMl0udG9TdHJpbmcoKX1gO1xuICAgIGNhY2hlLnNldCh0aWxlSUQsIHRpbGVQaXhlbERhdGEpO1xuICB9KTtcbiAgY29uc3QgZWxldmF0ZWRQb3NpdGlvbnMgPSBwb3NpdGlvbnMubWFwKChwb3NpdGlvbiwgaSkgPT4ge1xuICAgIGNvbnN0IHRpbGVJRCA9IHRpbGVJRHNbaV07XG4gICAgY29uc3QgdGlsZUluZGV4RmxvYXQgPSB0aWxlSW5kaWNlc0Zsb2F0c1tpXTtcbiAgICBjb25zdCB0aWxlUGl4ZWxEYXRhID0gY2FjaGUuZ2V0KHRpbGVJRCk7XG4gICAgY29uc3QgcGl4ZWxYID0gTWF0aC5taW4oXG4gICAgICBNYXRoLnJvdW5kKHRpbGVQaXhlbERhdGEud2lkdGggKiAodGlsZUluZGV4RmxvYXRbMF0gJSAxKSksXG4gICAgICB0aWxlUGl4ZWxEYXRhLndpZHRoIC0gMVxuICAgICk7XG4gICAgY29uc3QgcGl4ZWxZID0gTWF0aC5taW4oXG4gICAgICBNYXRoLnJvdW5kKHRpbGVQaXhlbERhdGEuaGVpZ2h0ICogKHRpbGVJbmRleEZsb2F0WzFdICUgMSkpLFxuICAgICAgdGlsZVBpeGVsRGF0YS5oZWlnaHQgLSAxXG4gICAgKTtcbiAgICBjb25zdCBwaXhlbERhdGFJbmRleCA9IChwaXhlbFkgKiB0aWxlUGl4ZWxEYXRhLndpZHRoICsgcGl4ZWxYKSAqIHRpbGVQaXhlbERhdGEuY29tcG9uZW50cztcbiAgICBjb25zdCBSID0gdGlsZVBpeGVsRGF0YS5waXhlbHNbcGl4ZWxEYXRhSW5kZXhdO1xuICAgIGNvbnN0IEcgPSB0aWxlUGl4ZWxEYXRhLnBpeGVsc1twaXhlbERhdGFJbmRleCArIDFdO1xuICAgIGNvbnN0IEIgPSB0aWxlUGl4ZWxEYXRhLnBpeGVsc1twaXhlbERhdGFJbmRleCArIDJdO1xuICAgIGNvbnN0IGVsZXZhdGlvbjIgPSAtMWU0ICsgKFIgKiAyNTYgKiAyNTYgKyBHICogMjU2ICsgQikgKiAwLjE7XG4gICAgcmV0dXJuIFtwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIH5+KGVsZXZhdGlvbjIgKiAxZTMpIC8gMWUzXTtcbiAgfSk7XG4gIHJldHVybiBlbGV2YXRlZFBvc2l0aW9ucztcbn1cbmFzeW5jIGZ1bmN0aW9uIGF0KHBvc2l0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZWxldmF0ZWRQb3NpdGlvbnMgPSBhd2FpdCBiYXRjaChbcG9zaXRpb25dLCBvcHRpb25zKTtcbiAgcmV0dXJuIGVsZXZhdGVkUG9zaXRpb25zWzBdO1xufVxuYXN5bmMgZnVuY3Rpb24gYmF0Y2gocG9zaXRpb25zLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBhcGlLZXkgPSBvcHRpb25zLmFwaUtleSA/PyBjb25maWcuYXBpS2V5O1xuICBjb25zdCBlbGV2YXRlZFBvc2l0aW9ucyA9IG9wdGlvbnMuY29tcHV0ZU9uID09PSBcImNsaWVudFwiID8gYXdhaXQgY29tcHV0ZU9uQ2xpZW50KHBvc2l0aW9ucywgYXBpS2V5LCBvcHRpb25zLnpvb20pIDogYXdhaXQgY29tcHV0ZU9uU2VydmVyKHBvc2l0aW9ucywgYXBpS2V5KTtcbiAgaWYgKG9wdGlvbnMuc21vb3RoaW5nS2VybmVsU2l6ZSkge1xuICAgIGNvbnN0IGtlcm5lbFNpemUgPSB+fihvcHRpb25zLnNtb290aGluZ0tlcm5lbFNpemUgLyAyKSAqIDIgKyAxO1xuICAgIGNvbnN0IGVsZXZhdGlvbnMgPSBlbGV2YXRlZFBvc2l0aW9ucy5tYXAoKHBvcykgPT4gcG9zWzJdKTtcbiAgICBjb25zdCBrZXJuZWxTcGFuID0gfn4oa2VybmVsU2l6ZSAvIDIpO1xuICAgIGZvciAobGV0IGkgPSBrZXJuZWxTcGFuOyBpIDwgZWxldmF0aW9ucy5sZW5ndGggLSBrZXJuZWxTcGFuIC0gMTsgaSArPSAxKSB7XG4gICAgICBsZXQgc3VtID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2VybmVsU2l6ZTsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGVsZXYgPSBlbGV2YXRpb25zW2kgLSBrZXJuZWxTcGFuICsgal07XG4gICAgICAgIHN1bSArPSBlbGV2O1xuICAgICAgfVxuICAgICAgc3VtIC89IGtlcm5lbFNpemU7XG4gICAgICBlbGV2YXRlZFBvc2l0aW9uc1tpXVsyXSA9IHN1bTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZXZhdGVkUG9zaXRpb25zO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUxpbmVTdHJpbmcobHMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAobHMudHlwZSAhPT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIEdlb0pTT04gTGluZVN0cmluZ1wiKTtcbiAgfVxuICBvcHRpb25zLmNvbXB1dGVPbiA/PyAob3B0aW9ucy5jb21wdXRlT24gPSBjYW5QYXJzZVBpeGVsRGF0YSgpID8gXCJjbGllbnRcIiA6IFwic2VydmVyXCIpO1xuICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShscyk7XG4gIGNvbnN0IGVsZXZhdGVkUG9zaXRpb25zID0gYXdhaXQgYmF0Y2goY2xvbmUuY29vcmRpbmF0ZXMsIG9wdGlvbnMpO1xuICBjbG9uZS5jb29yZGluYXRlcyA9IGVsZXZhdGVkUG9zaXRpb25zO1xuICByZXR1cm4gY2xvbmU7XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tTXVsdGlMaW5lU3RyaW5nKGxzLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKGxzLnR5cGUgIT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIEdlb0pTT04gTXVsdGlMaW5lU3RyaW5nXCIpO1xuICB9XG4gIG9wdGlvbnMuY29tcHV0ZU9uID8/IChvcHRpb25zLmNvbXB1dGVPbiA9IGNhblBhcnNlUGl4ZWxEYXRhKCkgPyBcImNsaWVudFwiIDogXCJzZXJ2ZXJcIik7XG4gIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKGxzKTtcbiAgY29uc3QgbXVsdGlMZW5ndGhzID0gY2xvbmUuY29vcmRpbmF0ZXMubWFwKChwb3NzKSA9PiBwb3NzLmxlbmd0aCk7XG4gIGNvbnN0IGZsYXR0ZW5Qb3NpdGlvbnMgPSBjbG9uZS5jb29yZGluYXRlcy5mbGF0KCk7XG4gIGNvbnN0IGZsYXR0ZW5Qb3NpdGlvbnNFbGV2YXRlZCA9IGF3YWl0IGJhdGNoKGZsYXR0ZW5Qb3NpdGlvbnMsIG9wdGlvbnMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBsZW5ndGggb2YgbXVsdGlMZW5ndGhzKSB7XG4gICAgcmVzdWx0LnB1c2goZmxhdHRlblBvc2l0aW9uc0VsZXZhdGVkLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCkpO1xuICAgIGluZGV4ICs9IGxlbmd0aDtcbiAgfVxuICBjbG9uZS5jb29yZGluYXRlcyA9IHJlc3VsdDtcbiAgcmV0dXJuIGNsb25lO1xufVxuY29uc3QgZWxldmF0aW9uID0ge1xuICBhdCxcbiAgYmF0Y2gsXG4gIGZyb21MaW5lU3RyaW5nLFxuICBmcm9tTXVsdGlMaW5lU3RyaW5nXG59O1xuXG5leHBvcnQgeyBDbGllbnRDb25maWcsIElTT0xhbmd1YWdlLCBMYW5ndWFnZSwgTWFwU3R5bGUsIE1hcFN0eWxlVmFyaWFudCwgTm9uSVNPTGFuZ3VhZ2UsIFJlZmVyZW5jZU1hcFN0eWxlLCBTZXJ2aWNlRXJyb3IsIGFyZVNhbWVMYW5ndWFnZXMsIGJ1ZmZlclRvUGl4ZWxEYXRhQnJvd3NlciwgY2FuUGFyc2VQaXhlbERhdGEsIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlLCBjb25maWcsIGNvb3JkaW5hdGVzLCBkYXRhLCBlbGV2YXRpb24sIGV4cGFuZE1hcFN0eWxlLCBnZW9jb2RpbmcsIGdlb2xvY2F0aW9uLCBnZXRBdXRvTGFuZ3VhZ2UsIGdldEJ1ZmZlclRvUGl4ZWxEYXRhUGFyc2VyLCBnZXRMYW5ndWFnZUluZm9Gcm9tQ29kZSwgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUZsYWcsIGdldExhbmd1YWdlSW5mb0Zyb21LZXksIGdldFRpbGVDYWNoZSwgaXNMYW5ndWFnZUluZm8sIG1hcFN0eWxlUHJlc2V0TGlzdCwgbWF0aCwgbWlzYywgc3RhdGljTWFwcywgc3R5bGVUb1N0eWxlLCB0b0xhbmd1YWdlSW5mbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwdGlsZXItY2xpZW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@maptiler/leaflet-maptilersdk/dist/leaflet-maptilersdk.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@maptiler/leaflet-maptilersdk/dist/leaflet-maptilersdk.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Language: () => (/* reexport safe */ _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.Language),\n/* harmony export */   MapStyle: () => (/* reexport safe */ _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.MapStyle),\n/* harmony export */   MaptilerLayer: () => (/* binding */ d),\n/* harmony export */   maptilerLayer: () => (/* binding */ f)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"(ssr)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @maptiler/sdk */ \"(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs\");\n\n\n\nconst _ = \"@maptiler/leaflet-maptilersdk\", c = \"4.1.1\", d = leaflet__WEBPACK_IMPORTED_MODULE_0__.Layer.extend({\n  options: {\n    updateInterval: 32,\n    // How much to extend the overlay view (relative to map size)\n    // e.g. 0.1 would be 10% of map view in each direction\n    padding: 0.1,\n    // whether or not to register the mouse and keyboard\n    // events on the maptiler sdk overlay\n    interactive: !1,\n    // set the tilepane as the default pane to draw gl tiles\n    pane: \"tilePane\"\n  },\n  map: null,\n  initialize: function(t) {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.setOptions(this, t), this._throttledUpdate = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.throttle(this._update, this.options.updateInterval, this);\n  },\n  onAdd: function(t) {\n    var o;\n    this._container || this._initContainer();\n    const i = this.getPaneName();\n    (o = t.getPane(i)) == null || o.appendChild(this._container), this._initMaptilerSDK(), this._offset = this._map.containerPointToLayerPoint([0, 0]), t.options.zoomAnimation && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.on(\n      // @ts-ignore\n      t._proxy,\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.TRANSITION_END,\n      this._transitionEnd,\n      this\n    ), t.attributionControl.addAttribution(\n      '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> <a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>'\n    );\n  },\n  onRemove: function(t) {\n    var o;\n    this._map._proxy && this._map.options.zoomAnimation && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.off(this._map._proxy, leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.TRANSITION_END, this._transitionEnd, this);\n    const i = this.getPaneName();\n    (o = t.getPane(i)) == null || o.removeChild(this._container), this._maptilerMap.remove(), this._maptilerMap = null;\n  },\n  getEvents: function() {\n    return {\n      move: this._throttledUpdate,\n      // sensibly throttle updating while panning\n      zoomanim: this._animateZoom,\n      // applys the zoom animation to the <canvas>\n      zoom: this._pinchZoom,\n      // animate every zoom event for smoother pinch-zooming\n      zoomstart: this._zoomStart,\n      // flag starting a zoom to disable panning\n      zoomend: this._zoomEnd,\n      resize: this._resize\n    };\n  },\n  getMaptilerSDKMap: function() {\n    return this._maptilerMap;\n  },\n  getCanvas: function() {\n    return this._maptilerMap.getCanvas();\n  },\n  getSize: function() {\n    return this._map.getSize().multiplyBy(1 + this.options.padding * 2);\n  },\n  getBounds: function() {\n    const t = this.getSize().multiplyBy(0.5), i = this._map.latLngToContainerPoint(this._map.getCenter());\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(\n      this._map.containerPointToLatLng(i.subtract(t)),\n      this._map.containerPointToLatLng(i.add(t))\n    );\n  },\n  getContainer: function() {\n    return this._container;\n  },\n  // returns the pane name set in options if it is a valid pane, defaults to tilePane\n  getPaneName: function() {\n    return this._map.getPane(this.options.pane) ? this.options.pane : \"tilePane\";\n  },\n  setStyle: function(t) {\n    this._maptilerMap.setStyle(t);\n  },\n  setLanguage: function(t) {\n    this._maptilerMap.setLanguage(t);\n  },\n  _roundPoint: (t) => ({ x: Math.round(t.x), y: Math.round(t.y) }),\n  _initContainer: function() {\n    this._container = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create(\"div\", \"leaflet-gl-layer\");\n    const t = this.getSize(), i = this._map.getSize().multiplyBy(this.options.padding);\n    this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`;\n    const o = this._map.containerPointToLayerPoint([0, 0]).subtract(i);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setPosition(this._container, this._roundPoint(o));\n  },\n  _initMaptilerSDK: function() {\n    const t = this._map.getCenter(), i = this.options.maxBounds ? this.options.maxBounds : [\n      [Number.NEGATIVE_INFINITY, -90],\n      [Number.POSITIVE_INFINITY, 90]\n    ];\n    this._map.setMaxBounds(\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(i[0][1], i[0][0]), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(i[1][1], i[1][0]))\n    );\n    const o = {\n      maxBounds: i,\n      ...this.options,\n      projection: \"mercator\",\n      container: this._container,\n      center: [t.lng, t.lat],\n      zoom: this._map.getZoom() - 1,\n      attributionControl: !1\n    };\n    this.options.geolocate && (o.center = void 0, o.zoom = void 0), this._maptilerMap = new _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.Map(o), this._maptilerMap.telemetry.registerModule(_, c), this._maptilerMap.once(\"load\", () => {\n      this.fire(\"ready\");\n    }), this._maptilerMap.once(\"load\", async () => {\n      let a = { logo: null };\n      try {\n        const p = Object.keys(this._maptilerMap.style.sourceCaches).map((s) => this._maptilerMap.getSource(s)).filter((s) => s && \"url\" in s && typeof s.url == \"string\" && (s == null ? void 0 : s.url.includes(\"tiles.json\"))), n = new URL(p[0].url);\n        n.searchParams.has(\"key\") || n.searchParams.append(\"key\", o.apiKey), a = await (await fetch(n.href)).json();\n      } catch {\n      }\n      if (a.logo || o.maptilerLogo) {\n        const p = a.logo ?? \"https://api.maptiler.com/resources/logo.svg\", n = document.createElement(\"a\");\n        n.href = \"https://www.maptiler.com\", n.style.setProperty(\"position\", \"absolute\"), n.style.setProperty(\"left\", \"10px\"), n.style.setProperty(\"bottom\", \"2px\"), n.style.setProperty(\"z-index\", \"999\");\n        const l = document.createElement(\"img\");\n        l.src = p, l.alt = \"MapTiler logo\", l.width = 100, l.height = 30, n.appendChild(l), this._map.getContainer().appendChild(n);\n      }\n    }), this._maptilerMap.transform.freezeElevation = !0, this.options.geolocate && this._maptilerMap.on(\"load\", () => {\n      this._map.setView(this._maptilerMap.getCenter(), this._maptilerMap.getZoom() + 1);\n    }), this._transformGL(), this._maptilerMap._actualCanvas = this._maptilerMap._canvas;\n    const r = this._maptilerMap._actualCanvas;\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, \"leaflet-image-layer\"), leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, \"leaflet-zoom-animated\"), this.options.interactive && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, \"leaflet-interactive\"), this.options.className && leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(r, this.options.className), this.addHeatmap = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addHeatmap(this._maptilerMap, a), this.addPolygon = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addPolygon(this._maptilerMap, a), this.addPoint = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addPoint(this._maptilerMap, a), this.addPolyline = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.addPolyline(this._maptilerMap, a), this.takeScreenshot = (a) => _maptiler_sdk__WEBPACK_IMPORTED_MODULE_1__.helpers.takeScreenshot(this._maptilerMap, a);\n  },\n  _update: function() {\n    if (this._offset = this._map.containerPointToLayerPoint([0, 0]), this._zooming)\n      return;\n    const t = this.getSize(), i = this._map.getSize().multiplyBy(this.options.padding), o = this._map.containerPointToLayerPoint([0, 0]).subtract(i);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setPosition(this._container, this._roundPoint(o)), this._transformGL(), this._maptilerMap.transform.width !== t.x || this._maptilerMap.transform.height !== t.y ? (this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`, this._maptilerMap._resize !== null && this._maptilerMap._resize !== void 0 ? this._maptilerMap._resize() : this._maptilerMap.resize()) : this._maptilerMap._update !== null && this._maptilerMap._update !== void 0 ? this._maptilerMap._update() : this._maptilerMap.update();\n  },\n  _transformGL: function() {\n    this._maptilerMap.setCenter(this._map.getCenter()), this._maptilerMap.setZoom(this._map.getZoom() - 1);\n  },\n  // update the map constantly during a pinch zoom\n  _pinchZoom: function() {\n    this._maptilerMap.jumpTo({\n      zoom: this._map.getZoom() - 1,\n      center: this._map.getCenter()\n    });\n  },\n  // borrowed from L.ImageOverlay\n  // https://github.com/Leaflet/Leaflet/blob/master/src/layer/ImageOverlay.js#L139-L144\n  _animateZoom: function(t) {\n    const i = this._map.getZoomScale(t.zoom), o = this._map.getSize().multiplyBy(this.options.padding * i), r = this.getSize()._divideBy(2), a = this._map.project(t.center, t.zoom)._subtract(r)._add(this._map._getMapPanePos().add(o))._round(), p = this._map.project(this._map.getBounds().getNorthWest(), t.zoom)._subtract(a);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setTransform(this._maptilerMap.getCanvas(), p.subtract(this._offset), i);\n  },\n  _zoomStart: function() {\n    this._zooming = !0;\n  },\n  _zoomEnd: function() {\n    const t = this._map.getZoomScale(this._map.getZoom());\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setTransform(\n      this._maptilerMap.getCanvas(),\n      // https://github.com/mapbox/mapbox-gl-leaflet/pull/130\n      new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0),\n      t\n    ), this._zooming = !1, this._update();\n  },\n  _transitionEnd: function() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(() => {\n      const t = this._map.getZoom(), i = this._map.getCenter(), o = this._map.latLngToContainerPoint(this._map.getBounds().getNorthWest());\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setTransform(this._maptilerMap._actualCanvas, o, 1), this._maptilerMap.once(\n        \"moveend\",\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(() => {\n          this._zoomEnd();\n        }, this)\n      ), this._maptilerMap.jumpTo({\n        center: i,\n        zoom: t - 1\n      });\n    }, this);\n  },\n  // @ts-ignore\n  _resize: function(t) {\n    this._transitionEnd(t);\n  }\n});\nfunction f(t) {\n  return new d(t);\n}\n\n//# sourceMappingURL=leaflet-maptilersdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2xlYWZsZXQtbWFwdGlsZXJzZGsvZGlzdC9sZWFmbGV0LW1hcHRpbGVyc2RrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QjtBQUMrQjtBQUNNO0FBQzdELDREQUE0RCwwQ0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSwrQ0FBWSxtQ0FBbUMseUNBQU07QUFDekQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUxBQW1MLDZDQUFVO0FBQzdMO0FBQ0E7QUFDQSxNQUFNLDRDQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNGQUFzRjtBQUNsSztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkRBQTJELDZDQUFVLHVCQUF1Qiw0Q0FBUztBQUNyRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLGlEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBLHNCQUFzQiw0Q0FBUztBQUMvQjtBQUNBLHFDQUFxQyxJQUFJLHVDQUF1QyxJQUFJO0FBQ3BGO0FBQ0EsSUFBSSw0Q0FBUztBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlEQUFjLENBQUMsMkNBQVEsb0JBQW9CLDJDQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDhDQUFDO0FBQzdGO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLDRDQUFTLHFDQUFxQyw0Q0FBUyxtRUFBbUUsNENBQVMsK0RBQStELDRDQUFTLCtEQUErRCxrREFBQyw0REFBNEQsa0RBQUMsMERBQTBELGtEQUFDLDJEQUEyRCxrREFBQyxpRUFBaUUsa0RBQUM7QUFDcmdCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNENBQVMscU1BQXFNLElBQUksdUNBQXVDLElBQUk7QUFDalEsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUFTO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksNENBQVM7QUFDYjtBQUNBO0FBQ0EsVUFBVSwwQ0FBTztBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSx5Q0FBTTtBQUNWO0FBQ0EsTUFBTSw0Q0FBUztBQUNmO0FBQ0EsUUFBUSx5Q0FBTTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBwbGllci1kaXJlY3RvcnkvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL2xlYWZsZXQtbWFwdGlsZXJzZGsvZGlzdC9sZWFmbGV0LW1hcHRpbGVyc2RrLmpzPzNjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGUgZnJvbSBcImxlYWZsZXRcIjtcbmltcG9ydCB7IE1hcCBhcyBoLCBoZWxwZXJzIGFzIG0gfSBmcm9tIFwiQG1hcHRpbGVyL3Nka1wiO1xuaW1wb3J0IHsgTGFuZ3VhZ2UgYXMgeiwgTWFwU3R5bGUgYXMgUCB9IGZyb20gXCJAbWFwdGlsZXIvc2RrXCI7XG5jb25zdCBfID0gXCJAbWFwdGlsZXIvbGVhZmxldC1tYXB0aWxlcnNka1wiLCBjID0gXCI0LjEuMVwiLCBkID0gZS5MYXllci5leHRlbmQoe1xuICBvcHRpb25zOiB7XG4gICAgdXBkYXRlSW50ZXJ2YWw6IDMyLFxuICAgIC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgb3ZlcmxheSB2aWV3IChyZWxhdGl2ZSB0byBtYXAgc2l6ZSlcbiAgICAvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cbiAgICBwYWRkaW5nOiAwLjEsXG4gICAgLy8gd2hldGhlciBvciBub3QgdG8gcmVnaXN0ZXIgdGhlIG1vdXNlIGFuZCBrZXlib2FyZFxuICAgIC8vIGV2ZW50cyBvbiB0aGUgbWFwdGlsZXIgc2RrIG92ZXJsYXlcbiAgICBpbnRlcmFjdGl2ZTogITEsXG4gICAgLy8gc2V0IHRoZSB0aWxlcGFuZSBhcyB0aGUgZGVmYXVsdCBwYW5lIHRvIGRyYXcgZ2wgdGlsZXNcbiAgICBwYW5lOiBcInRpbGVQYW5lXCJcbiAgfSxcbiAgbWFwOiBudWxsLFxuICBpbml0aWFsaXplOiBmdW5jdGlvbih0KSB7XG4gICAgZS5zZXRPcHRpb25zKHRoaXMsIHQpLCB0aGlzLl90aHJvdHRsZWRVcGRhdGUgPSBlLlV0aWwudGhyb3R0bGUodGhpcy5fdXBkYXRlLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuICB9LFxuICBvbkFkZDogZnVuY3Rpb24odCkge1xuICAgIHZhciBvO1xuICAgIHRoaXMuX2NvbnRhaW5lciB8fCB0aGlzLl9pbml0Q29udGFpbmVyKCk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0UGFuZU5hbWUoKTtcbiAgICAobyA9IHQuZ2V0UGFuZShpKSkgPT0gbnVsbCB8fCBvLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX2luaXRNYXB0aWxlclNESygpLCB0aGlzLl9vZmZzZXQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoWzAsIDBdKSwgdC5vcHRpb25zLnpvb21BbmltYXRpb24gJiYgZS5Eb21FdmVudC5vbihcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHQuX3Byb3h5LFxuICAgICAgZS5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELFxuICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZCxcbiAgICAgIHRoaXNcbiAgICApLCB0LmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbihcbiAgICAgICc8YSBocmVmPVwiaHR0cHM6Ly93d3cubWFwdGlsZXIuY29tL2NvcHlyaWdodC9cIiB0YXJnZXQ9XCJfYmxhbmtcIj4mY29weTsgTWFwVGlsZXI8L2E+IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIiB0YXJnZXQ9XCJfYmxhbmtcIj4mY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnM8L2E+J1xuICAgICk7XG4gIH0sXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIG87XG4gICAgdGhpcy5fbWFwLl9wcm94eSAmJiB0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIGUuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fcHJveHksIGUuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fdHJhbnNpdGlvbkVuZCwgdGhpcyk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0UGFuZU5hbWUoKTtcbiAgICAobyA9IHQuZ2V0UGFuZShpKSkgPT0gbnVsbCB8fCBvLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX21hcHRpbGVyTWFwLnJlbW92ZSgpLCB0aGlzLl9tYXB0aWxlck1hcCA9IG51bGw7XG4gIH0sXG4gIGdldEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdmU6IHRoaXMuX3Rocm90dGxlZFVwZGF0ZSxcbiAgICAgIC8vIHNlbnNpYmx5IHRocm90dGxlIHVwZGF0aW5nIHdoaWxlIHBhbm5pbmdcbiAgICAgIHpvb21hbmltOiB0aGlzLl9hbmltYXRlWm9vbSxcbiAgICAgIC8vIGFwcGx5cyB0aGUgem9vbSBhbmltYXRpb24gdG8gdGhlIDxjYW52YXM+XG4gICAgICB6b29tOiB0aGlzLl9waW5jaFpvb20sXG4gICAgICAvLyBhbmltYXRlIGV2ZXJ5IHpvb20gZXZlbnQgZm9yIHNtb290aGVyIHBpbmNoLXpvb21pbmdcbiAgICAgIHpvb21zdGFydDogdGhpcy5fem9vbVN0YXJ0LFxuICAgICAgLy8gZmxhZyBzdGFydGluZyBhIHpvb20gdG8gZGlzYWJsZSBwYW5uaW5nXG4gICAgICB6b29tZW5kOiB0aGlzLl96b29tRW5kLFxuICAgICAgcmVzaXplOiB0aGlzLl9yZXNpemVcbiAgICB9O1xuICB9LFxuICBnZXRNYXB0aWxlclNES01hcDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcHRpbGVyTWFwO1xuICB9LFxuICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXB0aWxlck1hcC5nZXRDYW52YXMoKTtcbiAgfSxcbiAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgxICsgdGhpcy5vcHRpb25zLnBhZGRpbmcgKiAyKTtcbiAgfSxcbiAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUpLCBpID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5fbWFwLmdldENlbnRlcigpKTtcbiAgICByZXR1cm4gZS5sYXRMbmdCb3VuZHMoXG4gICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhpLnN1YnRyYWN0KHQpKSxcbiAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKGkuYWRkKHQpKVxuICAgICk7XG4gIH0sXG4gIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgfSxcbiAgLy8gcmV0dXJucyB0aGUgcGFuZSBuYW1lIHNldCBpbiBvcHRpb25zIGlmIGl0IGlzIGEgdmFsaWQgcGFuZSwgZGVmYXVsdHMgdG8gdGlsZVBhbmVcbiAgZ2V0UGFuZU5hbWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZSh0aGlzLm9wdGlvbnMucGFuZSkgPyB0aGlzLm9wdGlvbnMucGFuZSA6IFwidGlsZVBhbmVcIjtcbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLl9tYXB0aWxlck1hcC5zZXRTdHlsZSh0KTtcbiAgfSxcbiAgc2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLl9tYXB0aWxlck1hcC5zZXRMYW5ndWFnZSh0KTtcbiAgfSxcbiAgX3JvdW5kUG9pbnQ6ICh0KSA9PiAoeyB4OiBNYXRoLnJvdW5kKHQueCksIHk6IE1hdGgucm91bmQodC55KSB9KSxcbiAgX2luaXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGUuRG9tVXRpbC5jcmVhdGUoXCJkaXZcIiwgXCJsZWFmbGV0LWdsLWxheWVyXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFNpemUoKSwgaSA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSh0aGlzLm9wdGlvbnMucGFkZGluZyk7XG4gICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7dC54fXB4YCwgdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke3QueX1weGA7XG4gICAgY29uc3QgbyA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChbMCwgMF0pLnN1YnRyYWN0KGkpO1xuICAgIGUuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRoaXMuX3JvdW5kUG9pbnQobykpO1xuICB9LFxuICBfaW5pdE1hcHRpbGVyU0RLOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbWFwLmdldENlbnRlcigpLCBpID0gdGhpcy5vcHRpb25zLm1heEJvdW5kcyA/IHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgOiBbXG4gICAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCAtOTBdLFxuICAgICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgOTBdXG4gICAgXTtcbiAgICB0aGlzLl9tYXAuc2V0TWF4Qm91bmRzKFxuICAgICAgZS5sYXRMbmdCb3VuZHMoZS5sYXRMbmcoaVswXVsxXSwgaVswXVswXSksIGUubGF0TG5nKGlbMV1bMV0sIGlbMV1bMF0pKVxuICAgICk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIG1heEJvdW5kczogaSxcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIHByb2plY3Rpb246IFwibWVyY2F0b3JcIixcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxuICAgICAgY2VudGVyOiBbdC5sbmcsIHQubGF0XSxcbiAgICAgIHpvb206IHRoaXMuX21hcC5nZXRab29tKCkgLSAxLFxuICAgICAgYXR0cmlidXRpb25Db250cm9sOiAhMVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLmdlb2xvY2F0ZSAmJiAoby5jZW50ZXIgPSB2b2lkIDAsIG8uem9vbSA9IHZvaWQgMCksIHRoaXMuX21hcHRpbGVyTWFwID0gbmV3IGgobyksIHRoaXMuX21hcHRpbGVyTWFwLnRlbGVtZXRyeS5yZWdpc3Rlck1vZHVsZShfLCBjKSwgdGhpcy5fbWFwdGlsZXJNYXAub25jZShcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5maXJlKFwicmVhZHlcIik7XG4gICAgfSksIHRoaXMuX21hcHRpbGVyTWFwLm9uY2UoXCJsb2FkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBhID0geyBsb2dvOiBudWxsIH07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwID0gT2JqZWN0LmtleXModGhpcy5fbWFwdGlsZXJNYXAuc3R5bGUuc291cmNlQ2FjaGVzKS5tYXAoKHMpID0+IHRoaXMuX21hcHRpbGVyTWFwLmdldFNvdXJjZShzKSkuZmlsdGVyKChzKSA9PiBzICYmIFwidXJsXCIgaW4gcyAmJiB0eXBlb2Ygcy51cmwgPT0gXCJzdHJpbmdcIiAmJiAocyA9PSBudWxsID8gdm9pZCAwIDogcy51cmwuaW5jbHVkZXMoXCJ0aWxlcy5qc29uXCIpKSksIG4gPSBuZXcgVVJMKHBbMF0udXJsKTtcbiAgICAgICAgbi5zZWFyY2hQYXJhbXMuaGFzKFwia2V5XCIpIHx8IG4uc2VhcmNoUGFyYW1zLmFwcGVuZChcImtleVwiLCBvLmFwaUtleSksIGEgPSBhd2FpdCAoYXdhaXQgZmV0Y2gobi5ocmVmKSkuanNvbigpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpZiAoYS5sb2dvIHx8IG8ubWFwdGlsZXJMb2dvKSB7XG4gICAgICAgIGNvbnN0IHAgPSBhLmxvZ28gPz8gXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vcmVzb3VyY2VzL2xvZ28uc3ZnXCIsIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbi5ocmVmID0gXCJodHRwczovL3d3dy5tYXB0aWxlci5jb21cIiwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIiksIG4uc3R5bGUuc2V0UHJvcGVydHkoXCJsZWZ0XCIsIFwiMTBweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcImJvdHRvbVwiLCBcIjJweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcInotaW5kZXhcIiwgXCI5OTlcIik7XG4gICAgICAgIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBsLnNyYyA9IHAsIGwuYWx0ID0gXCJNYXBUaWxlciBsb2dvXCIsIGwud2lkdGggPSAxMDAsIGwuaGVpZ2h0ID0gMzAsIG4uYXBwZW5kQ2hpbGQobCksIHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChuKTtcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5fbWFwdGlsZXJNYXAudHJhbnNmb3JtLmZyZWV6ZUVsZXZhdGlvbiA9ICEwLCB0aGlzLm9wdGlvbnMuZ2VvbG9jYXRlICYmIHRoaXMuX21hcHRpbGVyTWFwLm9uKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXAuc2V0Vmlldyh0aGlzLl9tYXB0aWxlck1hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwdGlsZXJNYXAuZ2V0Wm9vbSgpICsgMSk7XG4gICAgfSksIHRoaXMuX3RyYW5zZm9ybUdMKCksIHRoaXMuX21hcHRpbGVyTWFwLl9hY3R1YWxDYW52YXMgPSB0aGlzLl9tYXB0aWxlck1hcC5fY2FudmFzO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9tYXB0aWxlck1hcC5fYWN0dWFsQ2FudmFzO1xuICAgIGUuRG9tVXRpbC5hZGRDbGFzcyhyLCBcImxlYWZsZXQtaW1hZ2UtbGF5ZXJcIiksIGUuRG9tVXRpbC5hZGRDbGFzcyhyLCBcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSwgdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICYmIGUuRG9tVXRpbC5hZGRDbGFzcyhyLCBcImxlYWZsZXQtaW50ZXJhY3RpdmVcIiksIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgJiYgZS5Eb21VdGlsLmFkZENsYXNzKHIsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpLCB0aGlzLmFkZEhlYXRtYXAgPSAoYSkgPT4gbS5hZGRIZWF0bWFwKHRoaXMuX21hcHRpbGVyTWFwLCBhKSwgdGhpcy5hZGRQb2x5Z29uID0gKGEpID0+IG0uYWRkUG9seWdvbih0aGlzLl9tYXB0aWxlck1hcCwgYSksIHRoaXMuYWRkUG9pbnQgPSAoYSkgPT4gbS5hZGRQb2ludCh0aGlzLl9tYXB0aWxlck1hcCwgYSksIHRoaXMuYWRkUG9seWxpbmUgPSAoYSkgPT4gbS5hZGRQb2x5bGluZSh0aGlzLl9tYXB0aWxlck1hcCwgYSksIHRoaXMudGFrZVNjcmVlbnNob3QgPSAoYSkgPT4gbS50YWtlU2NyZWVuc2hvdCh0aGlzLl9tYXB0aWxlck1hcCwgYSk7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9vZmZzZXQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoWzAsIDBdKSwgdGhpcy5fem9vbWluZylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRTaXplKCksIGkgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkodGhpcy5vcHRpb25zLnBhZGRpbmcpLCBvID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KFswLCAwXSkuc3VidHJhY3QoaSk7XG4gICAgZS5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fcm91bmRQb2ludChvKSksIHRoaXMuX3RyYW5zZm9ybUdMKCksIHRoaXMuX21hcHRpbGVyTWFwLnRyYW5zZm9ybS53aWR0aCAhPT0gdC54IHx8IHRoaXMuX21hcHRpbGVyTWFwLnRyYW5zZm9ybS5oZWlnaHQgIT09IHQueSA/ICh0aGlzLl9jb250YWluZXIuc3R5bGUud2lkdGggPSBgJHt0Lnh9cHhgLCB0aGlzLl9jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7dC55fXB4YCwgdGhpcy5fbWFwdGlsZXJNYXAuX3Jlc2l6ZSAhPT0gbnVsbCAmJiB0aGlzLl9tYXB0aWxlck1hcC5fcmVzaXplICE9PSB2b2lkIDAgPyB0aGlzLl9tYXB0aWxlck1hcC5fcmVzaXplKCkgOiB0aGlzLl9tYXB0aWxlck1hcC5yZXNpemUoKSkgOiB0aGlzLl9tYXB0aWxlck1hcC5fdXBkYXRlICE9PSBudWxsICYmIHRoaXMuX21hcHRpbGVyTWFwLl91cGRhdGUgIT09IHZvaWQgMCA/IHRoaXMuX21hcHRpbGVyTWFwLl91cGRhdGUoKSA6IHRoaXMuX21hcHRpbGVyTWFwLnVwZGF0ZSgpO1xuICB9LFxuICBfdHJhbnNmb3JtR0w6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcHRpbGVyTWFwLnNldENlbnRlcih0aGlzLl9tYXAuZ2V0Q2VudGVyKCkpLCB0aGlzLl9tYXB0aWxlck1hcC5zZXRab29tKHRoaXMuX21hcC5nZXRab29tKCkgLSAxKTtcbiAgfSxcbiAgLy8gdXBkYXRlIHRoZSBtYXAgY29uc3RhbnRseSBkdXJpbmcgYSBwaW5jaCB6b29tXG4gIF9waW5jaFpvb206IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcHRpbGVyTWFwLmp1bXBUbyh7XG4gICAgICB6b29tOiB0aGlzLl9tYXAuZ2V0Wm9vbSgpIC0gMSxcbiAgICAgIGNlbnRlcjogdGhpcy5fbWFwLmdldENlbnRlcigpXG4gICAgfSk7XG4gIH0sXG4gIC8vIGJvcnJvd2VkIGZyb20gTC5JbWFnZU92ZXJsYXlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9ibG9iL21hc3Rlci9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzI0wxMzktTDE0NFxuICBfYW5pbWF0ZVpvb206IGZ1bmN0aW9uKHQpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh0Lnpvb20pLCBvID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KHRoaXMub3B0aW9ucy5wYWRkaW5nICogaSksIHIgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMiksIGEgPSB0aGlzLl9tYXAucHJvamVjdCh0LmNlbnRlciwgdC56b29tKS5fc3VidHJhY3QocikuX2FkZCh0aGlzLl9tYXAuX2dldE1hcFBhbmVQb3MoKS5hZGQobykpLl9yb3VuZCgpLCBwID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fbWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLCB0Lnpvb20pLl9zdWJ0cmFjdChhKTtcbiAgICBlLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX21hcHRpbGVyTWFwLmdldENhbnZhcygpLCBwLnN1YnRyYWN0KHRoaXMuX29mZnNldCksIGkpO1xuICB9LFxuICBfem9vbVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl96b29taW5nID0gITA7XG4gIH0sXG4gIF96b29tRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICBlLkRvbVV0aWwuc2V0VHJhbnNmb3JtKFxuICAgICAgdGhpcy5fbWFwdGlsZXJNYXAuZ2V0Q2FudmFzKCksXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1sZWFmbGV0L3B1bGwvMTMwXG4gICAgICBuZXcgZS5Qb2ludCgwLCAwKSxcbiAgICAgIHRcbiAgICApLCB0aGlzLl96b29taW5nID0gITEsIHRoaXMuX3VwZGF0ZSgpO1xuICB9LFxuICBfdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgZS5VdGlsLnJlcXVlc3RBbmltRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX21hcC5nZXRab29tKCksIGkgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIG8gPSB0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuZ2V0Tm9ydGhXZXN0KCkpO1xuICAgICAgZS5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9tYXB0aWxlck1hcC5fYWN0dWFsQ2FudmFzLCBvLCAxKSwgdGhpcy5fbWFwdGlsZXJNYXAub25jZShcbiAgICAgICAgXCJtb3ZlZW5kXCIsXG4gICAgICAgIGUuVXRpbC5iaW5kKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl96b29tRW5kKCk7XG4gICAgICAgIH0sIHRoaXMpXG4gICAgICApLCB0aGlzLl9tYXB0aWxlck1hcC5qdW1wVG8oe1xuICAgICAgICBjZW50ZXI6IGksXG4gICAgICAgIHpvb206IHQgLSAxXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBfcmVzaXplOiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5fdHJhbnNpdGlvbkVuZCh0KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBmKHQpIHtcbiAgcmV0dXJuIG5ldyBkKHQpO1xufVxuZXhwb3J0IHtcbiAgeiBhcyBMYW5ndWFnZSxcbiAgUCBhcyBNYXBTdHlsZSxcbiAgZCBhcyBNYXB0aWxlckxheWVyLFxuICBmIGFzIG1hcHRpbGVyTGF5ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0LW1hcHRpbGVyc2RrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/leaflet-maptilersdk/dist/leaflet-maptilersdk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AJAXError: () => (/* binding */ Pp),\n/* harmony export */   AttributionControl: () => (/* binding */ Bc),\n/* harmony export */   AttributionControlMLGL: () => (/* binding */ dp),\n/* harmony export */   BoxZoomHandler: () => (/* binding */ Vc),\n/* harmony export */   BoxZoomHandlerMLGL: () => (/* binding */ vp),\n/* harmony export */   CanvasSource: () => (/* binding */ Fc),\n/* harmony export */   CanvasSourceMLGL: () => (/* binding */ ap),\n/* harmony export */   ColorRamp: () => (/* binding */ A),\n/* harmony export */   ColorRampCollection: () => (/* binding */ Xo),\n/* harmony export */   CooperativeGesturesHandler: () => (/* binding */ Hc),\n/* harmony export */   CooperativeGesturesHandlerMLGL: () => (/* binding */ wp),\n/* harmony export */   CubemapFaceNames: () => (/* binding */ Ue),\n/* harmony export */   CubemapImagesPresets: () => (/* binding */ _u),\n/* harmony export */   CubemapLayer: () => (/* binding */ Pr),\n/* harmony export */   DOMcreate: () => (/* binding */ Le),\n/* harmony export */   DOMremove: () => (/* binding */ kt),\n/* harmony export */   DoubleClickZoomHandler: () => (/* binding */ Up),\n/* harmony export */   DragPanHandler: () => (/* binding */ Np),\n/* harmony export */   DragRotateHandler: () => (/* binding */ Op),\n/* harmony export */   EdgeInsets: () => (/* binding */ $p),\n/* harmony export */   Evented: () => (/* binding */ Mp),\n/* harmony export */   FullscreenControl: () => (/* binding */ Fi),\n/* harmony export */   FullscreenControlMLGL: () => (/* binding */ yp),\n/* harmony export */   GeoJSONSource: () => (/* binding */ $c),\n/* harmony export */   GeoJSONSourceMLGL: () => (/* binding */ op),\n/* harmony export */   GeolocateControl: () => (/* binding */ Pi),\n/* harmony export */   GeolocateControlMLGL: () => (/* binding */ fp),\n/* harmony export */   GeolocationType: () => (/* binding */ qu),\n/* harmony export */   Hash: () => (/* binding */ Fp),\n/* harmony export */   ImageSource: () => (/* binding */ Oc),\n/* harmony export */   ImageSourceMLGL: () => (/* binding */ ip),\n/* harmony export */   ImageViewer: () => (/* binding */ Jc),\n/* harmony export */   ImageViewerEvent: () => (/* binding */ ae),\n/* harmony export */   KeyboardHandler: () => (/* binding */ Zc),\n/* harmony export */   KeyboardHandlerMLGL: () => (/* binding */ Sp),\n/* harmony export */   Language: () => (/* binding */ z),\n/* harmony export */   LngLat: () => (/* binding */ kc),\n/* harmony export */   LngLatBounds: () => (/* binding */ Ip),\n/* harmony export */   LogoControl: () => (/* binding */ Ri),\n/* harmony export */   LogoControlMLGL: () => (/* binding */ hp),\n/* harmony export */   Map: () => (/* binding */ Lo),\n/* harmony export */   MapMLGL: () => (/* binding */ ep),\n/* harmony export */   MapMouseEvent: () => (/* binding */ Wc),\n/* harmony export */   MapMouseEventMLGL: () => (/* binding */ Cp),\n/* harmony export */   MapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyle),\n/* harmony export */   MapStyleVariant: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyleVariant),\n/* harmony export */   MapTouchEvent: () => (/* binding */ Yc),\n/* harmony export */   MapTouchEventMLGL: () => (/* binding */ Lp),\n/* harmony export */   MapWheelEvent: () => (/* binding */ Kc),\n/* harmony export */   MapWheelEventMLGL: () => (/* binding */ kp),\n/* harmony export */   MaptilerCustomControl: () => (/* binding */ tu),\n/* harmony export */   MaptilerExternalControl: () => (/* binding */ Gr),\n/* harmony export */   MaptilerGeolocateControl: () => (/* binding */ eu),\n/* harmony export */   MaptilerLogoControl: () => (/* binding */ Nn),\n/* harmony export */   MaptilerNavigationControl: () => (/* binding */ Jl),\n/* harmony export */   MaptilerProjectionControl: () => (/* binding */ ru),\n/* harmony export */   MaptilerTerrainControl: () => (/* binding */ Wl),\n/* harmony export */   Marker: () => (/* binding */ Mc),\n/* harmony export */   MarkerMLGL: () => (/* binding */ tp),\n/* harmony export */   MercatorCoordinate: () => (/* binding */ en),\n/* harmony export */   NavigationControMLGL: () => (/* binding */ pp),\n/* harmony export */   NavigationControl: () => (/* binding */ Ma),\n/* harmony export */   Point: () => (/* binding */ Ko),\n/* harmony export */   Popup: () => (/* binding */ Rc),\n/* harmony export */   PopupMLGL: () => (/* binding */ rp),\n/* harmony export */   RadialGradientLayer: () => (/* binding */ Rr),\n/* harmony export */   RasterDEMTileSource: () => (/* binding */ jc),\n/* harmony export */   RasterDEMTileSourceMLGL: () => (/* binding */ lp),\n/* harmony export */   RasterTileSource: () => (/* binding */ Nc),\n/* harmony export */   RasterTileSourceMLGL: () => (/* binding */ sp),\n/* harmony export */   ReferenceMapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.ReferenceMapStyle),\n/* harmony export */   ScaleControl: () => (/* binding */ zi),\n/* harmony export */   ScaleControlMLGL: () => (/* binding */ mp),\n/* harmony export */   ScrollZoomHandler: () => (/* binding */ Gc),\n/* harmony export */   ScrollZoomHandlerMLGL: () => (/* binding */ bp),\n/* harmony export */   SdkConfig: () => (/* binding */ di),\n/* harmony export */   ServiceError: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.ServiceError),\n/* harmony export */   Style: () => (/* binding */ zc),\n/* harmony export */   StyleMLGL: () => (/* binding */ np),\n/* harmony export */   TerrainControMLGL: () => (/* binding */ gp),\n/* harmony export */   TerrainControl: () => (/* binding */ qc),\n/* harmony export */   TwoFingersTouchPitchHandler: () => (/* binding */ Xc),\n/* harmony export */   TwoFingersTouchPitchHandlerMLGL: () => (/* binding */ xp),\n/* harmony export */   TwoFingersTouchRotateHandler: () => (/* binding */ Bp),\n/* harmony export */   TwoFingersTouchZoomHandler: () => (/* binding */ Dp),\n/* harmony export */   TwoFingersTouchZoomRotateHandler: () => (/* binding */ jp),\n/* harmony export */   VectorTileSource: () => (/* binding */ Uc),\n/* harmony export */   VectorTileSourceMLGL: () => (/* binding */ up),\n/* harmony export */   VideoSource: () => (/* binding */ Dc),\n/* harmony export */   VideoSourceMLGL: () => (/* binding */ cp),\n/* harmony export */   addProtocol: () => (/* binding */ Wp),\n/* harmony export */   addSourceType: () => (/* binding */ Kp),\n/* harmony export */   areSameLanguages: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.areSameLanguages),\n/* harmony export */   bufferToPixelDataBrowser: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.bufferToPixelDataBrowser),\n/* harmony export */   canParsePixelData: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.canParsePixelData),\n/* harmony export */   circumferenceAtLatitude: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.circumferenceAtLatitude),\n/* harmony export */   clearPrewarmedResources: () => (/* binding */ zp),\n/* harmony export */   config: () => (/* binding */ j),\n/* harmony export */   configMLGL: () => (/* binding */ Ep),\n/* harmony export */   coordinates: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.coordinates),\n/* harmony export */   cubemapPresets: () => (/* binding */ He),\n/* harmony export */   data: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.data),\n/* harmony export */   displayWebGLContextLostWarning: () => (/* binding */ Ic),\n/* harmony export */   elevation: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.elevation),\n/* harmony export */   expandMapStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.expandMapStyle),\n/* harmony export */   geocoding: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.geocoding),\n/* harmony export */   geolocation: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.geolocation),\n/* harmony export */   getAutoLanguage: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getAutoLanguage),\n/* harmony export */   getBrowserLanguage: () => (/* binding */ Pn),\n/* harmony export */   getBufferToPixelDataParser: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getBufferToPixelDataParser),\n/* harmony export */   getLanguageInfoFromCode: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getLanguageInfoFromCode),\n/* harmony export */   getLanguageInfoFromFlag: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getLanguageInfoFromFlag),\n/* harmony export */   getLanguageInfoFromKey: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getLanguageInfoFromKey),\n/* harmony export */   getMapLibreVersion: () => (/* binding */ Ap),\n/* harmony export */   getMaxParallelImageRequests: () => (/* binding */ Gp),\n/* harmony export */   getRTLTextPluginStatus: () => (/* binding */ _p),\n/* harmony export */   getTileCache: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getTileCache),\n/* harmony export */   getVersion: () => (/* binding */ xc),\n/* harmony export */   getWebGLSupportError: () => (/* binding */ ki),\n/* harmony export */   getWorkerCount: () => (/* binding */ qp),\n/* harmony export */   getWorkerUrl: () => (/* binding */ Zp),\n/* harmony export */   gpx: () => (/* binding */ Oo),\n/* harmony export */   gpxOrKml: () => (/* binding */ dc),\n/* harmony export */   hasChildNodeWithName: () => (/* binding */ $o),\n/* harmony export */   helpers: () => (/* binding */ Qc),\n/* harmony export */   importScriptInWorkers: () => (/* binding */ Yp),\n/* harmony export */   isLanguageInfo: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.isLanguageInfo),\n/* harmony export */   kml: () => (/* binding */ No),\n/* harmony export */   mapStylePresetList: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.mapStylePresetList),\n/* harmony export */   math: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.math),\n/* harmony export */   misc: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.misc),\n/* harmony export */   prewarm: () => (/* binding */ Rp),\n/* harmony export */   removeProtocol: () => (/* binding */ Jp),\n/* harmony export */   setMaxParallelImageRequests: () => (/* binding */ Hp),\n/* harmony export */   setRTLTextPlugin: () => (/* binding */ Tp),\n/* harmony export */   setWorkerCount: () => (/* binding */ Vp),\n/* harmony export */   setWorkerUrl: () => (/* binding */ Xp),\n/* harmony export */   staticMaps: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.staticMaps),\n/* harmony export */   str2xml: () => (/* binding */ Cn),\n/* harmony export */   styleToStyle: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.styleToStyle),\n/* harmony export */   toLanguageInfo: () => (/* reexport safe */ _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.toLanguageInfo),\n/* harmony export */   toggleProjection: () => (/* binding */ vo),\n/* harmony export */   toggleTerrain: () => (/* binding */ go),\n/* harmony export */   xml2str: () => (/* binding */ La)\n/* harmony export */ });\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maplibre-gl */ \"(ssr)/./node_modules/maplibre-gl/dist/maplibre-gl.js\");\n/* harmony import */ var _maptiler_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @maptiler/client */ \"(ssr)/./node_modules/@maptiler/client/dist/maptiler-client.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm/v4.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\nvar ni = Object.defineProperty;\nvar Tn = (r) => {\n  throw TypeError(r);\n};\nvar ai = (r, e, t) => e in r ? ni(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar v = (r, e, t) => ai(r, typeof e != \"symbol\" ? e + \"\" : e, t), hr = (r, e, t) => e.has(r) || Tn(\"Cannot \" + t);\nvar k = (r, e, t) => (hr(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)), Z = (r, e, t) => e.has(r) ? Tn(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t), K = (r, e, t, n) => (hr(r, e, \"write to private field\"), n ? n.call(r, t) : e.set(r, t), t), Y = (r, e, t) => (hr(r, e, \"access private method\"), t);\n\n\n\n\n\n\nconst z = {\n  /**\n   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR: {\n    code: null,\n    flag: \"visitor\",\n    name: \"Visitor\",\n    latin: !0,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in both the local language and English, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR_ENGLISH: {\n    code: null,\n    flag: \"visitor_en\",\n    name: \"Visitor English\",\n    latin: !0,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in a language enforced in the style.\n   */\n  STYLE: {\n    code: null,\n    flag: \"style\",\n    name: \"Style\",\n    latin: !1,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.\n   */\n  STYLE_LOCK: {\n    code: null,\n    flag: \"style_lock\",\n    name: \"Style Lock\",\n    latin: !1,\n    isMode: !0,\n    geocoding: !1\n  },\n  ..._maptiler_client__WEBPACK_IMPORTED_MODULE_1__.Language\n};\nfunction Pn() {\n  if (typeof navigator > \"u\") {\n    const e = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0], t = (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getLanguageInfoFromCode)(e);\n    return t || z.ENGLISH;\n  }\n  return Array.from(new Set(navigator.languages.map((e) => e.split(\"-\")[0]))).map((e) => (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getLanguageInfoFromCode)(e)).filter((e) => e)[0] ?? z.LOCAL;\n}\nconst X = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  telemetryURL: \"https://api.maptiler.com/metrics\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: z.STYLE,\n  secondaryLanguage: z.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(X);\nconst tn = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\nclass di extends events__WEBPACK_IMPORTED_MODULE_2__ {\n  constructor() {\n    super(...arguments);\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    v(this, \"primaryLanguage\", X.primaryLanguage);\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    v(this, \"secondaryLanguage\");\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    v(this, \"session\", !0);\n    /**\n     * Enables client-side caching of requests for tiles and fonts.\n     * The cached requests persist multiple browser sessions and will be reused when possible.\n     * Works only for requests to the MapTiler Cloud API when sessions are enabled.\n     */\n    v(this, \"caching\", !0);\n    /**\n     * Telemetry is enabled by default but can be opted-out by setting this value to `false`.\n     * The telemetry is very valuable to the team at MapTiler because it shares information\n     * about where to add the extra effort. It also helps spotting some incompatibility issues\n     * that may arise between the SDK and a specific version of a module.\n     *\n     * It consists in sending metrics about usage of the following features:\n     * - SDK version [string]\n     * - API key [string]\n     * - MapTiler sesion ID (if opted-in) [string]\n     * - if tile caching is enabled [boolean]\n     * - if language specified at initialization [boolean]\n     * - if terrain is activated at initialization [boolean]\n     * - if globe projection is activated at initialization [boolean]\n     *\n     * In addition, each official module will be added to a list, alongside its version number.\n     */\n    v(this, \"telemetry\", !0);\n    /**\n     * Unit to be used\n     */\n    v(this, \"_unit\", \"metric\");\n    /**\n     * MapTiler Cloud API key\n     */\n    v(this, \"_apiKey\", \"\");\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(t) {\n    this._unit = t, this.emit(\"unit\", t);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(t) {\n    this._apiKey = t, _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.config.apiKey = t, this.emit(\"apiKey\", t);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(t) {\n    _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.config.fetch = t;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.config.fetch;\n  }\n}\nconst j = new di(), zr = \"localcache_source\", Fr = \"localcache\", hi = \"maptiler_sdk\", mi = 1e3, yi = 100, $r = typeof caches < \"u\", { addProtocol: Rn } = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\nfunction gi(r, e) {\n  if ($r && j.caching && j.session && r.host === X.maptilerApiHost) {\n    if (e === \"Source\" && r.href.includes(\"tiles.json\"))\n      return r.href.replace(\"https://\", `${zr}://`);\n    if (e === \"Tile\" || e === \"Glyphs\")\n      return r.href.replace(\"https://\", `${Fr}://`);\n  }\n  return r.href;\n}\nlet gr;\nasync function _a() {\n  return gr || (gr = await caches.open(hi)), gr;\n}\nlet zn = 0;\nasync function vi() {\n  const r = await _a(), e = await r.keys(), t = e.slice(0, Math.max(e.length - mi, 0));\n  for (const n of t)\n    r.delete(n);\n}\nfunction bi() {\n  Rn(\n    zr,\n    async (r, e) => {\n      if (!r.url) throw new Error(\"\");\n      r.url = r.url.replace(`${zr}://`, \"https://\");\n      const t = r;\n      t.signal = e.signal;\n      const n = await fetch(r.url, t), a = await n.json();\n      return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get(\"Last-Modified\")}`), {\n        data: a,\n        cacheControl: n.headers.get(\"Cache-Control\"),\n        expires: n.headers.get(\"Expires\")\n      };\n    }\n  ), Rn(Fr, async (r, e) => {\n    if (!r.url) throw new Error(\"\");\n    r.url = r.url.replace(`${Fr}://`, \"https://\");\n    const t = new URL(r.url), n = new URL(t);\n    n.searchParams.delete(\"mtsid\"), n.searchParams.delete(\"key\");\n    const a = n.toString(), o = new URL(t);\n    o.searchParams.delete(\"last-modified\");\n    const i = o.toString(), s = async (d) => ({\n      data: await d.arrayBuffer(),\n      cacheControl: d.headers.get(\"Cache-Control\"),\n      expires: d.headers.get(\"Expires\")\n    }), l = await _a(), u = await l.match(a);\n    if (u)\n      return s(u);\n    const c = r;\n    c.signal = e.signal;\n    const p = await fetch(i, c);\n    return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {\n    }), ++zn > yi && (vi(), zn = 0)), s(p);\n  });\n}\nfunction wi() {\n  if (typeof window > \"u\") return;\n  const r = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.getRTLTextPluginStatus();\n  if (r === \"unavailable\" || r === \"requested\")\n    try {\n      maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.setRTLTextPlugin(X.rtlPluginURL, !0);\n    } catch {\n    }\n}\nfunction Si(r, e) {\n  for (const t of r)\n    typeof e[t] == \"function\" && (e[t] = e[t].bind(e));\n}\nfunction Fn(r, e) {\n  let t = null;\n  try {\n    t = new URL(r);\n  } catch {\n    return {\n      url: r\n    };\n  }\n  return t.host === X.maptilerApiHost && (t.searchParams.has(\"key\") || t.searchParams.append(\"key\", j.apiKey), j.session && t.searchParams.append(\"mtsid\", tn)), {\n    url: gi(t, e)\n  };\n}\nfunction $n(r) {\n  return (e, t) => {\n    if (r != null) {\n      const n = r(e, t), a = Fn((n == null ? void 0 : n.url) ?? \"\", t);\n      return {\n        ...n,\n        ...a\n      };\n    }\n    return Fn(e, t);\n  };\n}\nfunction Ia() {\n  return Math.random().toString(36).substring(2);\n}\nfunction Yt(r) {\n  return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi.test(r);\n}\nfunction xi(r) {\n  try {\n    return JSON.parse(r);\n  } catch {\n  }\n  return null;\n}\nfunction ki() {\n  return document.createElement(\"canvas\").getContext(\"webgl2\") ? null : typeof WebGL2RenderingContext < \"u\" ? \"Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed.\" : \"Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.\";\n}\nfunction Li(r) {\n  const e = ki();\n  if (!e) return;\n  let t = null;\n  if (typeof r == \"string\" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t)\n    throw new Error(\"The Map container must be provided.\");\n  const n = document.createElement(\"div\");\n  throw n.innerHTML = e, n.classList.add(\"webgl-warning-div\"), t.appendChild(n), new Error(e);\n}\nfunction Ic(r) {\n  const e = \"The WebGL context was lost.\", t = r.getContainer(), n = document.createElement(\"div\");\n  n.innerHTML = e, n.classList.add(\"webgl-warning-div\"), t.appendChild(n);\n}\nfunction On(r, e) {\n  return !(!Array.isArray(r) || r.length !== 2 || r[0] !== \"get\" || typeof r[1] != \"string\" || e && !r[1].startsWith(\"name:\") || !e && r[1] !== \"name\");\n}\nfunction Ci(r, e, t) {\n  const n = structuredClone(r), a = (o) => {\n    if (typeof o != \"string\")\n      for (let i = 0; i < o.length; i += 1)\n        On(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);\n  };\n  return On(n, t) ? e : (a(n), n);\n}\nfunction Ei(r, e) {\n  const t = e ? /\\{name:\\S+\\}/ : /\\{name\\}/;\n  return {\n    contains: t.test(r),\n    exactMatch: new RegExp(`^${t.source}$`).test(r)\n  };\n}\nfunction Ai(r, e, t) {\n  const n = t ? /\\{name:\\S+\\}/ : /\\{name\\}/, a = r.split(n);\n  return [\"concat\", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];\n}\nfunction Ti(r) {\n  var n;\n  const e = /\\{name(?::(?<language>\\S+))?\\}/g, t = [];\n  for (; ; ) {\n    const a = e.exec(r);\n    if (!a) break;\n    const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;\n    t.push(o);\n  }\n  return t;\n}\nfunction _i(r) {\n  return !Array.isArray(r) || r.length !== 2 || r[0] !== \"get\" || typeof r[1] != \"string\" ? null : r[1].trim() === \"name\" ? {\n    isLanguage: !0,\n    localization: null\n  } : r[1].trim().startsWith(\"name:\") ? {\n    isLanguage: !0,\n    localization: r[1].trim().split(\":\").pop()\n  } : null;\n}\nfunction Ii(r) {\n  const e = [], t = structuredClone(r), n = (a) => {\n    if (typeof a != \"string\")\n      for (let o = 0; o < a.length; o += 1) {\n        const i = _i(a[o]);\n        i ? e.push(i.localization) : n(a[o]);\n      }\n  };\n  return n([t]), e;\n}\nfunction Mi(r, e) {\n  const t = [];\n  for (const o of r) {\n    if (o.type !== \"symbol\")\n      continue;\n    const i = o, { id: s, layout: l } = i;\n    if (!l || !(\"text-field\" in l))\n      continue;\n    const u = e.getLayoutProperty(s, \"text-field\");\n    if (u)\n      if (typeof u == \"string\") {\n        const c = Ti(u);\n        t.push(c);\n      } else {\n        const c = Ii(u);\n        t.push(c);\n      }\n  }\n  const n = t.flat(), a = {\n    unlocalized: 0,\n    localized: {}\n  };\n  for (const o of n)\n    o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);\n  return a;\n}\nlet Mc = class extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker {\n  addTo(e) {\n    return super.addTo(e);\n  }\n};\nclass Rc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup {\n  addTo(e) {\n    return super.addTo(e);\n  }\n}\nclass zc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Style {\n  constructor(e, t = {}) {\n    super(e, t);\n  }\n}\nclass Fc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CanvasSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass $c extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeoJSONSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Oc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ImageSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Nc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass jc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterDEMTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Uc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VectorTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Dc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VideoSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Ma extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Pi extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeolocateControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Bc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Ri extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LogoControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass zi extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScaleControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Fi extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.FullscreenControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass qc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TerrainControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Vc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.BoxZoomHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass Gc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScrollZoomHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass Hc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CooperativeGesturesHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass Zc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.KeyboardHandler {\n  constructor(e) {\n    super(e);\n  }\n}\nclass Xc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TwoFingersTouchPitchHandler {\n  constructor(e) {\n    super(e);\n  }\n}\nclass Kc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapWheelEvent {\n  constructor(e, t, n) {\n    super(e, t, n);\n  }\n}\nclass Yc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapTouchEvent {\n  constructor(e, t, n) {\n    super(e, t, n);\n  }\n}\nclass Wc extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapMouseEvent {\n  constructor(e, t, n, a = {}) {\n    super(e, t, n, a);\n  }\n}\nclass Nn extends Ri {\n  constructor(t = {}) {\n    super(t);\n    v(this, \"logoURL\", \"\");\n    v(this, \"linkURL\", \"\");\n    this.logoURL = t.logoURL ?? X.maptilerLogoURL, this.linkURL = t.linkURL ?? X.maptilerURL;\n  }\n  onAdd(t) {\n    this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement(\"div\"), this._container.className = \"maplibregl-ctrl\";\n    const n = window.document.createElement(\"a\");\n    return n.style.backgroundRepeat = \"no-repeat\", n.style.cursor = \"pointer\", n.style.display = \"block\", n.style.height = \"23px\", n.style.margin = \"0 0 -4px -4px\", n.style.overflow = \"hidden\", n.style.width = \"88px\", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = \"100px 30px\", n.style.width = \"100px\", n.style.height = \"30px\", n.target = \"_blank\", n.rel = \"noopener\", n.href = this.linkURL, n.setAttribute(\"aria-label\", \"MapTiler logo\"), n.setAttribute(\"rel\", \"noopener\"), this._container.appendChild(n), this._container.style.display = \"block\", this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n  }\n}\nvar $i = 8, Oi = {\n  version: {\n    required: !0,\n    type: \"enum\",\n    values: [\n      8\n    ]\n  },\n  name: {\n    type: \"string\"\n  },\n  metadata: {\n    type: \"*\"\n  },\n  center: {\n    type: \"array\",\n    value: \"number\"\n  },\n  centerAltitude: {\n    type: \"number\"\n  },\n  zoom: {\n    type: \"number\"\n  },\n  bearing: {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    units: \"degrees\"\n  },\n  pitch: {\n    type: \"number\",\n    default: 0,\n    units: \"degrees\"\n  },\n  roll: {\n    type: \"number\",\n    default: 0,\n    units: \"degrees\"\n  },\n  state: {\n    type: \"state\",\n    default: {}\n  },\n  light: {\n    type: \"light\"\n  },\n  sky: {\n    type: \"sky\"\n  },\n  projection: {\n    type: \"projection\"\n  },\n  terrain: {\n    type: \"terrain\"\n  },\n  sources: {\n    required: !0,\n    type: \"sources\"\n  },\n  sprite: {\n    type: \"sprite\"\n  },\n  glyphs: {\n    type: \"string\"\n  },\n  transition: {\n    type: \"transition\"\n  },\n  layers: {\n    required: !0,\n    type: \"array\",\n    value: \"layer\"\n  }\n}, Ni = {\n  \"*\": {\n    type: \"source\"\n  }\n}, ji = [\n  \"source_vector\",\n  \"source_raster\",\n  \"source_raster_dem\",\n  \"source_geojson\",\n  \"source_video\",\n  \"source_image\"\n], Ui = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      vector: {}\n    }\n  },\n  url: {\n    type: \"string\"\n  },\n  tiles: {\n    type: \"array\",\n    value: \"string\"\n  },\n  bounds: {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      -180,\n      -85.051129,\n      180,\n      85.051129\n    ]\n  },\n  scheme: {\n    type: \"enum\",\n    values: {\n      xyz: {},\n      tms: {}\n    },\n    default: \"xyz\"\n  },\n  minzoom: {\n    type: \"number\",\n    default: 0\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 22\n  },\n  attribution: {\n    type: \"string\"\n  },\n  promoteId: {\n    type: \"promoteId\"\n  },\n  volatile: {\n    type: \"boolean\",\n    default: !1\n  },\n  \"*\": {\n    type: \"*\"\n  }\n}, Di = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      raster: {}\n    }\n  },\n  url: {\n    type: \"string\"\n  },\n  tiles: {\n    type: \"array\",\n    value: \"string\"\n  },\n  bounds: {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      -180,\n      -85.051129,\n      180,\n      85.051129\n    ]\n  },\n  minzoom: {\n    type: \"number\",\n    default: 0\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 22\n  },\n  tileSize: {\n    type: \"number\",\n    default: 512,\n    units: \"pixels\"\n  },\n  scheme: {\n    type: \"enum\",\n    values: {\n      xyz: {},\n      tms: {}\n    },\n    default: \"xyz\"\n  },\n  attribution: {\n    type: \"string\"\n  },\n  volatile: {\n    type: \"boolean\",\n    default: !1\n  },\n  \"*\": {\n    type: \"*\"\n  }\n}, Bi = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      \"raster-dem\": {}\n    }\n  },\n  url: {\n    type: \"string\"\n  },\n  tiles: {\n    type: \"array\",\n    value: \"string\"\n  },\n  bounds: {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      -180,\n      -85.051129,\n      180,\n      85.051129\n    ]\n  },\n  minzoom: {\n    type: \"number\",\n    default: 0\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 22\n  },\n  tileSize: {\n    type: \"number\",\n    default: 512,\n    units: \"pixels\"\n  },\n  attribution: {\n    type: \"string\"\n  },\n  encoding: {\n    type: \"enum\",\n    values: {\n      terrarium: {},\n      mapbox: {},\n      custom: {}\n    },\n    default: \"mapbox\"\n  },\n  redFactor: {\n    type: \"number\",\n    default: 1\n  },\n  blueFactor: {\n    type: \"number\",\n    default: 1\n  },\n  greenFactor: {\n    type: \"number\",\n    default: 1\n  },\n  baseShift: {\n    type: \"number\",\n    default: 0\n  },\n  volatile: {\n    type: \"boolean\",\n    default: !1\n  },\n  \"*\": {\n    type: \"*\"\n  }\n}, qi = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      geojson: {}\n    }\n  },\n  data: {\n    required: !0,\n    type: \"*\"\n  },\n  maxzoom: {\n    type: \"number\",\n    default: 18\n  },\n  attribution: {\n    type: \"string\"\n  },\n  buffer: {\n    type: \"number\",\n    default: 128,\n    maximum: 512,\n    minimum: 0\n  },\n  filter: {\n    type: \"*\"\n  },\n  tolerance: {\n    type: \"number\",\n    default: 0.375\n  },\n  cluster: {\n    type: \"boolean\",\n    default: !1\n  },\n  clusterRadius: {\n    type: \"number\",\n    default: 50,\n    minimum: 0\n  },\n  clusterMaxZoom: {\n    type: \"number\"\n  },\n  clusterMinPoints: {\n    type: \"number\"\n  },\n  clusterProperties: {\n    type: \"*\"\n  },\n  lineMetrics: {\n    type: \"boolean\",\n    default: !1\n  },\n  generateId: {\n    type: \"boolean\",\n    default: !1\n  },\n  promoteId: {\n    type: \"promoteId\"\n  }\n}, Vi = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      video: {}\n    }\n  },\n  urls: {\n    required: !0,\n    type: \"array\",\n    value: \"string\"\n  },\n  coordinates: {\n    required: !0,\n    type: \"array\",\n    length: 4,\n    value: {\n      type: \"array\",\n      length: 2,\n      value: \"number\"\n    }\n  }\n}, Gi = {\n  type: {\n    required: !0,\n    type: \"enum\",\n    values: {\n      image: {}\n    }\n  },\n  url: {\n    required: !0,\n    type: \"string\"\n  },\n  coordinates: {\n    required: !0,\n    type: \"array\",\n    length: 4,\n    value: {\n      type: \"array\",\n      length: 2,\n      value: \"number\"\n    }\n  }\n}, Hi = {\n  id: {\n    type: \"string\",\n    required: !0\n  },\n  type: {\n    type: \"enum\",\n    values: {\n      fill: {},\n      line: {},\n      symbol: {},\n      circle: {},\n      heatmap: {},\n      \"fill-extrusion\": {},\n      raster: {},\n      hillshade: {},\n      \"color-relief\": {},\n      background: {}\n    },\n    required: !0\n  },\n  metadata: {\n    type: \"*\"\n  },\n  source: {\n    type: \"string\"\n  },\n  \"source-layer\": {\n    type: \"string\"\n  },\n  minzoom: {\n    type: \"number\",\n    minimum: 0,\n    maximum: 24\n  },\n  maxzoom: {\n    type: \"number\",\n    minimum: 0,\n    maximum: 24\n  },\n  filter: {\n    type: \"filter\"\n  },\n  layout: {\n    type: \"layout\"\n  },\n  paint: {\n    type: \"paint\"\n  }\n}, Zi = [\n  \"layout_fill\",\n  \"layout_line\",\n  \"layout_circle\",\n  \"layout_heatmap\",\n  \"layout_fill-extrusion\",\n  \"layout_symbol\",\n  \"layout_raster\",\n  \"layout_hillshade\",\n  \"layout_color-relief\",\n  \"layout_background\"\n], Xi = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, Ki = {\n  \"fill-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, Yi = {\n  \"circle-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, Wi = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, Ji = {\n  \"line-cap\": {\n    type: \"enum\",\n    values: {\n      butt: {},\n      round: {},\n      square: {}\n    },\n    default: \"butt\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-join\": {\n    type: \"enum\",\n    values: {\n      bevel: {},\n      round: {},\n      miter: {}\n    },\n    default: \"miter\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-miter-limit\": {\n    type: \"number\",\n    default: 2,\n    requires: [\n      {\n        \"line-join\": \"miter\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-round-limit\": {\n    type: \"number\",\n    default: 1.05,\n    requires: [\n      {\n        \"line-join\": \"round\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, Qi = {\n  \"symbol-placement\": {\n    type: \"enum\",\n    values: {\n      point: {},\n      line: {},\n      \"line-center\": {}\n    },\n    default: \"point\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"symbol-spacing\": {\n    type: \"number\",\n    default: 250,\n    minimum: 1,\n    units: \"pixels\",\n    requires: [\n      {\n        \"symbol-placement\": \"line\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"symbol-avoid-edges\": {\n    type: \"boolean\",\n    default: !1,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"symbol-sort-key\": {\n    type: \"number\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"symbol-z-order\": {\n    type: \"enum\",\n    values: {\n      auto: {},\n      \"viewport-y\": {},\n      source: {}\n    },\n    default: \"auto\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-allow-overlap\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\",\n      {\n        \"!\": \"icon-overlap\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-overlap\": {\n    type: \"enum\",\n    values: {\n      never: {},\n      always: {},\n      cooperative: {}\n    },\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-ignore-placement\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-optional\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\",\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-rotation-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-size\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    units: \"factor of the original icon size\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-text-fit\": {\n    type: \"enum\",\n    values: {\n      none: {},\n      width: {},\n      height: {},\n      both: {}\n    },\n    default: \"none\",\n    requires: [\n      \"icon-image\",\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-text-fit-padding\": {\n    type: \"array\",\n    value: \"number\",\n    length: 4,\n    default: [\n      0,\n      0,\n      0,\n      0\n    ],\n    units: \"pixels\",\n    requires: [\n      \"icon-image\",\n      \"text-field\",\n      {\n        \"icon-text-fit\": [\n          \"both\",\n          \"width\",\n          \"height\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-image\": {\n    type: \"resolvedImage\",\n    tokens: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-rotate\": {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    units: \"degrees\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-padding\": {\n    type: \"padding\",\n    default: [\n      2\n    ],\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-keep-upright\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"icon-image\",\n      {\n        \"icon-rotation-alignment\": \"map\"\n      },\n      {\n        \"symbol-placement\": [\n          \"line\",\n          \"line-center\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-offset\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-anchor\": {\n    type: \"enum\",\n    values: {\n      center: {},\n      left: {},\n      right: {},\n      top: {},\n      bottom: {},\n      \"top-left\": {},\n      \"top-right\": {},\n      \"bottom-left\": {},\n      \"bottom-right\": {}\n    },\n    default: \"center\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-pitch-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-pitch-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-rotation-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {},\n      \"viewport-glyph\": {},\n      auto: {}\n    },\n    default: \"auto\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-field\": {\n    type: \"formatted\",\n    default: \"\",\n    tokens: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-font\": {\n    type: \"array\",\n    value: \"string\",\n    default: [\n      \"Open Sans Regular\",\n      \"Arial Unicode MS Regular\"\n    ],\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-size\": {\n    type: \"number\",\n    default: 16,\n    minimum: 0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-max-width\": {\n    type: \"number\",\n    default: 10,\n    minimum: 0,\n    units: \"ems\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-line-height\": {\n    type: \"number\",\n    default: 1.2,\n    units: \"ems\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-letter-spacing\": {\n    type: \"number\",\n    default: 0,\n    units: \"ems\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-justify\": {\n    type: \"enum\",\n    values: {\n      auto: {},\n      left: {},\n      center: {},\n      right: {}\n    },\n    default: \"center\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-radial-offset\": {\n    type: \"number\",\n    units: \"ems\",\n    default: 0,\n    requires: [\n      \"text-field\"\n    ],\n    \"property-type\": \"data-driven\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    }\n  },\n  \"text-variable-anchor\": {\n    type: \"array\",\n    value: \"enum\",\n    values: {\n      center: {},\n      left: {},\n      right: {},\n      top: {},\n      bottom: {},\n      \"top-left\": {},\n      \"top-right\": {},\n      \"bottom-left\": {},\n      \"bottom-right\": {}\n    },\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"point\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-variable-anchor-offset\": {\n    type: \"variableAnchorOffsetCollection\",\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"point\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-anchor\": {\n    type: \"enum\",\n    values: {\n      center: {},\n      left: {},\n      right: {},\n      top: {},\n      bottom: {},\n      \"top-left\": {},\n      \"top-right\": {},\n      \"bottom-left\": {},\n      \"bottom-right\": {}\n    },\n    default: \"center\",\n    requires: [\n      \"text-field\",\n      {\n        \"!\": \"text-variable-anchor\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-max-angle\": {\n    type: \"number\",\n    default: 45,\n    units: \"degrees\",\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"line\",\n          \"line-center\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-writing-mode\": {\n    type: \"array\",\n    value: \"enum\",\n    values: {\n      horizontal: {},\n      vertical: {}\n    },\n    requires: [\n      \"text-field\",\n      {\n        \"symbol-placement\": [\n          \"point\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-rotate\": {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    units: \"degrees\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-padding\": {\n    type: \"number\",\n    default: 2,\n    minimum: 0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-keep-upright\": {\n    type: \"boolean\",\n    default: !0,\n    requires: [\n      \"text-field\",\n      {\n        \"text-rotation-alignment\": \"map\"\n      },\n      {\n        \"symbol-placement\": [\n          \"line\",\n          \"line-center\"\n        ]\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-transform\": {\n    type: \"enum\",\n    values: {\n      none: {},\n      uppercase: {},\n      lowercase: {}\n    },\n    default: \"none\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-offset\": {\n    type: \"array\",\n    value: \"number\",\n    units: \"ems\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    requires: [\n      \"text-field\",\n      {\n        \"!\": \"text-radial-offset\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-allow-overlap\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"text-field\",\n      {\n        \"!\": \"text-overlap\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-overlap\": {\n    type: \"enum\",\n    values: {\n      never: {},\n      always: {},\n      cooperative: {}\n    },\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-ignore-placement\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-optional\": {\n    type: \"boolean\",\n    default: !1,\n    requires: [\n      \"text-field\",\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, es = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, ts = {\n  visibility: {\n    type: \"enum\",\n    values: {\n      visible: {},\n      none: {}\n    },\n    default: \"visible\",\n    \"property-type\": \"constant\"\n  }\n}, rs = {\n  type: \"array\",\n  value: \"*\"\n}, ns = {\n  type: \"enum\",\n  values: {\n    \"==\": {},\n    \"!=\": {},\n    \">\": {},\n    \">=\": {},\n    \"<\": {},\n    \"<=\": {},\n    in: {},\n    \"!in\": {},\n    all: {},\n    any: {},\n    none: {},\n    has: {},\n    \"!has\": {}\n  }\n}, as = {\n  type: \"enum\",\n  values: {\n    Point: {},\n    LineString: {},\n    Polygon: {}\n  }\n}, os = {\n  type: \"array\",\n  minimum: 0,\n  maximum: 24,\n  value: [\n    \"number\",\n    \"color\"\n  ],\n  length: 2\n}, is = {\n  type: \"array\",\n  value: \"*\",\n  minimum: 1\n}, ss = {\n  anchor: {\n    type: \"enum\",\n    default: \"viewport\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    \"property-type\": \"data-constant\",\n    transition: !1,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    }\n  },\n  position: {\n    type: \"array\",\n    default: [\n      1.15,\n      210,\n      30\n    ],\n    length: 3,\n    value: \"number\",\n    \"property-type\": \"data-constant\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    }\n  },\n  color: {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#ffffff\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  intensity: {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.5,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  }\n}, ls = {\n  \"sky-color\": {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#88C6FC\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"horizon-color\": {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#ffffff\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"fog-color\": {\n    type: \"color\",\n    \"property-type\": \"data-constant\",\n    default: \"#ffffff\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"fog-ground-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.5,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"horizon-fog-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.8,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"sky-horizon-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.8,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  },\n  \"atmosphere-blend\": {\n    type: \"number\",\n    \"property-type\": \"data-constant\",\n    default: 0.8,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    transition: !0\n  }\n}, us = {\n  source: {\n    type: \"string\",\n    required: !0\n  },\n  exaggeration: {\n    type: \"number\",\n    minimum: 0,\n    default: 1\n  }\n}, cs = {\n  type: {\n    type: \"projectionDefinition\",\n    default: \"mercator\",\n    \"property-type\": \"data-constant\",\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    }\n  }\n}, ps = [\n  \"paint_fill\",\n  \"paint_line\",\n  \"paint_circle\",\n  \"paint_heatmap\",\n  \"paint_fill-extrusion\",\n  \"paint_symbol\",\n  \"paint_raster\",\n  \"paint_hillshade\",\n  \"paint_color-relief\",\n  \"paint_background\"\n], fs = {\n  \"fill-antialias\": {\n    type: \"boolean\",\n    default: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"fill-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"fill-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"fill-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"fill-outline-color\": {\n    type: \"color\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"fill-pattern\"\n      },\n      {\n        \"fill-antialias\": !0\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"fill-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"fill-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"fill-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"fill-pattern\": {\n    type: \"resolvedImage\",\n    transition: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"cross-faded-data-driven\"\n  }\n}, ds = {\n  \"line-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"line-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"line-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"line-width\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-gap-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-offset\": {\n    type: \"number\",\n    default: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-blur\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"line-dasharray\": {\n    type: \"array\",\n    value: \"number\",\n    minimum: 0,\n    transition: !0,\n    units: \"line widths\",\n    requires: [\n      {\n        \"!\": \"line-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"cross-faded\"\n  },\n  \"line-pattern\": {\n    type: \"resolvedImage\",\n    transition: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\",\n        \"feature\"\n      ]\n    },\n    \"property-type\": \"cross-faded-data-driven\"\n  },\n  \"line-gradient\": {\n    type: \"color\",\n    transition: !1,\n    requires: [\n      {\n        \"!\": \"line-dasharray\"\n      },\n      {\n        \"!\": \"line-pattern\"\n      },\n      {\n        source: \"geojson\",\n        has: {\n          lineMetrics: !0\n        }\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"line-progress\"\n      ]\n    },\n    \"property-type\": \"color-ramp\"\n  }\n}, hs = {\n  \"circle-radius\": {\n    type: \"number\",\n    default: 5,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-blur\": {\n    type: \"number\",\n    default: 0,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"circle-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-pitch-scale\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-pitch-alignment\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"viewport\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"circle-stroke-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-stroke-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"circle-stroke-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  }\n}, ms = {\n  \"heatmap-radius\": {\n    type: \"number\",\n    default: 30,\n    minimum: 1,\n    transition: !0,\n    units: \"pixels\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"heatmap-weight\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"heatmap-intensity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"heatmap-color\": {\n    type: \"color\",\n    default: [\n      \"interpolate\",\n      [\n        \"linear\"\n      ],\n      [\n        \"heatmap-density\"\n      ],\n      0,\n      \"rgba(0, 0, 255, 0)\",\n      0.1,\n      \"royalblue\",\n      0.3,\n      \"cyan\",\n      0.5,\n      \"lime\",\n      0.7,\n      \"yellow\",\n      1,\n      \"red\"\n    ],\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"heatmap-density\"\n      ]\n    },\n    \"property-type\": \"color-ramp\"\n  },\n  \"heatmap-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, ys = {\n  \"icon-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-halo-color\": {\n    type: \"color\",\n    default: \"rgba(0, 0, 0, 0)\",\n    transition: !0,\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-halo-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-halo-blur\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"icon-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"icon-image\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"icon-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"icon-image\",\n      \"icon-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    overridable: !0,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-halo-color\": {\n    type: \"color\",\n    default: \"rgba(0, 0, 0, 0)\",\n    transition: !0,\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-halo-width\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-halo-blur\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\",\n        \"feature\",\n        \"feature-state\"\n      ]\n    },\n    \"property-type\": \"data-driven\"\n  },\n  \"text-translate\": {\n    type: \"array\",\n    value: \"number\",\n    length: 2,\n    default: [\n      0,\n      0\n    ],\n    transition: !0,\n    units: \"pixels\",\n    requires: [\n      \"text-field\"\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"text-translate-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"map\",\n    requires: [\n      \"text-field\",\n      \"text-translate\"\n    ],\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, gs = {\n  \"raster-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-hue-rotate\": {\n    type: \"number\",\n    default: 0,\n    period: 360,\n    transition: !0,\n    units: \"degrees\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-brightness-min\": {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-brightness-max\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-saturation\": {\n    type: \"number\",\n    default: 0,\n    minimum: -1,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-contrast\": {\n    type: \"number\",\n    default: 0,\n    minimum: -1,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-resampling\": {\n    type: \"enum\",\n    values: {\n      linear: {},\n      nearest: {}\n    },\n    default: \"linear\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"raster-fade-duration\": {\n    type: \"number\",\n    default: 300,\n    minimum: 0,\n    transition: !1,\n    units: \"milliseconds\",\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, vs = {\n  \"hillshade-illumination-direction\": {\n    type: \"numberArray\",\n    default: 335,\n    minimum: 0,\n    maximum: 359,\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-illumination-altitude\": {\n    type: \"numberArray\",\n    default: 45,\n    minimum: 0,\n    maximum: 90,\n    transition: !1,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-illumination-anchor\": {\n    type: \"enum\",\n    values: {\n      map: {},\n      viewport: {}\n    },\n    default: \"viewport\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-exaggeration\": {\n    type: \"number\",\n    default: 0.5,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-shadow-color\": {\n    type: \"colorArray\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-highlight-color\": {\n    type: \"colorArray\",\n    default: \"#FFFFFF\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-accent-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"hillshade-method\": {\n    type: \"enum\",\n    values: {\n      standard: {},\n      basic: {},\n      combined: {},\n      igor: {},\n      multidirectional: {}\n    },\n    default: \"standard\",\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, bs = {\n  \"background-color\": {\n    type: \"color\",\n    default: \"#000000\",\n    transition: !0,\n    requires: [\n      {\n        \"!\": \"background-pattern\"\n      }\n    ],\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  },\n  \"background-pattern\": {\n    type: \"resolvedImage\",\n    transition: !0,\n    expression: {\n      interpolated: !1,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"cross-faded\"\n  },\n  \"background-opacity\": {\n    type: \"number\",\n    default: 1,\n    minimum: 0,\n    maximum: 1,\n    transition: !0,\n    expression: {\n      interpolated: !0,\n      parameters: [\n        \"zoom\"\n      ]\n    },\n    \"property-type\": \"data-constant\"\n  }\n}, ws = {\n  duration: {\n    type: \"number\",\n    default: 300,\n    minimum: 0,\n    units: \"milliseconds\"\n  },\n  delay: {\n    type: \"number\",\n    default: 0,\n    minimum: 0,\n    units: \"milliseconds\"\n  }\n}, Ss = {\n  \"*\": {\n    type: \"string\"\n  }\n}, xs = {\n  $version: $i,\n  $root: Oi,\n  sources: Ni,\n  source: ji,\n  source_vector: Ui,\n  source_raster: Di,\n  source_raster_dem: Bi,\n  source_geojson: qi,\n  source_video: Vi,\n  source_image: Gi,\n  layer: Hi,\n  layout: Zi,\n  layout_background: Xi,\n  layout_fill: Ki,\n  layout_circle: Yi,\n  layout_heatmap: Wi,\n  \"layout_fill-extrusion\": {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  layout_line: Ji,\n  layout_symbol: Qi,\n  layout_raster: es,\n  layout_hillshade: ts,\n  \"layout_color-relief\": {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  filter: rs,\n  filter_operator: ns,\n  geometry_type: as,\n  function: {\n    expression: {\n      type: \"expression\"\n    },\n    stops: {\n      type: \"array\",\n      value: \"function_stop\"\n    },\n    base: {\n      type: \"number\",\n      default: 1,\n      minimum: 0\n    },\n    property: {\n      type: \"string\",\n      default: \"$zoom\"\n    },\n    type: {\n      type: \"enum\",\n      values: {\n        identity: {},\n        exponential: {},\n        interval: {},\n        categorical: {}\n      },\n      default: \"exponential\"\n    },\n    colorSpace: {\n      type: \"enum\",\n      values: {\n        rgb: {},\n        lab: {},\n        hcl: {}\n      },\n      default: \"rgb\"\n    },\n    default: {\n      type: \"*\",\n      required: !1\n    }\n  },\n  function_stop: os,\n  expression: is,\n  light: ss,\n  sky: ls,\n  terrain: us,\n  projection: cs,\n  paint: ps,\n  paint_fill: fs,\n  \"paint_fill-extrusion\": {\n    \"fill-extrusion-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      requires: [\n        {\n          \"!\": \"fill-extrusion-pattern\"\n        }\n      ],\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\",\n          \"feature\",\n          \"feature-state\"\n        ]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [\n        0,\n        0\n      ],\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\n        \"fill-extrusion-translate\"\n      ],\n      expression: {\n        interpolated: !1,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-extrusion-pattern\": {\n      type: \"resolvedImage\",\n      transition: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\n          \"zoom\",\n          \"feature\"\n        ]\n      },\n      \"property-type\": \"cross-faded-data-driven\"\n    },\n    \"fill-extrusion-height\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      units: \"meters\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\",\n          \"feature\",\n          \"feature-state\"\n        ]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-base\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      units: \"meters\",\n      transition: !0,\n      requires: [\n        \"fill-extrusion-height\"\n      ],\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\",\n          \"feature\",\n          \"feature-state\"\n        ]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-extrusion-vertical-gradient\": {\n      type: \"boolean\",\n      default: !0,\n      transition: !1,\n      expression: {\n        interpolated: !1,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  paint_line: ds,\n  paint_circle: hs,\n  paint_heatmap: ms,\n  paint_symbol: ys,\n  paint_raster: gs,\n  paint_hillshade: vs,\n  \"paint_color-relief\": {\n    \"color-relief-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"zoom\"\n        ]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"color-relief-color\": {\n      type: \"color\",\n      transition: !1,\n      expression: {\n        interpolated: !0,\n        parameters: [\n          \"elevation\"\n        ]\n      },\n      \"property-type\": \"color-ramp\"\n    }\n  },\n  paint_background: bs,\n  transition: ws,\n  \"property-type\": {\n    \"data-driven\": {\n      type: \"property-type\"\n    },\n    \"cross-faded\": {\n      type: \"property-type\"\n    },\n    \"cross-faded-data-driven\": {\n      type: \"property-type\"\n    },\n    \"color-ramp\": {\n      type: \"property-type\"\n    },\n    \"data-constant\": {\n      type: \"property-type\"\n    },\n    constant: {\n      type: \"property-type\"\n    }\n  },\n  promoteId: Ss\n};\nclass b {\n  constructor(e, t, n, a) {\n    this.message = (e ? `${e}: ` : \"\") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);\n  }\n}\nfunction Dt(r, ...e) {\n  for (const t of e)\n    for (const n in t)\n      r[n] = t[n];\n  return r;\n}\nclass be extends Error {\n  constructor(e, t) {\n    super(t), this.message = t, this.key = e;\n  }\n}\nclass rn {\n  constructor(e, t = []) {\n    this.parent = e, this.bindings = {};\n    for (const [n, a] of t)\n      this.bindings[n] = a;\n  }\n  concat(e) {\n    return new rn(this, e);\n  }\n  get(e) {\n    if (this.bindings[e])\n      return this.bindings[e];\n    if (this.parent)\n      return this.parent.get(e);\n    throw new Error(`${e} not found in scope.`);\n  }\n  has(e) {\n    return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;\n  }\n}\nconst Wt = { kind: \"null\" }, S = { kind: \"number\" }, P = { kind: \"string\" }, M = { kind: \"boolean\" }, we = { kind: \"color\" }, Jt = { kind: \"projectionDefinition\" }, Be = { kind: \"object\" }, I = { kind: \"value\" }, ks = { kind: \"error\" }, Qt = { kind: \"collator\" }, er = { kind: \"formatted\" }, tr = { kind: \"padding\" }, yt = { kind: \"colorArray\" }, rr = { kind: \"numberArray\" }, At = { kind: \"resolvedImage\" }, nr = { kind: \"variableAnchorOffsetCollection\" };\nfunction te(r, e) {\n  return {\n    kind: \"array\",\n    itemType: r,\n    N: e\n  };\n}\nfunction U(r) {\n  if (r.kind === \"array\") {\n    const e = U(r.itemType);\n    return typeof r.N == \"number\" ? `array<${e}, ${r.N}>` : r.itemType.kind === \"value\" ? \"array\" : `array<${e}>`;\n  } else\n    return r.kind;\n}\nconst Ls = [\n  Wt,\n  S,\n  P,\n  M,\n  we,\n  Jt,\n  er,\n  Be,\n  te(I),\n  tr,\n  rr,\n  yt,\n  At,\n  nr\n];\nfunction gt(r, e) {\n  if (e.kind === \"error\")\n    return null;\n  if (r.kind === \"array\") {\n    if (e.kind === \"array\" && (e.N === 0 && e.itemType.kind === \"value\" || !gt(r.itemType, e.itemType)) && (typeof r.N != \"number\" || r.N === e.N))\n      return null;\n  } else {\n    if (r.kind === e.kind)\n      return null;\n    if (r.kind === \"value\") {\n      for (const t of Ls)\n        if (!gt(t, e))\n          return null;\n    }\n  }\n  return `Expected ${U(r)} but found ${U(e)} instead.`;\n}\nfunction nn(r, e) {\n  return e.some((t) => t.kind === r.kind);\n}\nfunction qe(r, e) {\n  return e.some((t) => t === \"null\" ? r === null : t === \"array\" ? Array.isArray(r) : t === \"object\" ? r && !Array.isArray(r) && typeof r == \"object\" : t === typeof r);\n}\nfunction Ee(r, e) {\n  return r.kind === \"array\" && e.kind === \"array\" ? r.itemType.kind === e.itemType.kind && typeof r.N == \"number\" : r.kind === e.kind;\n}\nconst Pa = 0.96422, Ra = 1, za = 0.82521, Fa = 4 / 29, tt = 6 / 29, $a = 3 * tt * tt, Cs = tt * tt * tt, Es = Math.PI / 180, As = 180 / Math.PI;\nfunction Oa(r) {\n  return r = r % 360, r < 0 && (r += 360), r;\n}\nfunction Na([r, e, t, n]) {\n  r = vr(r), e = vr(e), t = vr(t);\n  let a, o;\n  const i = br((0.2225045 * r + 0.7168786 * e + 0.0606169 * t) / Ra);\n  r === e && e === t ? a = o = i : (a = br((0.4360747 * r + 0.3850649 * e + 0.1430804 * t) / Pa), o = br((0.0139322 * r + 0.0971045 * e + 0.7141733 * t) / za));\n  const s = 116 * i - 16;\n  return [s < 0 ? 0 : s, 500 * (a - i), 200 * (i - o), n];\n}\nfunction vr(r) {\n  return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);\n}\nfunction br(r) {\n  return r > Cs ? Math.pow(r, 1 / 3) : r / $a + Fa;\n}\nfunction ja([r, e, t, n]) {\n  let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;\n  return a = Ra * Sr(a), o = Pa * Sr(o), i = za * Sr(i), [\n    wr(3.1338561 * o - 1.6168667 * a - 0.4906146 * i),\n    // D50 -> sRGB\n    wr(-0.9787684 * o + 1.9161415 * a + 0.033454 * i),\n    wr(0.0719453 * o - 0.2289914 * a + 1.4052427 * i),\n    n\n  ];\n}\nfunction wr(r) {\n  return r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055, r < 0 ? 0 : r > 1 ? 1 : r;\n}\nfunction Sr(r) {\n  return r > tt ? r * r * r : $a * (r - Fa);\n}\nfunction Ts(r) {\n  const [e, t, n, a] = Na(r), o = Math.sqrt(t * t + n * n);\n  return [Math.round(o * 1e4) ? Oa(Math.atan2(n, t) * As) : NaN, o, e, a];\n}\nfunction _s([r, e, t, n]) {\n  return r = isNaN(r) ? 0 : r * Es, ja([t, Math.cos(r) * e, Math.sin(r) * e, n]);\n}\nfunction Is([r, e, t, n]) {\n  r = Oa(r), e /= 100, t /= 100;\n  function a(o) {\n    const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);\n    return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));\n  }\n  return [a(0), a(8), a(4), n];\n}\nconst Ms = Object.hasOwn || function(e, t) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n};\nfunction dt(r, e) {\n  return Ms(r, e) ? r[e] : void 0;\n}\nfunction Ps(r) {\n  if (r = r.toLowerCase().trim(), r === \"transparent\")\n    return [0, 0, 0, 0];\n  const e = dt(Rs, r);\n  if (e) {\n    const [a, o, i] = e;\n    return [a / 255, o / 255, i / 255, 1];\n  }\n  if (r.startsWith(\"#\") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {\n    const o = r.length < 6 ? 1 : 2;\n    let i = 1;\n    return [\n      Pt(r.slice(i, i += o)),\n      Pt(r.slice(i, i += o)),\n      Pt(r.slice(i, i += o)),\n      Pt(r.slice(i, i + o) || \"ff\")\n    ];\n  }\n  if (r.startsWith(\"rgb\")) {\n    const a = /^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/, o = r.match(a);\n    if (o) {\n      const [\n        i,\n        // eslint-disable-line @typescript-eslint/no-unused-vars\n        s,\n        // <numeric>\n        l,\n        // %         (optional)\n        u,\n        // ,         (optional)\n        c,\n        // <numeric>\n        p,\n        // %         (optional)\n        d,\n        // ,         (optional)\n        f,\n        // <numeric>\n        h,\n        // %         (optional)\n        m,\n        // ,|/       (optional)\n        y,\n        // <numeric> (optional)\n        w\n        // %         (optional)\n      ] = o, g = [u || \" \", d || \" \", m].join(\"\");\n      if (g === \"  \" || g === \"  /\" || g === \",,\" || g === \",,,\") {\n        const x = [l, p, h].join(\"\"), E = x === \"%%%\" ? 100 : x === \"\" ? 255 : 0;\n        if (E) {\n          const C = [\n            Qe(+s / E, 0, 1),\n            Qe(+c / E, 0, 1),\n            Qe(+f / E, 0, 1),\n            y ? jn(+y, w) : 1\n          ];\n          if (Un(C))\n            return C;\n        }\n      }\n      return;\n    }\n  }\n  const t = /^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/, n = r.match(t);\n  if (n) {\n    const [\n      a,\n      // eslint-disable-line @typescript-eslint/no-unused-vars\n      o,\n      // <numeric>\n      i,\n      // ,         (optional)\n      s,\n      // <numeric>\n      l,\n      // ,         (optional)\n      u,\n      // <numeric>\n      c,\n      // ,|/       (optional)\n      p,\n      // <numeric> (optional)\n      d\n      // %         (optional)\n    ] = n, f = [i || \" \", l || \" \", c].join(\"\");\n    if (f === \"  \" || f === \"  /\" || f === \",,\" || f === \",,,\") {\n      const h = [\n        +o,\n        Qe(+s, 0, 100),\n        Qe(+u, 0, 100),\n        p ? jn(+p, d) : 1\n      ];\n      if (Un(h))\n        return Is(h);\n    }\n  }\n}\nfunction Pt(r) {\n  return parseInt(r.padEnd(2, r), 16) / 255;\n}\nfunction jn(r, e) {\n  return Qe(e ? r / 100 : r, 0, 1);\n}\nfunction Qe(r, e, t) {\n  return Math.min(Math.max(e, r), t);\n}\nfunction Un(r) {\n  return !r.some(Number.isNaN);\n}\nconst Rs = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  grey: [128, 128, 128],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  rebeccapurple: [102, 51, 153],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\nfunction ze(r, e, t) {\n  return r + t * (e - r);\n}\nfunction at(r, e, t) {\n  return r.map((n, a) => ze(n, e[a], t));\n}\nclass $ {\n  /**\n   * @param r Red component premultiplied by `alpha` 0..1\n   * @param g Green component premultiplied by `alpha` 0..1\n   * @param b Blue component premultiplied by `alpha` 0..1\n   * @param [alpha=1] Alpha component 0..1\n   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already\n   * been multiplied by alpha. If `true` nothing happens if `false` then they will\n   * be multiplied automatically.\n   */\n  constructor(e, t, n, a = 1, o = !0) {\n    this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter(\"rgb\", [e, t, n, a]));\n  }\n  /**\n   * Parses CSS color strings and converts colors to sRGB color space if needed.\n   * Officially supported color formats:\n   * - keyword, e.g. 'aquamarine' or 'steelblue'\n   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'\n   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'\n   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'\n   *\n   * @param input CSS color string to parse.\n   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.\n   */\n  static parse(e) {\n    if (e instanceof $)\n      return e;\n    if (typeof e != \"string\")\n      return;\n    const t = Ps(e);\n    if (t)\n      return new $(...t, !1);\n  }\n  /**\n   * Used in color interpolation and by 'to-rgba' expression.\n   *\n   * @returns Gien color, with reversed alpha blending, in sRGB color space.\n   */\n  get rgb() {\n    const { r: e, g: t, b: n, a } = this, o = a || 1 / 0;\n    return this.overwriteGetter(\"rgb\", [e / o, t / o, n / o, a]);\n  }\n  /**\n   * Used in color interpolation.\n   *\n   * @returns Gien color, with reversed alpha blending, in HCL color space.\n   */\n  get hcl() {\n    return this.overwriteGetter(\"hcl\", Ts(this.rgb));\n  }\n  /**\n   * Used in color interpolation.\n   *\n   * @returns Gien color, with reversed alpha blending, in LAB color space.\n   */\n  get lab() {\n    return this.overwriteGetter(\"lab\", Na(this.rgb));\n  }\n  /**\n   * Lazy getter pattern. When getter is called for the first time lazy value\n   * is calculated and then overwrites getter function in given object instance.\n   *\n   * @example:\n   * const redColor = Color.parse('red');\n   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate\n   * // the value of red in HCL space and invoke this `overwriteGetter` function\n   * // which in turn will set a field with a key 'hcl' in the `redColor` object.\n   * // In other words it will override `get hcl()` from its `Color` prototype\n   * // with its own property: hcl = [calculated red value in hcl].\n   * let y = redColor.hcl; // next call will no longer invoke getter but simply\n   * // return the previously calculated value\n   * x === y; // true - `x` is exactly the same object as `y`\n   *\n   * @param getterKey Getter key\n   * @param lazyValue Lazily calculated value to be memoized by current instance\n   * @private\n   */\n  overwriteGetter(e, t) {\n    return Object.defineProperty(this, e, { value: t }), t;\n  }\n  /**\n   * Used by 'to-string' expression.\n   *\n   * @returns Serialized color in format `rgba(r,g,b,a)`\n   * where r,g,b are numbers within 0..255 and alpha is number within 1..0\n   *\n   * @example\n   * var purple = new Color.parse('purple');\n   * purple.toString; // = \"rgba(128,0,128,1)\"\n   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');\n   * translucentGreen.toString(); // = \"rgba(26,207,26,0.73)\"\n   */\n  toString() {\n    const [e, t, n, a] = this.rgb;\n    return `rgba(${[e, t, n].map((o) => Math.round(o * 255)).join(\",\")},${a})`;\n  }\n  static interpolate(e, t, n, a = \"rgb\") {\n    switch (a) {\n      case \"rgb\": {\n        const [o, i, s, l] = at(e.rgb, t.rgb, n);\n        return new $(o, i, s, l, !1);\n      }\n      case \"hcl\": {\n        const [o, i, s, l] = e.hcl, [u, c, p, d] = t.hcl;\n        let f, h;\n        if (!isNaN(o) && !isNaN(u)) {\n          let x = u - o;\n          u > o && x > 180 ? x -= 360 : u < o && o - u > 180 && (x += 360), f = o + n * x;\n        } else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (h = c)) : (f = o, (p === 1 || p === 0) && (h = i));\n        const [m, y, w, g] = _s([\n          f,\n          h ?? ze(i, c, n),\n          ze(s, p, n),\n          ze(l, d, n)\n        ]);\n        return new $(m, y, w, g, !1);\n      }\n      case \"lab\": {\n        const [o, i, s, l] = ja(at(e.lab, t.lab, n));\n        return new $(o, i, s, l, !1);\n      }\n    }\n  }\n}\n$.black = new $(0, 0, 0, 1);\n$.white = new $(1, 1, 1, 1);\n$.transparent = new $(0, 0, 0, 0);\n$.red = new $(1, 0, 0, 1);\nclass an {\n  constructor(e, t, n) {\n    e ? this.sensitivity = t ? \"variant\" : \"case\" : this.sensitivity = t ? \"accent\" : \"base\", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: \"search\" });\n  }\n  compare(e, t) {\n    return this.collator.compare(e, t);\n  }\n  resolvedLocale() {\n    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n  }\n}\nconst zs = [\"bottom\", \"center\", \"top\"];\nclass Or {\n  constructor(e, t, n, a, o, i) {\n    this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;\n  }\n}\nclass ke {\n  constructor(e) {\n    this.sections = e;\n  }\n  static fromString(e) {\n    return new ke([new Or(e, null, null, null, null, null)]);\n  }\n  isEmpty() {\n    return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);\n  }\n  static factory(e) {\n    return e instanceof ke ? e : ke.fromString(e);\n  }\n  toString() {\n    return this.sections.length === 0 ? \"\" : this.sections.map((e) => e.text).join(\"\");\n  }\n}\nclass oe {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * Numeric padding values\n   * @param input A padding value\n   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.\n   */\n  static parse(e) {\n    if (e instanceof oe)\n      return e;\n    if (typeof e == \"number\")\n      return new oe([e, e, e, e]);\n    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {\n      for (const t of e)\n        if (typeof t != \"number\")\n          return;\n      switch (e.length) {\n        case 1:\n          e = [e[0], e[0], e[0], e[0]];\n          break;\n        case 2:\n          e = [e[0], e[1], e[0], e[1]];\n          break;\n        case 3:\n          e = [e[0], e[1], e[2], e[1]];\n          break;\n      }\n      return new oe(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    return new oe(at(e.values, t.values, n));\n  }\n}\nclass ie {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * Numeric NumberArray values\n   * @param input A NumberArray value\n   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.\n   */\n  static parse(e) {\n    if (e instanceof ie)\n      return e;\n    if (typeof e == \"number\")\n      return new ie([e]);\n    if (Array.isArray(e)) {\n      for (const t of e)\n        if (typeof t != \"number\")\n          return;\n      return new ie(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    return new ie(at(e.values, t.values, n));\n  }\n}\nclass Q {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * ColorArray values\n   * @param input A ColorArray value\n   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.\n   */\n  static parse(e) {\n    if (e instanceof Q)\n      return e;\n    if (typeof e == \"string\") {\n      const n = $.parse(e);\n      return n ? new Q([n]) : void 0;\n    }\n    if (!Array.isArray(e))\n      return;\n    const t = [];\n    for (const n of e) {\n      if (typeof n != \"string\")\n        return;\n      const a = $.parse(n);\n      if (!a)\n        return;\n      t.push(a);\n    }\n    return new Q(t);\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n, a = \"rgb\") {\n    const o = [];\n    if (e.values.length != t.values.length)\n      throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);\n    for (let i = 0; i < e.values.length; i++)\n      o.push($.interpolate(e.values[i], t.values[i], n, a));\n    return new Q(o);\n  }\n}\nclass D extends Error {\n  constructor(e) {\n    super(e), this.name = \"RuntimeError\";\n  }\n  toJSON() {\n    return this.message;\n  }\n}\nconst Fs = /* @__PURE__ */ new Set([\"center\", \"left\", \"right\", \"top\", \"bottom\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]);\nclass me {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  static parse(e) {\n    if (e instanceof me)\n      return e;\n    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {\n      for (let t = 0; t < e.length; t += 2) {\n        const n = e[t], a = e[t + 1];\n        if (typeof n != \"string\" || !Fs.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != \"number\" || typeof a[1] != \"number\")\n          return;\n      }\n      return new me(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    const a = e.values, o = t.values;\n    if (a.length !== o.length)\n      throw new D(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);\n    const i = [];\n    for (let s = 0; s < a.length; s += 2) {\n      if (a[s] !== o[s])\n        throw new D(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);\n      i.push(a[s]);\n      const [l, u] = a[s + 1], [c, p] = o[s + 1];\n      i.push([ze(l, c, n), ze(u, p, n)]);\n    }\n    return new me(i);\n  }\n}\nclass $e {\n  constructor(e) {\n    this.name = e.name, this.available = e.available;\n  }\n  toString() {\n    return this.name;\n  }\n  static fromString(e) {\n    return e ? new $e({ name: e, available: !1 }) : null;\n  }\n}\nclass fe {\n  constructor(e, t, n) {\n    this.from = e, this.to = t, this.transition = n;\n  }\n  static interpolate(e, t, n) {\n    return new fe(e, t, n);\n  }\n  static parse(e) {\n    if (e instanceof fe)\n      return e;\n    if (Array.isArray(e) && e.length === 3 && typeof e[0] == \"string\" && typeof e[1] == \"string\" && typeof e[2] == \"number\")\n      return new fe(e[0], e[1], e[2]);\n    if (typeof e == \"object\" && typeof e.from == \"string\" && typeof e.to == \"string\" && typeof e.transition == \"number\")\n      return new fe(e.from, e.to, e.transition);\n    if (typeof e == \"string\")\n      return new fe(e, e, 1);\n  }\n}\nfunction Ua(r, e, t, n) {\n  return typeof r == \"number\" && r >= 0 && r <= 255 && typeof e == \"number\" && e >= 0 && e <= 255 && typeof t == \"number\" && t >= 0 && t <= 255 ? typeof n > \"u\" || typeof n == \"number\" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[r, e, t, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == \"number\" ? [r, e, t, n] : [r, e, t]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n}\nfunction vt(r) {\n  if (r === null || typeof r == \"string\" || typeof r == \"boolean\" || typeof r == \"number\" || r instanceof fe || r instanceof $ || r instanceof an || r instanceof ke || r instanceof oe || r instanceof ie || r instanceof Q || r instanceof me || r instanceof $e)\n    return !0;\n  if (Array.isArray(r)) {\n    for (const e of r)\n      if (!vt(e))\n        return !1;\n    return !0;\n  } else if (typeof r == \"object\") {\n    for (const e in r)\n      if (!vt(r[e]))\n        return !1;\n    return !0;\n  } else\n    return !1;\n}\nfunction q(r) {\n  if (r === null)\n    return Wt;\n  if (typeof r == \"string\")\n    return P;\n  if (typeof r == \"boolean\")\n    return M;\n  if (typeof r == \"number\")\n    return S;\n  if (r instanceof $)\n    return we;\n  if (r instanceof fe)\n    return Jt;\n  if (r instanceof an)\n    return Qt;\n  if (r instanceof ke)\n    return er;\n  if (r instanceof oe)\n    return tr;\n  if (r instanceof ie)\n    return rr;\n  if (r instanceof Q)\n    return yt;\n  if (r instanceof me)\n    return nr;\n  if (r instanceof $e)\n    return At;\n  if (Array.isArray(r)) {\n    const e = r.length;\n    let t;\n    for (const n of r) {\n      const a = q(n);\n      if (!t)\n        t = a;\n      else {\n        if (t === a)\n          continue;\n        t = I;\n        break;\n      }\n    }\n    return te(t || I, e);\n  } else\n    return Be;\n}\nfunction ht(r) {\n  const e = typeof r;\n  return r === null ? \"\" : e === \"string\" || e === \"number\" || e === \"boolean\" ? String(r) : r instanceof $ || r instanceof fe || r instanceof ke || r instanceof oe || r instanceof ie || r instanceof Q || r instanceof me || r instanceof $e ? r.toString() : JSON.stringify(r);\n}\nclass ot {\n  constructor(e, t) {\n    this.type = e, this.value = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (!vt(e[1]))\n      return t.error(\"invalid value\");\n    const n = e[1];\n    let a = q(n);\n    const o = t.expectedType;\n    return a.kind === \"array\" && a.N === 0 && o && o.kind === \"array\" && (typeof o.N != \"number\" || o.N === 0) && (a = o), new ot(a, n);\n  }\n  evaluate() {\n    return this.value;\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nconst Rt = {\n  string: P,\n  number: S,\n  boolean: M,\n  object: Be\n};\nclass de {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    let n = 1, a;\n    const o = e[0];\n    if (o === \"array\") {\n      let s;\n      if (e.length > 2) {\n        const u = e[1];\n        if (typeof u != \"string\" || !(u in Rt) || u === \"object\")\n          return t.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n        s = Rt[u], n++;\n      } else\n        s = I;\n      let l;\n      if (e.length > 3) {\n        if (e[2] !== null && (typeof e[2] != \"number\" || e[2] < 0 || e[2] !== Math.floor(e[2])))\n          return t.error('The length argument to \"array\" must be a positive integer literal', 2);\n        l = e[2], n++;\n      }\n      a = te(s, l);\n    } else {\n      if (!Rt[o])\n        throw new Error(`Types doesn't contain name = ${o}`);\n      a = Rt[o];\n    }\n    const i = [];\n    for (; n < e.length; n++) {\n      const s = t.parse(e[n], n, I);\n      if (!s)\n        return null;\n      i.push(s);\n    }\n    return new de(a, i);\n  }\n  evaluate(e) {\n    for (let t = 0; t < this.args.length; t++) {\n      const n = this.args[t].evaluate(e);\n      if (gt(this.type, q(n))) {\n        if (t === this.args.length - 1)\n          throw new D(`Expected value to be of type ${U(this.type)}, but found ${U(q(n))} instead.`);\n      } else return n;\n    }\n    throw new Error();\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every((e) => e.outputDefined());\n  }\n}\nconst Dn = {\n  \"to-boolean\": M,\n  \"to-color\": we,\n  \"to-number\": S,\n  \"to-string\": P\n};\nclass Pe {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    const n = e[0];\n    if (!Dn[n])\n      throw new Error(`Can't parse ${n} as it is not part of the known types`);\n    if ((n === \"to-boolean\" || n === \"to-string\") && e.length !== 2)\n      return t.error(\"Expected one argument.\");\n    const a = Dn[n], o = [];\n    for (let i = 1; i < e.length; i++) {\n      const s = t.parse(e[i], i, I);\n      if (!s)\n        return null;\n      o.push(s);\n    }\n    return new Pe(a, o);\n  }\n  evaluate(e) {\n    switch (this.type.kind) {\n      case \"boolean\":\n        return !!this.args[0].evaluate(e);\n      case \"color\": {\n        let t, n;\n        for (const a of this.args) {\n          if (t = a.evaluate(e), n = null, t instanceof $)\n            return t;\n          if (typeof t == \"string\") {\n            const o = e.parseColor(t);\n            if (o)\n              return o;\n          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = Ua(t[0], t[1], t[2], t[3]), !n))\n            return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);\n        }\n        throw new D(n || `Could not parse color from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"padding\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = oe.parse(t);\n          if (a)\n            return a;\n        }\n        throw new D(`Could not parse padding from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"numberArray\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = ie.parse(t);\n          if (a)\n            return a;\n        }\n        throw new D(`Could not parse numberArray from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"colorArray\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = Q.parse(t);\n          if (a)\n            return a;\n        }\n        throw new D(`Could not parse colorArray from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"variableAnchorOffsetCollection\": {\n        let t;\n        for (const n of this.args) {\n          t = n.evaluate(e);\n          const a = me.parse(t);\n          if (a)\n            return a;\n        }\n        throw new D(`Could not parse variableAnchorOffsetCollection from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n      }\n      case \"number\": {\n        let t = null;\n        for (const n of this.args) {\n          if (t = n.evaluate(e), t === null)\n            return 0;\n          const a = Number(t);\n          if (!isNaN(a))\n            return a;\n        }\n        throw new D(`Could not convert ${JSON.stringify(t)} to number.`);\n      }\n      case \"formatted\":\n        return ke.fromString(ht(this.args[0].evaluate(e)));\n      case \"resolvedImage\":\n        return $e.fromString(ht(this.args[0].evaluate(e)));\n      case \"projectionDefinition\":\n        return this.args[0].evaluate(e);\n      default:\n        return ht(this.args[0].evaluate(e));\n    }\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every((e) => e.outputDefined());\n  }\n}\nconst $s = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\nclass Da {\n  constructor() {\n    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;\n  }\n  id() {\n    return this.feature && \"id\" in this.feature ? this.feature.id : null;\n  }\n  geometryType() {\n    return this.feature ? typeof this.feature.type == \"number\" ? $s[this.feature.type] : this.feature.type : null;\n  }\n  geometry() {\n    return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n  }\n  canonicalID() {\n    return this.canonical;\n  }\n  properties() {\n    return this.feature && this.feature.properties || {};\n  }\n  parseColor(e) {\n    let t = this._parseColorCache.get(e);\n    return t || (t = $.parse(e), this._parseColorCache.set(e, t)), t;\n  }\n}\nclass ar {\n  constructor(e, t, n = [], a, o = new rn(), i = []) {\n    this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(\"\"), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;\n  }\n  /**\n   * @param expr the JSON expression to parse\n   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed\n   * @param options\n   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.\n   * @private\n   */\n  parse(e, t, n, a, o = {}) {\n    return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);\n  }\n  _parse(e, t) {\n    (e === null || typeof e == \"string\" || typeof e == \"boolean\" || typeof e == \"number\") && (e = [\"literal\", e]);\n    function n(a, o, i) {\n      return i === \"assert\" ? new de(o, [a]) : i === \"coerce\" ? new Pe(o, [a]) : a;\n    }\n    if (Array.isArray(e)) {\n      if (e.length === 0)\n        return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n      const a = e[0];\n      if (typeof a != \"string\")\n        return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n      const o = this.registry[a];\n      if (o) {\n        let i = o.parse(e, this);\n        if (!i)\n          return null;\n        if (this.expectedType) {\n          const s = this.expectedType, l = i.type;\n          if ((s.kind === \"string\" || s.kind === \"number\" || s.kind === \"boolean\" || s.kind === \"object\" || s.kind === \"array\") && l.kind === \"value\")\n            i = n(i, s, t.typeAnnotation || \"assert\");\n          else if (s.kind === \"projectionDefinition\" && [\"string\", \"array\"].includes(l.kind) || [\"color\", \"formatted\", \"resolvedImage\"].includes(s.kind) && [\"value\", \"string\"].includes(l.kind) || [\"padding\", \"numberArray\"].includes(s.kind) && [\"value\", \"number\", \"array\"].includes(l.kind) || s.kind === \"colorArray\" && [\"value\", \"string\", \"array\"].includes(l.kind) || s.kind === \"variableAnchorOffsetCollection\" && [\"value\", \"array\"].includes(l.kind))\n            i = n(i, s, t.typeAnnotation || \"coerce\");\n          else if (this.checkSubtype(s, l))\n            return null;\n        }\n        if (!(i instanceof ot) && i.type.kind !== \"resolvedImage\" && this._isConstant(i)) {\n          const s = new Da();\n          try {\n            i = new ot(i.type, i.evaluate(s));\n          } catch (l) {\n            return this.error(l.message), null;\n          }\n        }\n        return i;\n      }\n      return this.error(`Unknown expression \"${a}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n    } else return typeof e > \"u\" ? this.error(\"'undefined' value invalid. Use null instead.\") : typeof e == \"object\" ? this.error('Bare objects invalid. Use [\"literal\", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);\n  }\n  /**\n   * Returns a copy of this context suitable for parsing the subexpression at\n   * index `index`, optionally appending to 'let' binding map.\n   *\n   * Note that `errors` property, intended for collecting errors while\n   * parsing, is copied by reference rather than cloned.\n   * @private\n   */\n  concat(e, t, n) {\n    const a = typeof e == \"number\" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;\n    return new ar(this.registry, this._isConstant, a, t || null, o, this.errors);\n  }\n  /**\n   * Push a parsing (or type checking) error into the `this.errors`\n   * @param error The message\n   * @param keys Optionally specify the source of the error at a child\n   * of the current expression at `this.key`.\n   * @private\n   */\n  error(e, ...t) {\n    const n = `${this.key}${t.map((a) => `[${a}]`).join(\"\")}`;\n    this.errors.push(new be(n, e));\n  }\n  /**\n   * Returns null if `t` is a subtype of `expected`; otherwise returns an\n   * error message and also pushes it to `this.errors`.\n   * @param expected The expected type\n   * @param t The actual type\n   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message\n   */\n  checkSubtype(e, t) {\n    const n = gt(e, t);\n    return n && this.error(n), n;\n  }\n}\nclass or {\n  constructor(e, t) {\n    this.type = t.type, this.bindings = [].concat(e), this.result = t;\n  }\n  evaluate(e) {\n    return this.result.evaluate(e);\n  }\n  eachChild(e) {\n    for (const t of this.bindings)\n      e(t[1]);\n    e(this.result);\n  }\n  static parse(e, t) {\n    if (e.length < 4)\n      return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);\n    const n = [];\n    for (let o = 1; o < e.length - 1; o += 2) {\n      const i = e[o];\n      if (typeof i != \"string\")\n        return t.error(`Expected string, but found ${typeof i} instead.`, o);\n      if (/[^a-zA-Z0-9_]/.test(i))\n        return t.error(\"Variable names must contain only alphanumeric characters or '_'.\", o);\n      const s = t.parse(e[o + 1], o + 1);\n      if (!s)\n        return null;\n      n.push([i, s]);\n    }\n    const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);\n    return a ? new or(n, a) : null;\n  }\n  outputDefined() {\n    return this.result.outputDefined();\n  }\n}\nclass ir {\n  constructor(e, t) {\n    this.type = t.type, this.name = e, this.boundExpression = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2 || typeof e[1] != \"string\")\n      return t.error(\"'var' expression requires exactly one string literal argument.\");\n    const n = e[1];\n    return t.scope.has(n) ? new ir(n, t.scope.get(n)) : t.error(`Unknown variable \"${n}\". Make sure \"${n}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n  }\n  evaluate(e) {\n    return this.boundExpression.evaluate(e);\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass on {\n  constructor(e, t, n) {\n    this.type = e, this.index = t, this.input = n;\n  }\n  static parse(e, t) {\n    if (e.length !== 3)\n      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, S), a = t.parse(e[2], 2, te(t.expectedType || I));\n    if (!n || !a)\n      return null;\n    const o = a.type;\n    return new on(o.itemType, n, a);\n  }\n  evaluate(e) {\n    const t = this.index.evaluate(e), n = this.input.evaluate(e);\n    if (t < 0)\n      throw new D(`Array index out of bounds: ${t} < 0.`);\n    if (t >= n.length)\n      throw new D(`Array index out of bounds: ${t} > ${n.length - 1}.`);\n    if (t !== Math.floor(t))\n      throw new D(`Array index must be an integer, but found ${t} instead.`);\n    return n[t];\n  }\n  eachChild(e) {\n    e(this.index), e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass sn {\n  constructor(e, t) {\n    this.type = M, this.needle = e, this.haystack = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 3)\n      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);\n    return !n || !a ? null : nn(n.type, [M, P, S, Wt, I]) ? new sn(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${U(n.type)} instead`);\n  }\n  evaluate(e) {\n    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);\n    if (!n)\n      return !1;\n    if (!qe(t, [\"boolean\", \"string\", \"number\", \"null\"]))\n      throw new D(`Expected first argument to be of type boolean, string, number or null, but found ${U(q(t))} instead.`);\n    if (!qe(n, [\"string\", \"array\"]))\n      throw new D(`Expected second argument to be of type array or string, but found ${U(q(n))} instead.`);\n    return n.indexOf(t) >= 0;\n  }\n  eachChild(e) {\n    e(this.needle), e(this.haystack);\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass Bt {\n  constructor(e, t, n) {\n    this.type = S, this.needle = e, this.haystack = t, this.fromIndex = n;\n  }\n  static parse(e, t) {\n    if (e.length <= 2 || e.length >= 5)\n      return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);\n    if (!n || !a)\n      return null;\n    if (!nn(n.type, [M, P, S, Wt, I]))\n      return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${U(n.type)} instead`);\n    if (e.length === 4) {\n      const o = t.parse(e[3], 3, S);\n      return o ? new Bt(n, a, o) : null;\n    } else\n      return new Bt(n, a);\n  }\n  evaluate(e) {\n    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);\n    if (!qe(t, [\"boolean\", \"string\", \"number\", \"null\"]))\n      throw new D(`Expected first argument to be of type boolean, string, number or null, but found ${U(q(t))} instead.`);\n    let a;\n    if (this.fromIndex && (a = this.fromIndex.evaluate(e)), qe(n, [\"string\"])) {\n      const o = n.indexOf(t, a);\n      return o === -1 ? -1 : [...n.slice(0, o)].length;\n    } else {\n      if (qe(n, [\"array\"]))\n        return n.indexOf(t, a);\n      throw new D(`Expected second argument to be of type array or string, but found ${U(q(n))} instead.`);\n    }\n  }\n  eachChild(e) {\n    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass ln {\n  constructor(e, t, n, a, o, i) {\n    this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;\n  }\n  static parse(e, t) {\n    if (e.length < 5)\n      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if (e.length % 2 !== 1)\n      return t.error(\"Expected an even number of arguments.\");\n    let n, a;\n    t.expectedType && t.expectedType.kind !== \"value\" && (a = t.expectedType);\n    const o = {}, i = [];\n    for (let u = 2; u < e.length - 1; u += 2) {\n      let c = e[u];\n      const p = e[u + 1];\n      Array.isArray(c) || (c = [c]);\n      const d = t.concat(u);\n      if (c.length === 0)\n        return d.error(\"Expected at least one branch label.\");\n      for (const h of c) {\n        if (typeof h != \"number\" && typeof h != \"string\")\n          return d.error(\"Branch labels must be numbers or strings.\");\n        if (typeof h == \"number\" && Math.abs(h) > Number.MAX_SAFE_INTEGER)\n          return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n        if (typeof h == \"number\" && Math.floor(h) !== h)\n          return d.error(\"Numeric branch labels must be integer values.\");\n        if (!n)\n          n = q(h);\n        else if (d.checkSubtype(n, q(h)))\n          return null;\n        if (typeof o[String(h)] < \"u\")\n          return d.error(\"Branch labels must be unique.\");\n        o[String(h)] = i.length;\n      }\n      const f = t.parse(p, u, a);\n      if (!f)\n        return null;\n      a = a || f.type, i.push(f);\n    }\n    const s = t.parse(e[1], 1, I);\n    if (!s)\n      return null;\n    const l = t.parse(e[e.length - 1], e.length - 1, a);\n    return !l || s.type.kind !== \"value\" && t.concat(1).checkSubtype(n, s.type) ? null : new ln(n, a, s, o, i, l);\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e);\n    return (q(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);\n  }\n  eachChild(e) {\n    e(this.input), this.outputs.forEach(e), e(this.otherwise);\n  }\n  outputDefined() {\n    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();\n  }\n}\nclass un {\n  constructor(e, t, n) {\n    this.type = e, this.branches = t, this.otherwise = n;\n  }\n  static parse(e, t) {\n    if (e.length < 4)\n      return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);\n    if (e.length % 2 !== 0)\n      return t.error(\"Expected an odd number of arguments.\");\n    let n;\n    t.expectedType && t.expectedType.kind !== \"value\" && (n = t.expectedType);\n    const a = [];\n    for (let i = 1; i < e.length - 1; i += 2) {\n      const s = t.parse(e[i], i, M);\n      if (!s)\n        return null;\n      const l = t.parse(e[i + 1], i + 1, n);\n      if (!l)\n        return null;\n      a.push([s, l]), n = n || l.type;\n    }\n    const o = t.parse(e[e.length - 1], e.length - 1, n);\n    if (!o)\n      return null;\n    if (!n)\n      throw new Error(\"Can't infer output type\");\n    return new un(n, a, o);\n  }\n  evaluate(e) {\n    for (const [t, n] of this.branches)\n      if (t.evaluate(e))\n        return n.evaluate(e);\n    return this.otherwise.evaluate(e);\n  }\n  eachChild(e) {\n    for (const [t, n] of this.branches)\n      e(t), e(n);\n    e(this.otherwise);\n  }\n  outputDefined() {\n    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();\n  }\n}\nclass qt {\n  constructor(e, t, n, a) {\n    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;\n  }\n  static parse(e, t) {\n    if (e.length <= 2 || e.length >= 5)\n      return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, S);\n    if (!n || !a)\n      return null;\n    if (!nn(n.type, [te(I), P, I]))\n      return t.error(`Expected first argument to be of type array or string, but found ${U(n.type)} instead`);\n    if (e.length === 4) {\n      const o = t.parse(e[3], 3, S);\n      return o ? new qt(n.type, n, a, o) : null;\n    } else\n      return new qt(n.type, n, a);\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);\n    let a;\n    if (this.endIndex && (a = this.endIndex.evaluate(e)), qe(t, [\"string\"]))\n      return [...t].slice(n, a).join(\"\");\n    if (qe(t, [\"array\"]))\n      return t.slice(n, a);\n    throw new D(`Expected first argument to be of type array or string, but found ${U(q(t))} instead.`);\n  }\n  eachChild(e) {\n    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nfunction Ba(r, e) {\n  const t = r.length - 1;\n  let n = 0, a = t, o = 0, i, s;\n  for (; n <= a; )\n    if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {\n      if (o === t || e < s)\n        return o;\n      n = o + 1;\n    } else if (i > e)\n      a = o - 1;\n    else\n      throw new D(\"Input is not a number.\");\n  return 0;\n}\nclass sr {\n  constructor(e, t, n) {\n    this.type = e, this.input = t, this.labels = [], this.outputs = [];\n    for (const [a, o] of n)\n      this.labels.push(a), this.outputs.push(o);\n  }\n  static parse(e, t) {\n    if (e.length - 1 < 4)\n      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if ((e.length - 1) % 2 !== 0)\n      return t.error(\"Expected an even number of arguments.\");\n    const n = t.parse(e[1], 1, S);\n    if (!n)\n      return null;\n    const a = [];\n    let o = null;\n    t.expectedType && t.expectedType.kind !== \"value\" && (o = t.expectedType);\n    for (let i = 1; i < e.length; i += 2) {\n      const s = i === 1 ? -1 / 0 : e[i], l = e[i + 1], u = i, c = i + 1;\n      if (typeof s != \"number\")\n        return t.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);\n      if (a.length && a[a.length - 1][0] >= s)\n        return t.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', u);\n      const p = t.parse(l, c, o);\n      if (!p)\n        return null;\n      o = o || p.type, a.push([s, p]);\n    }\n    return new sr(o, n, a);\n  }\n  evaluate(e) {\n    const t = this.labels, n = this.outputs;\n    if (t.length === 1)\n      return n[0].evaluate(e);\n    const a = this.input.evaluate(e);\n    if (a <= t[0])\n      return n[0].evaluate(e);\n    const o = t.length;\n    if (a >= t[o - 1])\n      return n[o - 1].evaluate(e);\n    const i = Ba(t, a);\n    return n[i].evaluate(e);\n  }\n  eachChild(e) {\n    e(this.input);\n    for (const t of this.outputs)\n      e(t);\n  }\n  outputDefined() {\n    return this.outputs.every((e) => e.outputDefined());\n  }\n}\nfunction Os(r) {\n  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, \"default\") ? r.default : r;\n}\nvar xr, Bn;\nfunction Ns() {\n  if (Bn) return xr;\n  Bn = 1, xr = r;\n  function r(e, t, n, a) {\n    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;\n  }\n  return r.prototype = {\n    sampleCurveX: function(e) {\n      return ((this.ax * e + this.bx) * e + this.cx) * e;\n    },\n    sampleCurveY: function(e) {\n      return ((this.ay * e + this.by) * e + this.cy) * e;\n    },\n    sampleCurveDerivativeX: function(e) {\n      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;\n    },\n    solveCurveX: function(e, t) {\n      if (t === void 0 && (t = 1e-6), e < 0) return 0;\n      if (e > 1) return 1;\n      for (var n = e, a = 0; a < 8; a++) {\n        var o = this.sampleCurveX(n) - e;\n        if (Math.abs(o) < t) return n;\n        var i = this.sampleCurveDerivativeX(n);\n        if (Math.abs(i) < 1e-6) break;\n        n = n - o / i;\n      }\n      var s = 0, l = 1;\n      for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++)\n        e > o ? s = n : l = n, n = (l - s) * 0.5 + s;\n      return n;\n    },\n    solve: function(e, t) {\n      return this.sampleCurveY(this.solveCurveX(e, t));\n    }\n  }, xr;\n}\nvar js = Ns(), Us = /* @__PURE__ */ Os(js);\nclass Se {\n  constructor(e, t, n, a, o) {\n    this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];\n    for (const [i, s] of o)\n      this.labels.push(i), this.outputs.push(s);\n  }\n  static interpolationFactor(e, t, n, a) {\n    let o = 0;\n    if (e.name === \"exponential\")\n      o = kr(t, e.base, n, a);\n    else if (e.name === \"linear\")\n      o = kr(t, 1, n, a);\n    else if (e.name === \"cubic-bezier\") {\n      const i = e.controlPoints;\n      o = new Us(i[0], i[1], i[2], i[3]).solve(kr(t, 1, n, a));\n    }\n    return o;\n  }\n  static parse(e, t) {\n    let [n, a, o, ...i] = e;\n    if (!Array.isArray(a) || a.length === 0)\n      return t.error(\"Expected an interpolation type expression.\", 1);\n    if (a[0] === \"linear\")\n      a = { name: \"linear\" };\n    else if (a[0] === \"exponential\") {\n      const u = a[1];\n      if (typeof u != \"number\")\n        return t.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n      a = {\n        name: \"exponential\",\n        base: u\n      };\n    } else if (a[0] === \"cubic-bezier\") {\n      const u = a.slice(1);\n      if (u.length !== 4 || u.some((c) => typeof c != \"number\" || c < 0 || c > 1))\n        return t.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n      a = {\n        name: \"cubic-bezier\",\n        controlPoints: u\n      };\n    } else\n      return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);\n    if (e.length - 1 < 4)\n      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if ((e.length - 1) % 2 !== 0)\n      return t.error(\"Expected an even number of arguments.\");\n    if (o = t.parse(o, 2, S), !o)\n      return null;\n    const s = [];\n    let l = null;\n    (n === \"interpolate-hcl\" || n === \"interpolate-lab\") && t.expectedType != yt ? l = we : t.expectedType && t.expectedType.kind !== \"value\" && (l = t.expectedType);\n    for (let u = 0; u < i.length; u += 2) {\n      const c = i[u], p = i[u + 1], d = u + 3, f = u + 4;\n      if (typeof c != \"number\")\n        return t.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', d);\n      if (s.length && s[s.length - 1][0] >= c)\n        return t.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', d);\n      const h = t.parse(p, f, l);\n      if (!h)\n        return null;\n      l = l || h.type, s.push([c, h]);\n    }\n    return !Ee(l, S) && !Ee(l, Jt) && !Ee(l, we) && !Ee(l, tr) && !Ee(l, rr) && !Ee(l, yt) && !Ee(l, nr) && !Ee(l, te(S)) ? t.error(`Type ${U(l)} is not interpolatable.`) : new Se(l, n, a, o, s);\n  }\n  evaluate(e) {\n    const t = this.labels, n = this.outputs;\n    if (t.length === 1)\n      return n[0].evaluate(e);\n    const a = this.input.evaluate(e);\n    if (a <= t[0])\n      return n[0].evaluate(e);\n    const o = t.length;\n    if (a >= t[o - 1])\n      return n[o - 1].evaluate(e);\n    const i = Ba(t, a), s = t[i], l = t[i + 1], u = Se.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);\n    switch (this.operator) {\n      case \"interpolate\":\n        switch (this.type.kind) {\n          case \"number\":\n            return ze(c, p, u);\n          case \"color\":\n            return $.interpolate(c, p, u);\n          case \"padding\":\n            return oe.interpolate(c, p, u);\n          case \"colorArray\":\n            return Q.interpolate(c, p, u);\n          case \"numberArray\":\n            return ie.interpolate(c, p, u);\n          case \"variableAnchorOffsetCollection\":\n            return me.interpolate(c, p, u);\n          case \"array\":\n            return at(c, p, u);\n          case \"projectionDefinition\":\n            return fe.interpolate(c, p, u);\n        }\n      case \"interpolate-hcl\":\n        switch (this.type.kind) {\n          case \"color\":\n            return $.interpolate(c, p, u, \"hcl\");\n          case \"colorArray\":\n            return Q.interpolate(c, p, u, \"hcl\");\n        }\n      case \"interpolate-lab\":\n        switch (this.type.kind) {\n          case \"color\":\n            return $.interpolate(c, p, u, \"lab\");\n          case \"colorArray\":\n            return Q.interpolate(c, p, u, \"lab\");\n        }\n    }\n  }\n  eachChild(e) {\n    e(this.input);\n    for (const t of this.outputs)\n      e(t);\n  }\n  outputDefined() {\n    return this.outputs.every((e) => e.outputDefined());\n  }\n}\nfunction kr(r, e, t, n) {\n  const a = n - t, o = r - t;\n  return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);\n}\n$.interpolate, oe.interpolate, ie.interpolate, Q.interpolate, me.interpolate;\nclass bt {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    let n = null;\n    const a = t.expectedType;\n    a && a.kind !== \"value\" && (n = a);\n    const o = [];\n    for (const s of e.slice(1)) {\n      const l = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: \"omit\" });\n      if (!l)\n        return null;\n      n = n || l.type, o.push(l);\n    }\n    if (!n)\n      throw new Error(\"No output type\");\n    return a && o.some((s) => gt(a, s.type)) ? new bt(I, o) : new bt(n, o);\n  }\n  evaluate(e) {\n    let t = null, n = 0, a;\n    for (const o of this.args)\n      if (n++, t = o.evaluate(e), t && t instanceof $e && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null)\n        break;\n    return t;\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every((e) => e.outputDefined());\n  }\n}\nfunction qn(r, e) {\n  return r === \"==\" || r === \"!=\" ? e.kind === \"boolean\" || e.kind === \"string\" || e.kind === \"number\" || e.kind === \"null\" || e.kind === \"value\" : e.kind === \"string\" || e.kind === \"number\" || e.kind === \"value\";\n}\nfunction Ds(r, e, t) {\n  return e === t;\n}\nfunction Bs(r, e, t) {\n  return e !== t;\n}\nfunction qs(r, e, t) {\n  return e < t;\n}\nfunction Vs(r, e, t) {\n  return e > t;\n}\nfunction Gs(r, e, t) {\n  return e <= t;\n}\nfunction Hs(r, e, t) {\n  return e >= t;\n}\nfunction qa(r, e, t, n) {\n  return n.compare(e, t) === 0;\n}\nfunction Zs(r, e, t, n) {\n  return !qa(r, e, t, n);\n}\nfunction Xs(r, e, t, n) {\n  return n.compare(e, t) < 0;\n}\nfunction Ks(r, e, t, n) {\n  return n.compare(e, t) > 0;\n}\nfunction Ys(r, e, t, n) {\n  return n.compare(e, t) <= 0;\n}\nfunction Ws(r, e, t, n) {\n  return n.compare(e, t) >= 0;\n}\nfunction st(r, e, t) {\n  const n = r !== \"==\" && r !== \"!=\";\n  return class Va {\n    constructor(o, i, s) {\n      this.type = M, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === \"value\" || i.type.kind === \"value\";\n    }\n    static parse(o, i) {\n      if (o.length !== 3 && o.length !== 4)\n        return i.error(\"Expected two or three arguments.\");\n      const s = o[0];\n      let l = i.parse(o[1], 1, I);\n      if (!l)\n        return null;\n      if (!qn(s, l.type))\n        return i.concat(1).error(`\"${s}\" comparisons are not supported for type '${U(l.type)}'.`);\n      let u = i.parse(o[2], 2, I);\n      if (!u)\n        return null;\n      if (!qn(s, u.type))\n        return i.concat(2).error(`\"${s}\" comparisons are not supported for type '${U(u.type)}'.`);\n      if (l.type.kind !== u.type.kind && l.type.kind !== \"value\" && u.type.kind !== \"value\")\n        return i.error(`Cannot compare types '${U(l.type)}' and '${U(u.type)}'.`);\n      n && (l.type.kind === \"value\" && u.type.kind !== \"value\" ? l = new de(u.type, [l]) : l.type.kind !== \"value\" && u.type.kind === \"value\" && (u = new de(l.type, [u])));\n      let c = null;\n      if (o.length === 4) {\n        if (l.type.kind !== \"string\" && u.type.kind !== \"string\" && l.type.kind !== \"value\" && u.type.kind !== \"value\")\n          return i.error(\"Cannot use collator to compare non-string types.\");\n        if (c = i.parse(o[3], 3, Qt), !c)\n          return null;\n      }\n      return new Va(l, u, c);\n    }\n    evaluate(o) {\n      const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);\n      if (n && this.hasUntypedArgument) {\n        const l = q(i), u = q(s);\n        if (l.kind !== u.kind || !(l.kind === \"string\" || l.kind === \"number\"))\n          throw new D(`Expected arguments for \"${r}\" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);\n      }\n      if (this.collator && !n && this.hasUntypedArgument) {\n        const l = q(i), u = q(s);\n        if (l.kind !== \"string\" || u.kind !== \"string\")\n          return e(o, i, s);\n      }\n      return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);\n    }\n    eachChild(o) {\n      o(this.lhs), o(this.rhs), this.collator && o(this.collator);\n    }\n    outputDefined() {\n      return !0;\n    }\n  };\n}\nconst Js = st(\"==\", Ds, qa), Qs = st(\"!=\", Bs, Zs), el = st(\"<\", qs, Xs), tl = st(\">\", Vs, Ks), rl = st(\"<=\", Gs, Ys), nl = st(\">=\", Hs, Ws);\nclass lr {\n  constructor(e, t, n) {\n    this.type = Qt, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(\"Expected one argument.\");\n    const n = e[1];\n    if (typeof n != \"object\" || Array.isArray(n))\n      return t.error(\"Collator options argument must be an object.\");\n    const a = t.parse(n[\"case-sensitive\"] === void 0 ? !1 : n[\"case-sensitive\"], 1, M);\n    if (!a)\n      return null;\n    const o = t.parse(n[\"diacritic-sensitive\"] === void 0 ? !1 : n[\"diacritic-sensitive\"], 1, M);\n    if (!o)\n      return null;\n    let i = null;\n    return n.locale && (i = t.parse(n.locale, 1, P), !i) ? null : new lr(a, o, i);\n  }\n  evaluate(e) {\n    return new an(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);\n  }\n  eachChild(e) {\n    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass cn {\n  constructor(e, t, n, a, o) {\n    this.type = P, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;\n  }\n  static parse(e, t) {\n    if (e.length !== 3)\n      return t.error(\"Expected two arguments.\");\n    const n = t.parse(e[1], 1, S);\n    if (!n)\n      return null;\n    const a = e[2];\n    if (typeof a != \"object\" || Array.isArray(a))\n      return t.error(\"NumberFormat options argument must be an object.\");\n    let o = null;\n    if (a.locale && (o = t.parse(a.locale, 1, P), !o))\n      return null;\n    let i = null;\n    if (a.currency && (i = t.parse(a.currency, 1, P), !i))\n      return null;\n    let s = null;\n    if (a[\"min-fraction-digits\"] && (s = t.parse(a[\"min-fraction-digits\"], 1, S), !s))\n      return null;\n    let l = null;\n    return a[\"max-fraction-digits\"] && (l = t.parse(a[\"max-fraction-digits\"], 1, S), !l) ? null : new cn(n, o, i, s, l);\n  }\n  evaluate(e) {\n    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {\n      style: this.currency ? \"currency\" : \"decimal\",\n      currency: this.currency ? this.currency.evaluate(e) : void 0,\n      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,\n      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0\n    }).format(this.number.evaluate(e));\n  }\n  eachChild(e) {\n    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass pn {\n  constructor(e) {\n    this.type = er, this.sections = e;\n  }\n  static parse(e, t) {\n    if (e.length < 2)\n      return t.error(\"Expected at least one argument.\");\n    const n = e[1];\n    if (!Array.isArray(n) && typeof n == \"object\")\n      return t.error(\"First argument must be an image or text section.\");\n    const a = [];\n    let o = !1;\n    for (let i = 1; i <= e.length - 1; ++i) {\n      const s = e[i];\n      if (o && typeof s == \"object\" && !Array.isArray(s)) {\n        o = !1;\n        let l = null;\n        if (s[\"font-scale\"] && (l = t.parse(s[\"font-scale\"], 1, S), !l))\n          return null;\n        let u = null;\n        if (s[\"text-font\"] && (u = t.parse(s[\"text-font\"], 1, te(P)), !u))\n          return null;\n        let c = null;\n        if (s[\"text-color\"] && (c = t.parse(s[\"text-color\"], 1, we), !c))\n          return null;\n        let p = null;\n        if (s[\"vertical-align\"]) {\n          if (typeof s[\"vertical-align\"] == \"string\" && !zs.includes(s[\"vertical-align\"]))\n            return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s[\"vertical-align\"]}' instead.`);\n          if (p = t.parse(s[\"vertical-align\"], 1, P), !p)\n            return null;\n        }\n        const d = a[a.length - 1];\n        d.scale = l, d.font = u, d.textColor = c, d.verticalAlign = p;\n      } else {\n        const l = t.parse(e[i], 1, I);\n        if (!l)\n          return null;\n        const u = l.type.kind;\n        if (u !== \"string\" && u !== \"value\" && u !== \"null\" && u !== \"resolvedImage\")\n          return t.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n        o = !0, a.push({ content: l, scale: null, font: null, textColor: null, verticalAlign: null });\n      }\n    }\n    return new pn(a);\n  }\n  evaluate(e) {\n    const t = (n) => {\n      const a = n.content.evaluate(e);\n      return q(a) === At ? new Or(\"\", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new Or(ht(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(\",\") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);\n    };\n    return new ke(this.sections.map(t));\n  }\n  eachChild(e) {\n    for (const t of this.sections)\n      e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass fn {\n  constructor(e) {\n    this.type = At, this.input = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(\"Expected two arguments.\");\n    const n = t.parse(e[1], 1, P);\n    return n ? new fn(n) : t.error(\"No image name provided.\");\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e), n = $e.fromString(t);\n    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;\n  }\n  eachChild(e) {\n    e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass dn {\n  constructor(e) {\n    this.type = S, this.input = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1);\n    return n ? n.type.kind !== \"array\" && n.type.kind !== \"string\" && n.type.kind !== \"value\" ? t.error(`Expected argument of type string or array, but found ${U(n.type)} instead.`) : new dn(n) : null;\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e);\n    if (typeof t == \"string\")\n      return [...t].length;\n    if (Array.isArray(t))\n      return t.length;\n    throw new D(`Expected value to be of type string or array, but found ${U(q(t))} instead.`);\n  }\n  eachChild(e) {\n    e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nconst xe = 8192;\nfunction al(r, e) {\n  const t = ol(r[0]), n = sl(r[1]), a = Math.pow(2, e.z);\n  return [Math.round(t * a * xe), Math.round(n * a * xe)];\n}\nfunction hn(r, e) {\n  const t = Math.pow(2, e.z), n = (r[0] / xe + e.x) / t, a = (r[1] / xe + e.y) / t;\n  return [il(n), ll(a)];\n}\nfunction ol(r) {\n  return (180 + r) / 360;\n}\nfunction il(r) {\n  return r * 360 - 180;\n}\nfunction sl(r) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;\n}\nfunction ll(r) {\n  return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;\n}\nfunction Tt(r, e) {\n  r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);\n}\nfunction wt(r, e) {\n  return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);\n}\nfunction ul(r, e, t) {\n  return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];\n}\nfunction cl(r, e, t) {\n  const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];\n  return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;\n}\nfunction ur(r, e, t, n) {\n  const a = [e[0] - r[0], e[1] - r[1]], o = [n[0] - t[0], n[1] - t[1]];\n  return hl(o, a) === 0 ? !1 : !!(Vn(r, e, t, n) && Vn(t, n, r, e));\n}\nfunction pl(r, e, t) {\n  for (const n of t)\n    for (let a = 0; a < n.length - 1; ++a)\n      if (ur(r, e, n[a], n[a + 1]))\n        return !0;\n  return !1;\n}\nfunction lt(r, e, t = !1) {\n  let n = !1;\n  for (const a of e)\n    for (let o = 0; o < a.length - 1; o++) {\n      if (cl(r, a[o], a[o + 1]))\n        return t;\n      ul(r, a[o], a[o + 1]) && (n = !n);\n    }\n  return n;\n}\nfunction fl(r, e) {\n  for (const t of e)\n    if (lt(r, t))\n      return !0;\n  return !1;\n}\nfunction Ga(r, e) {\n  for (const t of r)\n    if (!lt(t, e))\n      return !1;\n  for (let t = 0; t < r.length - 1; ++t)\n    if (pl(r[t], r[t + 1], e))\n      return !1;\n  return !0;\n}\nfunction dl(r, e) {\n  for (const t of e)\n    if (Ga(r, t))\n      return !0;\n  return !1;\n}\nfunction hl(r, e) {\n  return r[0] * e[1] - r[1] * e[0];\n}\nfunction Vn(r, e, t, n) {\n  const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;\n  return c > 0 && p < 0 || c < 0 && p > 0;\n}\nfunction mn(r, e, t) {\n  const n = [];\n  for (let a = 0; a < r.length; a++) {\n    const o = [];\n    for (let i = 0; i < r[a].length; i++) {\n      const s = al(r[a][i], t);\n      Tt(e, s), o.push(s);\n    }\n    n.push(o);\n  }\n  return n;\n}\nfunction Ha(r, e, t) {\n  const n = [];\n  for (let a = 0; a < r.length; a++) {\n    const o = mn(r[a], e, t);\n    n.push(o);\n  }\n  return n;\n}\nfunction Za(r, e, t, n) {\n  if (r[0] < t[0] || r[0] > t[2]) {\n    const a = n * 0.5;\n    let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;\n    o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;\n  }\n  Tt(e, r);\n}\nfunction ml(r) {\n  r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;\n}\nfunction Gn(r, e, t, n) {\n  const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];\n  for (const s of r)\n    for (const l of s) {\n      const u = [l.x + o[0], l.y + o[1]];\n      Za(u, e, t, a), i.push(u);\n    }\n  return i;\n}\nfunction Hn(r, e, t, n) {\n  const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];\n  for (const s of r) {\n    const l = [];\n    for (const u of s) {\n      const c = [u.x + o[0], u.y + o[1]];\n      Tt(e, c), l.push(c);\n    }\n    i.push(l);\n  }\n  if (e[2] - e[0] <= a / 2) {\n    ml(e);\n    for (const s of i)\n      for (const l of s)\n        Za(l, e, t, a);\n  }\n  return i;\n}\nfunction yl(r, e) {\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();\n  if (e.type === \"Polygon\") {\n    const o = mn(e.coordinates, n, a), i = Gn(r.geometry(), t, n, a);\n    if (!wt(t, n))\n      return !1;\n    for (const s of i)\n      if (!lt(s, o))\n        return !1;\n  }\n  if (e.type === \"MultiPolygon\") {\n    const o = Ha(e.coordinates, n, a), i = Gn(r.geometry(), t, n, a);\n    if (!wt(t, n))\n      return !1;\n    for (const s of i)\n      if (!fl(s, o))\n        return !1;\n  }\n  return !0;\n}\nfunction gl(r, e) {\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();\n  if (e.type === \"Polygon\") {\n    const o = mn(e.coordinates, n, a), i = Hn(r.geometry(), t, n, a);\n    if (!wt(t, n))\n      return !1;\n    for (const s of i)\n      if (!Ga(s, o))\n        return !1;\n  }\n  if (e.type === \"MultiPolygon\") {\n    const o = Ha(e.coordinates, n, a), i = Hn(r.geometry(), t, n, a);\n    if (!wt(t, n))\n      return !1;\n    for (const s of i)\n      if (!dl(s, o))\n        return !1;\n  }\n  return !0;\n}\nclass Ve {\n  constructor(e, t) {\n    this.type = M, this.geojson = e, this.geometries = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (vt(e[1])) {\n      const n = e[1];\n      if (n.type === \"FeatureCollection\") {\n        const a = [];\n        for (const o of n.features) {\n          const { type: i, coordinates: s } = o.geometry;\n          i === \"Polygon\" && a.push(s), i === \"MultiPolygon\" && a.push(...s);\n        }\n        if (a.length) {\n          const o = {\n            type: \"MultiPolygon\",\n            coordinates: a\n          };\n          return new Ve(n, o);\n        }\n      } else if (n.type === \"Feature\") {\n        const a = n.geometry.type;\n        if (a === \"Polygon\" || a === \"MultiPolygon\")\n          return new Ve(n, n.geometry);\n      } else if (n.type === \"Polygon\" || n.type === \"MultiPolygon\")\n        return new Ve(n, n);\n    }\n    return t.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n  }\n  evaluate(e) {\n    if (e.geometry() != null && e.canonicalID() != null) {\n      if (e.geometryType() === \"Point\")\n        return yl(e, this.geometries);\n      if (e.geometryType() === \"LineString\")\n        return gl(e, this.geometries);\n    }\n    return !1;\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass Xa {\n  constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {\n    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)\n      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);\n  }\n  push(e) {\n    this.data.push(e), this._up(this.length++);\n  }\n  pop() {\n    if (this.length === 0) return;\n    const e = this.data[0], t = this.data.pop();\n    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;\n  }\n  peek() {\n    return this.data[0];\n  }\n  _up(e) {\n    const { data: t, compare: n } = this, a = t[e];\n    for (; e > 0; ) {\n      const o = e - 1 >> 1, i = t[o];\n      if (n(a, i) >= 0) break;\n      t[e] = i, e = o;\n    }\n    t[e] = a;\n  }\n  _down(e) {\n    const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];\n    for (; e < a; ) {\n      let i = (e << 1) + 1;\n      const s = i + 1;\n      if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;\n      t[e] = t[i], e = i;\n    }\n    t[e] = o;\n  }\n}\nfunction vl(r, e) {\n  if (r.length <= 1)\n    return [r];\n  const n = [];\n  let a, o;\n  for (const i of r) {\n    const s = bl(i);\n    s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));\n  }\n  return a && n.push(a), n;\n}\nfunction bl(r) {\n  let e = 0;\n  for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++)\n    o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);\n  return e;\n}\nconst wl = 6378.137, Zn = 1 / 298.257223563, Xn = Zn * (2 - Zn), Kn = Math.PI / 180;\nclass yn {\n  constructor(e) {\n    const t = Kn * wl * 1e3, n = Math.cos(e * Kn), a = 1 / (1 - Xn * (1 - n * n)), o = Math.sqrt(a);\n    this.kx = t * o * n, this.ky = t * o * a * (1 - Xn);\n  }\n  /**\n   * Given two points of the form [longitude, latitude], returns the distance.\n   *\n   * @param a - point [longitude, latitude]\n   * @param b - point [longitude, latitude]\n   * @returns distance\n   * @example\n   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);\n   * //=distance\n   */\n  distance(e, t) {\n    const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;\n    return Math.sqrt(n * n + a * a);\n  }\n  /**\n   * Returns an object of the form {point, index, t}, where point is closest point on the line\n   * from the given point, index is the start index of the segment with the closest point,\n   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.\n   *\n   * @param line - an array of points that form the line\n   * @param p - point [longitude, latitude]\n   * @returns the nearest point, its index in the array and the proportion along the line\n   * @example\n   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;\n   * //=point\n   */\n  pointOnLine(e, t) {\n    let n = 1 / 0, a, o, i, s;\n    for (let l = 0; l < e.length - 1; l++) {\n      let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, d = (e[l + 1][1] - c) * this.ky, f = 0;\n      (p !== 0 || d !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * d) / (p * p + d * d), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += d / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, d = (t[1] - c) * this.ky;\n      const h = p * p + d * d;\n      h < n && (n = h, a = u, o = c, i = l, s = f);\n    }\n    return {\n      point: [a, o],\n      index: i,\n      t: Math.max(0, Math.min(1, s))\n    };\n  }\n  wrap(e) {\n    for (; e < -180; )\n      e += 360;\n    for (; e > 180; )\n      e -= 360;\n    return e;\n  }\n}\nconst Nr = 100, jr = 50;\nfunction Ka(r, e) {\n  return e[0] - r[0];\n}\nfunction Vt(r) {\n  return r[1] - r[0] + 1;\n}\nfunction Ce(r, e) {\n  return r[1] >= r[0] && r[1] < e;\n}\nfunction Ur(r, e) {\n  if (r[0] > r[1])\n    return [null, null];\n  const t = Vt(r);\n  if (e) {\n    if (t === 2)\n      return [r, null];\n    const a = Math.floor(t / 2);\n    return [\n      [r[0], r[0] + a],\n      [r[0] + a, r[1]]\n    ];\n  }\n  if (t === 1)\n    return [r, null];\n  const n = Math.floor(t / 2) - 1;\n  return [\n    [r[0], r[0] + n],\n    [r[0] + n + 1, r[1]]\n  ];\n}\nfunction Dr(r, e) {\n  if (!Ce(e, r.length))\n    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  for (let n = e[0]; n <= e[1]; ++n)\n    Tt(t, r[n]);\n  return t;\n}\nfunction Br(r) {\n  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  for (const t of r)\n    for (const n of t)\n      Tt(e, n);\n  return e;\n}\nfunction Yn(r) {\n  return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;\n}\nfunction gn(r, e, t) {\n  if (!Yn(r) || !Yn(e))\n    return NaN;\n  let n = 0, a = 0;\n  return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);\n}\nfunction De(r, e, t) {\n  const n = t.pointOnLine(e, r);\n  return t.distance(r, n.point);\n}\nfunction vn(r, e, t, n, a) {\n  const o = Math.min(De(r, [t, n], a), De(e, [t, n], a)), i = Math.min(De(t, [r, e], a), De(n, [r, e], a));\n  return Math.min(o, i);\n}\nfunction Sl(r, e, t, n, a) {\n  if (!(Ce(e, r.length) && Ce(n, t.length)))\n    return 1 / 0;\n  let i = 1 / 0;\n  for (let s = e[0]; s < e[1]; ++s) {\n    const l = r[s], u = r[s + 1];\n    for (let c = n[0]; c < n[1]; ++c) {\n      const p = t[c], d = t[c + 1];\n      if (ur(l, u, p, d))\n        return 0;\n      i = Math.min(i, vn(l, u, p, d, a));\n    }\n  }\n  return i;\n}\nfunction xl(r, e, t, n, a) {\n  if (!(Ce(e, r.length) && Ce(n, t.length)))\n    return NaN;\n  let i = 1 / 0;\n  for (let s = e[0]; s <= e[1]; ++s)\n    for (let l = n[0]; l <= n[1]; ++l)\n      if (i = Math.min(i, a.distance(r[s], t[l])), i === 0)\n        return i;\n  return i;\n}\nfunction kl(r, e, t) {\n  if (lt(r, e, !0))\n    return 0;\n  let n = 1 / 0;\n  for (const a of e) {\n    const o = a[0], i = a[a.length - 1];\n    if (o !== i && (n = Math.min(n, De(r, [i, o], t)), n === 0))\n      return n;\n    const s = t.pointOnLine(a, r);\n    if (n = Math.min(n, t.distance(r, s.point)), n === 0)\n      return n;\n  }\n  return n;\n}\nfunction Ll(r, e, t, n) {\n  if (!Ce(e, r.length))\n    return NaN;\n  for (let o = e[0]; o <= e[1]; ++o)\n    if (lt(r[o], t, !0))\n      return 0;\n  let a = 1 / 0;\n  for (let o = e[0]; o < e[1]; ++o) {\n    const i = r[o], s = r[o + 1];\n    for (const l of t)\n      for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {\n        const d = l[p], f = l[u];\n        if (ur(i, s, d, f))\n          return 0;\n        a = Math.min(a, vn(i, s, d, f, n));\n      }\n  }\n  return a;\n}\nfunction Wn(r, e) {\n  for (const t of r)\n    for (const n of t)\n      if (lt(n, e, !0))\n        return !0;\n  return !1;\n}\nfunction Cl(r, e, t, n = 1 / 0) {\n  const a = Br(r), o = Br(e);\n  if (n !== 1 / 0 && gn(a, o, t) >= n)\n    return n;\n  if (wt(a, o)) {\n    if (Wn(r, e))\n      return 0;\n  } else if (Wn(e, r))\n    return 0;\n  let i = 1 / 0;\n  for (const s of r)\n    for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {\n      const p = s[c], d = s[l];\n      for (const f of e)\n        for (let h = 0, m = f.length, y = m - 1; h < m; y = h++) {\n          const w = f[y], g = f[h];\n          if (ur(p, d, w, g))\n            return 0;\n          i = Math.min(i, vn(p, d, w, g, t));\n        }\n    }\n  return i;\n}\nfunction Jn(r, e, t, n, a, o) {\n  if (!o)\n    return;\n  const i = gn(Dr(n, o), a, t);\n  i < e && r.push([i, o, [0, 0]]);\n}\nfunction zt(r, e, t, n, a, o, i) {\n  if (!o || !i)\n    return;\n  const s = gn(Dr(n, o), Dr(a, i), t);\n  s < e && r.push([s, o, i]);\n}\nfunction Gt(r, e, t, n, a = 1 / 0) {\n  let o = Math.min(n.distance(r[0], t[0][0]), a);\n  if (o === 0)\n    return o;\n  const i = new Xa([[0, [0, r.length - 1], [0, 0]]], Ka), s = Br(t);\n  for (; i.length > 0; ) {\n    const l = i.pop();\n    if (l[0] >= o)\n      continue;\n    const u = l[1], c = e ? jr : Nr;\n    if (Vt(u) <= c) {\n      if (!Ce(u, r.length))\n        return NaN;\n      if (e) {\n        const p = Ll(r, u, t, n);\n        if (isNaN(p) || p === 0)\n          return p;\n        o = Math.min(o, p);\n      } else\n        for (let p = u[0]; p <= u[1]; ++p) {\n          const d = kl(r[p], t, n);\n          if (o = Math.min(o, d), o === 0)\n            return 0;\n        }\n    } else {\n      const p = Ur(u, e);\n      Jn(i, o, n, r, s, p[0]), Jn(i, o, n, r, s, p[1]);\n    }\n  }\n  return o;\n}\nfunction Ht(r, e, t, n, a, o = 1 / 0) {\n  let i = Math.min(o, a.distance(r[0], t[0]));\n  if (i === 0)\n    return i;\n  const s = new Xa([[0, [0, r.length - 1], [0, t.length - 1]]], Ka);\n  for (; s.length > 0; ) {\n    const l = s.pop();\n    if (l[0] >= i)\n      continue;\n    const u = l[1], c = l[2], p = e ? jr : Nr, d = n ? jr : Nr;\n    if (Vt(u) <= p && Vt(c) <= d) {\n      if (!Ce(u, r.length) && Ce(c, t.length))\n        return NaN;\n      let f;\n      if (e && n)\n        f = Sl(r, u, t, c, a), i = Math.min(i, f);\n      else if (e && !n) {\n        const h = r.slice(u[0], u[1] + 1);\n        for (let m = c[0]; m <= c[1]; ++m)\n          if (f = De(t[m], h, a), i = Math.min(i, f), i === 0)\n            return i;\n      } else if (!e && n) {\n        const h = t.slice(c[0], c[1] + 1);\n        for (let m = u[0]; m <= u[1]; ++m)\n          if (f = De(r[m], h, a), i = Math.min(i, f), i === 0)\n            return i;\n      } else\n        f = xl(r, u, t, c, a), i = Math.min(i, f);\n    } else {\n      const f = Ur(u, e), h = Ur(c, n);\n      zt(s, i, a, r, t, f[0], h[0]), zt(s, i, a, r, t, f[0], h[1]), zt(s, i, a, r, t, f[1], h[0]), zt(s, i, a, r, t, f[1], h[1]);\n    }\n  }\n  return i;\n}\nfunction El(r, e) {\n  const t = r.geometry(), n = t.flat().map((i) => hn([i.x, i.y], r.canonical));\n  if (t.length === 0)\n    return NaN;\n  const a = new yn(n[0][1]);\n  let o = 1 / 0;\n  for (const i of e) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, Ht(n, !1, [i.coordinates], !1, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, Ht(n, !1, i.coordinates, !0, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, Gt(n, !1, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0)\n      return o;\n  }\n  return o;\n}\nfunction Al(r, e) {\n  const t = r.geometry(), n = t.flat().map((i) => hn([i.x, i.y], r.canonical));\n  if (t.length === 0)\n    return NaN;\n  const a = new yn(n[0][1]);\n  let o = 1 / 0;\n  for (const i of e) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, Ht(n, !0, [i.coordinates], !1, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, Ht(n, !0, i.coordinates, !0, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, Gt(n, !0, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0)\n      return o;\n  }\n  return o;\n}\nfunction Tl(r, e) {\n  const t = r.geometry();\n  if (t.length === 0 || t[0].length === 0)\n    return NaN;\n  const n = vl(t).map((i) => i.map((s) => s.map((l) => hn([l.x, l.y], r.canonical)))), a = new yn(n[0][0][0][1]);\n  let o = 1 / 0;\n  for (const i of e)\n    for (const s of n) {\n      switch (i.type) {\n        case \"Point\":\n          o = Math.min(o, Gt([i.coordinates], !1, s, a, o));\n          break;\n        case \"LineString\":\n          o = Math.min(o, Gt(i.coordinates, !0, s, a, o));\n          break;\n        case \"Polygon\":\n          o = Math.min(o, Cl(s, i.coordinates, a, o));\n          break;\n      }\n      if (o === 0)\n        return o;\n    }\n  return o;\n}\nfunction Lr(r) {\n  return r.type === \"MultiPolygon\" ? r.coordinates.map((e) => ({\n    type: \"Polygon\",\n    coordinates: e\n  })) : r.type === \"MultiLineString\" ? r.coordinates.map((e) => ({\n    type: \"LineString\",\n    coordinates: e\n  })) : r.type === \"MultiPoint\" ? r.coordinates.map((e) => ({\n    type: \"Point\",\n    coordinates: e\n  })) : [r];\n}\nclass Ge {\n  constructor(e, t) {\n    this.type = S, this.geojson = e, this.geometries = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (vt(e[1])) {\n      const n = e[1];\n      if (n.type === \"FeatureCollection\")\n        return new Ge(n, n.features.map((a) => Lr(a.geometry)).flat());\n      if (n.type === \"Feature\")\n        return new Ge(n, Lr(n.geometry));\n      if (\"type\" in n && \"coordinates\" in n)\n        return new Ge(n, Lr(n));\n    }\n    return t.error(\"'distance' expression requires valid geojson object that contains polygon geometry type.\");\n  }\n  evaluate(e) {\n    if (e.geometry() != null && e.canonicalID() != null) {\n      if (e.geometryType() === \"Point\")\n        return El(e, this.geometries);\n      if (e.geometryType() === \"LineString\")\n        return Al(e, this.geometries);\n      if (e.geometryType() === \"Polygon\")\n        return Tl(e, this.geometries);\n    }\n    return NaN;\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass _t {\n  constructor(e) {\n    this.type = I, this.key = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2)\n      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);\n    const n = e[1];\n    return n == null ? t.error(\"Global state property must be defined.\") : typeof n != \"string\" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new _t(n);\n  }\n  evaluate(e) {\n    var t;\n    const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;\n    return !n || Object.keys(n).length === 0 ? null : dt(n, this.key);\n  }\n  eachChild() {\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nconst bn = {\n  // special forms\n  \"==\": Js,\n  \"!=\": Qs,\n  \">\": tl,\n  \"<\": el,\n  \">=\": nl,\n  \"<=\": rl,\n  array: de,\n  at: on,\n  boolean: de,\n  case: un,\n  coalesce: bt,\n  collator: lr,\n  format: pn,\n  image: fn,\n  in: sn,\n  \"index-of\": Bt,\n  interpolate: Se,\n  \"interpolate-hcl\": Se,\n  \"interpolate-lab\": Se,\n  length: dn,\n  let: or,\n  literal: ot,\n  match: ln,\n  number: de,\n  \"number-format\": cn,\n  object: de,\n  slice: qt,\n  step: sr,\n  string: de,\n  \"to-boolean\": Pe,\n  \"to-color\": Pe,\n  \"to-number\": Pe,\n  \"to-string\": Pe,\n  var: ir,\n  within: Ve,\n  distance: Ge,\n  \"global-state\": _t\n};\nclass he {\n  constructor(e, t, n, a) {\n    this.name = e, this.type = t, this._evaluate = n, this.args = a;\n  }\n  evaluate(e) {\n    return this._evaluate(e, this.args);\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return !1;\n  }\n  static parse(e, t) {\n    const n = e[0], a = he.definitions[n];\n    if (!a)\n      return t.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n    const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(([u]) => !Array.isArray(u) || // varags\n    u.length === e.length - 1);\n    let l = null;\n    for (const [u, c] of s) {\n      l = new ar(t.registry, Zt, t.path, null, t.scope);\n      const p = [];\n      let d = !1;\n      for (let f = 1; f < e.length; f++) {\n        const h = e[f], m = Array.isArray(u) ? u[f - 1] : u.type, y = l.parse(h, 1 + p.length, m);\n        if (!y) {\n          d = !0;\n          break;\n        }\n        p.push(y);\n      }\n      if (!d) {\n        if (Array.isArray(u) && u.length !== p.length) {\n          l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);\n          continue;\n        }\n        for (let f = 0; f < p.length; f++) {\n          const h = Array.isArray(u) ? u[f] : u.type, m = p[f];\n          l.concat(f + 1).checkSubtype(h, m.type);\n        }\n        if (l.errors.length === 0)\n          return new he(n, o, c, p);\n      }\n    }\n    if (s.length === 1)\n      t.errors.push(...l.errors);\n    else {\n      const c = (s.length ? s : i).map(([d]) => Il(d)).join(\" | \"), p = [];\n      for (let d = 1; d < e.length; d++) {\n        const f = t.parse(e[d], 1 + p.length);\n        if (!f)\n          return null;\n        p.push(U(f.type));\n      }\n      t.error(`Expected arguments of type ${c}, but found (${p.join(\", \")}) instead.`);\n    }\n    return null;\n  }\n  static register(e, t) {\n    he.definitions = t;\n    for (const n in t)\n      e[n] = he;\n  }\n}\nfunction Qn(r, [e, t, n, a]) {\n  e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);\n  const o = a ? a.evaluate(r) : 1, i = Ua(e, t, n, o);\n  if (i)\n    throw new D(i);\n  return new $(e / 255, t / 255, n / 255, o, !1);\n}\nfunction ea(r, e) {\n  return r in e;\n}\nfunction Cr(r, e) {\n  const t = e[r];\n  return typeof t > \"u\" ? null : t;\n}\nfunction _l(r, e, t, n) {\n  for (; t <= n; ) {\n    const a = t + n >> 1;\n    if (e[a] === r)\n      return !0;\n    e[a] > r ? n = a - 1 : t = a + 1;\n  }\n  return !1;\n}\nfunction Ne(r) {\n  return { type: r };\n}\nhe.register(bn, {\n  error: [\n    ks,\n    [P],\n    (r, [e]) => {\n      throw new D(e.evaluate(r));\n    }\n  ],\n  typeof: [\n    P,\n    [I],\n    (r, [e]) => U(q(e.evaluate(r)))\n  ],\n  \"to-rgba\": [\n    te(S, 4),\n    [we],\n    (r, [e]) => {\n      const [t, n, a, o] = e.evaluate(r).rgb;\n      return [t * 255, n * 255, a * 255, o];\n    }\n  ],\n  rgb: [\n    we,\n    [S, S, S],\n    Qn\n  ],\n  rgba: [\n    we,\n    [S, S, S, S],\n    Qn\n  ],\n  has: {\n    type: M,\n    overloads: [\n      [\n        [P],\n        (r, [e]) => ea(e.evaluate(r), r.properties())\n      ],\n      [\n        [P, Be],\n        (r, [e, t]) => ea(e.evaluate(r), t.evaluate(r))\n      ]\n    ]\n  },\n  get: {\n    type: I,\n    overloads: [\n      [\n        [P],\n        (r, [e]) => Cr(e.evaluate(r), r.properties())\n      ],\n      [\n        [P, Be],\n        (r, [e, t]) => Cr(e.evaluate(r), t.evaluate(r))\n      ]\n    ]\n  },\n  \"feature-state\": [\n    I,\n    [P],\n    (r, [e]) => Cr(e.evaluate(r), r.featureState || {})\n  ],\n  properties: [\n    Be,\n    [],\n    (r) => r.properties()\n  ],\n  \"geometry-type\": [\n    P,\n    [],\n    (r) => r.geometryType()\n  ],\n  id: [\n    I,\n    [],\n    (r) => r.id()\n  ],\n  zoom: [\n    S,\n    [],\n    (r) => r.globals.zoom\n  ],\n  \"heatmap-density\": [\n    S,\n    [],\n    (r) => r.globals.heatmapDensity || 0\n  ],\n  elevation: [\n    S,\n    [],\n    (r) => r.globals.elevation || 0\n  ],\n  \"line-progress\": [\n    S,\n    [],\n    (r) => r.globals.lineProgress || 0\n  ],\n  accumulated: [\n    I,\n    [],\n    (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated\n  ],\n  \"+\": [\n    S,\n    Ne(S),\n    (r, e) => {\n      let t = 0;\n      for (const n of e)\n        t += n.evaluate(r);\n      return t;\n    }\n  ],\n  \"*\": [\n    S,\n    Ne(S),\n    (r, e) => {\n      let t = 1;\n      for (const n of e)\n        t *= n.evaluate(r);\n      return t;\n    }\n  ],\n  \"-\": {\n    type: S,\n    overloads: [\n      [\n        [S, S],\n        (r, [e, t]) => e.evaluate(r) - t.evaluate(r)\n      ],\n      [\n        [S],\n        (r, [e]) => -e.evaluate(r)\n      ]\n    ]\n  },\n  \"/\": [\n    S,\n    [S, S],\n    (r, [e, t]) => e.evaluate(r) / t.evaluate(r)\n  ],\n  \"%\": [\n    S,\n    [S, S],\n    (r, [e, t]) => e.evaluate(r) % t.evaluate(r)\n  ],\n  ln2: [\n    S,\n    [],\n    () => Math.LN2\n  ],\n  pi: [\n    S,\n    [],\n    () => Math.PI\n  ],\n  e: [\n    S,\n    [],\n    () => Math.E\n  ],\n  \"^\": [\n    S,\n    [S, S],\n    (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))\n  ],\n  sqrt: [\n    S,\n    [S],\n    (r, [e]) => Math.sqrt(e.evaluate(r))\n  ],\n  log10: [\n    S,\n    [S],\n    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10\n  ],\n  ln: [\n    S,\n    [S],\n    (r, [e]) => Math.log(e.evaluate(r))\n  ],\n  log2: [\n    S,\n    [S],\n    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2\n  ],\n  sin: [\n    S,\n    [S],\n    (r, [e]) => Math.sin(e.evaluate(r))\n  ],\n  cos: [\n    S,\n    [S],\n    (r, [e]) => Math.cos(e.evaluate(r))\n  ],\n  tan: [\n    S,\n    [S],\n    (r, [e]) => Math.tan(e.evaluate(r))\n  ],\n  asin: [\n    S,\n    [S],\n    (r, [e]) => Math.asin(e.evaluate(r))\n  ],\n  acos: [\n    S,\n    [S],\n    (r, [e]) => Math.acos(e.evaluate(r))\n  ],\n  atan: [\n    S,\n    [S],\n    (r, [e]) => Math.atan(e.evaluate(r))\n  ],\n  min: [\n    S,\n    Ne(S),\n    (r, e) => Math.min(...e.map((t) => t.evaluate(r)))\n  ],\n  max: [\n    S,\n    Ne(S),\n    (r, e) => Math.max(...e.map((t) => t.evaluate(r)))\n  ],\n  abs: [\n    S,\n    [S],\n    (r, [e]) => Math.abs(e.evaluate(r))\n  ],\n  round: [\n    S,\n    [S],\n    (r, [e]) => {\n      const t = e.evaluate(r);\n      return t < 0 ? -Math.round(-t) : Math.round(t);\n    }\n  ],\n  floor: [\n    S,\n    [S],\n    (r, [e]) => Math.floor(e.evaluate(r))\n  ],\n  ceil: [\n    S,\n    [S],\n    (r, [e]) => Math.ceil(e.evaluate(r))\n  ],\n  \"filter-==\": [\n    M,\n    [P, I],\n    (r, [e, t]) => r.properties()[e.value] === t.value\n  ],\n  \"filter-id-==\": [\n    M,\n    [I],\n    (r, [e]) => r.id() === e.value\n  ],\n  \"filter-type-==\": [\n    M,\n    [P],\n    (r, [e]) => r.geometryType() === e.value\n  ],\n  \"filter-<\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n < a;\n    }\n  ],\n  \"filter-id-<\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t < n;\n    }\n  ],\n  \"filter->\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n > a;\n    }\n  ],\n  \"filter-id->\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t > n;\n    }\n  ],\n  \"filter-<=\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n <= a;\n    }\n  ],\n  \"filter-id-<=\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t <= n;\n    }\n  ],\n  \"filter->=\": [\n    M,\n    [P, I],\n    (r, [e, t]) => {\n      const n = r.properties()[e.value], a = t.value;\n      return typeof n == typeof a && n >= a;\n    }\n  ],\n  \"filter-id->=\": [\n    M,\n    [I],\n    (r, [e]) => {\n      const t = r.id(), n = e.value;\n      return typeof t == typeof n && t >= n;\n    }\n  ],\n  \"filter-has\": [\n    M,\n    [I],\n    (r, [e]) => e.value in r.properties()\n  ],\n  \"filter-has-id\": [\n    M,\n    [],\n    (r) => r.id() !== null && r.id() !== void 0\n  ],\n  \"filter-type-in\": [\n    M,\n    [te(P)],\n    (r, [e]) => e.value.indexOf(r.geometryType()) >= 0\n  ],\n  \"filter-id-in\": [\n    M,\n    [te(I)],\n    (r, [e]) => e.value.indexOf(r.id()) >= 0\n  ],\n  \"filter-in-small\": [\n    M,\n    [P, te(I)],\n    // assumes v is an array literal\n    (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0\n  ],\n  \"filter-in-large\": [\n    M,\n    [P, te(I)],\n    // assumes v is a array literal with values sorted in ascending order and of a single type\n    (r, [e, t]) => _l(r.properties()[e.value], t.value, 0, t.value.length - 1)\n  ],\n  all: {\n    type: M,\n    overloads: [\n      [\n        [M, M],\n        (r, [e, t]) => e.evaluate(r) && t.evaluate(r)\n      ],\n      [\n        Ne(M),\n        (r, e) => {\n          for (const t of e)\n            if (!t.evaluate(r))\n              return !1;\n          return !0;\n        }\n      ]\n    ]\n  },\n  any: {\n    type: M,\n    overloads: [\n      [\n        [M, M],\n        (r, [e, t]) => e.evaluate(r) || t.evaluate(r)\n      ],\n      [\n        Ne(M),\n        (r, e) => {\n          for (const t of e)\n            if (t.evaluate(r))\n              return !0;\n          return !1;\n        }\n      ]\n    ]\n  },\n  \"!\": [\n    M,\n    [M],\n    (r, [e]) => !e.evaluate(r)\n  ],\n  \"is-supported-script\": [\n    M,\n    [P],\n    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant\n    (r, [e]) => {\n      const t = r.globals && r.globals.isSupportedScript;\n      return t ? t(e.evaluate(r)) : !0;\n    }\n  ],\n  upcase: [\n    P,\n    [P],\n    (r, [e]) => e.evaluate(r).toUpperCase()\n  ],\n  downcase: [\n    P,\n    [P],\n    (r, [e]) => e.evaluate(r).toLowerCase()\n  ],\n  concat: [\n    P,\n    Ne(I),\n    (r, e) => e.map((t) => ht(t.evaluate(r))).join(\"\")\n  ],\n  \"resolved-locale\": [\n    P,\n    [Qt],\n    (r, [e]) => e.evaluate(r).resolvedLocale()\n  ]\n});\nfunction Il(r) {\n  return Array.isArray(r) ? `(${r.map(U).join(\", \")})` : `(${U(r.type)}...)`;\n}\nfunction Zt(r) {\n  if (r instanceof ir)\n    return Zt(r.boundExpression);\n  if (r instanceof he && r.name === \"error\")\n    return !1;\n  if (r instanceof lr)\n    return !1;\n  if (r instanceof Ve)\n    return !1;\n  if (r instanceof Ge)\n    return !1;\n  if (r instanceof _t)\n    return !1;\n  const e = r instanceof Pe || r instanceof de;\n  let t = !0;\n  return r.eachChild((n) => {\n    e ? t = t && Zt(n) : t = t && n instanceof ot;\n  }), t ? cr(r) && pr(r, [\"zoom\", \"heatmap-density\", \"elevation\", \"line-progress\", \"accumulated\", \"is-supported-script\"]) : !1;\n}\nfunction cr(r) {\n  if (r instanceof he) {\n    if (r.name === \"get\" && r.args.length === 1)\n      return !1;\n    if (r.name === \"feature-state\")\n      return !1;\n    if (r.name === \"has\" && r.args.length === 1)\n      return !1;\n    if (r.name === \"properties\" || r.name === \"geometry-type\" || r.name === \"id\")\n      return !1;\n    if (/^filter-/.test(r.name))\n      return !1;\n  }\n  if (r instanceof Ve || r instanceof Ge)\n    return !1;\n  let e = !0;\n  return r.eachChild((t) => {\n    e && !cr(t) && (e = !1);\n  }), e;\n}\nfunction St(r) {\n  if (r instanceof he && r.name === \"feature-state\")\n    return !1;\n  let e = !0;\n  return r.eachChild((t) => {\n    e && !St(t) && (e = !1);\n  }), e;\n}\nfunction pr(r, e) {\n  if (r instanceof he && e.indexOf(r.name) >= 0)\n    return !1;\n  let t = !0;\n  return r.eachChild((n) => {\n    t && !pr(n, e) && (t = !1);\n  }), t;\n}\nfunction qr(r) {\n  return { result: \"success\", value: r };\n}\nfunction et(r) {\n  return { result: \"error\", value: r };\n}\nfunction Xt(r) {\n  return r[\"property-type\"] === \"data-driven\" || r[\"property-type\"] === \"cross-faded-data-driven\";\n}\nfunction Ya(r) {\n  return !!r.expression && r.expression.parameters.indexOf(\"zoom\") > -1;\n}\nfunction Wa(r) {\n  return !!r.expression && r.expression.interpolated;\n}\nfunction R(r) {\n  return r instanceof Number ? \"number\" : r instanceof String ? \"string\" : r instanceof Boolean ? \"boolean\" : Array.isArray(r) ? \"array\" : r === null ? \"null\" : typeof r;\n}\nfunction wn(r) {\n  return typeof r == \"object\" && r !== null && !Array.isArray(r) && q(r) === Be;\n}\nclass Ml {\n  constructor(e, t) {\n    this.expression = e, this._warningHistory = {}, this._evaluator = new Da(), this._defaultValue = t ? zl(t) : null, this._enumValues = t && t.type === \"enum\" ? t.values : null;\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);\n  }\n  evaluate(e, t, n, a, o, i) {\n    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;\n    try {\n      const s = this.expression.evaluate(this._evaluator);\n      if (s == null || typeof s == \"number\" && s !== s)\n        return this._defaultValue;\n      if (this._enumValues && !(s in this._enumValues))\n        throw new D(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(\", \")}, but found ${JSON.stringify(s)} instead.`);\n      return s;\n    } catch (s) {\n      return this._warningHistory[s.message] || (this._warningHistory[s.message] = !0, typeof console < \"u\" && console.warn(s.message)), this._defaultValue;\n    }\n  }\n}\nfunction Ja(r) {\n  return Array.isArray(r) && r.length > 0 && typeof r[0] == \"string\" && r[0] in bn;\n}\nfunction Qa(r, e) {\n  const t = new ar(bn, Zt, [], e ? Rl(e) : void 0), n = t.parse(r, void 0, void 0, void 0, e && e.type === \"string\" ? { typeAnnotation: \"coerce\" } : void 0);\n  return n ? qr(new Ml(n, e)) : et(t.errors);\n}\nclass ta {\n  constructor(e, t) {\n    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== \"constant\" && !St(t.expression), this.globalStateRefs = Sn(t.expression);\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);\n  }\n  evaluate(e, t, n, a, o, i) {\n    return this._styleExpression.evaluate(e, t, n, a, o, i);\n  }\n}\nclass ra {\n  constructor(e, t, n, a) {\n    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== \"camera\" && !St(t.expression), this.globalStateRefs = Sn(t.expression), this.interpolationType = a;\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);\n  }\n  evaluate(e, t, n, a, o, i) {\n    return this._styleExpression.evaluate(e, t, n, a, o, i);\n  }\n  interpolationFactor(e, t, n) {\n    return this.interpolationType ? Se.interpolationFactor(this.interpolationType, e, t, n) : 0;\n  }\n}\nfunction Pl(r, e) {\n  const t = Qa(r, e);\n  if (t.result === \"error\")\n    return t;\n  const n = t.value.expression, a = cr(n);\n  if (!a && !Xt(e))\n    return et([new be(\"\", \"data expressions not supported\")]);\n  const o = pr(n, [\"zoom\"]);\n  if (!o && !Ya(e))\n    return et([new be(\"\", \"zoom expressions not supported\")]);\n  const i = Ot(n);\n  if (!i && !o)\n    return et([new be(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n  if (i instanceof be)\n    return et([i]);\n  if (i instanceof Se && !Wa(e))\n    return et([new be(\"\", '\"interpolate\" expressions cannot be used with this property')]);\n  if (!i)\n    return qr(a ? new ta(\"constant\", t.value) : new ta(\"source\", t.value));\n  const s = i instanceof Se ? i.interpolation : void 0;\n  return qr(a ? new ra(\"camera\", t.value, i.labels, s) : new ra(\"composite\", t.value, i.labels, s));\n}\nfunction Ot(r) {\n  let e = null;\n  if (r instanceof or)\n    e = Ot(r.result);\n  else if (r instanceof bt) {\n    for (const t of r.args)\n      if (e = Ot(t), e)\n        break;\n  } else (r instanceof sr || r instanceof Se) && r.input instanceof he && r.input.name === \"zoom\" && (e = r);\n  return e instanceof be || r.eachChild((t) => {\n    const n = Ot(t);\n    n instanceof be ? e = n : !e && n ? e = new be(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : e && n && e !== n && (e = new be(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n  }), e;\n}\nfunction Sn(r, e = /* @__PURE__ */ new Set()) {\n  return r instanceof _t && e.add(r.key), r.eachChild((t) => {\n    Sn(t, e);\n  }), e;\n}\nfunction Rl(r) {\n  const e = {\n    color: we,\n    string: P,\n    number: S,\n    enum: P,\n    boolean: M,\n    formatted: er,\n    padding: tr,\n    numberArray: rr,\n    colorArray: yt,\n    projectionDefinition: Jt,\n    resolvedImage: At,\n    variableAnchorOffsetCollection: nr\n  };\n  return r.type === \"array\" ? te(e[r.value] || I, r.length) : e[r.type];\n}\nfunction zl(r) {\n  if (r.type === \"color\" && wn(r.default))\n    return new $(0, 0, 0, 0);\n  switch (r.type) {\n    case \"color\":\n      return $.parse(r.default) || null;\n    case \"padding\":\n      return oe.parse(r.default) || null;\n    case \"numberArray\":\n      return ie.parse(r.default) || null;\n    case \"colorArray\":\n      return Q.parse(r.default) || null;\n    case \"variableAnchorOffsetCollection\":\n      return me.parse(r.default) || null;\n    case \"projectionDefinition\":\n      return fe.parse(r.default) || null;\n    default:\n      return r.default === void 0 ? null : r.default;\n  }\n}\nfunction eo(r) {\n  if (r === !0 || r === !1)\n    return !0;\n  if (!Array.isArray(r) || r.length === 0)\n    return !1;\n  switch (r[0]) {\n    case \"has\":\n      return r.length >= 2 && r[1] !== \"$id\" && r[1] !== \"$type\";\n    case \"in\":\n      return r.length >= 3 && (typeof r[1] != \"string\" || Array.isArray(r[2]));\n    case \"!in\":\n    case \"!has\":\n    case \"none\":\n      return !1;\n    case \"==\":\n    case \"!=\":\n    case \">\":\n    case \">=\":\n    case \"<\":\n    case \"<=\":\n      return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);\n    case \"any\":\n    case \"all\":\n      for (const e of r.slice(1))\n        if (!eo(e) && typeof e != \"boolean\")\n          return !1;\n      return !0;\n    default:\n      return !0;\n  }\n}\nfunction to(r) {\n  const e = r.key, t = r.value;\n  return t ? [new b(e, t, \"constants have been deprecated as of v8\")] : [];\n}\nfunction B(r) {\n  return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;\n}\nfunction Xe(r) {\n  if (Array.isArray(r))\n    return r.map(Xe);\n  if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {\n    const e = {};\n    for (const t in r)\n      e[t] = Xe(r[t]);\n    return e;\n  }\n  return B(r);\n}\nfunction se(r) {\n  const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;\n  let l = [];\n  const u = R(t);\n  if (u !== \"object\")\n    return [new b(e, t, `object expected, ${u} found`)];\n  for (const c in t) {\n    const p = c.split(\".\")[0], d = dt(n, p) || n[\"*\"];\n    let f;\n    if (dt(a, p))\n      f = a[p];\n    else if (dt(n, p))\n      f = s;\n    else if (a[\"*\"])\n      f = a[\"*\"];\n    else if (n[\"*\"])\n      f = s;\n    else {\n      l.push(new b(e, t[c], `unknown property \"${c}\"`));\n      continue;\n    }\n    l = l.concat(f({\n      key: (e && `${e}.`) + c,\n      value: t[c],\n      valueSpec: d,\n      style: o,\n      styleSpec: i,\n      object: t,\n      objectKey: c,\n      validateSpec: s\n    }, t));\n  }\n  for (const c in n)\n    a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new b(e, t, `missing required property \"${c}\"`));\n  return l;\n}\nfunction xn(r) {\n  const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;\n  if (R(e) !== \"array\")\n    return [new b(i, e, `array expected, ${R(e)} found`)];\n  if (t.length && e.length !== t.length)\n    return [new b(i, e, `array length ${t.length} expected, length ${e.length} found`)];\n  if (t[\"min-length\"] && e.length < t[\"min-length\"])\n    return [new b(i, e, `array length at least ${t[\"min-length\"]} expected, length ${e.length} found`)];\n  let l = {\n    type: t.value,\n    values: t.values\n  };\n  o.$version < 7 && (l.function = t.function), R(t.value) === \"object\" && (l = t.value);\n  let u = [];\n  for (let c = 0; c < e.length; c++)\n    u = u.concat(s({\n      array: e,\n      arrayIndex: c,\n      value: e[c],\n      valueSpec: l,\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: o,\n      key: `${i}[${c}]`\n    }));\n  return u;\n}\nfunction fr(r) {\n  const e = r.key, t = r.value, n = r.valueSpec;\n  let a = R(t);\n  return a === \"number\" && t !== t && (a = \"NaN\"), a !== \"number\" ? [new b(e, t, `number expected, ${a} found`)] : \"minimum\" in n && t < n.minimum ? [new b(e, t, `${t} is less than the minimum value ${n.minimum}`)] : \"maximum\" in n && t > n.maximum ? [new b(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];\n}\nfunction ro(r) {\n  const e = r.valueSpec, t = B(r.value.type);\n  let n, a = {}, o, i;\n  const s = t !== \"categorical\" && r.value.property === void 0, l = !s, u = R(r.value.stops) === \"array\" && R(r.value.stops[0]) === \"array\" && R(r.value.stops[0][0]) === \"object\", c = se({\n    key: r.key,\n    value: r.value,\n    valueSpec: r.styleSpec.function,\n    validateSpec: r.validateSpec,\n    style: r.style,\n    styleSpec: r.styleSpec,\n    objectElementValidators: {\n      stops: p,\n      default: h\n    }\n  });\n  return t === \"identity\" && s && c.push(new b(r.key, r.value, 'missing required property \"property\"')), t !== \"identity\" && !r.value.stops && c.push(new b(r.key, r.value, 'missing required property \"stops\"')), t === \"exponential\" && r.valueSpec.expression && !Wa(r.valueSpec) && c.push(new b(r.key, r.value, \"exponential functions not supported\")), r.styleSpec.$version >= 8 && (l && !Xt(r.valueSpec) ? c.push(new b(r.key, r.value, \"property functions not supported\")) : s && !Ya(r.valueSpec) && c.push(new b(r.key, r.value, \"zoom functions not supported\"))), (t === \"categorical\" || u) && r.value.property === void 0 && c.push(new b(r.key, r.value, '\"property\" property is required')), c;\n  function p(m) {\n    if (t === \"identity\")\n      return [new b(m.key, m.value, 'identity function may not have a \"stops\" property')];\n    let y = [];\n    const w = m.value;\n    return y = y.concat(xn({\n      key: m.key,\n      value: w,\n      valueSpec: m.valueSpec,\n      validateSpec: m.validateSpec,\n      style: m.style,\n      styleSpec: m.styleSpec,\n      arrayElementValidator: d\n    })), R(w) === \"array\" && w.length === 0 && y.push(new b(m.key, w, \"array must have at least one stop\")), y;\n  }\n  function d(m) {\n    let y = [];\n    const w = m.value, g = m.key;\n    if (R(w) !== \"array\")\n      return [new b(g, w, `array expected, ${R(w)} found`)];\n    if (w.length !== 2)\n      return [new b(g, w, `array length 2 expected, length ${w.length} found`)];\n    if (u) {\n      if (R(w[0]) !== \"object\")\n        return [new b(g, w, `object expected, ${R(w[0])} found`)];\n      if (w[0].zoom === void 0)\n        return [new b(g, w, \"object stop key must have zoom\")];\n      if (w[0].value === void 0)\n        return [new b(g, w, \"object stop key must have value\")];\n      if (i && i > B(w[0].zoom))\n        return [new b(g, w[0].zoom, \"stop zoom values must appear in ascending order\")];\n      B(w[0].zoom) !== i && (i = B(w[0].zoom), o = void 0, a = {}), y = y.concat(se({\n        key: `${g}[0]`,\n        value: w[0],\n        valueSpec: { zoom: {} },\n        validateSpec: m.validateSpec,\n        style: m.style,\n        styleSpec: m.styleSpec,\n        objectElementValidators: { zoom: fr, value: f }\n      }));\n    } else\n      y = y.concat(f({\n        key: `${g}[0]`,\n        value: w[0],\n        validateSpec: m.validateSpec,\n        style: m.style,\n        styleSpec: m.styleSpec\n      }, w));\n    return Ja(Xe(w[1])) ? y.concat([new b(`${g}[1]`, w[1], \"expressions are not allowed in function stops.\")]) : y.concat(m.validateSpec({\n      key: `${g}[1]`,\n      value: w[1],\n      valueSpec: e,\n      validateSpec: m.validateSpec,\n      style: m.style,\n      styleSpec: m.styleSpec\n    }));\n  }\n  function f(m, y) {\n    const w = R(m.value), g = B(m.value), x = m.value !== null ? m.value : y;\n    if (!n)\n      n = w;\n    else if (w !== n)\n      return [new b(m.key, x, `${w} stop domain type must match previous stop domain type ${n}`)];\n    if (w !== \"number\" && w !== \"string\" && w !== \"boolean\")\n      return [new b(m.key, x, \"stop domain value must be a number, string, or boolean\")];\n    if (w !== \"number\" && t !== \"categorical\") {\n      let E = `number expected, ${w} found`;\n      return Xt(e) && t === void 0 && (E += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new b(m.key, x, E)];\n    }\n    return t === \"categorical\" && w === \"number\" && (!isFinite(g) || Math.floor(g) !== g) ? [new b(m.key, x, `integer expected, found ${g}`)] : t !== \"categorical\" && w === \"number\" && o !== void 0 && g < o ? [new b(m.key, x, \"stop domain values must appear in ascending order\")] : (o = g, t === \"categorical\" && g in a ? [new b(m.key, x, \"stop domain values must be unique\")] : (a[g] = !0, []));\n  }\n  function h(m) {\n    return m.validateSpec({\n      key: m.key,\n      value: m.value,\n      valueSpec: e,\n      validateSpec: m.validateSpec,\n      style: m.style,\n      styleSpec: m.styleSpec\n    });\n  }\n}\nfunction it(r) {\n  const e = (r.expressionContext === \"property\" ? Pl : Qa)(Xe(r.value), r.valueSpec);\n  if (e.result === \"error\")\n    return e.value.map((n) => new b(`${r.key}${n.key}`, r.value, n.message));\n  const t = e.value.expression || e.value._styleExpression.expression;\n  if (r.expressionContext === \"property\" && r.propertyKey === \"text-font\" && !t.outputDefined())\n    return [new b(r.key, r.value, `Invalid data expression for \"${r.propertyKey}\". Output values must be contained as literals within the expression.`)];\n  if (r.expressionContext === \"property\" && r.propertyType === \"layout\" && !St(t))\n    return [new b(r.key, r.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n  if (r.expressionContext === \"filter\" && !St(t))\n    return [new b(r.key, r.value, '\"feature-state\" data expressions are not supported with filters.')];\n  if (r.expressionContext && r.expressionContext.indexOf(\"cluster\") === 0) {\n    if (!pr(t, [\"zoom\", \"feature-state\"]))\n      return [new b(r.key, r.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n    if (r.expressionContext === \"cluster-initial\" && !cr(t))\n      return [new b(r.key, r.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n  }\n  return [];\n}\nfunction Fl(r) {\n  const e = r.value, t = r.key, n = R(e);\n  return n !== \"boolean\" ? [new b(t, e, `boolean expected, ${n} found`)] : [];\n}\nfunction Vr(r) {\n  const e = r.key, t = r.value, n = R(t);\n  return n !== \"string\" ? [new b(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new b(e, t, `color expected, \"${t}\" found`)];\n}\nfunction xt(r) {\n  const e = r.key, t = r.value, n = r.valueSpec, a = [];\n  return Array.isArray(n.values) ? n.values.indexOf(B(t)) === -1 && a.push(new b(e, t, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(B(t)) === -1 && a.push(new b(e, t, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(t)} found`)), a;\n}\nfunction kn(r) {\n  return eo(Xe(r.value)) ? it(Dt({}, r, {\n    expressionContext: \"filter\",\n    valueSpec: { value: \"boolean\" }\n  })) : no(r);\n}\nfunction no(r) {\n  const e = r.value, t = r.key;\n  if (R(e) !== \"array\")\n    return [new b(t, e, `array expected, ${R(e)} found`)];\n  const n = r.styleSpec;\n  let a, o = [];\n  if (e.length < 1)\n    return [new b(t, e, \"filter array must have at least 1 element\")];\n  switch (o = o.concat(xt({\n    key: `${t}[0]`,\n    value: e[0],\n    valueSpec: n.filter_operator,\n    style: r.style,\n    styleSpec: r.styleSpec\n  })), B(e[0])) {\n    case \"<\":\n    case \"<=\":\n    case \">\":\n    case \">=\":\n      e.length >= 2 && B(e[1]) === \"$type\" && o.push(new b(t, e, `\"$type\" cannot be use with operator \"${e[0]}\"`));\n    /* falls through */\n    case \"==\":\n    case \"!=\":\n      e.length !== 3 && o.push(new b(t, e, `filter array for operator \"${e[0]}\" must have 3 elements`));\n    /* falls through */\n    case \"in\":\n    case \"!in\":\n      e.length >= 2 && (a = R(e[1]), a !== \"string\" && o.push(new b(`${t}[1]`, e[1], `string expected, ${a} found`)));\n      for (let i = 2; i < e.length; i++)\n        a = R(e[i]), B(e[1]) === \"$type\" ? o = o.concat(xt({\n          key: `${t}[${i}]`,\n          value: e[i],\n          valueSpec: n.geometry_type,\n          style: r.style,\n          styleSpec: r.styleSpec\n        })) : a !== \"string\" && a !== \"number\" && a !== \"boolean\" && o.push(new b(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));\n      break;\n    case \"any\":\n    case \"all\":\n    case \"none\":\n      for (let i = 1; i < e.length; i++)\n        o = o.concat(no({\n          key: `${t}[${i}]`,\n          value: e[i],\n          style: r.style,\n          styleSpec: r.styleSpec\n        }));\n      break;\n    case \"has\":\n    case \"!has\":\n      a = R(e[1]), e.length !== 2 ? o.push(new b(t, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : a !== \"string\" && o.push(new b(`${t}[1]`, e[1], `string expected, ${a} found`));\n      break;\n  }\n  return o;\n}\nfunction ao(r, e) {\n  const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];\n  if (!l)\n    return [];\n  const u = s.match(/^(.*)-transition$/);\n  if (e === \"paint\" && u && l[u[1]] && l[u[1]].transition)\n    return n({\n      key: t,\n      value: i,\n      valueSpec: o.transition,\n      style: a,\n      styleSpec: o\n    });\n  const c = r.valueSpec || l[s];\n  if (!c)\n    return [new b(t, i, `unknown property \"${s}\"`)];\n  let p;\n  if (R(i) === \"string\" && Xt(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i)))\n    return [new b(t, i, `\"${s}\" does not support interpolation syntax\nUse an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(p[1])} }\\`.`)];\n  const d = [];\n  return r.layerType === \"symbol\" && (s === \"text-field\" && a && !a.glyphs && d.push(new b(t, i, 'use of \"text-field\" requires a style \"glyphs\" property')), s === \"text-font\" && wn(Xe(i)) && B(i.type) === \"identity\" && d.push(new b(t, i, '\"text-font\" does not support identity functions'))), d.concat(n({\n    key: r.key,\n    value: i,\n    valueSpec: c,\n    style: a,\n    styleSpec: o,\n    expressionContext: \"property\",\n    propertyType: e,\n    propertyKey: s\n  }));\n}\nfunction oo(r) {\n  return ao(r, \"paint\");\n}\nfunction io(r) {\n  return ao(r, \"layout\");\n}\nfunction so(r) {\n  let e = [];\n  const t = r.value, n = r.key, a = r.style, o = r.styleSpec;\n  if (R(t) !== \"object\")\n    return [new b(n, t, `object expected, ${R(t)} found`)];\n  !t.type && !t.ref && e.push(new b(n, t, 'either \"type\" or \"ref\" is required'));\n  let i = B(t.type);\n  const s = B(t.ref);\n  if (t.id) {\n    const l = B(t.id);\n    for (let u = 0; u < r.arrayIndex; u++) {\n      const c = a.layers[u];\n      B(c.id) === l && e.push(new b(n, t.id, `duplicate layer id \"${t.id}\", previously used at line ${c.id.__line__}`));\n    }\n  }\n  if (\"ref\" in t) {\n    [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach((u) => {\n      u in t && e.push(new b(n, t[u], `\"${u}\" is prohibited for ref layers`));\n    });\n    let l;\n    a.layers.forEach((u) => {\n      B(u.id) === s && (l = u);\n    }), l ? l.ref ? e.push(new b(n, t.ref, \"ref cannot reference another ref layer\")) : i = B(l.type) : e.push(new b(n, t.ref, `ref layer \"${s}\" not found`));\n  } else if (i !== \"background\")\n    if (!t.source)\n      e.push(new b(n, t, 'missing required property \"source\"'));\n    else {\n      const l = a.sources && a.sources[t.source], u = l && B(l.type);\n      l ? u === \"vector\" && i === \"raster\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a raster source`)) : u !== \"raster-dem\" && i === \"hillshade\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a raster-dem source`)) : u !== \"raster-dem\" && i === \"color-relief\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a raster-dem source`)) : u === \"raster\" && i !== \"raster\" ? e.push(new b(n, t.source, `layer \"${t.id}\" requires a vector source`)) : u === \"vector\" && !t[\"source-layer\"] ? e.push(new b(n, t, `layer \"${t.id}\" must specify a \"source-layer\"`)) : u === \"raster-dem\" && i !== \"hillshade\" && i !== \"color-relief\" ? e.push(new b(n, t.source, \"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.\")) : i === \"line\" && t.paint && t.paint[\"line-gradient\"] && (u !== \"geojson\" || !l.lineMetrics) && e.push(new b(n, t, `layer \"${t.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new b(n, t.source, `source \"${t.source}\" not found`));\n    }\n  return e = e.concat(se({\n    key: n,\n    value: t,\n    valueSpec: o.layer,\n    style: r.style,\n    styleSpec: r.styleSpec,\n    validateSpec: r.validateSpec,\n    objectElementValidators: {\n      \"*\"() {\n        return [];\n      },\n      // We don't want to enforce the spec's `\"requires\": true` for backward compatibility with refs;\n      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.\n      type() {\n        return r.validateSpec({\n          key: `${n}.type`,\n          value: t.type,\n          valueSpec: o.layer.type,\n          style: r.style,\n          styleSpec: r.styleSpec,\n          validateSpec: r.validateSpec,\n          object: t,\n          objectKey: \"type\"\n        });\n      },\n      filter: kn,\n      layout(l) {\n        return se({\n          layer: t,\n          key: l.key,\n          value: l.value,\n          style: l.style,\n          styleSpec: l.styleSpec,\n          validateSpec: l.validateSpec,\n          objectElementValidators: {\n            \"*\"(u) {\n              return io(Dt({ layerType: i }, u));\n            }\n          }\n        });\n      },\n      paint(l) {\n        return se({\n          layer: t,\n          key: l.key,\n          value: l.value,\n          style: l.style,\n          styleSpec: l.styleSpec,\n          validateSpec: l.validateSpec,\n          objectElementValidators: {\n            \"*\"(u) {\n              return oo(Dt({ layerType: i }, u));\n            }\n          }\n        });\n      }\n    }\n  })), e;\n}\nfunction Ke(r) {\n  const e = r.value, t = r.key, n = R(e);\n  return n !== \"string\" ? [new b(t, e, `string expected, ${n} found`)] : [];\n}\nfunction $l(r) {\n  var e;\n  const t = (e = r.sourceName) !== null && e !== void 0 ? e : \"\", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;\n  let s = [];\n  const l = R(n);\n  if (n === void 0)\n    return s;\n  if (l !== \"object\")\n    return s.push(new b(\"source_raster_dem\", n, `object expected, ${l} found`)), s;\n  const c = B(n.encoding) === \"custom\", p = [\"redFactor\", \"greenFactor\", \"blueFactor\", \"baseShift\"], d = r.value.encoding ? `\"${r.value.encoding}\"` : \"Default\";\n  for (const f in n)\n    !c && p.includes(f) ? s.push(new b(f, n[f], `In \"${t}\": \"${f}\" is only valid when \"encoding\" is set to \"custom\". ${d} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({\n      key: f,\n      value: n[f],\n      valueSpec: o[f],\n      validateSpec: r.validateSpec,\n      style: i,\n      styleSpec: a\n    })) : s.push(new b(f, n[f], `unknown property \"${f}\"`));\n  return s;\n}\nconst na = {\n  promoteId: Ol\n};\nfunction lo(r) {\n  const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;\n  if (!e.type)\n    return [new b(t, e, '\"type\" is required')];\n  const i = B(e.type);\n  let s;\n  switch (i) {\n    case \"vector\":\n    case \"raster\":\n      return s = se({\n        key: t,\n        value: e,\n        valueSpec: n[`source_${i.replace(\"-\", \"_\")}`],\n        style: r.style,\n        styleSpec: n,\n        objectElementValidators: na,\n        validateSpec: o\n      }), s;\n    case \"raster-dem\":\n      return s = $l({\n        sourceName: t,\n        value: e,\n        style: r.style,\n        styleSpec: n,\n        validateSpec: o\n      }), s;\n    case \"geojson\":\n      if (s = se({\n        key: t,\n        value: e,\n        valueSpec: n.source_geojson,\n        style: a,\n        styleSpec: n,\n        validateSpec: o,\n        objectElementValidators: na\n      }), e.cluster)\n        for (const l in e.clusterProperties) {\n          const [u, c] = e.clusterProperties[l], p = typeof u == \"string\" ? [u, [\"accumulated\"], [\"get\", l]] : u;\n          s.push(...it({\n            key: `${t}.${l}.map`,\n            value: c,\n            expressionContext: \"cluster-map\"\n          })), s.push(...it({\n            key: `${t}.${l}.reduce`,\n            value: p,\n            expressionContext: \"cluster-reduce\"\n          }));\n        }\n      return s;\n    case \"video\":\n      return se({\n        key: t,\n        value: e,\n        valueSpec: n.source_video,\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n    case \"image\":\n      return se({\n        key: t,\n        value: e,\n        valueSpec: n.source_image,\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n    case \"canvas\":\n      return [new b(t, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n    default:\n      return xt({\n        key: `${t}.type`,\n        value: e.type,\n        valueSpec: { values: [\"vector\", \"raster\", \"raster-dem\", \"geojson\", \"video\", \"image\"] }\n      });\n  }\n}\nfunction Ol({ key: r, value: e }) {\n  if (R(e) === \"string\")\n    return Ke({ key: r, value: e });\n  {\n    const t = [];\n    for (const n in e)\n      t.push(...Ke({ key: `${r}.${n}`, value: e[n] }));\n    return t;\n  }\n}\nfunction uo(r) {\n  const e = r.value, t = r.styleSpec, n = t.light, a = r.style;\n  let o = [];\n  const i = R(e);\n  if (e === void 0)\n    return o;\n  if (i !== \"object\")\n    return o = o.concat([new b(\"light\", e, `object expected, ${i} found`)]), o;\n  for (const s in e) {\n    const l = s.match(/^(.*)-transition$/);\n    l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: t.transition,\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : n[s] ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : o = o.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  }\n  return o;\n}\nfunction co(r) {\n  const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = R(e);\n  if (e === void 0)\n    return [];\n  if (o !== \"object\")\n    return [new b(\"sky\", e, `object expected, ${o} found`)];\n  let i = [];\n  for (const s in e)\n    n[s] ? i = i.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      style: a,\n      styleSpec: t\n    })) : i = i.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  return i;\n}\nfunction po(r) {\n  const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;\n  let o = [];\n  const i = R(e);\n  if (e === void 0)\n    return o;\n  if (i !== \"object\")\n    return o = o.concat([new b(\"terrain\", e, `object expected, ${i} found`)]), o;\n  for (const s in e)\n    n[s] ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : o = o.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  return o;\n}\nfunction Nl(r) {\n  return Ke(r).length === 0 ? [] : it(r);\n}\nfunction jl(r) {\n  return Ke(r).length === 0 ? [] : it(r);\n}\nfunction Ul(r) {\n  const e = r.key, t = r.value;\n  if (R(t) === \"array\") {\n    if (t.length < 1 || t.length > 4)\n      return [new b(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];\n    const a = {\n      type: \"number\"\n    };\n    let o = [];\n    for (let i = 0; i < t.length; i++)\n      o = o.concat(r.validateSpec({\n        key: `${e}[${i}]`,\n        value: t[i],\n        validateSpec: r.validateSpec,\n        valueSpec: a\n      }));\n    return o;\n  } else\n    return fr({\n      key: e,\n      value: t,\n      valueSpec: {}\n    });\n}\nfunction Dl(r) {\n  const e = r.key, t = r.value;\n  if (R(t) === \"array\") {\n    const a = {\n      type: \"number\"\n    };\n    if (t.length < 1)\n      return [new b(e, t, \"array length at least 1 expected, length 0 found\")];\n    let o = [];\n    for (let i = 0; i < t.length; i++)\n      o = o.concat(r.validateSpec({\n        key: `${e}[${i}]`,\n        value: t[i],\n        validateSpec: r.validateSpec,\n        valueSpec: a\n      }));\n    return o;\n  } else\n    return fr({\n      key: e,\n      value: t,\n      valueSpec: {}\n    });\n}\nfunction Bl(r) {\n  const e = r.key, t = r.value;\n  if (R(t) === \"array\") {\n    if (t.length < 1)\n      return [new b(e, t, \"array length at least 1 expected, length 0 found\")];\n    let a = [];\n    for (let o = 0; o < t.length; o++)\n      a = a.concat(Vr({\n        key: `${e}[${o}]`,\n        value: t[o]\n      }));\n    return a;\n  } else\n    return Vr({\n      key: e,\n      value: t\n    });\n}\nfunction ql(r) {\n  const e = r.key, t = r.value, n = R(t), a = r.styleSpec;\n  if (n !== \"array\" || t.length < 1 || t.length % 2 !== 0)\n    return [new b(e, t, \"variableAnchorOffsetCollection requires a non-empty array of even length\")];\n  let o = [];\n  for (let i = 0; i < t.length; i += 2)\n    o = o.concat(xt({\n      key: `${e}[${i}]`,\n      value: t[i],\n      valueSpec: a.layout_symbol[\"text-anchor\"]\n    })), o = o.concat(xn({\n      key: `${e}[${i + 1}]`,\n      value: t[i + 1],\n      valueSpec: {\n        length: 2,\n        value: \"number\"\n      },\n      validateSpec: r.validateSpec,\n      style: r.style,\n      styleSpec: a\n    }));\n  return o;\n}\nfunction fo(r) {\n  let e = [];\n  const t = r.value, n = r.key;\n  if (Array.isArray(t)) {\n    const a = [], o = [];\n    for (const i in t) {\n      t[i].id && a.includes(t[i].id) && e.push(new b(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new b(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);\n      const s = {\n        id: {\n          type: \"string\",\n          required: !0\n        },\n        url: {\n          type: \"string\",\n          required: !0\n        }\n      };\n      e = e.concat(se({\n        key: `${n}[${i}]`,\n        value: t[i],\n        valueSpec: s,\n        validateSpec: r.validateSpec\n      }));\n    }\n    return e;\n  } else\n    return Ke({\n      key: n,\n      value: t\n    });\n}\nfunction Vl(r) {\n  const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = R(e);\n  if (e === void 0)\n    return [];\n  if (o !== \"object\")\n    return [new b(\"projection\", e, `object expected, ${o} found`)];\n  let i = [];\n  for (const s in e)\n    n[s] ? i = i.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      style: a,\n      styleSpec: t\n    })) : i = i.concat([new b(s, e[s], `unknown property \"${s}\"`)]);\n  return i;\n}\nfunction Gl(r) {\n  const e = r.key;\n  let t = r.value;\n  t = t instanceof String ? t.valueOf() : t;\n  const n = R(t);\n  return n === \"array\" && !Zl(t) && !Hl(t) ? [new b(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : [\"array\", \"string\"].includes(n) ? [] : [new b(e, t, `projection expected, invalid type \"${n}\" found`)];\n}\nfunction Hl(r) {\n  return !![\"interpolate\", \"step\", \"literal\"].includes(r[0]);\n}\nfunction Zl(r) {\n  return Array.isArray(r) && r.length === 3 && typeof r[0] == \"string\" && typeof r[1] == \"string\" && typeof r[2] == \"number\";\n}\nfunction Xl(r) {\n  return !!r && r.constructor === Object;\n}\nfunction ho(r) {\n  return Xl(r.value) ? [] : [\n    new b(r.key, r.value, `object expected, ${R(r.value)} found`)\n  ];\n}\nconst aa = {\n  \"*\"() {\n    return [];\n  },\n  array: xn,\n  boolean: Fl,\n  number: fr,\n  color: Vr,\n  constants: to,\n  enum: xt,\n  filter: kn,\n  function: ro,\n  layer: so,\n  object: se,\n  source: lo,\n  light: uo,\n  sky: co,\n  terrain: po,\n  projection: Vl,\n  projectionDefinition: Gl,\n  string: Ke,\n  formatted: Nl,\n  resolvedImage: jl,\n  padding: Ul,\n  numberArray: Dl,\n  colorArray: Bl,\n  variableAnchorOffsetCollection: ql,\n  sprite: fo,\n  state: ho\n};\nfunction Kt(r) {\n  const e = r.value, t = r.valueSpec, n = r.styleSpec;\n  return r.validateSpec = Kt, t.expression && wn(B(e)) ? ro(r) : t.expression && Ja(Xe(e)) ? it(r) : t.type && aa[t.type] ? aa[t.type](r) : se(Dt({}, r, {\n    valueSpec: t.type ? n[t.type] : t\n  }));\n}\nfunction mo(r) {\n  const e = r.value, t = r.key, n = Ke(r);\n  return n.length || (e.indexOf(\"{fontstack}\") === -1 && n.push(new b(t, e, '\"glyphs\" url must include a \"{fontstack}\" token')), e.indexOf(\"{range}\") === -1 && n.push(new b(t, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n}\nfunction re(r, e = xs) {\n  let t = [];\n  return t = t.concat(Kt({\n    key: \"\",\n    value: r,\n    valueSpec: e.$root,\n    styleSpec: e,\n    style: r,\n    validateSpec: Kt,\n    objectElementValidators: {\n      glyphs: mo,\n      \"*\"() {\n        return [];\n      }\n    }\n  })), r.constants && (t = t.concat(to({\n    key: \"constants\",\n    value: r.constants\n  }))), yo(t);\n}\nre.source = ge(ye(lo));\nre.sprite = ge(ye(fo));\nre.glyphs = ge(ye(mo));\nre.light = ge(ye(uo));\nre.sky = ge(ye(co));\nre.terrain = ge(ye(po));\nre.state = ge(ye(ho));\nre.layer = ge(ye(so));\nre.filter = ge(ye(kn));\nre.paintProperty = ge(ye(oo));\nre.layoutProperty = ge(ye(io));\nfunction ye(r) {\n  return function(e) {\n    return r({\n      ...e,\n      validateSpec: Kt\n    });\n  };\n}\nfunction yo(r) {\n  return [].concat(r).sort((e, t) => e.line - t.line);\n}\nfunction ge(r) {\n  return function(...e) {\n    return yo(r.apply(this, e));\n  };\n}\nfunction oa(r) {\n  if (!r)\n    return {\n      style: _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n      requiresUrlMonitoring: !1,\n      // default styles don't require URL monitoring\n      isFallback: !0\n    };\n  if (typeof r == \"string\") {\n    const t = Yl(r);\n    return t.isValidStyle ? {\n      style: t.styleObject,\n      requiresUrlMonitoring: !1,\n      isFallback: !1\n    } : t.isValidJSON ? {\n      style: _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n      requiresUrlMonitoring: !1,\n      // default styles don't require URL monitoring\n      isFallback: !0\n    } : r.startsWith(\"http\") ? { style: r, requiresUrlMonitoring: !0, isFallback: !1 } : r.toLowerCase().includes(\".json\") ? {\n      style: Kl(r),\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    } : {\n      style: (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.expandMapStyle)(r),\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    };\n  }\n  return r instanceof _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyleVariant ? {\n    style: r.getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : r instanceof _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.ReferenceMapStyle ? {\n    style: r.getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : re(r).length === 0 ? {\n    style: r,\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : {\n    style: _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyle[_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    // default styles don't require URL monitoring\n    isFallback: !0\n  };\n}\nfunction Kl(r) {\n  try {\n    return new URL(r).href;\n  } catch {\n  }\n  return new URL(r, location.origin).href;\n}\nfunction Yl(r) {\n  try {\n    const e = JSON.parse(r), t = re(e);\n    return {\n      isValidJSON: !0,\n      isValidStyle: t.length === 0,\n      styleObject: t.length === 0 ? e : null\n    };\n  } catch {\n    return {\n      isValidJSON: !1,\n      isValidStyle: !1,\n      styleObject: null\n    };\n  }\n}\nfunction Le(r, e, t) {\n  const n = window.document.createElement(r);\n  return e !== void 0 && (n.className = e), t && t.appendChild(n), n;\n}\nfunction kt(r) {\n  r.parentNode && r.parentNode.removeChild(r);\n}\nclass Wl {\n  constructor() {\n    v(this, \"_map\");\n    v(this, \"_container\");\n    v(this, \"_terrainButton\");\n    Si([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(e) {\n    return this._map = e, this._container = Le(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"), this._terrainButton = Le(\"button\", \"maplibregl-ctrl-terrain\", this._container), Le(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\"aria-hidden\", \"true\"), this._terrainButton.type = \"button\", this._terrainButton.addEventListener(\"click\", this._toggleTerrain), this._updateTerrainIcon(), this._map.on(\"terrain\", this._updateTerrainIcon), this._container;\n  }\n  onRemove() {\n    kt(this._container), this._map.off(\"terrain\", this._updateTerrainIcon), this._map = void 0;\n  }\n  _toggleTerrain() {\n    go(this._map), this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\"), this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\"), this._map.hasTerrain() ? (this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\"), this._terrainButton.title = this._map._getUIString(\"TerrainControl.Disable\")) : (this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\"), this._terrainButton.title = this._map._getUIString(\"TerrainControl.Enable\"));\n  }\n}\nfunction go(r) {\n  r.hasTerrain() ? r.disableTerrain() : r.enableTerrain();\n}\nclass Jl extends Ma {\n  constructor(t = {}) {\n    super({\n      showCompass: t.showCompass ?? !0,\n      showZoom: t.showZoom ?? !0,\n      visualizePitch: t.visualizePitch ?? !0\n    });\n    /**\n     * Overloading: Limit how flat the compass icon can get\n     */\n    v(this, \"_rotateCompassArrow\", () => {\n      const t = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t}deg)` : `rotate(${-t}deg)`;\n      this._compassIcon.style.transform = a;\n    });\n    this._compass && (this._compass.removeEventListener(\"click\", this._compass.clickFunction), this._compass.addEventListener(\"click\", (n) => {\n      this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });\n    }));\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(t, n) {\n    const a = super._createButton(t, n);\n    return a.clickFunction = n, a;\n  }\n}\nconst ia = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker, sa = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLat, Ql = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds;\nclass eu extends Pi {\n  constructor() {\n    super(...arguments);\n    v(this, \"lastUpdatedCenter\", new sa(0, 0));\n    /**\n     * Update the camera location to center on the current position\n     *\n     * @param {Position} position the Geolocation API Position\n     * @private\n     */\n    v(this, \"_updateCamera\", (t) => {\n      var c;\n      const n = new sa(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {\n        bearing: this._map.getBearing(),\n        ...this.options.fitBoundsOptions,\n        linear: !0\n      }, s = this._map.getZoom();\n      s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(Ql.fromLngLat(n, a), i, {\n        geolocateSource: !0\n        // tag this camera change so it won't cause the control to change to background state\n      });\n      let l = !1;\n      const u = () => {\n        l = !0;\n      };\n      this._map.once(\"click\", u), this._map.once(\"dblclick\", u), this._map.once(\"dragstart\", u), this._map.once(\"mousedown\", u), this._map.once(\"touchstart\", u), this._map.once(\"wheel\", u), this._map.once(\"moveend\", () => {\n        this._map.off(\"click\", u), this._map.off(\"dblclick\", u), this._map.off(\"dragstart\", u), this._map.off(\"mousedown\", u), this._map.off(\"touchstart\", u), this._map.off(\"wheel\", u), !l && (this.lastUpdatedCenter = this._map.getCenter());\n      });\n    });\n    v(this, \"_finishSetupUI\", (t) => {\n      if (this._map) {\n        if (t === !1) {\n          const n = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n          this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute(\"aria-label\", n);\n        } else {\n          const n = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n          this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute(\"aria-label\", n);\n        }\n        this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = Le(\"div\", \"maplibregl-user-location-dot\"), this._userLocationDotMarker = new ia({ element: this._dotElement }), this._circleElement = Le(\"div\", \"maplibregl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new ia({\n          element: this._circleElement,\n          pitchAlignment: \"map\"\n        }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"move\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"moveend\", (n) => {\n          const a = n.originalEvent && n.originalEvent.type === \"resize\", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());\n          !n.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !a && o > 1 && (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this.fire(new Event(\"trackuserlocationend\")));\n        });\n      }\n    });\n    v(this, \"_onZoom\", () => {\n      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n    });\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\")\n      return;\n    const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);\n    this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;\n  }\n  // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the\n  // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.\n  // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294\n  _setErrorState() {\n    switch (this._watchState) {\n      case \"WAITING_ACTIVE\":\n        this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\");\n        break;\n      case \"ACTIVE_LOCK\":\n        this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\");\n        break;\n      case \"BACKGROUND\":\n        this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\");\n        break;\n      case \"ACTIVE_ERROR\":\n        break;\n      case \"BACKGROUND_ERROR\":\n        break;\n      default:\n        throw new Error(`Unexpected watchState ${this._watchState}`);\n    }\n  }\n}\nvar Ae, W, Te, _e, rt;\nclass tu {\n  /**\n   * @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM\n   * @param onClick Function called when the element is clicked\n   * @param onRender Function called every time the underlying map renders a new state\n   */\n  constructor(e, t, n) {\n    Z(this, Ae);\n    Z(this, W);\n    Z(this, Te);\n    Z(this, _e);\n    Z(this, rt);\n    if (typeof e == \"string\") {\n      const a = document.querySelector(e);\n      if (!a) throw new Error(`No element has been found with selector \"${e}\" when creating an external control.`);\n      K(this, W, a);\n    } else\n      K(this, W, e);\n    t && K(this, Te, (a) => {\n      t(k(this, Ae), k(this, W), a);\n    }), n && K(this, _e, (a) => {\n      n(k(this, Ae), k(this, W), a);\n    }), K(this, rt, k(this, W).parentElement);\n  }\n  onAdd(e) {\n    return K(this, Ae, e), k(this, Te) && k(this, W).addEventListener(\"click\", k(this, Te)), k(this, _e) && k(this, Ae).on(\"render\", k(this, _e)), kt(k(this, W)), k(this, W);\n  }\n  onRemove() {\n    k(this, Te) && k(this, W).removeEventListener(\"click\", k(this, Te)), k(this, _e) && k(this, Ae).off(\"render\", k(this, _e)), k(this, rt) ? k(this, rt).appendChild(k(this, W)) : kt(k(this, W));\n  }\n}\nAe = new WeakMap(), W = new WeakMap(), Te = new WeakMap(), _e = new WeakMap(), rt = new WeakMap();\nclass ru {\n  constructor() {\n    v(this, \"map\");\n    v(this, \"container\");\n    v(this, \"projectionButton\");\n  }\n  onAdd(e) {\n    return this.map = e, this.container = Le(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"), this.projectionButton = Le(\"button\", \"maplibregl-ctrl-projection\", this.container), Le(\"span\", \"maplibregl-ctrl-icon\", this.projectionButton).setAttribute(\"aria-hidden\", \"true\"), this.projectionButton.type = \"button\", this.projectionButton.addEventListener(\"click\", this.toggleProjection.bind(this)), e.on(\"projectiontransition\", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;\n  }\n  onRemove() {\n    kt(this.container), this.map.off(\"projectiontransition\", this.updateProjectionIcon), this.map = void 0;\n  }\n  toggleProjection() {\n    vo(this.map), this.updateProjectionIcon();\n  }\n  updateProjectionIcon() {\n    this.projectionButton.classList.remove(\"maplibregl-ctrl-projection-globe\"), this.projectionButton.classList.remove(\"maplibregl-ctrl-projection-mercator\"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add(\"maplibregl-ctrl-projection-mercator\"), this.projectionButton.title = \"Enable Mercator projection\") : (this.projectionButton.classList.add(\"maplibregl-ctrl-projection-globe\"), this.projectionButton.title = \"Enable Globe projection\");\n  }\n}\nfunction vo(r) {\n  r.getProjection() === void 0 && r.setProjection({ type: \"mercator\" }), r.isGlobeProjection() ? r.enableMercatorProjection() : r.enableGlobeProjection();\n}\nconst ut = {\n  \"zoom-in\": (r) => r.zoomIn(),\n  \"zoom-out\": (r) => r.zoomOut(),\n  \"toggle-projection\": vo,\n  \"toggle-terrain\": go,\n  \"reset-view\": (r) => {\n    r.getPitch() === 0 ? r.easeTo({ pitch: Math.min(r.getMaxPitch(), 80) }) : r.resetNorthPitch();\n  },\n  \"reset-bearing\": (r) => {\n    r.rotateTo(0);\n  },\n  \"reset-pitch\": (r) => {\n    r.setPitch(0);\n  },\n  \"reset-roll\": (r) => {\n    r.setRoll(0);\n  }\n};\nvar Ct, nt;\nclass Gr extends tu {\n  /**\n   * Constructs an instance of External Control to have a predefined functionality\n   * @param controlElement Element to be used as control, specified as reference to element itself\n   * @param controlType One of the predefined types of functionality\n   */\n  constructor(t, n) {\n    if (n && !(n in ut)) throw new Error(`data-maptiler-control value \"${n}\" is invalid.`);\n    super(t, n && ut[n]);\n    Z(this, Ct);\n    Z(this, nt, /* @__PURE__ */ new Map());\n  }\n  onAdd(t) {\n    return K(this, Ct, t), super.onAdd(t);\n  }\n  onRemove() {\n    for (const [t, n] of k(this, nt)) {\n      const a = t.deref();\n      a && a.removeEventListener(\"click\", n);\n    }\n    k(this, nt).clear(), super.onRemove();\n  }\n  /**\n   * Configure a child element to be part of this control and to have a predefined functionality added\n   * @param controlElement Element that is a descendant of the control element and that optionally should have some functionality\n   * @param controlType One of the predefined types of functionality\n   */\n  configureGroupItem(t, n) {\n    if (!n) return;\n    if (!(n in ut)) throw new Error(`data-maptiler-control value \"${n}\" is invalid.`);\n    const a = (o) => {\n      ut[n](k(this, Ct), t, o);\n    };\n    t.addEventListener(\"click\", a), k(this, nt).set(new WeakRef(t), a);\n  }\n}\nCt = new WeakMap(), nt = new WeakMap(), v(Gr, \"controlCallbacks\", ut);\nvar J, pe, Ie, Me, ee, Et, V, bo, ne, wo;\nclass Er {\n  constructor(e, t) {\n    Z(this, V);\n    Z(this, J);\n    v(this, \"map\");\n    Z(this, pe);\n    Z(this, Ie);\n    Z(this, Me);\n    Z(this, ee, !1);\n    Z(this, Et);\n    e.style !== void 0 && K(this, ee, !0), K(this, J, {\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\",\n      // inherit map options\n      ...t,\n      // override any lingering control options\n      forceNoAttributionControl: !0,\n      attributionControl: !1,\n      navigationControl: !1,\n      geolocateControl: !1,\n      maptilerLogo: !1,\n      minimap: !1,\n      hash: !1,\n      pitchAdjust: !1,\n      // override map options with new user defined minimap options\n      ...e,\n      containerStyle: {\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\",\n        ...e.containerStyle ?? {}\n      }\n    }), e.lockZoom !== void 0 && (k(this, J).minZoom = e.lockZoom, k(this, J).maxZoom = e.lockZoom);\n  }\n  setStyle(e, t) {\n    k(this, ee) || this.map.setStyle(e, t), Y(this, V, ne).call(this);\n  }\n  addLayer(e, t) {\n    return k(this, ee) || this.map.addLayer(e, t), Y(this, V, ne).call(this), this.map;\n  }\n  moveLayer(e, t) {\n    return k(this, ee) || this.map.moveLayer(e, t), Y(this, V, ne).call(this), this.map;\n  }\n  removeLayer(e) {\n    return k(this, ee) || this.map.removeLayer(e), Y(this, V, ne).call(this), this;\n  }\n  setLayerZoomRange(e, t, n) {\n    return k(this, ee) || this.map.setLayerZoomRange(e, t, n), Y(this, V, ne).call(this), this;\n  }\n  setFilter(e, t, n) {\n    return k(this, ee) || this.map.setFilter(e, t, n), Y(this, V, ne).call(this), this;\n  }\n  setPaintProperty(e, t, n, a) {\n    return k(this, ee) || this.map.setPaintProperty(e, t, n, a), Y(this, V, ne).call(this), this;\n  }\n  setLayoutProperty(e, t, n, a) {\n    return k(this, ee) || this.map.setLayoutProperty(e, t, n, a), Y(this, V, ne).call(this), this;\n  }\n  setGlyphs(e, t) {\n    return k(this, ee) || this.map.setGlyphs(e, t), Y(this, V, ne).call(this), this;\n  }\n  onAdd(e) {\n    K(this, pe, e), K(this, Ie, Le(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"));\n    for (const [t, n] of Object.entries(k(this, J).containerStyle))\n      k(this, Ie).style.setProperty(t, n);\n    return k(this, J).container = k(this, Ie), k(this, J).zoom = e.getZoom() + k(this, J).zoomAdjust, this.map = new Lo(k(this, J)), this.map.once(\"style.load\", () => {\n      this.map.resize();\n    }), this.map.once(\"load\", () => {\n      Y(this, V, bo).call(this, k(this, J).parentRect), K(this, Et, Y(this, V, wo).call(this));\n    }), k(this, Ie);\n  }\n  onRemove() {\n    var e;\n    (e = k(this, Et)) == null || e.call(this), kt(k(this, Ie));\n  }\n}\nJ = new WeakMap(), pe = new WeakMap(), Ie = new WeakMap(), Me = new WeakMap(), ee = new WeakMap(), Et = new WeakMap(), V = new WeakSet(), bo = function(e) {\n  e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (K(this, Me, {\n    type: \"Feature\",\n    properties: {\n      name: \"parentRect\"\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[[], [], [], [], []]]\n    }\n  }), this.map.addSource(\"parentRect\", {\n    type: \"geojson\",\n    data: k(this, Me)\n  }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({\n    id: \"parentRectOutline\",\n    type: \"line\",\n    source: \"parentRect\",\n    layout: {\n      ...e.lineLayout\n    },\n    paint: {\n      \"line-color\": \"#FFF\",\n      \"line-width\": 1,\n      \"line-opacity\": 0.85,\n      ...e.linePaint\n    }\n  }), e.fillPaint !== void 0 && this.map.addLayer({\n    id: \"parentRectFill\",\n    type: \"fill\",\n    source: \"parentRect\",\n    layout: {},\n    paint: {\n      \"fill-color\": \"#08F\",\n      \"fill-opacity\": 0.135,\n      ...e.fillPaint\n    }\n  }), Y(this, V, ne).call(this));\n}, ne = function() {\n  if (k(this, Me) === void 0) return;\n  const { devicePixelRatio: e } = window, t = k(this, pe).getCanvas(), n = t.width / e, a = t.height / e, o = k(this, pe).unproject.bind(k(this, pe)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);\n  k(this, Me).geometry.coordinates = [[l.toArray(), u.toArray(), s.toArray(), i.toArray(), l.toArray()]];\n  const c = this.map.getSource(\"parentRect\");\n  c !== void 0 && c.setData(k(this, Me));\n}, wo = function() {\n  const { pitchAdjust: e } = k(this, J), t = () => {\n    i(\"parent\");\n  }, n = () => {\n    i(\"minimap\");\n  }, a = () => {\n    k(this, pe).on(\"move\", t), this.map.on(\"move\", n);\n  }, o = () => {\n    k(this, pe).off(\"move\", t), this.map.off(\"move\", n);\n  }, i = (s) => {\n    o();\n    const l = s === \"parent\" ? k(this, pe) : this.map, u = s === \"parent\" ? this.map : k(this, pe), c = l.getCenter(), p = l.getZoom() + k(this, J).zoomAdjust * (s === \"parent\" ? 1 : -1), d = l.getBearing(), f = l.getPitch();\n    u.jumpTo({\n      center: c,\n      zoom: p,\n      bearing: d,\n      pitch: e ? f : 0\n    }), Y(this, V, ne).call(this), a();\n  };\n  return a(), () => {\n    o();\n  };\n};\nclass nu {\n  /**\n   *\n   * @param map : a Map instance\n   * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)\n   */\n  constructor(e, t = 2e3) {\n    v(this, \"map\");\n    v(this, \"registeredModules\", /* @__PURE__ */ new Set());\n    v(this, \"viewerType\");\n    this.map = e, this.viewerType = \"Map\", setTimeout(\n      async () => {\n        if (!j.telemetry)\n          return;\n        const n = this.preparePayload();\n        try {\n          (await fetch(n, { method: \"POST\" })).ok || console.warn(\"The metrics could not be sent to MapTiler Cloud\");\n        } catch (a) {\n          console.warn(\"The metrics could not be sent to MapTiler Cloud\", a);\n        }\n      },\n      Math.max(1e3, t)\n    );\n  }\n  /**\n   * Register a module to the telemetry system of the SDK.\n   * The arguments `name` and `version` likely come from the package.json\n   * of each module.\n   */\n  registerModule(e, t) {\n    this.registeredModules.add(`${e}:${t}`);\n  }\n  registerViewerType(e = \"Map\") {\n    this.viewerType = e;\n  }\n  preparePayload() {\n    const e = new URL(X.telemetryURL);\n    return e.searchParams.append(\"sdk\", xc()), e.searchParams.append(\"key\", j.apiKey), e.searchParams.append(\"mtsid\", tn), e.searchParams.append(\"session\", j.session ? \"1\" : \"0\"), e.searchParams.append(\"caching\", j.caching ? \"1\" : \"0\"), e.searchParams.append(\"lang-updated\", this.map.isLanguageUpdated() ? \"1\" : \"0\"), e.searchParams.append(\"terrain\", this.map.getTerrain() ? \"1\" : \"0\"), e.searchParams.append(\"globe\", this.map.isGlobeProjection() ? \"1\" : \"0\"), e.searchParams.append(\"viewerType\", this.viewerType), this.registeredModules.size > 0 && e.searchParams.append(\"modules\", Array.from(this.registeredModules).join(\"|\")), e.href;\n  }\n}\nvar Lt = typeof Float32Array < \"u\" ? Float32Array : Array;\nMath.hypot || (Math.hypot = function() {\n  for (var r = 0, e = arguments.length; e--; )\n    r += arguments[e] * arguments[e];\n  return Math.sqrt(r);\n});\nfunction mt() {\n  var r = new Lt(16);\n  return Lt != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;\n}\nfunction au(r, e, t, n, a, o, i, s, l, u, c, p, d, f, h, m, y) {\n  return r[0] = e, r[1] = t, r[2] = n, r[3] = a, r[4] = o, r[5] = i, r[6] = s, r[7] = l, r[8] = u, r[9] = c, r[10] = p, r[11] = d, r[12] = f, r[13] = h, r[14] = m, r[15] = y, r;\n}\nfunction ou(r, e, t) {\n  var n = e[0], a = e[1], o = e[2], i = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], d = e[9], f = e[10], h = e[11], m = e[12], y = e[13], w = e[14], g = e[15], x = t[0], E = t[1], C = t[2], T = t[3];\n  return r[0] = x * n + E * s + C * p + T * m, r[1] = x * a + E * l + C * d + T * y, r[2] = x * o + E * u + C * f + T * w, r[3] = x * i + E * c + C * h + T * g, x = t[4], E = t[5], C = t[6], T = t[7], r[4] = x * n + E * s + C * p + T * m, r[5] = x * a + E * l + C * d + T * y, r[6] = x * o + E * u + C * f + T * w, r[7] = x * i + E * c + C * h + T * g, x = t[8], E = t[9], C = t[10], T = t[11], r[8] = x * n + E * s + C * p + T * m, r[9] = x * a + E * l + C * d + T * y, r[10] = x * o + E * u + C * f + T * w, r[11] = x * i + E * c + C * h + T * g, x = t[12], E = t[13], C = t[14], T = t[15], r[12] = x * n + E * s + C * p + T * m, r[13] = x * a + E * l + C * d + T * y, r[14] = x * o + E * u + C * f + T * w, r[15] = x * i + E * c + C * h + T * g, r;\n}\nfunction iu(r, e, t) {\n  var n = t[0], a = t[1], o = t[2];\n  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * a, r[5] = e[5] * a, r[6] = e[6] * a, r[7] = e[7] * a, r[8] = e[8] * o, r[9] = e[9] * o, r[10] = e[10] * o, r[11] = e[11] * o, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;\n}\nfunction la(r, e, t) {\n  var n = Math.sin(t), a = Math.cos(t), o = e[4], i = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], d = e[11];\n  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = o * a + u * n, r[5] = i * a + c * n, r[6] = s * a + p * n, r[7] = l * a + d * n, r[8] = u * a - o * n, r[9] = c * a - i * n, r[10] = p * a - s * n, r[11] = d * a - l * n, r;\n}\nfunction su(r, e, t) {\n  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], d = e[11];\n  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a - u * n, r[1] = i * a - c * n, r[2] = s * a - p * n, r[3] = l * a - d * n, r[8] = o * n + u * a, r[9] = i * n + c * a, r[10] = s * n + p * a, r[11] = l * n + d * a, r;\n}\nfunction ua(r, e, t) {\n  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], d = e[7];\n  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a + u * n, r[1] = i * a + c * n, r[2] = s * a + p * n, r[3] = l * a + d * n, r[4] = u * a - o * n, r[5] = c * a - i * n, r[6] = p * a - s * n, r[7] = d * a - l * n, r;\n}\nfunction lu(r, e, t, n, a) {\n  var o = 1 / Math.tan(e / 2), i;\n  return r[0] = o / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, a != null && a !== 1 / 0 ? (i = 1 / (n - a), r[10] = (a + n) * i, r[14] = 2 * a * n * i) : (r[10] = -1, r[14] = -2 * n), r;\n}\nvar uu = lu;\nfunction Nt() {\n  var r = new Lt(3);\n  return Lt != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;\n}\nfunction cu(r, e, t) {\n  var n = new Lt(3);\n  return n[0] = r, n[1] = e, n[2] = t, n;\n}\nfunction Ar(r, e) {\n  var t = e[0], n = e[1], a = e[2], o = t * t + n * n + a * a;\n  return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = e[0] * o, r[1] = e[1] * o, r[2] = e[2] * o, r;\n}\nfunction ca(r, e, t) {\n  var n = e[0], a = e[1], o = e[2], i = t[0], s = t[1], l = t[2];\n  return r[0] = a * l - o * s, r[1] = o * i - n * l, r[2] = n * s - a * i, r;\n}\n(function() {\n  var r = Nt();\n  return function(e, t, n, a, o, i) {\n    var s, l;\n    for (t || (t = 3), n || (n = 0), a ? l = Math.min(a * t + n, e.length) : l = e.length, s = n; s < l; s += t)\n      r[0] = e[s], r[1] = e[s + 1], r[2] = e[s + 2], o(r, r, i), e[s] = r[0], e[s + 1] = r[1], e[s + 2] = r[2];\n    return e;\n  };\n})();\nfunction pu(r) {\n  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, \"default\") ? r.default : r;\n}\nvar Tr, pa;\nfunction fu() {\n  return pa || (pa = 1, Tr = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  }), Tr;\n}\nvar _r, fa;\nfunction So() {\n  if (fa) return _r;\n  fa = 1;\n  const r = fu(), e = {};\n  for (const a of Object.keys(r))\n    e[r[a]] = a;\n  const t = {\n    rgb: { channels: 3, labels: \"rgb\" },\n    hsl: { channels: 3, labels: \"hsl\" },\n    hsv: { channels: 3, labels: \"hsv\" },\n    hwb: { channels: 3, labels: \"hwb\" },\n    cmyk: { channels: 4, labels: \"cmyk\" },\n    xyz: { channels: 3, labels: \"xyz\" },\n    lab: { channels: 3, labels: \"lab\" },\n    lch: { channels: 3, labels: \"lch\" },\n    hex: { channels: 1, labels: [\"hex\"] },\n    keyword: { channels: 1, labels: [\"keyword\"] },\n    ansi16: { channels: 1, labels: [\"ansi16\"] },\n    ansi256: { channels: 1, labels: [\"ansi256\"] },\n    hcg: { channels: 3, labels: [\"h\", \"c\", \"g\"] },\n    apple: { channels: 3, labels: [\"r16\", \"g16\", \"b16\"] },\n    gray: { channels: 1, labels: [\"gray\"] }\n  };\n  _r = t;\n  for (const a of Object.keys(t)) {\n    if (!(\"channels\" in t[a]))\n      throw new Error(\"missing channels property: \" + a);\n    if (!(\"labels\" in t[a]))\n      throw new Error(\"missing channel labels property: \" + a);\n    if (t[a].labels.length !== t[a].channels)\n      throw new Error(\"channel and label counts mismatch: \" + a);\n    const { channels: o, labels: i } = t[a];\n    delete t[a].channels, delete t[a].labels, Object.defineProperty(t[a], \"channels\", { value: o }), Object.defineProperty(t[a], \"labels\", { value: i });\n  }\n  t.rgb.hsl = function(a) {\n    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(o, i, s), u = Math.max(o, i, s), c = u - l;\n    let p, d;\n    u === l ? p = 0 : o === u ? p = (i - s) / c : i === u ? p = 2 + (s - o) / c : s === u && (p = 4 + (o - i) / c), p = Math.min(p * 60, 360), p < 0 && (p += 360);\n    const f = (l + u) / 2;\n    return u === l ? d = 0 : f <= 0.5 ? d = c / (u + l) : d = c / (2 - u - l), [p, d * 100, f * 100];\n  }, t.rgb.hsv = function(a) {\n    let o, i, s, l, u;\n    const c = a[0] / 255, p = a[1] / 255, d = a[2] / 255, f = Math.max(c, p, d), h = f - Math.min(c, p, d), m = function(y) {\n      return (f - y) / 6 / h + 1 / 2;\n    };\n    return h === 0 ? (l = 0, u = 0) : (u = h / f, o = m(c), i = m(p), s = m(d), c === f ? l = s - i : p === f ? l = 1 / 3 + o - s : d === f && (l = 2 / 3 + i - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [\n      l * 360,\n      u * 100,\n      f * 100\n    ];\n  }, t.rgb.hwb = function(a) {\n    const o = a[0], i = a[1];\n    let s = a[2];\n    const l = t.rgb.hsl(a)[0], u = 1 / 255 * Math.min(o, Math.min(i, s));\n    return s = 1 - 1 / 255 * Math.max(o, Math.max(i, s)), [l, u * 100, s * 100];\n  }, t.rgb.cmyk = function(a) {\n    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(1 - o, 1 - i, 1 - s), u = (1 - o - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, p = (1 - s - l) / (1 - l) || 0;\n    return [u * 100, c * 100, p * 100, l * 100];\n  };\n  function n(a, o) {\n    return (a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2 + (a[2] - o[2]) ** 2;\n  }\n  return t.rgb.keyword = function(a) {\n    const o = e[a];\n    if (o)\n      return o;\n    let i = 1 / 0, s;\n    for (const l of Object.keys(r)) {\n      const u = r[l], c = n(a, u);\n      c < i && (i = c, s = l);\n    }\n    return s;\n  }, t.keyword.rgb = function(a) {\n    return r[a];\n  }, t.rgb.xyz = function(a) {\n    let o = a[0] / 255, i = a[1] / 255, s = a[2] / 255;\n    o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92, i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92, s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92;\n    const l = o * 0.4124 + i * 0.3576 + s * 0.1805, u = o * 0.2126 + i * 0.7152 + s * 0.0722, c = o * 0.0193 + i * 0.1192 + s * 0.9505;\n    return [l * 100, u * 100, c * 100];\n  }, t.rgb.lab = function(a) {\n    const o = t.rgb.xyz(a);\n    let i = o[0], s = o[1], l = o[2];\n    i /= 95.047, s /= 100, l /= 108.883, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, l = l > 8856e-6 ? l ** (1 / 3) : 7.787 * l + 16 / 116;\n    const u = 116 * s - 16, c = 500 * (i - s), p = 200 * (s - l);\n    return [u, c, p];\n  }, t.hsl.rgb = function(a) {\n    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;\n    let l, u, c;\n    if (i === 0)\n      return c = s * 255, [c, c, c];\n    s < 0.5 ? l = s * (1 + i) : l = s + i - s * i;\n    const p = 2 * s - l, d = [0, 0, 0];\n    for (let f = 0; f < 3; f++)\n      u = o + 1 / 3 * -(f - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = p + (l - p) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = p + (l - p) * (2 / 3 - u) * 6 : c = p, d[f] = c * 255;\n    return d;\n  }, t.hsl.hsv = function(a) {\n    const o = a[0];\n    let i = a[1] / 100, s = a[2] / 100, l = i;\n    const u = Math.max(s, 0.01);\n    s *= 2, i *= s <= 1 ? s : 2 - s, l *= u <= 1 ? u : 2 - u;\n    const c = (s + i) / 2, p = s === 0 ? 2 * l / (u + l) : 2 * i / (s + i);\n    return [o, p * 100, c * 100];\n  }, t.hsv.rgb = function(a) {\n    const o = a[0] / 60, i = a[1] / 100;\n    let s = a[2] / 100;\n    const l = Math.floor(o) % 6, u = o - Math.floor(o), c = 255 * s * (1 - i), p = 255 * s * (1 - i * u), d = 255 * s * (1 - i * (1 - u));\n    switch (s *= 255, l) {\n      case 0:\n        return [s, d, c];\n      case 1:\n        return [p, s, c];\n      case 2:\n        return [c, s, d];\n      case 3:\n        return [c, p, s];\n      case 4:\n        return [d, c, s];\n      case 5:\n        return [s, c, p];\n    }\n  }, t.hsv.hsl = function(a) {\n    const o = a[0], i = a[1] / 100, s = a[2] / 100, l = Math.max(s, 0.01);\n    let u, c;\n    c = (2 - i) * s;\n    const p = (2 - i) * l;\n    return u = i * l, u /= p <= 1 ? p : 2 - p, u = u || 0, c /= 2, [o, u * 100, c * 100];\n  }, t.hwb.rgb = function(a) {\n    const o = a[0] / 360;\n    let i = a[1] / 100, s = a[2] / 100;\n    const l = i + s;\n    let u;\n    l > 1 && (i /= l, s /= l);\n    const c = Math.floor(6 * o), p = 1 - s;\n    u = 6 * o - c, c & 1 && (u = 1 - u);\n    const d = i + u * (p - i);\n    let f, h, m;\n    switch (c) {\n      default:\n      case 6:\n      case 0:\n        f = p, h = d, m = i;\n        break;\n      case 1:\n        f = d, h = p, m = i;\n        break;\n      case 2:\n        f = i, h = p, m = d;\n        break;\n      case 3:\n        f = i, h = d, m = p;\n        break;\n      case 4:\n        f = d, h = i, m = p;\n        break;\n      case 5:\n        f = p, h = i, m = d;\n        break;\n    }\n    return [f * 255, h * 255, m * 255];\n  }, t.cmyk.rgb = function(a) {\n    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, o * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), p = 1 - Math.min(1, s * (1 - l) + l);\n    return [u * 255, c * 255, p * 255];\n  }, t.xyz.rgb = function(a) {\n    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100;\n    let l, u, c;\n    return l = o * 3.2406 + i * -1.5372 + s * -0.4986, u = o * -0.9689 + i * 1.8758 + s * 0.0415, c = o * 0.0557 + i * -0.204 + s * 1.057, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, u = u > 31308e-7 ? 1.055 * u ** (1 / 2.4) - 0.055 : u * 12.92, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [l * 255, u * 255, c * 255];\n  }, t.xyz.lab = function(a) {\n    let o = a[0], i = a[1], s = a[2];\n    o /= 95.047, i /= 100, s /= 108.883, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;\n    const l = 116 * i - 16, u = 500 * (o - i), c = 200 * (i - s);\n    return [l, u, c];\n  }, t.lab.xyz = function(a) {\n    const o = a[0], i = a[1], s = a[2];\n    let l, u, c;\n    u = (o + 16) / 116, l = i / 500 + u, c = u - s / 200;\n    const p = u ** 3, d = l ** 3, f = c ** 3;\n    return u = p > 8856e-6 ? p : (u - 16 / 116) / 7.787, l = d > 8856e-6 ? d : (l - 16 / 116) / 7.787, c = f > 8856e-6 ? f : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [l, u, c];\n  }, t.lab.lch = function(a) {\n    const o = a[0], i = a[1], s = a[2];\n    let l;\n    l = Math.atan2(s, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);\n    const c = Math.sqrt(i * i + s * s);\n    return [o, c, l];\n  }, t.lch.lab = function(a) {\n    const o = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI, u = i * Math.cos(l), c = i * Math.sin(l);\n    return [o, u, c];\n  }, t.rgb.ansi16 = function(a, o = null) {\n    const [i, s, l] = a;\n    let u = o === null ? t.rgb.hsv(a)[2] : o;\n    if (u = Math.round(u / 50), u === 0)\n      return 30;\n    let c = 30 + (Math.round(l / 255) << 2 | Math.round(s / 255) << 1 | Math.round(i / 255));\n    return u === 2 && (c += 60), c;\n  }, t.hsv.ansi16 = function(a) {\n    return t.rgb.ansi16(t.hsv.rgb(a), a[2]);\n  }, t.rgb.ansi256 = function(a) {\n    const o = a[0], i = a[1], s = a[2];\n    return o === i && i === s ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(s / 255 * 5);\n  }, t.ansi16.rgb = function(a) {\n    let o = a % 10;\n    if (o === 0 || o === 7)\n      return a > 50 && (o += 3.5), o = o / 10.5 * 255, [o, o, o];\n    const i = (~~(a > 50) + 1) * 0.5, s = (o & 1) * i * 255, l = (o >> 1 & 1) * i * 255, u = (o >> 2 & 1) * i * 255;\n    return [s, l, u];\n  }, t.ansi256.rgb = function(a) {\n    if (a >= 232) {\n      const u = (a - 232) * 10 + 8;\n      return [u, u, u];\n    }\n    a -= 16;\n    let o;\n    const i = Math.floor(a / 36) / 5 * 255, s = Math.floor((o = a % 36) / 6) / 5 * 255, l = o % 6 / 5 * 255;\n    return [i, s, l];\n  }, t.rgb.hex = function(a) {\n    const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();\n    return \"000000\".substring(i.length) + i;\n  }, t.hex.rgb = function(a) {\n    const o = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n    if (!o)\n      return [0, 0, 0];\n    let i = o[0];\n    o[0].length === 3 && (i = i.split(\"\").map((p) => p + p).join(\"\"));\n    const s = parseInt(i, 16), l = s >> 16 & 255, u = s >> 8 & 255, c = s & 255;\n    return [l, u, c];\n  }, t.rgb.hcg = function(a) {\n    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.max(Math.max(o, i), s), u = Math.min(Math.min(o, i), s), c = l - u;\n    let p, d;\n    return c < 1 ? p = u / (1 - c) : p = 0, c <= 0 ? d = 0 : l === o ? d = (i - s) / c % 6 : l === i ? d = 2 + (s - o) / c : d = 4 + (o - i) / c, d /= 6, d %= 1, [d * 360, c * 100, p * 100];\n  }, t.hsl.hcg = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = i < 0.5 ? 2 * o * i : 2 * o * (1 - i);\n    let l = 0;\n    return s < 1 && (l = (i - 0.5 * s) / (1 - s)), [a[0], s * 100, l * 100];\n  }, t.hsv.hcg = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = o * i;\n    let l = 0;\n    return s < 1 && (l = (i - s) / (1 - s)), [a[0], s * 100, l * 100];\n  }, t.hcg.rgb = function(a) {\n    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;\n    if (i === 0)\n      return [s * 255, s * 255, s * 255];\n    const l = [0, 0, 0], u = o % 1 * 6, c = u % 1, p = 1 - c;\n    let d = 0;\n    switch (Math.floor(u)) {\n      case 0:\n        l[0] = 1, l[1] = c, l[2] = 0;\n        break;\n      case 1:\n        l[0] = p, l[1] = 1, l[2] = 0;\n        break;\n      case 2:\n        l[0] = 0, l[1] = 1, l[2] = c;\n        break;\n      case 3:\n        l[0] = 0, l[1] = p, l[2] = 1;\n        break;\n      case 4:\n        l[0] = c, l[1] = 0, l[2] = 1;\n        break;\n      default:\n        l[0] = 1, l[1] = 0, l[2] = p;\n    }\n    return d = (1 - i) * s, [\n      (i * l[0] + d) * 255,\n      (i * l[1] + d) * 255,\n      (i * l[2] + d) * 255\n    ];\n  }, t.hcg.hsv = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);\n    let l = 0;\n    return s > 0 && (l = o / s), [a[0], l * 100, s * 100];\n  }, t.hcg.hsl = function(a) {\n    const o = a[1] / 100, s = a[2] / 100 * (1 - o) + 0.5 * o;\n    let l = 0;\n    return s > 0 && s < 0.5 ? l = o / (2 * s) : s >= 0.5 && s < 1 && (l = o / (2 * (1 - s))), [a[0], l * 100, s * 100];\n  }, t.hcg.hwb = function(a) {\n    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);\n    return [a[0], (s - o) * 100, (1 - s) * 100];\n  }, t.hwb.hcg = function(a) {\n    const o = a[1] / 100, s = 1 - a[2] / 100, l = s - o;\n    let u = 0;\n    return l < 1 && (u = (s - l) / (1 - l)), [a[0], l * 100, u * 100];\n  }, t.apple.rgb = function(a) {\n    return [a[0] / 65535 * 255, a[1] / 65535 * 255, a[2] / 65535 * 255];\n  }, t.rgb.apple = function(a) {\n    return [a[0] / 255 * 65535, a[1] / 255 * 65535, a[2] / 255 * 65535];\n  }, t.gray.rgb = function(a) {\n    return [a[0] / 100 * 255, a[0] / 100 * 255, a[0] / 100 * 255];\n  }, t.gray.hsl = function(a) {\n    return [0, 0, a[0]];\n  }, t.gray.hsv = t.gray.hsl, t.gray.hwb = function(a) {\n    return [0, 100, a[0]];\n  }, t.gray.cmyk = function(a) {\n    return [0, 0, 0, a[0]];\n  }, t.gray.lab = function(a) {\n    return [a[0], 0, 0];\n  }, t.gray.hex = function(a) {\n    const o = Math.round(a[0] / 100 * 255) & 255, s = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();\n    return \"000000\".substring(s.length) + s;\n  }, t.rgb.gray = function(a) {\n    return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];\n  }, _r;\n}\nvar Ir, da;\nfunction du() {\n  if (da) return Ir;\n  da = 1;\n  const r = So();\n  function e() {\n    const o = {}, i = Object.keys(r);\n    for (let s = i.length, l = 0; l < s; l++)\n      o[i[l]] = {\n        // http://jsperf.com/1-vs-infinity\n        // micro-opt, but this is simple.\n        distance: -1,\n        parent: null\n      };\n    return o;\n  }\n  function t(o) {\n    const i = e(), s = [o];\n    for (i[o].distance = 0; s.length; ) {\n      const l = s.pop(), u = Object.keys(r[l]);\n      for (let c = u.length, p = 0; p < c; p++) {\n        const d = u[p], f = i[d];\n        f.distance === -1 && (f.distance = i[l].distance + 1, f.parent = l, s.unshift(d));\n      }\n    }\n    return i;\n  }\n  function n(o, i) {\n    return function(s) {\n      return i(o(s));\n    };\n  }\n  function a(o, i) {\n    const s = [i[o].parent, o];\n    let l = r[i[o].parent][o], u = i[o].parent;\n    for (; i[u].parent; )\n      s.unshift(i[u].parent), l = n(r[i[u].parent][u], l), u = i[u].parent;\n    return l.conversion = s, l;\n  }\n  return Ir = function(o) {\n    const i = t(o), s = {}, l = Object.keys(i);\n    for (let u = l.length, c = 0; c < u; c++) {\n      const p = l[c];\n      i[p].parent !== null && (s[p] = a(p, i));\n    }\n    return s;\n  }, Ir;\n}\nvar Mr, ha;\nfunction hu() {\n  if (ha) return Mr;\n  ha = 1;\n  const r = So(), e = du(), t = {}, n = Object.keys(r);\n  function a(i) {\n    const s = function(...l) {\n      const u = l[0];\n      return u == null ? u : (u.length > 1 && (l = u), i(l));\n    };\n    return \"conversion\" in i && (s.conversion = i.conversion), s;\n  }\n  function o(i) {\n    const s = function(...l) {\n      const u = l[0];\n      if (u == null)\n        return u;\n      u.length > 1 && (l = u);\n      const c = i(l);\n      if (typeof c == \"object\")\n        for (let p = c.length, d = 0; d < p; d++)\n          c[d] = Math.round(c[d]);\n      return c;\n    };\n    return \"conversion\" in i && (s.conversion = i.conversion), s;\n  }\n  return n.forEach((i) => {\n    t[i] = {}, Object.defineProperty(t[i], \"channels\", { value: r[i].channels }), Object.defineProperty(t[i], \"labels\", { value: r[i].labels });\n    const s = e(i);\n    Object.keys(s).forEach((u) => {\n      const c = s[u];\n      t[i][u] = o(c), t[i][u].raw = a(c);\n    });\n  }), Mr = t, Mr;\n}\nvar mu = hu();\nconst yu = /* @__PURE__ */ pu(mu);\nfunction ma({ gl: r, type: e, source: t }) {\n  const n = r.createShader(e);\n  if (n === null)\n    throw new Error(\"Cannot create shader\");\n  if (r.shaderSource(n, t), r.compileShader(n), !r.getShaderParameter(n, r.COMPILE_STATUS))\n    throw console.error(\"Shader compilation error:\", r.getShaderInfoLog(n)), r.deleteShader(n), new Error(\"Cannot compile shader\");\n  return n;\n}\nfunction gu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }) {\n  const n = ma({\n    gl: r,\n    type: r.VERTEX_SHADER,\n    source: e\n  }), a = ma({ gl: r, type: r.FRAGMENT_SHADER, source: t }), o = r.createProgram();\n  if (r.attachShader(o, n), r.attachShader(o, a), r.linkProgram(o), !r.getProgramParameter(o, r.LINK_STATUS))\n    throw console.error(\"Error: \", r.getProgramInfoLog(o)), new Error(\"Cannot link shader program\");\n  return o;\n}\nfunction vu(r, e, t) {\n  const n = r.getUniformLocation(e, t);\n  if (n === null)\n    throw new Error(`Cannot get uniform location for ${t}`);\n  return n;\n}\nfunction xo({\n  gl: r,\n  vertexShaderSource: e,\n  fragmentShaderSource: t,\n  attributesKeys: n,\n  uniformsKeys: a,\n  vertices: o,\n  indices: i\n}) {\n  const s = gu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }), l = n.reduce((f, h) => (f[h] = r.getAttribLocation(s, `a_${h}`), f), {}), u = a.reduce((f, h) => (f[h] = vu(r, s, `u_${h}`), f), {}), c = r.createBuffer();\n  r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, new Float32Array(o), r.STATIC_DRAW);\n  let p, d;\n  return i !== void 0 && (p = r.createBuffer(), d = i.length, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, p), r.bufferData(r.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), r.STATIC_DRAW)), {\n    shaderProgram: s,\n    programInfo: {\n      attributesLocations: l,\n      uniformsLocations: u\n    },\n    positionBuffer: c,\n    indexBuffer: p,\n    indexBufferLength: d\n  };\n}\nfunction jt(r) {\n  if (!r)\n    return [1, 1, 1, 0];\n  if (r === \"transparent\")\n    return [1, 1, 1, 0];\n  try {\n    const e = bu(r), t = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i.exec(e);\n    if (t != null && t.length) {\n      const a = !!t[4];\n      return [...yu.hex.rgb(e).map((o) => o / 255), a ? parseInt(t[4], 16) / 255 : 1];\n    }\n    const n = e.match(/(\\d\\.\\d(\\d+)?|\\d{3}|\\d{2}|\\d{1})/gi) ?? [\"0\", \"0\", \"0\"];\n    if (e.includes(\"rgb\")) {\n      const a = e.includes(\"rgba\"), o = [\n        ...n.map((i) => parseFloat(i)).map((i, s) => s < 3 ? i / 255 : i)\n        // because alpha is in the range 0 - 1, not 0 - 255\n      ];\n      return a || o.push(1), o;\n    }\n  } catch {\n  }\n  return console.warn([`[parseColorStringToVec4]: Color ${r} is either not a valid color or its type is not supported, defaulting to black`]), [0, 0, 0, 1];\n}\nlet ct;\nfunction bu(r) {\n  return ct = ct ?? document.createElement(\"canvas\").getContext(\"2d\"), ct ? (ct.fillStyle = r, ct.fillStyle) : \"#000000\";\n}\nconst Ln = 1, le = Ln / 2, ue = Ln / 2, ce = Ln / 2, wu = [-0.5, -0.5, ce, le, -0.5, ce, le, ue, ce, -0.5, ue, ce], Su = [-0.5, -0.5, -0.5, -0.5, ue, -0.5, le, ue, -0.5, le, -0.5, -0.5], xu = [-0.5, ue, -0.5, -0.5, ue, ce, le, ue, ce, le, ue, -0.5], ku = [-0.5, -0.5, -0.5, le, -0.5, -0.5, le, -0.5, ce, -0.5, -0.5, ce], Lu = [le, -0.5, -0.5, le, ue, -0.5, le, ue, ce, le, -0.5, ce], Cu = [-0.5, -0.5, -0.5, -0.5, -0.5, ce, -0.5, ue, ce, -0.5, ue, -0.5], Eu = [...wu, ...Su, ...xu, ...ku, ...Lu, ...Cu], Au = [\n  // Front\n  0,\n  1,\n  2,\n  0,\n  2,\n  3,\n  // Back\n  4,\n  5,\n  6,\n  4,\n  6,\n  7,\n  // Left\n  8,\n  9,\n  10,\n  8,\n  10,\n  11,\n  // Right\n  12,\n  13,\n  14,\n  12,\n  14,\n  15,\n  // Up\n  16,\n  17,\n  18,\n  16,\n  18,\n  19,\n  // Down\n  20,\n  21,\n  22,\n  20,\n  22,\n  23\n], Tu = `attribute vec3 a_vertexPosition;\nvarying vec3 vTextureCoord;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_modelViewMatrix;\n  \nvoid main(void) {\n  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);\n  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);\n}\n`, ya = `precision mediump float;\n\nvarying vec3 vTextureCoord;\n\n%USE_TEXTURE_MACRO_MARKER%\n\n# ifdef USE_TEXTURE\nuniform samplerCube u_cubeSampler;\nuniform float u_fadeOpacity;\n# endif\n\nuniform vec4 u_bgColor;\n\nvoid main(void) {\n  #ifdef USE_TEXTURE\n  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);\n\n    gl_FragColor = mix(\n      u_bgColor,\n      texColor,\n      min(texColor.a, u_fadeOpacity)\n    );\n\n    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);\n\n  #else\n  gl_FragColor = u_bgColor;\n  #endif\n}\n`;\nvar _u = /* @__PURE__ */ ((r) => (r.UNIVERSE_DARK = \"universe-dark\", r))(_u || {});\nconst He = {\n  stars: {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"stars\"\n  },\n  space: {\n    color: \"hsl(210, 100%, 4%)\",\n    preset: \"space\"\n  },\n  milkyway: {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"milkyway\"\n  },\n  \"milkyway-subtle\": {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"milkyway-subtle\"\n  },\n  \"milkyway-bright\": {\n    color: \"hsl(233,100%,92%)\",\n    preset: \"milkyway-bright\"\n  },\n  \"milkyway-colored\": {\n    color: \"black\",\n    preset: \"milkyway-colored\"\n  }\n};\nvar Ue = /* @__PURE__ */ ((r) => (r.POSITIVE_X = \"pX\", r.NEGATIVE_X = \"nX\", r.POSITIVE_Y = \"pY\", r.NEGATIVE_Y = \"nY\", r.POSITIVE_Z = \"pZ\", r.NEGATIVE_Z = \"nZ\", r))(Ue || {});\nlet Ft, ga, va;\nfunction Iu({ gl: r, faces: e, onReady: t, forceRefresh: n }) {\n  Ft && !n && va === JSON.stringify(e) && t(Ft, ga), va = JSON.stringify(e);\n  const a = Ft ?? r.createTexture();\n  if (r.bindTexture(r.TEXTURE_CUBE_MAP, a), !e) {\n    console.warn(\"[CubemapLayer][loadCubemapTexture]: Faces are null\");\n    return;\n  }\n  const o = Object.keys(e).length;\n  if (o !== 6) {\n    console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${o}`);\n    return;\n  }\n  const i = Object.entries(e).map(([s, l]) => new Promise((u, c) => {\n    const p = s;\n    if (l === void 0) {\n      c(new Error(`[CubemapLayer][loadCubemapTexture]: Face ${s} is undefined`));\n      return;\n    }\n    const d = new Image();\n    d.crossOrigin = \"anonymous\";\n    const f = () => {\n      u({ image: d, key: p });\n    };\n    d.src = l, d.complete && d.naturalWidth > 0 ? f() : d.onload = f, d.onerror = () => {\n      c(new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${l}`));\n    };\n  }));\n  Promise.all(i).then((s) => {\n    for (let u = 0; u < s.length; u++) {\n      const p = r.RGBA, d = r.RGBA, f = r.UNSIGNED_BYTE, { image: h, key: m } = s[u] ?? {};\n      if (!h || !m) {\n        console.warn(\"[CubemapLayer][loadCubemapTexture]: Image or key is null\");\n        continue;\n      }\n      const y = Mu(r, m);\n      r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(y, 0, p, d, f, h);\n    }\n    r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.generateMipmap(r.TEXTURE_CUBE_MAP), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);\n    const l = s.map((u) => u.image);\n    t(a, l), ga = l, Ft = a;\n  }).catch((s) => {\n    console.error(\"[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture\", s);\n  });\n}\nfunction Mu(r, e) {\n  if (e === Ue.POSITIVE_X)\n    return r.TEXTURE_CUBE_MAP_POSITIVE_X;\n  if (e === Ue.NEGATIVE_X)\n    return r.TEXTURE_CUBE_MAP_NEGATIVE_X;\n  if (e === Ue.POSITIVE_Y)\n    return r.TEXTURE_CUBE_MAP_POSITIVE_Y;\n  if (e === Ue.NEGATIVE_Y)\n    return r.TEXTURE_CUBE_MAP_NEGATIVE_Y;\n  if (e === Ue.POSITIVE_Z)\n    return r.TEXTURE_CUBE_MAP_POSITIVE_Z;\n  if (e === Ue.NEGATIVE_Z)\n    return r.TEXTURE_CUBE_MAP_NEGATIVE_Z;\n  throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${e}`);\n}\nfunction Pu(r, e, t) {\n  return [\n    Re(r[0], e[0], t),\n    Re(r[1], e[1], t),\n    Re(r[2], e[2], t),\n    Re(r[3], e[3], t)\n  ];\n}\nfunction Re(r, e, t) {\n  return r + (e - r) * t;\n}\nconst Je = \"https://api.maptiler.com/resources/space\", Ru = [\"vertexPosition\"], zu = [\"projectionMatrix\", \"modelViewMatrix\", \"cubeSampler\", \"bgColor\", \"fadeOpacity\"], ba = \"%USE_TEXTURE_MACRO_MARKER%\", Fu = \"#define USE_TEXTURE\", wa = He.stars;\nfunction $u(r, e) {\n  if (!ko(r))\n    return {\n      color: \"transparent\"\n    };\n  if (r === !0)\n    return e;\n  const t = {\n    ...r\n  };\n  if (r.faces || r.path)\n    return delete t.preset, t;\n  const n = r.preset;\n  if (!(n === void 0) && !(n in He))\n    throw new Error(`[CubemapLayer]: Invalid preset \"${n}\". Available presets: ${Object.keys(He).join(\", \")}`);\n  return {\n    ...t,\n    // this _could_ be nullish_\n    color: t.color ?? He[n].color ?? \"hsl(233,100%,92%)\"\n  };\n}\nclass Pr {\n  /**\n   * Creates a new instance of CubemapLayer\n   *\n   * @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.\n   * Can specify faces, preset, path, and color properties to configure the cubemap.\n   *\n   * @remarks You shouldn't have to use this class directly.\n   * Instead, use the `Map.setHalo` method to create and add a halo layer to the map.\n   * The constructor initializes the cubemap with the provided configuration.\n   * It processes the faces definition, sets up background colors, and determines\n   * whether to use a cubemap texture based on the provided options.\n   */\n  constructor(e) {\n    v(this, \"id\", \"Cubemap Layer\");\n    v(this, \"type\", \"custom\");\n    v(this, \"renderingMode\", \"3d\");\n    /**\n     * The map instance to which this layer is added.\n     * @type {MapSDK}\n     * @private\n     */\n    v(this, \"map\");\n    /**\n     * The cubemap faces definition, which can be either a preset, path, or explicit face URLs.\n     * @type {CubemapFaces | null}\n     * @remarks\n     * This property is set during the initialization of the layer and can be updated later.\n     * If no faces are defined, it will be `null`.\n     */\n    v(this, \"faces\");\n    /**\n     * Indicates whether to use a cubemap texture for rendering.\n     * @type {boolean}\n     * @private\n     * @default true\n     */\n    v(this, \"useCubemapTexture\", !0);\n    /**\n     * The current opacity of the fade effect applied to the cubemap image texture, used for fading in and out.\n     * @type {number}\n     * @private\n     * @default 0.0\n     */\n    v(this, \"currentFadeOpacity\", 0);\n    /**\n     * Indicates whether the cubemap needs to be updated, typically when the faces or texture changes.\n     * @type {boolean}\n     * @private\n     * @default false\n     */\n    v(this, \"cubeMapNeedsUpdate\", !1);\n    /**\n     * The background color of the cubemap layer, represented as a Vec4 (RGBA).\n     * @type {Vec4}\n     * @private\n     */\n    v(this, \"bgColor\");\n    /**\n     * The previous background color used for transition animations.\n     * @type {Vec4}\n     * @private\n     */\n    v(this, \"previousBgColor\", [0, 0, 0, 0]);\n    /**\n     * The target background color to which the layer will transition.\n     * @type {Vec4}\n     * @private\n     */\n    v(this, \"targetBgColor\", [0, 0, 0, 0]);\n    /**\n     * The delta value used for transitioning the background color. 0 = start of transition, 1 = end of transition.\n     * This value is incremented over time to create a smooth transition effect.\n     * @type {number}\n     * @private\n     */\n    v(this, \"transitionDelta\", 0);\n    /**\n     * The WebGL context used for rendering the cubemap layer.\n     * @type {WebGLContext}\n     * @private\n     */\n    v(this, \"gl\");\n    /**\n     * The cubemap object that contains the shader program, buffers and uniform locations for rendering.\n     * @type {Object3D}\n     * @private\n     */\n    v(this, \"cubemap\");\n    /**\n     * The WebGL texture used for the cubemap, which is created from the defined faces.\n     * This texture is used to render the cubemap in the scene.\n     * @type {WebGLTexture | undefined}\n     * @private\n     */\n    v(this, \"texture\");\n    /**\n     * The key representing the current faces definition, used to diff / track changes in the cubemap faces.\n     * @type {string}\n     */\n    v(this, \"currentFacesDefinitionKey\", \"\");\n    /**\n     * The configuration options for the cubemap layer.\n     * @type {CubemapLayerConstructorOptions}\n     * @private\n     */\n    v(this, \"options\");\n    v(this, \"animationActive\", !0);\n    /**\n     * Animates the cubemap image fading in.\n     * This method gradually increases the opacity of the cubemap image to create a fade-in effect.\n     *\n     * @private\n     */\n    v(this, \"imageIsAnimating\", !1);\n    /**\n     * The delta value used for the image fade-in animation.\n     * This value is incremented over time to create a smooth fade-in effect.\n     * @type {number}\n     * @private\n     */\n    v(this, \"imageFadeInDelta\", 0);\n    const t = $u(e, wa);\n    this.options = t, this.currentFacesDefinitionKey = JSON.stringify(t.faces ?? t.preset ?? t.path), this.bgColor = [0, 0, 0, 0], this.targetBgColor = jt(t.color), this.faces = Sa(t), this.useCubemapTexture = this.faces !== null;\n  }\n  /**\n   * Updates the cubemap object with the current faces and shader configuration.\n   * This method is called when the cubemap faces change or when the layer is initialized.\n   * @returns {void}\n   * @remarks\n   * It creates a new Object3D instance with the specified vertex and fragment shaders,\n   * attributes, and uniforms. The cubemap will be rendered using this configuration.\n   */\n  updateCubemap({ facesNeedUpdate: e } = { facesNeedUpdate: !0 }) {\n    this.useCubemapTexture = this.faces !== null;\n    const t = zu.filter((n) => n === \"cubeSampler\" || n === \"fadeOpacity\" ? this.useCubemapTexture : !0);\n    this.cubemap = xo({\n      gl: this.gl,\n      vertexShaderSource: Tu,\n      // Because we only want to use the read the texture in gl if we're supposed to\n      fragmentShaderSource: this.useCubemapTexture ? ya.replace(ba, Fu) : ya.replace(ba, \"\"),\n      attributesKeys: Ru,\n      uniformsKeys: t,\n      vertices: Eu,\n      indices: Au\n    }), this.cubeMapNeedsUpdate = e, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();\n  }\n  /**\n   * Called when the layer is added to the map.\n   * Initializes the cubemap and sets up the WebGL context.\n   *\n   * @param {MapSDK} map - The map instance to which this layer is added.\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.\n   */\n  onAdd(e, t) {\n    this.map = e, this.gl = t, this.updateCubemap();\n  }\n  /**\n   * Called when the layer is removed from the map.\n   * Cleans up the cubemap resources and WebGL buffers.\n   *\n   * @param {MapSDK} _map - The map instance from which this layer is removed.\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.\n   */\n  onRemove(e, t) {\n    this.cubemap && (t.deleteProgram(this.cubemap.shaderProgram), t.deleteBuffer(this.cubemap.positionBuffer));\n  }\n  /**\n   * Updates the cubemap texture with the provided faces.\n   * This method is called when the cubemap faces change or when the layer is initialized.\n   *\n   * @param {WebGLContext} gl - The WebGL context used for rendering.\n   * @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.\n   */\n  updateTexture(e, t) {\n    if (this.cubeMapNeedsUpdate === !0 && !this.imageIsAnimating) {\n      if (this.cubeMapNeedsUpdate = !1, !this.useCubemapTexture)\n        return;\n      Iu({\n        gl: e,\n        faces: t,\n        onReady: (n) => {\n          this.texture = n, this.animateIn();\n        }\n      });\n    }\n  }\n  /**\n   * Called before the layer is rendered.\n   * Updates the cubemap texture with the current faces.\n   *\n   * @param {WebGLContext} gl - The WebGL context used for rendering.\n   * @param {CustomRenderMethodInput} _options - Additional options for the render method.\n   */\n  prerender(e, t) {\n    this.faces && this.updateTexture(this.gl, this.faces);\n  }\n  /**\n   * Lerps the background color transition of the cubemap layer.\n   * This method smoothly transitions the background color from the previous color to the target color.\n   *\n   * @private\n   */\n  animateColorChange() {\n    const e = () => {\n      this.transitionDelta < 1 && (requestAnimationFrame(e), this.bgColor = Pu(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += 0.075, this.map.triggerRepaint());\n    };\n    requestAnimationFrame(e);\n  }\n  /**\n   * Animates the cubemap image fading in.\n   * This method gradually increases the opacity of the cubemap image to create a fade-in effect.\n   * @private\n   */\n  async animateIn() {\n    if (!this.imageIsAnimating) {\n      if (!this.animationActive) {\n        this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();\n        return;\n      }\n      return new Promise((e) => {\n        this.imageIsAnimating = !0;\n        const t = () => {\n          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Re(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {\n            requestAnimationFrame(t);\n            return;\n          }\n          this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();\n        };\n        requestAnimationFrame(t);\n      });\n    }\n  }\n  /**\n   * Animates the cubemap image fading out.\n   * This method gradually decreases the opacity of the cubemap image to create a fade-out effect.\n   * @returns {Promise<void>} A promise that resolves when the animation is complete.\n   * @private\n   */\n  async animateOut() {\n    if (!(this.imageIsAnimating || !this.animationActive))\n      return new Promise((e) => {\n        const t = () => {\n          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = Re(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {\n            this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();\n            return;\n          }\n          requestAnimationFrame(t);\n        };\n        requestAnimationFrame(t);\n      });\n  }\n  setAnimationActive(e) {\n    this.animationActive = e;\n  }\n  /**\n   * Renders the cubemap layer to the WebGL context.\n   * This method is called internally during the rendering phase of the map.\n   *\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.\n   * @param {CustomRenderMethodInput} _options - Additional options for the render method.\n   * @throws Error if the map, cubemap, or texture is undefined.\n   */\n  render(e, t) {\n    if (!this.map.isGlobeProjection())\n      return;\n    if (this.map === void 0)\n      throw new Error(\"[CubemapLayer]: Map is undefined\");\n    if (this.cubemap === void 0)\n      throw new Error(\"[CubemapLayer]: Cubemap is undefined\");\n    this.texture, e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA), e.useProgram(this.cubemap.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer), e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);\n    const n = 0.1, a = 1e4, o = e.canvas, i = o.clientWidth / o.clientHeight, s = this.map.transform, l = s.fov * (Math.PI / 180), u = mt();\n    uu(u, l, i, n, a), ua(u, u, s.rollInRadians), la(u, u, -s.pitchInRadians), ua(u, u, s.bearingInRadians);\n    const c = s.center.lat * Math.PI / 180, p = s.center.lng * Math.PI / 180;\n    la(u, u, c), su(u, u, -p), e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, u);\n    const d = mt();\n    if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, d), e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture), e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0)\n      throw new Error(\"Index buffer is undefined\");\n    if (this.cubemap.indexBufferLength === void 0)\n      throw new Error(\"Index buffer length is undefined\");\n    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0);\n  }\n  setBgColor(e) {\n    this.targetBgColor = e, this.previousBgColor = this.bgColor, this.transitionDelta = 0;\n  }\n  /**\n   * Returns the current configuration options for the cubemap layer.\n   * @returns {CubemapLayerConstructorOptions} The current configuration options.\n   */\n  getConfig() {\n    return this.options;\n  }\n  async setCubemapFaces(e) {\n    if (await this.animateOut(), !e.faces && !e.preset && !e.path) {\n      this.faces = null, this.useCubemapTexture = !1, this.currentFacesDefinitionKey = \"empty\", await this.animateIn();\n      return;\n    }\n    this.faces = Sa(e), this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path);\n  }\n  /**\n   * Sets the cubemap for the layer based on the provided definition.\n   * This method updates the cubemap faces, background color, and triggers a repaint of the map.\n   *\n   * @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.\n   * @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.\n   * @remarks\n   * This method checks if the provided cubemap definition has a color, and if so, it updates the background color.\n   * It also checks if the faces definition has changed compared to the current one,\n   * and if so, it updates the cubemap faces.\n   * Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.\n   */\n  async setCubemap(e) {\n    const t = typeof e == \"boolean\" ? wa : e;\n    this.options = t;\n    const n = JSON.stringify(t.faces ?? t.preset ?? t.path), a = this.currentFacesDefinitionKey !== n;\n    a && (await this.setCubemapFaces(t), this.cubeMapNeedsUpdate = !0);\n    const o = jt(t.color);\n    if (t.color && this.targetBgColor.toString() !== o.toString())\n      this.setBgColor(o);\n    else if (!t.color && t.preset && t.preset in He) {\n      const i = He[t.preset];\n      this.setBgColor(jt(i.color));\n    }\n    this.updateCubemap({ facesNeedUpdate: a });\n  }\n  /**\n   * Shows the cubemap layer by setting its visibility to \"visible\".\n   * This method is used to make the cubemap layer visible on the map.\n   */\n  show() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"visible\");\n  }\n  /**\n   * Hides the cubemap layer by setting its visibility to \"none\".\n   * This method is used to remove the cubemap layer from the map without deleting it.\n   */\n  hide() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"none\");\n  }\n}\nfunction ko(r) {\n  return r ? typeof r == \"boolean\" ? !0 : !(!r.path && !r.preset && !r.faces && !r.color || r.preset && !(r.preset in He) || r.faces && (!r.faces.pX || !r.faces.nX || !r.faces.pY || !r.faces.nY || !r.faces.pZ || !r.faces.nZ)) : !1;\n}\nfunction Sa(r) {\n  if (r.faces)\n    return r.faces;\n  if (r.preset)\n    return {\n      pX: `${Je}/${r.preset}/px.webp`,\n      nX: `${Je}/${r.preset}/nx.webp`,\n      pY: `${Je}/${r.preset}/py.webp`,\n      nY: `${Je}/${r.preset}/ny.webp`,\n      pZ: `${Je}/${r.preset}/pz.webp`,\n      nZ: `${Je}/${r.preset}/nz.webp`\n    };\n  if (r.path) {\n    const e = r.path.baseUrl, t = r.path.format ?? \"png\";\n    return {\n      pX: `${e}/px.${t}`,\n      nX: `${e}/nx.${t}`,\n      pY: `${e}/py.${t}`,\n      nY: `${e}/ny.${t}`,\n      pZ: `${e}/pz.${t}`,\n      nZ: `${e}/nz.${t}`\n    };\n  }\n  return null;\n}\nconst Ou = `attribute vec3 a_position;\n\nuniform mat4 u_matrix;\nuniform mat4 u_rotationMatrix;\n\nuniform float u_scale;\n\nvarying vec2 v_pos;\nvarying float v_scale;\n\nvoid main() {\n  v_scale = u_scale;\n  v_pos = a_position.xy * u_scale;\n  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);\n}\n`, Nu = `precision mediump float;\nvarying vec2 v_pos;\n      \nuniform int u_stopsNumber;\nuniform float u_stops[100];\nuniform vec4 u_colors[100];\nuniform float u_maxDistance;\n\nvarying float v_scale;\n\nconst float EPSILON = 0.000001;\n\nvec2 center = vec2(0.0, 0.0);\nvoid main() {\n  float rawDistance = distance(center, v_pos);\n  float distanceFromGlobeEdge = rawDistance - 1.0;\n\n    vec4 color = u_colors[0];\n\n  // if we're further than the max distance, we should not render anything.\n  // This is to always render a circle, otherwise we end up rendering\n  // to the corners of the plane.\n  if (distance(center, v_pos) > u_maxDistance * v_scale) {\n    discard;\n  }\n\n  for (int i = 1; i < 100; i++) {\n    // if we're past the last stop\n    // we should fill to the end with the last stop color\n    if (i >= u_stopsNumber) {\n      color = u_colors[i - 1];\n      break;\n    }\n\n    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);\n    float lastStopValue = u_stops[i - 1];\n    float thisStopValue = u_stops[i];\n\n    // this is to avoid blending errors when the stops are the same\n    // eg when you would want a sharp edge between two stops.\n    // \\`numbersAreEqual\\` will be 1.0 if the numbers are equal, 0.0 if they are not.\n    // We then subtract EPSILON from the last stop making the stop value _almost_ equal\n    // to the next stop but not enough to cause blending issues.\n    // It's more efficient to do this than an if / else statement.\n    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));\n    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;\n\n    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);\n\n    if (distanceFromGlobeEdge <= scaledStopPosition) {\n      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);\n      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);\n      break;\n    }\n  }\n  \n  // gl_FragColor = color;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n`, pt = 2, ju = [\"position\"], Uu = [\"matrix\", \"rotationMatrix\", \"stopsNumber\", \"stops\", \"colors\", \"maxDistance\", \"scale\"], Du = [\n  -2,\n  -2,\n  0,\n  pt,\n  -2,\n  0,\n  -2,\n  pt,\n  0,\n  pt,\n  pt,\n  0\n], je = {\n  scale: 0.9,\n  stops: [\n    [0, \"rgba(176, 208, 240, 1)\"],\n    [0.1, \"rgba(98, 168, 229, 0.3)\"],\n    [0.2, \"rgba(98, 168, 229, 0.0)\"]\n  ]\n}, xa = 0.06;\nclass Rr {\n  /**\n   * Creates a new RadialGradientLayer instance.\n   *\n   * @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.\n   * If a boolean is provided, default configuration options will be used.\n   * If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.\n   */\n  constructor(e) {\n    v(this, \"id\", \"Halo Layer\");\n    v(this, \"type\", \"custom\");\n    v(this, \"renderingMode\", \"3d\");\n    /**\n     * The gradient definition used by this layer.\n     * It contains the stops and scale for the radial gradient.\n     * @private\n     * @type {GradientDefinition}\n     */\n    v(this, \"gradient\");\n    /**\n     * The scale of the radial gradient, which determines its size.\n     * This value is animated from 0 to the target scale during the layer's appearance.\n     * @private\n     * @type {number}\n     */\n    v(this, \"scale\", 0);\n    /**\n     * The animation delta value used to control the progress of the gradient's appearance animation.\n     * It is incremented during each frame of the animation until it reaches 1.\n     * @private\n     * @type {number}\n     */\n    v(this, \"animationDelta\", 0);\n    /**\n     * The MapSDK instance to which this layer is added.\n     * This is set when the layer is added to the map.\n     * @private\n     * @type {MapSDK}\n     */\n    v(this, \"map\");\n    /**\n     * The 3D object representing the radial gradient plane.\n     * This object is created when the layer is added to the map and contains the shader program and buffers.\n     * It is used for rendering the radial gradient effect.\n     * @private\n     * @type {Object3D<(typeof ATTRIBUTES_KEYS)[number], (typeof UNIFORMS_KEYS)[number]>}\n     */\n    v(this, \"plane\");\n    /**\n     * Whether the halo should be animated in and out.\n     * @private\n     * @type {boolean}\n     */\n    v(this, \"animationActive\", !0);\n    if (typeof e == \"boolean\") {\n      this.gradient = je;\n      return;\n    }\n    this.gradient = {\n      ...je,\n      ...e\n    };\n  }\n  /**\n   * Adds the radial gradient layer to the specified map.\n   * This method is called by the map when the layer is added to it.\n   *\n   * @param {MapSDK} map - The MapSDK instance to which this layer is being added\n   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer\n   * @returns void\n   */\n  onAdd(e, t) {\n    this.map = e, this.plane = xo({\n      gl: t,\n      vertexShaderSource: Ou,\n      fragmentShaderSource: Nu,\n      attributesKeys: ju,\n      uniformsKeys: Uu,\n      vertices: Du\n    }), this.animateIn();\n  }\n  /**\n   * Returns the current gradient configuration of the radial gradient layer.\n   *\n   * @returns {GradientDefinition} The current gradient configuration.\n   */\n  getConfig() {\n    return this.gradient;\n  }\n  /**\n   * Animates the radial gradient into view by gradually scaling from 0 to the target scale.\n   *\n   * This method uses requestAnimationFrame to create a smooth scaling animation effect.\n   * During each frame, it:\n   *   1. Interpolates the scale value between 0 and the target scale\n   *   2. Increments the animation progress (animationDelta)\n   *   3. Triggers a map repaint\n   *\n   * @private\n   * @returns {Promise<void>} A promise that resolves when the animation completes\n   */\n  async animateIn() {\n    if (!this.animationActive) {\n      this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();\n      return;\n    }\n    return new Promise((e) => {\n      this.animationDelta = 0;\n      const t = () => {\n        if (this.animationDelta < 1) {\n          this.scale = Re(0, this.gradient.scale, this.animationDelta), this.animationDelta += xa, this.map.triggerRepaint(), requestAnimationFrame(t);\n          return;\n        }\n        e();\n      };\n      requestAnimationFrame(t);\n    });\n  }\n  /**\n   * Animates the radial gradient layer out by gradually reducing its scale to zero.\n   *\n   * This method creates a smooth transition effect by linearly interpolating the scale\n   * from its current value to zero over multiple animation frames. During each frame,\n   * the animation progresses by incrementing the internal animation delta value.\n   *\n   * The map is repainted after each animation step to reflect the updated scale.\n   *\n   * @private\n   * @returns A Promise that resolves when the animation is complete.\n   */\n  async animateOut() {\n    if (this.animationActive)\n      return this.animationDelta = 0, new Promise((e) => {\n        const t = () => {\n          if (this.animationDelta < 1) {\n            this.scale = Re(this.gradient.scale, 0, this.animationDelta), this.animationDelta += xa, this.map.triggerRepaint(), requestAnimationFrame(t);\n            return;\n          }\n          e();\n        };\n        t();\n      });\n  }\n  onRemove(e, t) {\n    this.plane !== void 0 && (t.deleteProgram(this.plane.shaderProgram), t.deleteBuffer(this.plane.positionBuffer));\n  }\n  prerender(e, t) {\n  }\n  render(e, t) {\n    if (this.map === void 0)\n      throw new Error(\"[RadialGradientLayer]: Map is undefined\");\n    if (!this.map.isGlobeProjection())\n      return;\n    if (this.plane === void 0)\n      throw new Error(\"[RadialGradientLayer]: Plane is undefined\");\n    e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.useProgram(this.plane.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);\n    const n = this.plane.programInfo.attributesLocations.position;\n    e.enableVertexAttribArray(n), e.vertexAttribPointer(n, 3, e.FLOAT, !1, 0, 0);\n    const a = mt(), o = this.scale;\n    iu(a, a, [o, o, o]);\n    const i = mt();\n    ou(i, t.defaultProjectionData.mainMatrix, a);\n    const s = this.plane.programInfo.uniformsLocations.matrix;\n    e.uniformMatrix4fv(s, !1, i);\n    const l = mt(), u = this.map.transform.cameraPosition, c = Ar(Nt(), u), p = cu(0, 1, 0), d = Nt();\n    ca(d, p, c), Ar(d, d);\n    const f = Nt();\n    ca(f, c, d), Ar(f, f), au(l, d[0], d[1], d[2], 0, f[0], f[1], f[2], 0, c[0], c[1], c[2], 0, 0, 0, 0, 1);\n    const h = this.plane.programInfo.uniformsLocations.rotationMatrix;\n    e.uniformMatrix4fv(h, !1, l);\n    const m = this.gradient.stops.length, y = [], w = [];\n    for (let g = 0; g <= m; g++)\n      if (g < m) {\n        y[g] = this.gradient.stops[g][0];\n        const x = jt(this.gradient.stops[g][1]);\n        w.push(...x);\n      }\n    e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, m), e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(y)), e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(w)), e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, pt), e.uniform1f(this.plane.programInfo.uniformsLocations.scale, o), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);\n  }\n  /**\n   * Sets a new gradient for the radial gradient layer and animates the transition.\n   *\n   * This method first animates the current gradient out, then updates the gradient\n   * property with the new gradient definition, and finally animates the new gradient in.\n   *\n   * @param {GradientDefinition} gradient - The new gradient definition to set for this layer.\n   * @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.\n   */\n  async setGradient(e) {\n    if (e === !1) {\n      await this.animateOut();\n      return;\n    }\n    if (await this.animateOut(), !Bu(e)) {\n      this.gradient.scale = je.scale, this.gradient.stops = [\n        [0, \"transparent\"],\n        [1, \"transparent\"]\n      ];\n      return;\n    }\n    e === !0 ? (this.gradient.scale = je.scale, this.gradient.stops = je.stops) : (this.gradient.scale = e.scale ?? je.scale, this.gradient.stops = e.stops ?? je.stops), await this.animateIn();\n  }\n  setAnimationActive(e) {\n    this.animationActive = e;\n  }\n  show() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"visible\");\n  }\n  hide() {\n    this.map.setLayoutProperty(this.id, \"visibility\", \"none\");\n  }\n}\nfunction Bu(r) {\n  return typeof r == \"boolean\" ? !0 : !(typeof r.scale != \"number\" || !r.stops || r.stops.length === 0 || r.stops.some((e) => typeof e[0] != \"number\" || typeof e[1] != \"string\"));\n}\nconst qu = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nlet Lo = class Co extends maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map {\n  constructor(t) {\n    Li(t.container), t.apiKey && (j.apiKey = t.apiKey);\n    const { style: n, requiresUrlMonitoring: a, isFallback: o } = oa(t.style);\n    o && console.warn(\n      \"Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.\"\n    ), j.apiKey || console.warn(\"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\");\n    const i = location.hash;\n    let s = {\n      compact: !1\n    };\n    t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == \"object\" && (s = {\n      ...s,\n      ...t.attributionControl\n    });\n    const l = {\n      ...t,\n      style: n,\n      maplibreLogo: !1,\n      transformRequest: $n(t.transformRequest),\n      attributionControl: t.forceNoAttributionControl === !0 ? !1 : s\n    };\n    delete l.style;\n    super(l);\n    v(this, \"telemetry\");\n    v(this, \"space\");\n    v(this, \"halo\");\n    v(this, \"options\");\n    v(this, \"isTerrainEnabled\", !1);\n    v(this, \"terrainExaggeration\", 1);\n    v(this, \"primaryLanguage\");\n    v(this, \"terrainGrowing\", !1);\n    v(this, \"terrainFlattening\", !1);\n    v(this, \"minimap\");\n    v(this, \"forceLanguageUpdate\");\n    v(this, \"languageAlwaysBeenStyle\");\n    v(this, \"isReady\", !1);\n    v(this, \"terrainAnimationDuration\", 1e3);\n    v(this, \"monitoredStyleUrls\");\n    v(this, \"styleInProcess\", !1);\n    v(this, \"curentProjection\");\n    v(this, \"originalLabelStyle\", new window.Map());\n    v(this, \"isStyleLocalized\", !1);\n    v(this, \"languageIsUpdated\", !1);\n    v(this, \"spaceboxLoadingState\", {\n      styleLoadCallbackSet: !1\n    });\n    this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);\n    const u = () => {\n      let h = \"The distant style could not be loaded.\";\n      this.getStyle() ? h += \"Leaving the style as is.\" : (this.setStyle(_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyle.STREETS), h += `Loading default MapTiler Cloud style \"${_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.MapStyle.STREETS.getDefaultVariant().getId()}\" as a fallback.`), console.warn(h);\n    };\n    if (this.on(\"style.load\", () => {\n      this.styleInProcess = !1;\n    }), this.on(\"error\", (h) => {\n      if (h.error instanceof maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AJAXError) {\n        const y = h.error.url, w = new URL(y);\n        w.search = \"\";\n        const g = w.href;\n        this.monitoredStyleUrls && this.monitoredStyleUrls.has(g) && (this.monitoredStyleUrls.delete(g), u());\n        return;\n      }\n      if (this.styleInProcess) {\n        u();\n        return;\n      }\n    }), j.caching && !$r && console.warn(\"The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache\"), j.caching && $r && bi(), typeof t.language > \"u\")\n      this.primaryLanguage = j.primaryLanguage;\n    else {\n      const h = (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.toLanguageInfo)(t.language, z);\n      this.primaryLanguage = h ?? j.primaryLanguage;\n    }\n    this.forceLanguageUpdate = !(this.primaryLanguage === z.STYLE || this.primaryLanguage === z.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === z.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on(\"styledata\", () => {\n      this.curentProjection === \"mercator\" ? this.setProjection({ type: \"mercator\" }) : this.curentProjection === \"globe\" && this.setProjection({ type: \"globe\" });\n    }), this.once(\"styledata\", async () => {\n      if (!t.geolocate || t.center || t.hash && i)\n        return;\n      try {\n        if (t.geolocate === qu.COUNTRY) {\n          await this.fitToIpBounds();\n          return;\n        }\n      } catch (y) {\n        console.warn(y.message);\n      }\n      let h;\n      try {\n        await this.centerOnIpPoint(t.zoom), h = this.getCameraHash();\n      } catch (y) {\n        console.warn(y.message);\n      }\n      (await navigator.permissions.query({\n        name: \"geolocation\"\n      })).state === \"granted\" && navigator.geolocation.getCurrentPosition(\n        // success callback\n        (y) => {\n          h === this.getCameraHash() && (this.terrain ? this.easeTo({\n            center: [y.coords.longitude, y.coords.latitude],\n            zoom: t.zoom || 12,\n            duration: 2e3\n          }) : this.once(\"terrain\", () => {\n            this.easeTo({\n              center: [y.coords.longitude, y.coords.latitude],\n              zoom: t.zoom || 12,\n              duration: 2e3\n            });\n          }));\n        },\n        // error callback\n        null,\n        // options\n        {\n          maximumAge: 24 * 3600 * 1e3,\n          // a day in millisec\n          timeout: 5e3,\n          // milliseconds\n          enableHighAccuracy: !1\n        }\n      );\n    }), this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    }), this.on(\"styledata\", () => {\n      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);\n    }), this.once(\"load\", async () => {\n      let h = { logo: null };\n      try {\n        const m = Object.keys(this.style.sourceCaches).map((g) => this.getSource(g)).filter((g) => g && \"url\" in g && typeof g.url == \"string\" && g.url.includes(\"tiles.json\")), y = new URL(m[0].url);\n        y.searchParams.has(\"key\") || y.searchParams.append(\"key\", j.apiKey), h = await (await fetch(y.href)).json();\n      } catch {\n      }\n      if (t.customControls) {\n        const m = \"[data-maptiler-control-group]\", y = \"[data-maptiler-control]\", w = (T) => {\n          let N = T.dataset.maptilerControl;\n          return (N === \"true\" || N === \"\") && (N = void 0), N;\n        }, g = (T) => T.dataset.maptilerPosition;\n        let x = [...this._container.ownerDocument.querySelectorAll(m)], E = [...this._container.ownerDocument.querySelectorAll(y)].filter(\n          (T) => T.closest(m) === null\n        );\n        if (typeof t.customControls == \"string\") {\n          const T = t.customControls;\n          x = x.filter((N) => N.matches(T) || N.closest(T) !== null), E = E.filter((N) => N.matches(T) || N.closest(T) !== null);\n        }\n        for (const T of x) {\n          const N = new Gr(T);\n          this.addControl(N, g(T));\n          for (const ve of T.querySelectorAll(y))\n            N.configureGroupItem(ve, w(ve));\n        }\n        for (const T of E)\n          this.addControl(new Gr(T, w(T)), g(T));\n        const C = () => {\n          const { lng: T, lat: N } = this.getCenter();\n          this._container.style.setProperty(\"--maptiler-center-lng\", String(T)), this._container.style.setProperty(\"--maptiler-center-lat\", String(N)), this._container.style.setProperty(\"--maptiler-zoom\", String(this.getZoom())), this._container.style.setProperty(\"--maptiler-bearing\", String(this.getBearing())), this._container.style.setProperty(\"--maptiler-pitch\", String(this.getPitch())), this._container.style.setProperty(\"--maptiler-roll\", String(this.getRoll())), this._container.style.setProperty(\"--maptiler-is-globe-projection\", String(this.isGlobeProjection())), this._container.style.setProperty(\"--maptiler-has-terrain\", String(this.hasTerrain()));\n        };\n        C(), this.on(\"render\", C);\n      }\n      if (t.forceNoAttributionControl !== !0)\n        if (\"logo\" in h && h.logo) {\n          const m = h.logo;\n          this.addControl(new Nn({ logoURL: m }), t.logoPosition);\n        } else t.maptilerLogo && this.addControl(new Nn(), t.logoPosition);\n      if (t.scaleControl) {\n        const m = t.scaleControl === !0 || t.scaleControl === void 0 ? \"bottom-right\" : t.scaleControl, y = new zi({ unit: j.unit });\n        this.addControl(y, m), j.on(\"unit\", (w) => {\n          y.setUnit(w);\n        });\n      }\n      if (t.navigationControl !== !1) {\n        const m = t.navigationControl === !0 || t.navigationControl === void 0 ? \"top-right\" : t.navigationControl;\n        this.addControl(new Jl(), m);\n      }\n      if (t.geolocateControl !== !1) {\n        const m = t.geolocateControl === !0 || t.geolocateControl === void 0 ? \"top-right\" : t.geolocateControl;\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new eu({\n            positionOptions: {\n              enableHighAccuracy: !0,\n              maximumAge: 0,\n              timeout: 6e3\n            },\n            fitBoundsOptions: {\n              maxZoom: 15\n            },\n            trackUserLocation: !0,\n            showAccuracyCircle: !0,\n            showUserLocation: !0\n          }),\n          m\n        );\n      }\n      if (t.terrainControl) {\n        const m = t.terrainControl === !0 || t.terrainControl === void 0 ? \"top-right\" : t.terrainControl;\n        this.addControl(new Wl(), m);\n      }\n      if (t.projectionControl) {\n        const m = t.projectionControl === !0 || t.projectionControl === void 0 ? \"top-right\" : t.projectionControl;\n        this.addControl(new ru(), m);\n      }\n      if (t.fullscreenControl) {\n        const m = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? \"top-right\" : t.fullscreenControl;\n        this.addControl(new Fi({}), m);\n      }\n      this.isReady = !0, this.fire(\"ready\", { target: this });\n    });\n    let c = !1, p = !1, d;\n    this.once(\"ready\", () => {\n      c = !0, p && this.fire(\"loadWithTerrain\", d);\n    }), this.once(\"style.load\", () => {\n      const { minimap: h } = t;\n      if (typeof h == \"object\") {\n        const {\n          zoom: m,\n          center: y,\n          style: w,\n          language: g,\n          apiKey: x,\n          maptilerLogo: E,\n          canvasContextAttributes: C,\n          refreshExpiredTiles: T,\n          maxBounds: N,\n          scrollZoom: ve,\n          minZoom: Ye,\n          maxZoom: We,\n          boxZoom: H,\n          locale: Oe,\n          fadeDuration: Yo,\n          crossSourceCollisions: Wo,\n          clickTolerance: Jo,\n          bounds: Qo,\n          fitBoundsOptions: ei,\n          pixelRatio: ti,\n          validateStyle: ri\n        } = t;\n        this.minimap = new Er(h, {\n          zoom: m,\n          center: y,\n          style: w,\n          language: g,\n          apiKey: x,\n          container: \"null\",\n          maptilerLogo: E,\n          canvasContextAttributes: C,\n          refreshExpiredTiles: T,\n          maxBounds: N,\n          scrollZoom: ve,\n          minZoom: Ye,\n          maxZoom: We,\n          boxZoom: H,\n          locale: Oe,\n          fadeDuration: Yo,\n          crossSourceCollisions: Wo,\n          clickTolerance: Jo,\n          bounds: Qo,\n          fitBoundsOptions: ei,\n          pixelRatio: ti,\n          validateStyle: ri\n        }), this.addControl(this.minimap, h.position ?? \"bottom-left\");\n      } else h === !0 ? (this.minimap = new Er({}, t), this.addControl(this.minimap, \"bottom-left\")) : h !== void 0 && h !== !1 && (this.minimap = new Er({}, t), this.addControl(this.minimap, h));\n    });\n    const f = (h) => {\n      h.terrain && (p = !0, d = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: h.terrain\n      }, this.off(\"terrain\", f), c && this.fire(\"loadWithTerrain\", d));\n    };\n    this.on(\"terrain\", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once(\"load\", () => {\n      this.getCanvas().addEventListener(\"webglcontextlost\", (m) => {\n        if (this._removed === !0) {\n          console.warn(\"[webglcontextlost]\", \"WebGL context lost after map removal. This is harmless.\");\n          return;\n        }\n        console.warn(\"[webglcontextlost]\", \"Unexpected loss of WebGL context!\"), this.fire(\"webglContextLost\", m);\n      });\n      const h = this.getLayersOrder()[0];\n      t.space && this.initSpace({ options: t, before: h }), t.halo && this.initHalo({ options: t, before: h });\n    }), this.telemetry = new nu(this);\n  }\n  getSpace() {\n    return this.space;\n  }\n  /**\n   * Sets the space for the map.\n   * @param {CubemapDefinition} space the `CubemapDefinition` options to set.\n   * @remarks This method, at present, ** overwrites ** the current config.\n   * If an option is not set it will internally revert to the default option\n   * unless explicitly set when calling.\n   */\n  setSpace(t) {\n    if (t === !1) {\n      this.space = void 0;\n      return;\n    }\n    if (this.isGlobeProjection()) {\n      if (this.space) {\n        this.space.setCubemap(t), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);\n        return;\n      }\n      this.space = new Pr(t), this.once(\"load\", () => {\n        const n = this.getLayersOrder()[0];\n        this.space && this.addLayer(this.space, n);\n      });\n    }\n  }\n  /**\n   * Enables the animations for the space layer.\n   */\n  enableSpaceAnimations() {\n    this.setSpaceAnimationActive(!0);\n  }\n  /**\n   * Disables the animations for the space layer.\n   */\n  disableSpaceAnimations() {\n    this.setSpaceAnimationActive(!1);\n  }\n  /**\n   * Enables the animations for the halo layer.\n   */\n  enableHaloAnimations() {\n    this.setHaloAnimationActive(!0);\n  }\n  /**\n   * Disables the animations for the halo layer.\n   */\n  disableHaloAnimations() {\n    this.setHaloAnimationActive(!1);\n  }\n  /**\n   * Sets whether the halo layer should be animated in and out.\n   * @param active - Whether the animation should be active.\n   */\n  setHaloAnimationActive(t) {\n    this.halo ? this.halo.setAnimationActive(t) : this.once(\"load\", () => {\n      var n;\n      (n = this.halo) == null || n.setAnimationActive(t);\n    });\n  }\n  /**\n   * Sets whether the space layer should be animated in and out.\n   * @param active - Whether the animation should be active.\n   */\n  setSpaceAnimationActive(t) {\n    this.space ? this.space.setAnimationActive(t) : this.once(\"load\", () => {\n      var n;\n      (n = this.space) == null || n.setAnimationActive(t);\n    });\n  }\n  setSpaceFromStyle({ style: t }) {\n    var i, s, l;\n    if (this.options.space) {\n      this.setSpace(this.options.space);\n      return;\n    }\n    const n = (s = (i = t.metadata) == null ? void 0 : i.maptiler) == null ? void 0 : s.space;\n    if (!n) {\n      this.setSpace({\n        color: \"transparent\"\n      });\n      return;\n    }\n    if (!ko(n)) {\n      this.setSpace({\n        color: \"transparent\"\n      });\n      return;\n    }\n    if (JSON.stringify((l = this.space) == null ? void 0 : l.getConfig()) === JSON.stringify(n)) {\n      if (this.space && !this.getLayer(this.space.id)) {\n        const u = this.getLayersOrder()[0];\n        this.addLayer(this.space, u);\n      }\n      return;\n    }\n    (() => {\n      if (this.space && this.isGlobeProjection()) {\n        if (!this.getLayer(this.space.id)) {\n          const u = this.getLayersOrder()[0];\n          this.addLayer(this.space, u);\n        }\n        this.space.setCubemap(n);\n      }\n    })();\n  }\n  setHaloFromStyle({ style: t }) {\n    var o, i, s;\n    const n = (o = t.metadata) == null ? void 0 : o.maptiler;\n    if (JSON.stringify((i = this.halo) == null ? void 0 : i.getConfig()) === JSON.stringify(n == null ? void 0 : n.halo)) {\n      if (this.halo && !this.getLayer(this.halo.id)) {\n        const l = this.getLayersOrder().indexOf(((s = this.space) == null ? void 0 : s.id) ?? \"\") + 1, u = this.getLayersOrder()[l];\n        this.addLayer(this.halo, u);\n      }\n      return;\n    }\n    if (!(n != null && n.halo) && !this.options.halo) {\n      this.setHalo({\n        stops: [\n          [0, \"transparent\"],\n          [1, \"transparent\"]\n        ],\n        scale: 1\n      });\n      return;\n    }\n    (() => {\n      var l;\n      if (this.halo) {\n        if (!this.getLayer(this.halo.id)) {\n          const c = this.getLayersOrder().indexOf(((l = this.space) == null ? void 0 : l.id) ?? \"\") + 1, p = this.getLayersOrder()[c];\n          this.addLayer(this.halo, p);\n        }\n        const u = (n == null ? void 0 : n.halo) ?? this.options.halo;\n        u && this.halo.setGradient(u);\n      }\n    })();\n  }\n  initSpace({ options: t = this.options, before: n, spec: a }) {\n    if (this.space) {\n      this.getLayer(this.space.id) || this.addLayer(this.space, n);\n      return;\n    }\n    if (t.space === !1) return;\n    const o = a;\n    if (t.space) {\n      this.space = new Pr(t.space), this.addLayer(this.space, n);\n      return;\n    }\n    o && (this.space = new Pr(o), this.addLayer(this.space, n));\n  }\n  initHalo({ options: t = this.options, before: n, spec: a }) {\n    if (this.halo && this.getLayer(this.halo.id) || t.halo === !1) return;\n    const o = a;\n    if (t.halo) {\n      this.halo = new Rr(t.halo), this.addLayer(this.halo, n);\n      return;\n    }\n    o && (this.halo = new Rr(o), this.addLayer(this.halo, n));\n  }\n  getHalo() {\n    return this.halo;\n  }\n  setHalo(t) {\n    if (this.isGlobeProjection()) {\n      if (this.halo) {\n        this.halo.setGradient(t);\n        return;\n      }\n      this.halo = new Rr(t), this.once(\"load\", () => {\n        var s;\n        const n = this.getLayersOrder(), a = n[0], o = n.indexOf(((s = this.space) == null ? void 0 : s.id) ?? \"\") + 2, i = n[o];\n        this.halo && this.addLayer(this.halo, this.space ? i : a);\n      });\n    }\n  }\n  /**\n   * Recreates the map instance with the same options.\n   * Useful for WebGL context loss.\n   */\n  recreate() {\n    const t = {\n      center: this.getCenter(),\n      zoom: this.getZoom(),\n      bearing: this.getBearing(),\n      pitch: this.getPitch()\n    };\n    this.remove(), Object.assign(this, new Co({ ...this.options })), this.once(\"load\", () => {\n      this.jumpTo(t);\n    });\n  }\n  /**\n   * Set the duration (millisec) of the terrain animation for growing or flattening.\n   * Must be positive. (Built-in default: `1000` milliseconds)\n   */\n  setTerrainAnimationDuration(t) {\n    this.terrainAnimationDuration = Math.max(t, 0);\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  async onLoadAsync() {\n    return new Promise((t) => {\n      if (this.loaded()) {\n        t(this);\n        return;\n      }\n      this.once(\"load\", () => {\n        t(this);\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  async onReadyAsync() {\n    return new Promise((t) => {\n      if (this.isReady) {\n        t(this);\n        return;\n      }\n      this.once(\"ready\", () => {\n        t(this);\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  async onLoadWithTerrainAsync() {\n    return new Promise((t) => {\n      if (this.isReady && this.terrain) {\n        t(this);\n        return;\n      }\n      this.once(\"loadWithTerrain\", () => {\n        t(this);\n      });\n    });\n  }\n  monitorStyleUrl(t) {\n    typeof this.monitoredStyleUrls > \"u\" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());\n    const n = new URL(t);\n    n.search = \"\", this.monitoredStyleUrls.add(n.href);\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  setStyle(t, n) {\n    var c, p, d, f, h;\n    this.originalLabelStyle.clear(), (c = this.minimap) == null || c.setStyle(t), this.forceLanguageUpdate = !0, this.once(\"idle\", () => {\n      this.forceLanguageUpdate = !1;\n    });\n    const a = oa(t);\n    if (a.requiresUrlMonitoring && this.monitorStyleUrl(a.style), a.isFallback) {\n      if (this.getStyle())\n        return console.warn(\n          \"[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead.\"\n        ), this;\n      console.warn(\n        \"[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.\"\n      );\n    }\n    const o = this.getStyle(), i = a.style;\n    try {\n      super.setStyle(a.style, n), this.styleInProcess = !0;\n    } catch (m) {\n      this.styleInProcess = !1, console.error(\"[Map.setStyle]: Error while setting style:\", m);\n    }\n    const s = () => {\n      const m = a.style;\n      if (!m.projection || m.projection.type === \"mercator\") {\n        console.warn(\"[Map.setStyle]: Neither space nor halo is supported for mercator projection. Ignoring...\");\n        return;\n      }\n      this.setSpaceFromStyle({ style: a.style }), this.setHaloFromStyle({ style: a.style });\n    }, l = (m) => {\n      var g, x, E, C;\n      const y = (m == null ? void 0 : m.target.getStyle()) ?? a.style, w = this.getLayersOrder()[0];\n      this.space ? this.setSpaceFromStyle({ style: y }) : this.initSpace({ before: w, spec: (x = (g = y.metadata) == null ? void 0 : g.maptiler) == null ? void 0 : x.space }), this.halo ? this.setHaloFromStyle({ style: y }) : this.initHalo({ before: w, spec: (C = (E = y.metadata) == null ? void 0 : E.maptiler) == null ? void 0 : C.halo });\n    };\n    if (typeof a.style == \"string\" || a.requiresUrlMonitoring)\n      return this.on(\"styledata\", l), this;\n    if (this.styleInProcess && !this.spaceboxLoadingState.styleLoadCallbackSet)\n      return this.once(\"style.load\", l), this.once(\"styledata\", l), this.spaceboxLoadingState.styleLoadCallbackSet = !0, this;\n    if (((p = o == null ? void 0 : o.terrain) == null ? void 0 : p.source) !== ((d = i == null ? void 0 : i.terrain) == null ? void 0 : d.source) || ((f = o == null ? void 0 : o.terrain) == null ? void 0 : f.exaggeration) !== ((h = i == null ? void 0 : i.terrain) == null ? void 0 : h.exaggeration))\n      return this.once(\"terrain\", s), this;\n    try {\n      l();\n    } catch {\n    }\n    return this;\n  }\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);\n  }\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);\n  }\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(t) {\n    var n;\n    return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);\n  }\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(t, n, a) {\n    var o;\n    return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);\n  }\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(t, n, a) {\n    var o;\n    return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);\n  }\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(t, n, a, o) {\n    var i;\n    return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);\n  }\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(t, n, a, o) {\n    var i;\n    return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);\n  }\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);\n  }\n  getStyleLanguage() {\n    return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != \"object\" ? null : \"maptiler:language\" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata[\"maptiler:language\"] == \"string\" ? (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.getLanguageInfoFromFlag)(this.style.stylesheet.metadata[\"maptiler:language\"]) : null;\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(t) {\n    var n;\n    (n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {\n      this.setPrimaryLanguage(t);\n    });\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setPrimaryLanguage(t) {\n    const n = this.getStyleLanguage(), a = (0,_maptiler_client__WEBPACK_IMPORTED_MODULE_1__.toLanguageInfo)(t, z);\n    if (!a) {\n      console.warn(`The language \"${a}\" is not supported.`);\n      return;\n    }\n    if (!(a.flag === z.STYLE.flag && n && (n.flag === z.AUTO.flag || n.flag === z.VISITOR.flag)) && (a.flag !== z.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate))\n      return;\n    if (this.primaryLanguage.flag === z.STYLE_LOCK.flag) {\n      console.warn(\"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\");\n      return;\n    }\n    this.primaryLanguage = a;\n    let o = a;\n    if (a.flag === z.STYLE.flag) {\n      if (!n) {\n        console.warn(\"The style has no default languages or has an invalid one.\");\n        return;\n      }\n      o = n;\n    }\n    let i = z.LOCAL.flag, s = [\"get\", i];\n    o.flag === z.VISITOR.flag ? (i = Pn().flag, s = [\n      \"case\",\n      [\"all\", [\"has\", i], [\"has\", z.LOCAL.flag]],\n      [\n        \"case\",\n        [\"==\", [\"get\", i], [\"get\", z.LOCAL.flag]],\n        [\"get\", z.LOCAL.flag],\n        [\"format\", [\"get\", i], { \"font-scale\": 0.8 }, `\n`, [\"get\", z.LOCAL.flag], { \"font-scale\": 1.1 }]\n      ],\n      [\"get\", z.LOCAL.flag]\n    ]) : o.flag === z.VISITOR_ENGLISH.flag ? (i = z.ENGLISH.flag, s = [\n      \"case\",\n      [\"all\", [\"has\", i], [\"has\", z.LOCAL.flag]],\n      [\n        \"case\",\n        [\"==\", [\"get\", i], [\"get\", z.LOCAL.flag]],\n        [\"get\", z.LOCAL.flag],\n        [\"format\", [\"get\", i], { \"font-scale\": 0.8 }, `\n`, [\"get\", z.LOCAL.flag], { \"font-scale\": 1.1 }]\n      ],\n      [\"get\", z.LOCAL.flag]\n    ]) : o.flag === z.AUTO.flag ? (i = Pn().flag, s = [\"coalesce\", [\"get\", i], [\"get\", z.LOCAL.flag]]) : o === z.LOCAL ? (i = z.LOCAL.flag, s = [\"get\", i]) : (i = o.flag, s = [\"coalesce\", [\"get\", i], [\"get\", z.LOCAL.flag]]);\n    const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;\n    if (u) {\n      const c = Mi(l, this);\n      this.isStyleLocalized = Object.keys(c.localized).length > 0;\n    }\n    for (const c of l) {\n      if (c.type !== \"symbol\")\n        continue;\n      const p = c, d = this.getSource(p.source);\n      if (!d || !(\"url\" in d && typeof d.url == \"string\") || new URL(d.url).host !== X.maptilerApiHost)\n        continue;\n      const { id: h, layout: m } = p;\n      if (!m || !(\"text-field\" in m))\n        continue;\n      let y;\n      if (u ? (y = this.getLayoutProperty(h, \"text-field\"), this.originalLabelStyle.set(h, y)) : y = this.originalLabelStyle.get(h), typeof y == \"string\") {\n        const { contains: w, exactMatch: g } = Ei(y, this.isStyleLocalized);\n        if (!w) continue;\n        if (g)\n          this.setLayoutProperty(h, \"text-field\", s);\n        else {\n          const x = Ai(y, s, this.isStyleLocalized);\n          this.setLayoutProperty(h, \"text-field\", x);\n        }\n      } else {\n        const w = Ci(y, s, this.isStyleLocalized);\n        this.setLayoutProperty(h, \"text-field\", w);\n      }\n    }\n    this.languageIsUpdated = !0;\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(t) {\n    if (!this.terrain)\n      return;\n    const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {\n      if (!this.terrain || this.terrainFlattening)\n        return;\n      const s = (performance.now() - n) / this.terrainAnimationDuration;\n      if (s < 0.99) {\n        const l = 1 - (1 - s) ** 4, u = a + l * o;\n        this.terrain.exaggeration = u, requestAnimationFrame(i);\n      } else\n        this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t, this.fire(\"terrainAnimationStop\", { terrain: this.terrain });\n      this._elevationFreeze = !1, this.triggerRepaint();\n    };\n    !this.terrainGrowing && !this.terrainFlattening && this.fire(\"terrainAnimationStart\", { terrain: this.terrain }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(t = this.terrainExaggeration) {\n    if (t < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const n = (o) => {\n      !this.terrain || o.type !== \"data\" || o.dataType !== \"source\" || !(\"source\" in o) || o.sourceId !== \"maptiler-terrain\" || o.source.type !== \"raster-dem\" || o.isSourceLoaded && (this.off(\"data\", n), this.growTerrain(t));\n    }, a = () => {\n      this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on(\"data\", n), this.addSource(X.terrainSourceId, {\n        type: \"raster-dem\",\n        url: X.terrainSourceURL\n      }), this.setTerrain({\n        source: X.terrainSourceId,\n        exaggeration: 0\n      });\n    };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = !0, this.growTerrain(t);\n      return;\n    }\n    if (this.loaded() || this.isTerrainEnabled)\n      a();\n    else {\n      const o = () => {\n        this.getTerrain() && this.getSource(X.terrainSourceId) || a();\n      };\n      this.once(\"load\", () => {\n        o();\n      }), this.once(\"moveend\", () => {\n        o();\n      });\n    }\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain)\n      return;\n    this.isTerrainEnabled = !1;\n    const t = performance.now(), n = this.terrain.exaggeration, a = () => {\n      if (!this.terrain || this.terrainGrowing)\n        return;\n      const o = (performance.now() - t) / this.terrainAnimationDuration;\n      if (this._elevationFreeze = !1, o < 0.99) {\n        const i = (1 - o) ** 4, s = n * i;\n        this.terrain.exaggeration = s, requestAnimationFrame(a);\n      } else\n        this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(X.terrainSourceId) && this.removeSource(X.terrainSourceId), this.fire(\"terrainAnimationStop\", { terrain: null });\n      this.triggerRepaint();\n    };\n    !this.terrainGrowing && !this.terrainFlattening && this.fire(\"terrainAnimationStart\", { terrain: this.terrain }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(a);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(t, n = !0) {\n    !n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  onStyleReady(t) {\n    this.isStyleLoaded() ? t() : this.once(\"styledata\", () => {\n      t();\n    });\n  }\n  async fitToIpBounds() {\n    const t = await _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.geolocation.info();\n    this.fitBounds(t.country_bounds, {\n      duration: 0,\n      padding: 100\n    });\n  }\n  async centerOnIpPoint(t) {\n    const n = await _maptiler_client__WEBPACK_IMPORTED_MODULE_1__.geolocation.info();\n    this.jumpTo({\n      center: [n.longitude ?? 0, n.latitude ?? 0],\n      zoom: t || 11\n    });\n  }\n  getCameraHash() {\n    const t = new Float32Array(5), n = this.getCenter();\n    return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), js_base64__WEBPACK_IMPORTED_MODULE_4__.Base64.fromUint8Array(new Uint8Array(t.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig() {\n    return j;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return tn;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(t) {\n    return super.setTransformRequest($n(t)), this;\n  }\n  /**\n   * Returns whether a globe projection is currently being used\n   */\n  isGlobeProjection() {\n    const t = this.getProjection();\n    return t ? t.type === \"globe\" : !1;\n  }\n  /**\n   * Activate the globe projection.\n   */\n  enableGlobeProjection() {\n    this.isGlobeProjection() !== !0 && (this.setProjection({ type: \"globe\" }), this.curentProjection = \"globe\");\n  }\n  /**\n   * Activate the mercator projection.\n   */\n  enableMercatorProjection() {\n    this.isGlobeProjection() !== !1 && (this.setProjection({ type: \"mercator\" }), this.curentProjection = \"mercator\");\n  }\n  /**\n   * Returns `true` is the language was ever updated, meaning changed\n   * from what is delivered in the style.\n   * Returns `false` if language in use is the language from the style\n   * and has never been changed.\n   */\n  isLanguageUpdated() {\n    return this.languageIsUpdated;\n  }\n};\nclass ae {\n  constructor(e, t, n, a = {}) {\n    v(this, \"type\");\n    v(this, \"target\");\n    v(this, \"originalEvent\");\n    this.type = e, this.target = t, this.originalEvent = n ?? null, Object.assign(this, a);\n  }\n}\nconst Eo = [\n  // pass nothing other than target (map / viewer) and type\n  \"idle\",\n  \"render\",\n  \"load\",\n  \"remove\",\n  \"idle\"\n  // these are fired on layers, not the map,\n  // keeping them for reference\n  // \"content\",\n  // \"visibility\",\n], Ao = [\n  \"error\"\n  // ErrorEvent\n], To = [\"resize\"], _o = [\"webglcontextlost\", \"webglcontextrestored\"], Io = [\n  \"moveend\",\n  \"movestart\",\n  \"move\",\n  \"zoomend\",\n  \"zoomstart\",\n  \"zoom\",\n  \"rotatestart\",\n  \"rotateend\",\n  \"rotate\",\n  \"dragstart\",\n  \"dragend\",\n  \"drag\",\n  \"boxzoomcancel\",\n  \"boxzoomend\",\n  \"boxzoomstart\"\n], Mo = [\"click\", \"dblclick\", \"mousedown\", \"mouseup\", \"mousemove\", \"mouseout\", \"mouseover\", \"contextmenu\", \"touchstart\", \"touchend\", \"touchmove\", \"touchcancel\"], Po = [\"cooperativegestureprevented\"], Ro = [\n  \"data\",\n  \"dataloading\",\n  \"sourcedata\",\n  \"sourcedataloading\",\n  \"dataabort\",\n  \"sourcedataabort\"\n  // this is fired on layers, not the map\n  // keeping it for reference\n  // \"metadata\",\n], Vu = [\n  ...Eo,\n  ...Ao,\n  ...To,\n  ..._o,\n  ...Io,\n  ...Mo,\n  ...Ro,\n  ...Po\n], Gu = [\"lngLat\", \"_defaultPrevented\"];\nfunction Hu({ map: r, viewer: e, lngLatToPx: t }) {\n  Vu.forEach((n) => {\n    try {\n      r.on(n, (a) => {\n        const o = n;\n        if (Mo.includes(o)) {\n          const f = a, h = f.lngLat && t(f.lngLat), m = {\n            imageX: h[0],\n            imageY: h[1],\n            ...Object.fromEntries(Object.entries(a).filter(([y]) => !Gu.includes(y)))\n          };\n          e.fire(new ae(n, e, f.originalEvent, m));\n          return;\n        }\n        const i = n;\n        if (Io.includes(i)) {\n          const f = a;\n          e.fire(new ae(n, e, f.originalEvent, f));\n          return;\n        }\n        const s = n;\n        if (Ao.includes(s)) {\n          const f = a;\n          e.fire(new ae(n, e, null, f));\n          return;\n        }\n        const l = n;\n        if (To.includes(l)) {\n          const f = a;\n          e.fire(new ae(n, e, null, f));\n          return;\n        }\n        const u = n;\n        if (_o.includes(u)) {\n          const f = a;\n          e.fire(new ae(n, e, f.originalEvent, f));\n          return;\n        }\n        const c = n;\n        if (Ro.includes(c)) {\n          const f = a;\n          e.fire(new ae(n, e, null, f));\n          return;\n        }\n        const p = n;\n        if (Po.includes(p)) {\n          const f = a;\n          e.fire(new ae(n, e, null, f));\n          return;\n        }\n        const d = n;\n        if (Eo.includes(d)) {\n          e.fire(new ae(n, e));\n          return;\n        }\n      });\n    } catch (a) {\n      console.error(`Error forwarding event to ImageViewer, event of type \"${n}\" is not supported`, a);\n    }\n  });\n}\nclass Zu extends Error {\n  constructor(t, n, a) {\n    const o = `[${a}]: Failed to fetch ${n} at ${t.url}: ${t.status.toString()}: ${t.statusText}`;\n    super(o);\n    v(this, \"status\");\n    v(this, \"statusText\");\n    this.name = \"FetchError\", this.message = o, this.status = t.status, this.statusText = t.statusText;\n  }\n}\nconst Xu = 85.051129;\nfunction Ku(r, e) {\n  return new en(e.x / r, e.y / r).toLngLat();\n}\nfunction Yu(r) {\n  return Math.pow(2, r);\n}\nfunction Wu(r) {\n  return Math.log(r) / Math.LN2;\n}\nfunction zo(r, e, t) {\n  return Math.min(t, Math.max(e, r));\n}\nfunction Hr(r) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;\n}\nfunction Zr(r) {\n  return (180 + r) / 360;\n}\nfunction ka(r, e, t) {\n  const n = t - e, a = ((r - e) % n + n) % n + e;\n  return a === e ? t : a;\n}\nfunction Ju(r, e) {\n  const t = zo(e.lat, -85.051129, Xu);\n  return new Ko(Zr(e.lng) * r, Hr(t) * r);\n}\nfunction Qu(r) {\n  r.transform.getConstrained = function(e, t) {\n    t = zo(+t, this.minZoom, this.maxZoom);\n    const n = {\n      center: new kc(e.lng, e.lat),\n      zoom: t\n    };\n    let a = this._helper._lngRange;\n    a === null && (a = [-179.9999999999, 179.9999999999]);\n    const o = this.tileSize * Yu(n.zoom);\n    let i = 0, s = o, l = 0, u = o, c = 0, p = 0;\n    const { x: d, y: f } = this.size, h = 0.5;\n    if (this._helper._latRange) {\n      const H = this._helper._latRange;\n      i = Hr(H[1]) * o, s = Hr(H[0]) * o, s - i < h * f && (c = h * f / (s - i));\n    }\n    a && (l = ka(Zr(a[0]) * o, 0, o), u = ka(Zr(a[1]) * o, 0, o), u < l && (u += o), u - l < h * d && (p = h * d / (u - l)));\n    const { x: m, y } = Ju(o, e);\n    let w, g;\n    const x = Math.min(p || 0, c || 0);\n    if (x)\n      return n.zoom += Wu(x), n;\n    let E = 0, C = 0;\n    const T = 1, N = 1 - (s - i) / f, ve = 1 - (u - l) / d;\n    E = Math.max(ve, T), C = Math.max(N, T);\n    const Ye = 1 - E, We = 1 - C;\n    if (this._helper._latRange) {\n      const H = We * f / 2;\n      y - H < i && (g = i + H), y + H > s && (g = s - H);\n    }\n    if (a) {\n      const H = m, Oe = Ye * d / 2;\n      H - Oe < l && (w = l + Oe), H + Oe > u && (w = u - Oe);\n    }\n    if (w !== void 0 || g !== void 0) {\n      const H = new Ko(w ?? m, g ?? y);\n      n.center = Ku(o, H).wrap();\n    }\n    return n;\n  };\n}\nclass ec {\n  constructor({ imageViewer: e }) {\n    v(this, \"viewer\");\n    v(this, \"container\");\n    v(this, \"handleClick\", () => {\n      this.viewer.fitImageToViewport({ ease: !0 });\n    });\n    if (!e)\n      throw new Error(\"ImageViewerFitImageToBoundsControl: an instance of 'ImageViewer' is required\");\n    this.viewer = e;\n  }\n  onAdd(e) {\n    const t = document.createElement(\"button\");\n    this.container = document.createElement(\"div\"), this.container.classList.add(\"maplibregl-ctrl\", \"maplibregl-ctrl-group\"), t.classList.add(\"maplibregl-ctrl-fit-image-to-bounds\");\n    const n = document.createElement(\"span\");\n    return n.classList.add(\"maplibregl-ctrl-icon\"), t.title = \"Zoom image to viewport bounds\", t.appendChild(n), t.addEventListener(\"click\", this.handleClick), this.container.appendChild(t), this.container;\n  }\n  onRemove() {\n    this.container.remove();\n  }\n}\nconst tc = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Evented, rc = {\n  style: {\n    version: 8,\n    sources: {},\n    layers: []\n  },\n  minPitch: 0,\n  maxPitch: 0,\n  pitch: 0,\n  bearing: 0,\n  projection: \"mercator\",\n  geolocateControl: !1,\n  navigationControl: !1,\n  projectionControl: !1,\n  hash: !1,\n  renderWorldCopies: !1,\n  terrain: !1,\n  space: !1,\n  halo: !1\n}, nc = {\n  debug: !1,\n  fitToBoundsControl: !0,\n  navigationControl: !0\n};\nclass Jc extends tc {\n  //#region constructor\n  /**\n   * The constructor for the ImageViewer.\n   *\n   * @param {Partial<ImageViewerConstructorOptions>} imageViewerConstructorOptions - The options for the ImageViewer.\n   * @example\n   * ```ts\n   * import \"@maptiler/sdk/dist/maptiler-sdk.css\"; // import css\n   * import { ImageViewer } from \"@maptiler/sdk\"; // import the sdk\n   *\n   * const imageViewer = new ImageViewer({\n   *   container: document.getElementById(\"map\"),\n   *   imageUUID: \"01986025-ceb9-7487-9ea6-7a8637dcc1a1\",\n   *   debug: true, // show tile boundaries, padding, collision boxes etc\n   *   fitToBoundsControl: true, // show a control to fit the image to the viewport\n   *   navigationControl: true, // show a navigation control\n   *   center: [0, 0], // center in pixels\n   *   zoom: 1, // zoom level\n   *   bearing: 0, // bearing\n   * });\n   * ```\n   */\n  constructor(t) {\n    super();\n    /**\n     * The UUID of the image.\n     *\n     * @internal\n     */\n    v(this, \"imageUUID\");\n    /**\n     * Whether to enable debug mode.\n     *\n     * @internal\n     */\n    v(this, \"debug\");\n    /**\n     * The metadata of the image.\n     *\n     * @internal\n     */\n    v(this, \"imageMetadata\");\n    /**\n     * Why not extend the Map class?\n     * Because ImageViewer technically operates in screen space and not in map space.\n     * We wrap map and perform calculations in screen space.\n     * We do not want to have to extend the Map class and give access to\n     * methods and properties that operate in LngLat space.   *\n     */\n    v(this, \"sdk\");\n    /**\n     * The options for the ImageViewer.\n     *\n     * @internal\n     */\n    v(this, \"options\");\n    /**\n     * The size of the image.\n     *\n     * @internal\n     */\n    v(this, \"imageSize\");\n    /**\n     * The padded size max.\n     *\n     * @internal\n     */\n    v(this, \"paddedSizeMax\");\n    // this flag is used to determine if the image should be fit to the viewport\n    // when the map is resized\n    v(this, \"shouldFitImageToViewport\", !0);\n    if (!t.imageUUID)\n      throw new Error(\"[ImageViewer]: `imageUUID` is required\");\n    if (typeof t.container != \"string\" && !(t.container instanceof HTMLElement))\n      throw new Error(\"[ImageViewer]: `container` is required and must be a string or HTMLElement\");\n    this.options = {\n      ...nc,\n      ...t\n    };\n    const n = {\n      ...this.options,\n      ...rc\n    };\n    delete n.center, this.sdk = new Lo(n), this.sdk.telemetry.registerViewerType(\"ImageViewer\");\n    const { imageUUID: a, debug: o } = t;\n    this.imageUUID = a, this.debug = o ?? !1, this.debug && (this.sdk.showTileBoundaries = this.debug, this.sdk.showPadding = this.debug, this.sdk.showCollisionBoxes = this.debug, this.sdk.repaint = this.debug), this.init();\n  }\n  /**\n   * The version of the ImageViewer / SDK.\n   */\n  get version() {\n    return this.sdk.version;\n  }\n  //#region onReadyAsync\n  /**\n   * Waits for the ImageViewer to be ready.\n   *\n   * @returns {Promise<void>}\n   */\n  async onReadyAsync() {\n    try {\n      await this.sdk.onReadyAsync(), await Promise.race([\n        new Promise((t, n) => {\n          this.once(\"imageviewerready\", (a) => {\n            t(a);\n          }), this.once(\"imagevieweriniterror\", (a) => {\n            n(a.error);\n          });\n        }),\n        new Promise((t, n) => {\n          setTimeout(() => {\n            n(new Error(\"Timeout waiting for image viewer to be ready\"));\n          }, 5e3);\n        })\n      ]);\n    } catch (t) {\n      throw t;\n    }\n  }\n  //#region init\n  /**\n   * Initializes the ImageViewer\n   *  - fetches the image metadata\n   *  - adds the image source to the sdk instance\n   *  - sets the center to the middle of the image (if center is not provided)\n   *  - monkeypatches the maplibre-gl sdk transform method to allow for overpanning and underzooming.\n   *  - sets up global event forwarding / intercepting from the map instance\n   *  - sets the center to the middle of the image (if center is not provided)\n   *\n   * @internal\n   * @returns {Promise<void>}\n   */\n  async init() {\n    var t, n, a;\n    try {\n      await this.fetchImageMetadata(), this.addImageSource(), this.options.navigationControl && this.sdk.addControl(\n        new Ma({\n          visualizePitch: !1,\n          visualizeRoll: !1\n        })\n      ), this.options.fitToBoundsControl && this.sdk.addControl(new ec({ imageViewer: this })), Hu({\n        map: this.sdk,\n        viewer: this,\n        lngLatToPx: (u) => this.lngLatToPx(u)\n      }), Qu(this.sdk);\n      const { center: o, zoom: i, bearing: s } = this.options, l = o ?? [(((t = this.imageMetadata) == null ? void 0 : t.width) ?? 0) / 2, (((n = this.imageMetadata) == null ? void 0 : n.height) ?? 0) / 2];\n      this.setCenter(l), this.setBearing(s ?? 0), this.options.zoom ? this.setZoom(i ?? ((a = this.imageMetadata) == null ? void 0 : a.maxzoom) ?? 5) : this.fitImageToViewport(), this.sdk.on(\"wheel\", () => {\n        this.shouldFitImageToViewport = !1;\n      }), this.sdk.on(\"touchstart\", () => {\n        this.shouldFitImageToViewport = !1;\n      }), this.sdk.on(\"drag\", () => {\n        this.shouldFitImageToViewport = !1;\n      }), this.sdk.on(\"resize\", () => {\n        var d, f;\n        const u = this.getCenter(), c = ((d = this.imageMetadata) == null ? void 0 : d.width) ?? 0, p = ((f = this.imageMetadata) == null ? void 0 : f.height) ?? 0;\n        this.shouldFitImageToViewport && this.fitImageToViewport(), (u[0] !== c / 2 || u[1] !== p / 2) && this.setCenter(u);\n      }), this.fire(\"imageviewerready\", new ae(\"imageviewerready\", this));\n    } catch (o) {\n      this.fire(\"imagevieweriniterror\", { error: o });\n    }\n  }\n  //#region fitImageToViewport\n  /**\n   * Fits the image to the viewport.\n   *\n   * @param {Object} options - The options for the fit image to viewport.\n   * @param {boolean} options.ease - Whether to ease to the viewport bounds.\n   */\n  fitImageToViewport({ ease: t = !1 } = {}) {\n    if (!this.imageMetadata)\n      throw new Error(\"[ImageViewer]: Image metadata not found\");\n    const n = this.pxToLngLat([0, 0]), a = this.pxToLngLat([this.imageMetadata.width ?? 0, this.imageMetadata.height ?? 0]), o = this.sdk.cameraForBounds([n, a], { padding: 50 });\n    o && (t ? this.sdk.easeTo({ ...o, pitch: 0 }, null) : this.sdk.jumpTo({ ...o, pitch: 0 }, null)), this.shouldFitImageToViewport = !0;\n  }\n  //#region fetchImageMetadata\n  /**\n   * Fetches the image metadata from the API.\n   *\n   * @internal\n   * @returns {Promise<void>}\n   */\n  async fetchImageMetadata() {\n    const t = ac(this.imageUUID), n = await fetch(t);\n    if (!n.ok)\n      throw new Zu(n, \"image metadata\", \"ImageViewer\");\n    const a = await n.json();\n    this.imageMetadata = a;\n  }\n  //#region addImageSource\n  /**\n   * Adds the image source to the sdk instance.\n   *\n   * @internal\n   * @returns {void}\n   */\n  addImageSource() {\n    if (!this.imageMetadata)\n      throw this.fire(\"error\", new ae(\"error\", this, null, { error: new Error(\"[ImageViewer]: Image metadata not found\") })), new Error(\"[ImageViewer]: Image metadata not found\");\n    const t = oc(this.imageUUID), n = (s) => Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));\n    this.imageSize = [this.imageMetadata.width, this.imageMetadata.height], this.paddedSizeMax = Math.max(n(this.imageSize[0]), n(this.imageSize[1]));\n    const a = this.pxToLngLat([0, 0]), o = this.pxToLngLat(this.imageSize), i = [a.lng, o.lat, o.lng, a.lat];\n    this.sdk.addSource(\"image\", {\n      ...this.imageMetadata,\n      type: \"raster\",\n      bounds: i,\n      tiles: [t]\n    }), this.sdk.addLayer({\n      id: \"image\",\n      type: \"raster\",\n      source: \"image\"\n    });\n  }\n  //#region SDK mappings\n  /**\n   * Triggers a repaint of the ImageViewer. Same as map.triggerRepaint().\n   *\n   * @internal\n   * @returns {void}\n   */\n  triggerRepaint() {\n    this.sdk.triggerRepaint();\n  }\n  /**\n   * The scroll zoom handler.\n   *\n   * @internal\n   * @returns {ScrollZoomHandler}\n   */\n  get scrollZoom() {\n    return this.sdk.scrollZoom;\n  }\n  /**\n   * The scroll zoom handler.\n   *\n   * @internal\n   * @param {ScrollZoomHandler} value - The scroll zoom handler.\n   */\n  set scrollZoom(t) {\n    this.sdk.scrollZoom = t;\n  }\n  /**\n   * The box zoom handler.\n   *\n   * @internal\n   * @returns {BoxZoomHandler}\n   */\n  get boxZoom() {\n    return this.sdk.boxZoom;\n  }\n  /**\n   * The box zoom handler.\n   *\n   * @internal\n   * @param {BoxZoomHandler} value - The box zoom handler.\n   */\n  set boxZoom(t) {\n    this.sdk.boxZoom = t;\n  }\n  /**\n   * The drag pan handler.\n   *\n   * @internal\n   * @returns {DragPanHandler}\n   */\n  get dragPan() {\n    return this.sdk.dragPan;\n  }\n  /**\n   * The drag pan handler.\n   *\n   * @internal\n   * @param {DragPanHandler} value - The drag pan handler.\n   */\n  set dragPan(t) {\n    this.sdk.dragPan = t;\n  }\n  /**\n   * The keyboard handler.\n   *\n   * @internal\n   * @returns {KeyboardHandler}\n   */\n  get keyboard() {\n    return this.sdk.keyboard;\n  }\n  /**\n   * The keyboard handler.\n   *\n   * @internal\n   * @param {KeyboardHandler} value - The keyboard handler.\n   */\n  set keyboard(t) {\n    this.sdk.keyboard = t;\n  }\n  /**\n   * The double click zoom handler.\n   *\n   * @internal\n   * @returns {DoubleClickZoomHandler}\n   */\n  get doubleClickZoom() {\n    return this.sdk.doubleClickZoom;\n  }\n  /**\n   * The double click zoom handler.\n   *\n   * @internal\n   * @param {DoubleClickZoomHandler} value - The double click zoom handler.\n   */\n  set doubleClickZoom(t) {\n    this.sdk.doubleClickZoom = t;\n  }\n  /**\n   * The touch zoom rotate handler.\n   *\n   * @internal\n   * @returns {TwoFingersTouchZoomRotateHandler}\n   */\n  get touchZoomRotate() {\n    return this.sdk.touchZoomRotate;\n  }\n  /**\n   * The touch zoom rotate handler.\n   *\n   * @internal\n   * @param {TwoFingersTouchZoomRotateHandler} value - The touch zoom rotate handler.\n   */\n  set touchZoomRotate(t) {\n    this.sdk.touchZoomRotate = t;\n  }\n  /**\n   * The cooperative gestures handler.\n   *\n   * @internal\n   * @returns {CooperativeGesturesHandler}\n   */\n  get cooperativeGestures() {\n    return this.sdk.cooperativeGestures;\n  }\n  /**\n   * The cooperative gestures handler.\n   *\n   * @internal\n   * @param {CooperativeGesturesHandler} value - The cooperative gestures handler.\n   */\n  set cooperativeGestures(t) {\n    this.sdk.cooperativeGestures = t;\n  }\n  //#endregion SDK Mappings\n  //#region lngLatToPx\n  /**\n   * Converts a LngLat to a px coordinate, based on the image metadata.\n   *\n   * @internal\n   * @param {LngLat} lngLat - The LngLat to convert.\n   * @returns {[number, number]} The px coordinate.\n   */\n  lngLatToPx(t) {\n    if (!this.paddedSizeMax) {\n      const a = \"[ImageViewer]: Unable to convert LngLat to px, padded size max not set\";\n      throw this.fire(\"error\", new ae(\"error\", this, null, { error: new Error(a) })), new Error(a);\n    }\n    const n = en.fromLngLat(t.wrap());\n    return [n.x * this.paddedSizeMax, n.y * this.paddedSizeMax];\n  }\n  //#region pxToLngLat\n  /**\n   * Converts a px coordinate to a LngLat, based on the image metadata.\n   *\n   * @internal\n   * @param {LngLat} lngLat - The LngLat to convert.\n   * @returns {[number, number]} The px coordinate.\n   */\n  pxToLngLat(t) {\n    if (!this.paddedSizeMax) {\n      const a = \"[ImageViewer]: Unable to convert px to LngLat, padded size max not set\";\n      throw this.fire(\"error\", new ae(\"error\", this, null, { error: new Error(a) })), new Error(a);\n    }\n    return new en(t[0] / this.paddedSizeMax, t[1] / this.paddedSizeMax).toLngLat();\n  }\n  //#region flyTo\n  /**\n   * Fly to a given center.\n   *\n   * @param {ImageViewerFlyToOptions} options - The options for the fly to.\n   * @param {MapDataEvent} eventData - The event data.\n   */\n  flyTo(t, n) {\n    const a = this.pxToLngLat(t.center);\n    return this.sdk.flyTo({ ...t, pitch: 0, center: a }, n);\n  }\n  //#region jumpTo\n  /**\n   * Jump to a given center.\n   *\n   * @param {ImageViewerJumpToOptions} options - The options for the jump to.\n   * @param {MapDataEvent} eventData - The event data.\n   */\n  jumpTo(t, n) {\n    const a = this.pxToLngLat(t.center);\n    return this.sdk.jumpTo({ ...t, pitch: 0, center: a }, n);\n  }\n  //#region setZoom\n  /**\n   * Set the zoom level.\n   *\n   * @param {number} zoom - The zoom level.\n   */\n  setZoom(t) {\n    this.sdk.setZoom(t);\n  }\n  //#region getZoom\n  /**\n   * Get the zoom level.\n   *\n   * @returns {number} The zoom level.\n   */\n  getZoom() {\n    return this.sdk.getZoom();\n  }\n  //#region getCenter\n  /**\n   * Get the center of the ImageViewer in pixels.\n   *\n   * @internal\n   * @returns {[number, number]} The center of the ImageViewer.\n   */\n  getCenter() {\n    const t = this.sdk.getCenter();\n    return this.lngLatToPx(t);\n  }\n  //#region setCenter\n  /**\n   * Set the center of the ImageViewer in pixels.\n   *\n   * @param {number} center - The center of the ImageViewer.\n   */\n  setCenter(t) {\n    this.sdk.setCenter(this.pxToLngLat(t));\n  }\n  //#region setBearing\n  /**\n   * Set the bearing of the ImageViewer in degrees.\n   *\n   * @param {number} bearing - The bearing of the ImageViewer.\n   */\n  setBearing(t) {\n    this.sdk.setBearing(t);\n  }\n  //#region getBearing\n  /**\n   * Get the bearing of the ImageViewer in degrees.\n   *\n   * @returns {number} The bearing of the ImageViewer.\n   */\n  getBearing() {\n    return this.sdk.getBearing();\n  }\n  //#region panBy\n  /**\n   * Pan by a given delta in pixels.\n   *\n   * @param {PointLike} delta - The delta to pan by.\n   * @param {ImageViewerEaseToOptions} options - The options for the pan.\n   * @param {any} eventData - The event data.\n   */\n  panBy(t, n, a) {\n    this.sdk.panBy(t, { ...n, pitch: 0 }, a);\n  }\n  //#region panTo\n  /**\n   * Pan to a given center in pixels.\n   *\n   * @param {number} center - The center to pan to.\n   * @param {ImageViewerEaseToOptions} options - The options for the pan.\n   * @param {any} eventData - The event data.\n   */\n  panTo(t, n, a) {\n    this.sdk.panTo(this.pxToLngLat(t), { ...n, pitch: 0 }, a);\n  }\n}\nfunction ac(r) {\n  return `${Fo()}/${r}/image.json?key=${j.apiKey}`;\n}\nfunction oc(r) {\n  return `${Fo()}/${r}/{z}/{x}/{y}?key=${j.apiKey}`;\n}\nfunction Fo() {\n  return \"https://api.maptiler.com/images\";\n}\nfunction Cn(r) {\n  if (typeof DOMParser < \"u\") {\n    const e = new DOMParser().parseFromString(r, \"application/xml\");\n    if (e.querySelector(\"parsererror\"))\n      throw new Error(\"The provided string is not valid XML\");\n    return e;\n  }\n  throw new Error(\"No XML parser found\");\n}\nfunction $o(r, e) {\n  if (!r.hasChildNodes())\n    return !1;\n  for (const t of Array.from(r.childNodes)) {\n    const n = t.nodeName;\n    if (typeof n == \"string\" && n.trim().toLowerCase() === e.toLowerCase())\n      return !0;\n  }\n  return !1;\n}\nfunction La(r) {\n  if (typeof XMLSerializer < \"u\")\n    return new XMLSerializer().serializeToString(r);\n  throw new Error(\"No XML serializer found\");\n}\nfunction Oo(r) {\n  const e = typeof r == \"string\" ? Cn(r) : r;\n  if (!$o(e, \"gpx\"))\n    throw new Error(\"The XML document is not valid GPX\");\n  const t = G(e, \"trk\"), n = G(e, \"rte\"), a = G(e, \"wpt\"), o = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  for (const i of Array.from(t)) {\n    const s = uc(i);\n    s && o.features.push(s);\n  }\n  for (const i of Array.from(n)) {\n    const s = cc(i);\n    s && o.features.push(s);\n  }\n  for (const i of Array.from(a))\n    o.features.push(pc(i));\n  return o;\n}\nfunction No(r, e) {\n  let t = r;\n  if (typeof t == \"string\" && (t = Cn(t)), !$o(t, \"kml\"))\n    throw new Error(\"The XML document is not valid KML\");\n  const n = {\n    type: \"FeatureCollection\",\n    features: []\n  }, a = {}, o = {}, i = {}, s = G(t, \"Placemark\"), l = G(t, \"Style\"), u = G(t, \"StyleMap\");\n  for (const c of Array.from(l)) {\n    const p = Ea(e !== void 0 ? e(c) : La(c)).toString(16);\n    a[`#${Ze(c, \"id\")}`] = p, o[p] = c;\n  }\n  for (const c of Array.from(u)) {\n    a[`#${Ze(c, \"id\")}`] = Ea(e !== void 0 ? e(c) : La(c)).toString(16);\n    const p = G(c, \"Pair\"), d = {};\n    for (const f of Array.from(p))\n      d[O(_(f, \"key\")) ?? \"\"] = O(_(f, \"styleUrl\"));\n    i[`#${Ze(c, \"id\")}`] = d;\n  }\n  for (const c of Array.from(s))\n    n.features = n.features.concat(lc(c, a, o, i));\n  return n;\n}\nfunction Ca(r) {\n  if (r === null) return [\"#000000\", 1];\n  let e = \"\", t = 1, n = r;\n  return n.startsWith(\"#\") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? \"#000000\", t ?? 1];\n}\nfunction ic(r) {\n  return Do(r.split(\" \"));\n}\nfunction sc(r) {\n  let e = G(r, \"coord\");\n  const t = [], n = [];\n  e.length === 0 && (e = G(r, \"gx:coord\"));\n  for (const o of Array.from(e))\n    t.push(ic(O(o) ?? \"\"));\n  const a = G(r, \"when\");\n  for (const o of Array.from(a)) n.push(O(o));\n  return {\n    coords: t,\n    times: n\n  };\n}\nfunction Ut(r) {\n  const e = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  let t, n, a, o, i;\n  const s = [], l = [];\n  if (_(r, \"MultiGeometry\") !== null)\n    return Ut(_(r, \"MultiGeometry\"));\n  if (_(r, \"MultiTrack\") !== null)\n    return Ut(_(r, \"MultiTrack\"));\n  if (_(r, \"gx:MultiTrack\") !== null)\n    return Ut(_(r, \"gx:MultiTrack\"));\n  for (a = 0; a < e.length; a++)\n    if (n = G(r, e[a]), n) {\n      for (o = 0; o < n.length; o++)\n        if (t = n[o], e[a] === \"Point\")\n          s.push({\n            type: \"Point\",\n            coordinates: Bo(O(_(t, \"coordinates\")) ?? \"\")\n          });\n        else if (e[a] === \"LineString\")\n          s.push({\n            type: \"LineString\",\n            coordinates: Ta(O(_(t, \"coordinates\")) ?? \"\")\n          });\n        else if (e[a] === \"Polygon\") {\n          const u = G(t, \"LinearRing\"), c = [];\n          for (i = 0; i < u.length; i++)\n            c.push(Ta(O(_(u[i], \"coordinates\")) ?? \"\"));\n          s.push({\n            type: \"Polygon\",\n            coordinates: c\n          });\n        } else if (e[a] === \"Track\" || e[a] === \"gx:Track\") {\n          const u = sc(t);\n          s.push({\n            type: \"LineString\",\n            coordinates: u.coords\n          }), u.times.length && l.push(u.times);\n        }\n    }\n  return { geoms: s, coordTimes: l };\n}\nfunction lc(r, e, t, n) {\n  const a = Ut(r), o = {}, i = O(_(r, \"name\")), s = O(_(r, \"address\")), l = O(_(r, \"description\")), u = _(r, \"TimeSpan\"), c = _(r, \"TimeStamp\"), p = _(r, \"ExtendedData\"), d = _(r, \"visibility\");\n  let f, h = O(_(r, \"styleUrl\")), m = _(r, \"LineStyle\"), y = _(r, \"PolyStyle\");\n  if (!a.geoms.length) return [];\n  if (i && (o.name = i), s && (o.address = s), h) {\n    h.startsWith(\"#\") || (h = `#${h}`), o.styleUrl = h, e[h] && (o.styleHash = e[h]), n[h] && (o.styleMapHash = n[h], o.styleHash = e[n[h].normal ?? \"\"]);\n    const g = t[o.styleHash ?? \"\"];\n    if (g) {\n      m || (m = _(g, \"LineStyle\")), y || (y = _(g, \"PolyStyle\"));\n      const x = _(g, \"IconStyle\");\n      if (x) {\n        const E = _(x, \"Icon\");\n        if (E) {\n          const C = O(_(E, \"href\"));\n          C && (o.icon = C);\n        }\n      }\n    }\n  }\n  if (l && (o.description = l), u) {\n    const g = O(_(u, \"begin\")), x = O(_(u, \"end\"));\n    g && x && (o.timespan = { begin: g, end: x });\n  }\n  if (c !== null && (o.timestamp = O(_(c, \"when\")) ?? (/* @__PURE__ */ new Date()).toISOString()), m !== null) {\n    const g = Ca(O(_(m, \"color\"))), x = g[0], E = g[1], C = Number.parseFloat(O(_(m, \"width\")) ?? \"\");\n    x && (o.stroke = x), Number.isNaN(E) || (o[\"stroke-opacity\"] = E), Number.isNaN(C) || (o[\"stroke-width\"] = C);\n  }\n  if (y) {\n    const g = Ca(O(_(y, \"color\"))), x = g[0], E = g[1], C = O(_(y, \"fill\")), T = O(_(y, \"outline\"));\n    x && (o.fill = x), Number.isNaN(E) || (o[\"fill-opacity\"] = E), C && (o[\"fill-opacity\"] = C === \"1\" ? o[\"fill-opacity\"] || 1 : 0), T && (o[\"stroke-opacity\"] = T === \"1\" ? o[\"stroke-opacity\"] || 1 : 0);\n  }\n  if (p) {\n    const g = G(p, \"Data\"), x = G(p, \"SimpleData\");\n    for (f = 0; f < g.length; f++)\n      o[g[f].getAttribute(\"name\") ?? \"\"] = O(_(g[f], \"value\")) ?? \"\";\n    for (f = 0; f < x.length; f++)\n      o[x[f].getAttribute(\"name\") ?? \"\"] = O(x[f]) ?? \"\";\n  }\n  d !== null && (o.visibility = O(d) ?? \"\"), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);\n  const w = {\n    type: \"Feature\",\n    geometry: a.geoms.length === 1 ? a.geoms[0] : {\n      type: \"GeometryCollection\",\n      geometries: a.geoms\n    },\n    properties: o\n  };\n  return Ze(r, \"id\") && (w.id = Ze(r, \"id\") ?? void 0), [w];\n}\nfunction jo(r, e) {\n  const t = G(r, e), n = [], a = [];\n  let o = [];\n  const i = t.length;\n  if (!(i < 2)) {\n    for (let s = 0; s < i; s++) {\n      const l = qo(t[s]);\n      n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));\n    }\n    return {\n      line: n,\n      times: a,\n      heartRates: o\n    };\n  }\n}\nfunction uc(r) {\n  const e = G(r, \"trkseg\"), t = [], n = [], a = [];\n  let o;\n  for (let s = 0; s < e.length; s++)\n    if (o = jo(e[s], \"trkpt\"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {\n      if (!a.length)\n        for (let l = 0; l < s; l++)\n          a.push(new Array(t[l].length).fill(null));\n      o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));\n    }\n  if (t.length === 0) return;\n  const i = {\n    ...En(r),\n    ...Uo(_(r, \"extensions\"))\n  };\n  return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {\n    type: \"Feature\",\n    properties: i,\n    geometry: {\n      type: \"LineString\",\n      coordinates: t[0]\n    }\n  } : {\n    type: \"Feature\",\n    properties: i,\n    geometry: {\n      type: \"MultiLineString\",\n      coordinates: t\n    }\n  };\n}\nfunction cc(r) {\n  const e = jo(r, \"rtept\");\n  return e === void 0 ? void 0 : {\n    type: \"Feature\",\n    properties: {\n      ...En(r),\n      ...Uo(_(r, \"extensions\"))\n    },\n    geometry: {\n      type: \"LineString\",\n      coordinates: e.line\n    }\n  };\n}\nfunction pc(r) {\n  return {\n    type: \"Feature\",\n    properties: { ...En(r), ...Xr(r, [\"sym\"]) },\n    geometry: {\n      type: \"Point\",\n      coordinates: qo(r).coordinates\n    }\n  };\n}\nfunction Uo(r) {\n  const e = {};\n  if (r) {\n    const t = _(r, \"line\");\n    if (t) {\n      const n = O(_(t, \"color\")), a = Number.parseFloat(O(_(t, \"opacity\")) ?? \"0\"), o = Number.parseFloat(O(_(t, \"width\")) ?? \"0\");\n      n && (e.stroke = n), Number.isNaN(a) || (e[\"stroke-opacity\"] = a), Number.isNaN(o) || (e[\"stroke-width\"] = o * 96 / 25.4);\n    }\n  }\n  return e;\n}\nfunction En(r) {\n  const e = Xr(r, [\"name\", \"cmt\", \"desc\", \"type\", \"time\", \"keywords\"]), t = G(r, \"link\");\n  if (t.length !== 0) {\n    e.links = [];\n    for (const n of Array.from(t)) {\n      const a = {\n        href: Ze(n, \"href\"),\n        ...Xr(n, [\"text\", \"type\"])\n      };\n      e.links.push(a);\n    }\n  }\n  return e;\n}\nfunction Ea(r) {\n  let e = 0;\n  if (!r || !r.length) return e;\n  for (let t = 0; t < r.length; t++)\n    e = (e << 5) - e + r.charCodeAt(t) | 0;\n  return e;\n}\nfunction G(r, e) {\n  return r.getElementsByTagName(e);\n}\nfunction Ze(r, e) {\n  return r.getAttribute(e);\n}\nfunction Aa(r, e) {\n  return Number.parseFloat(Ze(r, e) ?? \"0\");\n}\nfunction _(r, e) {\n  const t = G(r, e);\n  return t.length ? t[0] : null;\n}\nfunction fc(r) {\n  return r.normalize && r.normalize(), r;\n}\nfunction Do(r) {\n  return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);\n}\nfunction O(r) {\n  return r && fc(r), r && r.textContent;\n}\nfunction Xr(r, e) {\n  const t = {};\n  let n, a;\n  for (a = 0; a < e.length; a++)\n    n = _(r, e[a]), n && (t[e[a]] = O(n) ?? \"\");\n  return t;\n}\nfunction Bo(r) {\n  return Do(r.replace(/\\s*/g, \"\").split(\",\"));\n}\nfunction Ta(r) {\n  const e = r.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/), t = [];\n  for (const n of e) t.push(Bo(n));\n  return t;\n}\nfunction qo(r) {\n  const e = [Aa(r, \"lon\"), Aa(r, \"lat\")], t = _(r, \"ele\"), n = _(r, \"gpxtpx:hr\") || _(r, \"hr\"), a = _(r, \"time\");\n  let o;\n  return t && (o = Number.parseFloat(O(t) ?? \"0\"), Number.isNaN(o) || e.push(o)), {\n    coordinates: e,\n    time: a ? O(a) : null,\n    heartRate: n !== null ? Number.parseFloat(O(n) ?? \"0\") : null\n  };\n}\nfunction dc(r) {\n  let e = r;\n  try {\n    typeof e == \"string\" && (e = Cn(e));\n  } catch {\n    return null;\n  }\n  try {\n    return Oo(e);\n  } catch {\n  }\n  try {\n    return No(e);\n  } catch {\n  }\n  return null;\n}\nasync function hc(r, e = {}) {\n  const t = e.download ?? !1, n = await mc(r);\n  if (t) {\n    const a = e.filename ?? \"maptiler_screenshot.png\", o = document.createElement(\"a\");\n    o.style.display = \"none\", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {\n      document.body.removeChild(o), URL.revokeObjectURL(o.href);\n    }, 0);\n  }\n  return n;\n}\nfunction mc(r) {\n  return new Promise((e, t) => {\n    r.redraw(), r.once(\"idle\", () => {\n      r.getCanvas().toBlob((n) => {\n        if (!n) {\n          t(Error(\"Screenshot could not be created.\"));\n          return;\n        }\n        e(n);\n      }, \"image/png\");\n    });\n  });\n}\nconst Kr = [\n  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n  [\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n  [\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n  [\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n  [\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n  [\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n  [\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n  [\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n  [\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n  [\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"]\n];\nfunction dr() {\n  return Kr[~~(Math.random() * Kr.length)][~~(Math.random() * 4)];\n}\nfunction It() {\n  return `maptiler_source_${Ia()}`;\n}\nfunction Mt() {\n  return `maptiler_layer_${Ia()}`;\n}\nfunction Yr(r, e) {\n  if (e <= r[0].zoom)\n    return r[0].value;\n  if (e >= r[r.length - 1].zoom)\n    return r[r.length - 1].value;\n  for (let t = 0; t < r.length - 1; t += 1)\n    if (e >= r[t].zoom && e < r[t + 1].zoom) {\n      const n = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / n;\n      return a * r[t + 1].value + (1 - a) * r[t].value;\n    }\n  return 0;\n}\nfunction Fe(r) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap((e) => [e.zoom, e.value])];\n}\nfunction F(r) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap((e) => [e.zoom, e.value])];\n}\nfunction Vo(r, e) {\n  if (typeof e == \"number\" && typeof r == \"number\")\n    return 2 * e + r;\n  if (typeof e == \"number\" && Array.isArray(r))\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap((t) => [t.zoom, 2 * e + t.value])];\n  if (typeof r == \"number\" && Array.isArray(e))\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...e.flatMap((t) => [t.zoom, 2 * t.value + r])];\n  if (Array.isArray(r) && Array.isArray(e)) {\n    const t = Array.from(/* @__PURE__ */ new Set([...r.map((n) => n.zoom), ...e.map((n) => n.zoom)])).sort((n, a) => n < a ? -1 : 1);\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...t.flatMap((n) => [n, 2 * Yr(e, n) + Yr(r, n)])];\n  }\n  return 0;\n}\nfunction Go(r, e) {\n  return [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((t) => [t.propertyValue, t.value])];\n}\nfunction An(r) {\n  const e = r.trimStart(), t = `${e}${\" \".repeat(r.length - e.length)}`, n = Array.from(t);\n  if (!n.every((s) => s === \" \" || s === \"_\"))\n    throw new Error(\"A dash pattern must be composed only of whitespace and underscore characters.\");\n  if (!(n.some((s) => s === \"_\") && n.some((s) => s === \" \")))\n    throw new Error(\"A dash pattern must contain at least one underscore and one whitespace character\");\n  const i = [1];\n  for (let s = 1; s < n.length; s += 1) {\n    const l = n[s - 1], u = n[s];\n    l === u ? i[i.length - 1] += 1 : i.push(1);\n  }\n  return i;\n}\nfunction Wr(r, e) {\n  return [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((t) => [t.value, t.color])];\n}\nfunction Jr(r, e, t = !0) {\n  return t ? [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.025])],\n    2,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.05])],\n    4,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.1])],\n    8,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.25])],\n    16,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius])]\n  ] : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.value, n.pointRadius])];\n}\nfunction Ho(r, e, t = !0) {\n  return t ? [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n    0,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.025])],\n    2,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.05])],\n    4,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.1])],\n    8,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.25])],\n    16,\n    [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value])]\n  ] : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap((n) => [n.propertyValue, n.value])];\n}\nfunction Qr(r, e) {\n  return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", e],\n    ...r.getRawColorStops().flatMap((t) => {\n      const n = t.value, a = t.color;\n      return [n, a.length === 4 ? a[3] / 255 : 1];\n    })\n  ];\n}\nfunction Zo(r, e = 10) {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"heatmap-density\"],\n    ...Array.from({ length: e + 1 }, (t, n) => {\n      const a = n / e;\n      return [a, r.getColorHex(a)];\n    }).flat()\n  ];\n}\nfunction $t(r) {\n  const e = r.toString(16);\n  return e.length === 1 ? `0${e}` : e;\n}\nfunction yc(r) {\n  return `#${$t(r[0])}${$t(r[1])}${$t(r[2])}${r.length === 4 ? $t(r[3]) : \"\"}`;\n}\nclass A extends Array {\n  constructor(t = {}) {\n    super();\n    v(this, \"min\", 0);\n    v(this, \"max\", 1);\n    \"min\" in t && (this.min = t.min), \"max\" in t && (this.max = t.max), \"stops\" in t && this.setStops(t.stops, { clone: !1 });\n  }\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(t) {\n    return new A({\n      stops: t.map((n) => ({\n        value: n[0],\n        color: n[1]\n      }))\n    });\n  }\n  setStops(t, n = { clone: !0 }) {\n    const a = n.clone ? this.clone() : this;\n    a.length = 0;\n    let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n    for (let s = 0; s < t.length; s += 1)\n      o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({\n        value: t[s].value,\n        color: t[s].color.slice()\n        // we want to make sure we do a deep copy and not a reference\n      });\n    return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;\n  }\n  scale(t, n, a = { clone: !0 }) {\n    const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];\n    for (let p = 0; p < this.length; p += 1) {\n      const h = (this[p].value - i) / l * u + t;\n      o ? c.push({\n        value: h,\n        color: this[p].color.slice()\n      }) : this[p].value = h;\n    }\n    return o ? new A({ stops: c }) : this;\n  }\n  // for some reason, I had to reimplement this\n  at(t) {\n    return t < 0 ? this[this.length + t] : this[t];\n  }\n  clone() {\n    return new A({ stops: this.getRawColorStops() });\n  }\n  getRawColorStops() {\n    const t = [];\n    for (let n = 0; n < this.length; n += 1)\n      t.push({ value: this[n].value, color: this[n].color });\n    return t;\n  }\n  reverse(t = { clone: !0 }) {\n    const n = t.clone ? this.clone() : this;\n    for (let a = 0; a < ~~(n.length / 2); a += 1) {\n      const o = n[a].color;\n      n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;\n    }\n    return n;\n  }\n  getBounds() {\n    return { min: this.min, max: this.max };\n  }\n  getColor(t, n = { smooth: !0 }) {\n    if (t <= this[0].value)\n      return this[0].color;\n    if (t >= this.at(-1).value)\n      return this.at(-1).color;\n    for (let a = 0; a < this.length - 1; a += 1) {\n      if (t > this[a + 1].value)\n        continue;\n      const o = this[a].color;\n      if (!n.smooth)\n        return o.slice();\n      const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);\n      return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));\n    }\n    return [0, 0, 0];\n  }\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(t, n = {\n    smooth: !0,\n    withAlpha: !1\n  }) {\n    return yc(this.getColor(t, n));\n  }\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(t, n = { smooth: !0 }) {\n    const a = this.getBounds();\n    return this.getColor(a.min + t * (a.max - a.min), n);\n  }\n  getCanvasStrip(t = {\n    horizontal: !0,\n    size: 512,\n    smooth: !0\n  }) {\n    const n = document.createElement(\"canvas\");\n    n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;\n    const a = n.getContext(\"2d\");\n    if (!a) throw new Error(\"Canvs context is missing\");\n    const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;\n    for (let d = 0; d < s; d += 1) {\n      const f = this.getColor(l + d * p, {\n        smooth: t.smooth\n      });\n      i[d * 4] = f[0], i[d * 4 + 1] = f[1], i[d * 4 + 2] = f[2], i[d * 4 + 3] = f.length > 3 ? f[3] : 255;\n    }\n    return a.putImageData(o, 0, 0), n;\n  }\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(t, n = 15) {\n    const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);\n    let s;\n    if (t === \"ease-in-square\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = d ** 2, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-out-square\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 1 - (1 - d) ** 2, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-out-sqrt\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = d ** 0.5, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-in-sqrt\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 1 - (1 - d) ** 0.5, h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-out-exp\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 1 - 2 ** (-10 * d), h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else if (t === \"ease-in-exp\")\n      s = Array.from({ length: n }, (c, p) => {\n        const d = p * i, f = 2 ** (10 * d - 10), h = o.getColor(f);\n        return { value: d, color: h };\n      });\n    else\n      throw new Error(\"Invalid ressampling method.\");\n    return new A({ stops: s }).scale(a.min, a.max);\n  }\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart() {\n    const t = this.getRawColorStops();\n    t.unshift({\n      value: t[0].value,\n      color: t[0].color.slice()\n    }), t[1].value += 1e-3;\n    for (const n of t)\n      n.color.length === 3 && n.color.push(255);\n    return t[0].color[3] = 0, new A({ stops: t });\n  }\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart() {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\nconst Xo = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0, 0] },\n      { value: 1, color: [0, 0, 0, 0] }\n    ]\n  }),\n  GRAY: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new A({\n    stops: [\n      { value: 0, color: [0, 0, 131] },\n      { value: 0.125, color: [0, 60, 170] },\n      { value: 0.375, color: [5, 255, 255] },\n      { value: 0.625, color: [255, 255, 0] },\n      { value: 0.875, color: [250, 0, 0] },\n      { value: 1, color: [128, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new A({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 0.169, color: [253, 255, 2] },\n      { value: 0.173, color: [247, 255, 2] },\n      { value: 0.337, color: [0, 252, 4] },\n      { value: 0.341, color: [0, 252, 10] },\n      { value: 0.506, color: [1, 249, 255] },\n      { value: 0.671, color: [2, 0, 253] },\n      { value: 0.675, color: [8, 0, 253] },\n      { value: 0.839, color: [255, 0, 251] },\n      { value: 0.843, color: [255, 0, 245] },\n      { value: 1, color: [255, 0, 6] }\n    ]\n  }),\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.3, color: [230, 0, 0] },\n      { value: 0.6, color: [255, 210, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new A({\n    stops: [\n      { value: 0, color: [255, 0, 255] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new A({\n    stops: [\n      { value: 0, color: [0, 128, 102] },\n      { value: 1, color: [255, 255, 102] }\n    ]\n  }),\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new A({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 1, color: [255, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new A({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [0, 255, 128] }\n    ]\n  }),\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.376, color: [84, 84, 116] },\n      { value: 0.753, color: [169, 200, 200] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.804, color: [255, 160, 102] },\n      { value: 1, color: [255, 199, 127] }\n    ]\n  }),\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new A({\n    stops: [\n      { value: 0, color: [8, 29, 88] },\n      { value: 0.125, color: [37, 52, 148] },\n      { value: 0.25, color: [34, 94, 168] },\n      { value: 0.375, color: [29, 145, 192] },\n      { value: 0.5, color: [65, 182, 196] },\n      { value: 0.625, color: [127, 205, 187] },\n      { value: 0.75, color: [199, 233, 180] },\n      { value: 0.875, color: [237, 248, 217] },\n      { value: 1, color: [255, 255, 217] }\n    ]\n  }),\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new A({\n    stops: [\n      { value: 0, color: [0, 68, 27] },\n      { value: 0.125, color: [0, 109, 44] },\n      { value: 0.25, color: [35, 139, 69] },\n      { value: 0.375, color: [65, 171, 93] },\n      { value: 0.5, color: [116, 196, 118] },\n      { value: 0.625, color: [161, 217, 155] },\n      { value: 0.75, color: [199, 233, 192] },\n      { value: 0.875, color: [229, 245, 224] },\n      { value: 1, color: [247, 252, 245] }\n    ]\n  }),\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new A({\n    stops: [\n      { value: 0, color: [128, 0, 38] },\n      { value: 0.125, color: [189, 0, 38] },\n      { value: 0.25, color: [227, 26, 28] },\n      { value: 0.375, color: [252, 78, 42] },\n      { value: 0.5, color: [253, 141, 60] },\n      { value: 0.625, color: [254, 178, 76] },\n      { value: 0.75, color: [254, 217, 118] },\n      { value: 0.875, color: [255, 237, 160] },\n      { value: 1, color: [255, 255, 204] }\n    ]\n  }),\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new A({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new A({\n    stops: [\n      { value: 0, color: [5, 10, 172] },\n      { value: 0.35, color: [106, 137, 247] },\n      { value: 0.5, color: [190, 190, 190] },\n      { value: 0.6, color: [220, 170, 132] },\n      { value: 0.7, color: [230, 145, 90] },\n      { value: 1, color: [178, 10, 28] }\n    ]\n  }),\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new A({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 0.1, color: [51, 153, 255] },\n      { value: 0.2, color: [102, 204, 255] },\n      { value: 0.3, color: [153, 204, 255] },\n      { value: 0.4, color: [204, 204, 255] },\n      { value: 0.5, color: [255, 255, 255] },\n      { value: 0.6, color: [255, 204, 255] },\n      { value: 0.7, color: [255, 153, 255] },\n      { value: 0.8, color: [255, 102, 204] },\n      { value: 0.9, color: [255, 102, 102] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new A({\n    stops: [\n      { value: 0, color: [150, 0, 90] },\n      { value: 0.125, color: [0, 0, 200] },\n      { value: 0.25, color: [0, 25, 255] },\n      { value: 0.375, color: [0, 152, 255] },\n      { value: 0.5, color: [44, 255, 150] },\n      { value: 0.625, color: [151, 255, 0] },\n      { value: 0.75, color: [255, 234, 0] },\n      { value: 0.875, color: [255, 111, 0] },\n      { value: 1, color: [255, 0, 0] }\n    ]\n  }),\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new A({\n    stops: [\n      { value: 0, color: [12, 51, 131] },\n      { value: 0.25, color: [10, 136, 186] },\n      { value: 0.5, color: [242, 211, 56] },\n      { value: 0.75, color: [242, 143, 56] },\n      { value: 1, color: [217, 30, 30] }\n    ]\n  }),\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.2, color: [230, 0, 0] },\n      { value: 0.4, color: [230, 210, 0] },\n      { value: 0.7, color: [255, 255, 255] },\n      { value: 1, color: [160, 200, 255] }\n    ]\n  }),\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new A({\n    stops: [\n      { value: 0, color: [0, 0, 130] },\n      { value: 0.1, color: [0, 180, 180] },\n      { value: 0.2, color: [40, 210, 40] },\n      { value: 0.4, color: [230, 230, 50] },\n      { value: 0.6, color: [120, 70, 20] },\n      { value: 1, color: [255, 255, 255] }\n    ]\n  }),\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.15, color: [30, 0, 100] },\n      { value: 0.4, color: [120, 0, 100] },\n      { value: 0.6, color: [160, 90, 0] },\n      { value: 0.8, color: [230, 200, 0] },\n      { value: 1, color: [255, 250, 220] }\n    ]\n  }),\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new A({\n    stops: [\n      { value: 0, color: [68, 1, 84] },\n      { value: 0.13, color: [71, 44, 122] },\n      { value: 0.25, color: [59, 81, 139] },\n      { value: 0.38, color: [44, 113, 142] },\n      { value: 0.5, color: [33, 144, 141] },\n      { value: 0.63, color: [39, 173, 129] },\n      { value: 0.75, color: [92, 200, 99] },\n      { value: 0.88, color: [170, 220, 50] },\n      { value: 1, color: [253, 231, 37] }\n    ]\n  }),\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new A({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [31, 12, 72] },\n      { value: 0.25, color: [85, 15, 109] },\n      { value: 0.38, color: [136, 34, 106] },\n      { value: 0.5, color: [186, 54, 85] },\n      { value: 0.63, color: [227, 89, 51] },\n      { value: 0.75, color: [249, 140, 10] },\n      { value: 0.88, color: [249, 201, 50] },\n      { value: 1, color: [252, 255, 164] }\n    ]\n  }),\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new A({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [28, 16, 68] },\n      { value: 0.25, color: [79, 18, 123] },\n      { value: 0.38, color: [129, 37, 129] },\n      { value: 0.5, color: [181, 54, 122] },\n      { value: 0.63, color: [229, 80, 100] },\n      { value: 0.75, color: [251, 135, 97] },\n      { value: 0.88, color: [254, 194, 135] },\n      { value: 1, color: [252, 253, 191] }\n    ]\n  }),\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new A({\n    stops: [\n      { value: 0, color: [13, 8, 135] },\n      { value: 0.13, color: [75, 3, 161] },\n      { value: 0.25, color: [125, 3, 168] },\n      { value: 0.38, color: [168, 34, 150] },\n      { value: 0.5, color: [203, 70, 121] },\n      { value: 0.63, color: [229, 107, 93] },\n      { value: 0.75, color: [248, 148, 65] },\n      { value: 0.88, color: [253, 195, 40] },\n      { value: 1, color: [240, 249, 33] }\n    ]\n  }),\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new A({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [172, 0, 187] },\n      { value: 0.25, color: [219, 0, 170] },\n      { value: 0.38, color: [255, 0, 130] },\n      { value: 0.5, color: [255, 63, 74] },\n      { value: 0.63, color: [255, 123, 0] },\n      { value: 0.75, color: [234, 176, 0] },\n      { value: 0.88, color: [190, 228, 0] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new A({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [116, 0, 218] },\n      { value: 0.25, color: [98, 74, 237] },\n      { value: 0.38, color: [68, 146, 231] },\n      { value: 0.5, color: [0, 204, 197] },\n      { value: 0.63, color: [0, 247, 146] },\n      { value: 0.75, color: [0, 255, 88] },\n      { value: 0.88, color: [40, 255, 8] },\n      { value: 1, color: [147, 255, 0] }\n    ]\n  }),\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new A({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.1, color: [199, 0, 180] },\n      { value: 0.2, color: [255, 0, 121] },\n      { value: 0.3, color: [255, 108, 0] },\n      { value: 0.4, color: [222, 194, 0] },\n      { value: 0.5, color: [150, 255, 0] },\n      { value: 0.6, color: [0, 255, 55] },\n      { value: 0.7, color: [0, 246, 150] },\n      { value: 0.8, color: [50, 167, 222] },\n      { value: 0.9, color: [103, 51, 235] },\n      { value: 1, color: [124, 0, 186] }\n    ]\n  }),\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new A({\n    stops: [\n      { value: 0, color: [40, 26, 44] },\n      { value: 0.13, color: [59, 49, 90] },\n      { value: 0.25, color: [64, 76, 139] },\n      { value: 0.38, color: [63, 110, 151] },\n      { value: 0.5, color: [72, 142, 158] },\n      { value: 0.63, color: [85, 174, 163] },\n      { value: 0.75, color: [120, 206, 163] },\n      { value: 0.88, color: [187, 230, 172] },\n      { value: 1, color: [253, 254, 204] }\n    ]\n  }),\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new A({\n    stops: [\n      { value: 0, color: [47, 15, 62] },\n      { value: 0.13, color: [87, 23, 86] },\n      { value: 0.25, color: [130, 28, 99] },\n      { value: 0.38, color: [171, 41, 96] },\n      { value: 0.5, color: [206, 67, 86] },\n      { value: 0.63, color: [230, 106, 84] },\n      { value: 0.75, color: [242, 149, 103] },\n      { value: 0.88, color: [249, 193, 135] },\n      { value: 1, color: [254, 237, 176] }\n    ]\n  }),\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new A({\n    stops: [\n      { value: 0, color: [18, 36, 20] },\n      { value: 0.13, color: [25, 63, 41] },\n      { value: 0.25, color: [24, 91, 59] },\n      { value: 0.38, color: [13, 119, 72] },\n      { value: 0.5, color: [18, 148, 80] },\n      { value: 0.63, color: [80, 173, 89] },\n      { value: 0.75, color: [132, 196, 122] },\n      { value: 0.88, color: [175, 221, 162] },\n      { value: 1, color: [215, 249, 208] }\n    ]\n  }),\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new A({\n    stops: [\n      { value: 0, color: [54, 14, 36] },\n      { value: 0.13, color: [89, 23, 80] },\n      { value: 0.25, color: [110, 45, 132] },\n      { value: 0.38, color: [120, 77, 178] },\n      { value: 0.5, color: [120, 113, 213] },\n      { value: 0.63, color: [115, 151, 228] },\n      { value: 0.75, color: [134, 185, 227] },\n      { value: 0.88, color: [177, 214, 227] },\n      { value: 1, color: [230, 241, 241] }\n    ]\n  }),\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new A({\n    stops: [\n      { value: 0, color: [30, 4, 110] },\n      { value: 0.13, color: [47, 14, 176] },\n      { value: 0.25, color: [41, 45, 236] },\n      { value: 0.38, color: [25, 99, 212] },\n      { value: 0.5, color: [68, 131, 200] },\n      { value: 0.63, color: [114, 156, 197] },\n      { value: 0.75, color: [157, 181, 203] },\n      { value: 0.88, color: [200, 208, 216] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new A({\n    stops: [\n      { value: 0, color: [60, 9, 18] },\n      { value: 0.13, color: [100, 17, 27] },\n      { value: 0.25, color: [142, 20, 29] },\n      { value: 0.38, color: [177, 43, 27] },\n      { value: 0.5, color: [192, 87, 63] },\n      { value: 0.63, color: [205, 125, 105] },\n      { value: 0.75, color: [216, 162, 148] },\n      { value: 0.88, color: [227, 199, 193] },\n      { value: 1, color: [241, 237, 236] }\n    ]\n  }),\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new A({\n    stops: [\n      { value: 0, color: [64, 5, 5] },\n      { value: 0.13, color: [106, 6, 15] },\n      { value: 0.25, color: [144, 26, 7] },\n      { value: 0.38, color: [168, 64, 3] },\n      { value: 0.5, color: [188, 100, 4] },\n      { value: 0.63, color: [206, 136, 11] },\n      { value: 0.75, color: [220, 174, 25] },\n      { value: 0.88, color: [231, 215, 44] },\n      { value: 1, color: [248, 254, 105] }\n    ]\n  }),\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new A({\n    stops: [\n      { value: 0, color: [51, 20, 24] },\n      { value: 0.13, color: [90, 32, 35] },\n      { value: 0.25, color: [129, 44, 34] },\n      { value: 0.38, color: [159, 68, 25] },\n      { value: 0.5, color: [182, 99, 19] },\n      { value: 0.63, color: [199, 134, 22] },\n      { value: 0.75, color: [212, 171, 35] },\n      { value: 0.88, color: [221, 210, 54] },\n      { value: 1, color: [225, 253, 75] }\n    ]\n  }),\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new A({\n    stops: [\n      { value: 0, color: [145, 105, 18] },\n      { value: 0.13, color: [184, 71, 38] },\n      { value: 0.25, color: [186, 58, 115] },\n      { value: 0.38, color: [160, 71, 185] },\n      { value: 0.5, color: [110, 97, 218] },\n      { value: 0.63, color: [50, 123, 164] },\n      { value: 0.75, color: [31, 131, 110] },\n      { value: 0.88, color: [77, 129, 34] },\n      { value: 1, color: [145, 105, 18] }\n    ]\n  }),\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new A({\n    stops: [\n      { value: 0, color: [42, 24, 108] },\n      { value: 0.13, color: [33, 50, 162] },\n      { value: 0.25, color: [15, 90, 145] },\n      { value: 0.38, color: [40, 118, 137] },\n      { value: 0.5, color: [59, 146, 135] },\n      { value: 0.63, color: [79, 175, 126] },\n      { value: 0.75, color: [120, 203, 104] },\n      { value: 0.88, color: [193, 221, 100] },\n      { value: 1, color: [253, 239, 154] }\n    ]\n  }),\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new A({\n    stops: [\n      { value: 0, color: [4, 35, 51] },\n      { value: 0.13, color: [23, 51, 122] },\n      { value: 0.25, color: [85, 59, 157] },\n      { value: 0.38, color: [129, 79, 143] },\n      { value: 0.5, color: [175, 95, 130] },\n      { value: 0.63, color: [222, 112, 101] },\n      { value: 0.75, color: [249, 146, 66] },\n      { value: 0.88, color: [249, 196, 65] },\n      { value: 1, color: [232, 250, 91] }\n    ]\n  }),\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new A({\n    stops: [\n      { value: 0, color: [34, 31, 27] },\n      { value: 0.13, color: [65, 50, 41] },\n      { value: 0.25, color: [98, 69, 52] },\n      { value: 0.38, color: [131, 89, 57] },\n      { value: 0.5, color: [161, 112, 59] },\n      { value: 0.63, color: [185, 140, 66] },\n      { value: 0.75, color: [202, 174, 88] },\n      { value: 0.88, color: [216, 209, 126] },\n      { value: 1, color: [233, 246, 171] }\n    ]\n  }),\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new A({\n    stops: [\n      { value: 0, color: [17, 32, 64] },\n      { value: 0.13, color: [35, 52, 116] },\n      { value: 0.25, color: [29, 81, 156] },\n      { value: 0.38, color: [31, 113, 162] },\n      { value: 0.5, color: [50, 144, 169] },\n      { value: 0.63, color: [87, 173, 176] },\n      { value: 0.75, color: [149, 196, 189] },\n      { value: 0.88, color: [203, 221, 211] },\n      { value: 1, color: [254, 251, 230] }\n    ]\n  }),\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new A({\n    stops: [\n      { value: 0, color: [23, 35, 19] },\n      { value: 0.13, color: [24, 64, 38] },\n      { value: 0.25, color: [11, 95, 45] },\n      { value: 0.38, color: [39, 123, 35] },\n      { value: 0.5, color: [95, 146, 12] },\n      { value: 0.63, color: [152, 165, 18] },\n      { value: 0.75, color: [201, 186, 69] },\n      { value: 0.88, color: [233, 216, 137] },\n      { value: 1, color: [255, 253, 205] }\n    ]\n  }),\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new A({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.07, color: [22, 5, 59] },\n      { value: 0.13, color: [60, 4, 105] },\n      { value: 0.2, color: [109, 1, 135] },\n      { value: 0.27, color: [161, 0, 147] },\n      { value: 0.33, color: [210, 2, 142] },\n      { value: 0.4, color: [251, 11, 123] },\n      { value: 0.47, color: [255, 29, 97] },\n      { value: 0.53, color: [255, 54, 69] },\n      { value: 0.6, color: [255, 85, 46] },\n      { value: 0.67, color: [255, 120, 34] },\n      { value: 0.73, color: [255, 157, 37] },\n      { value: 0.8, color: [241, 191, 57] },\n      { value: 0.87, color: [224, 220, 93] },\n      { value: 0.93, color: [218, 241, 142] },\n      { value: 1, color: [227, 253, 198] }\n    ]\n  }),\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new A({\n    stops: [\n      { value: 0, color: [0, 32, 77, 255] },\n      { value: 0.125, color: [5, 54, 110, 255] },\n      { value: 0.25, color: [65, 77, 108, 255] },\n      { value: 0.375, color: [97, 100, 111, 255] },\n      { value: 0.5, color: [125, 124, 121, 255] },\n      { value: 0.625, color: [156, 149, 120, 255] },\n      { value: 0.75, color: [190, 175, 111, 255] },\n      { value: 0.875, color: [225, 204, 94, 255] },\n      { value: 1, color: [255, 235, 70, 255] }\n    ]\n  }),\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new A({\n    stops: [\n      { value: 0, color: [48, 18, 59, 255] },\n      { value: 0.125, color: [70, 107, 227, 255] },\n      { value: 0.25, color: [40, 187, 236, 255] },\n      { value: 0.375, color: [49, 242, 153, 255] },\n      { value: 0.5, color: [162, 252, 60, 255] },\n      { value: 0.625, color: [237, 208, 58, 255] },\n      { value: 0.75, color: [251, 128, 34, 255] },\n      { value: 0.875, color: [210, 49, 5, 255] },\n      { value: 1, color: [122, 4, 3, 255] }\n    ]\n  }),\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new A({\n    stops: [\n      { value: 0, color: [250, 235, 221, 0] },\n      { value: 0.133, color: [250, 235, 221, 255] },\n      { value: 0.266, color: [246, 170, 130, 255] },\n      { value: 0.4, color: [240, 96, 67, 255] },\n      { value: 0.533, color: [203, 27, 79, 255] },\n      { value: 0.666, color: [132, 30, 90, 255] },\n      { value: 0.8, color: [63, 27, 68, 255] },\n      { value: 1, color: [3, 5, 26, 255] }\n    ]\n  }),\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new A({\n    stops: [\n      { value: 0, color: [11, 4, 5, 255] },\n      { value: 0.125, color: [43, 28, 53, 255] },\n      { value: 0.25, color: [62, 53, 107, 255] },\n      { value: 0.375, color: [59, 86, 152, 255] },\n      { value: 0.5, color: [53, 123, 162, 255] },\n      { value: 0.625, color: [53, 158, 170, 255] },\n      { value: 0.75, color: [73, 193, 173, 255] },\n      { value: 0.875, color: [150, 221, 181, 255] },\n      { value: 1, color: [222, 245, 229, 255] }\n    ]\n  })\n};\nasync function gc(r, e, t = {}) {\n  var a, o;\n  if (!e.sourceId && !e.data)\n    throw new Error(\"Creating a polyline layer requires an existing .sourceId or a valid .data property\");\n  let n = e.data;\n  if (typeof n == \"string\") {\n    if (Yt(n))\n      n = `https://api.maptiler.com/data/${e.data}/features.json?key=${j.apiKey}`;\n    else if (((a = n.split(\".\").pop()) == null ? void 0 : a.toLowerCase().trim()) === \"gpx\") {\n      const s = await (await fetch(n, t)).text();\n      n = Oo(s);\n    } else if (((o = n.split(\".\").pop()) == null ? void 0 : o.toLowerCase().trim()) === \"kml\") {\n      const s = await (await fetch(n, t)).text();\n      n = No(s);\n    } else {\n      const i = xi(n) ?? dc(n);\n      i && (n = i);\n    }\n    if (!n)\n      throw new Error(\"Polyline data was provided as string but is incompatible with valid formats.\");\n  }\n  return vc(r, {\n    ...e,\n    data: n\n  });\n}\nfunction vc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? It(), n = e.layerId ?? Mt(), a = {\n    polylineLayerId: n,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: t\n  };\n  e.data && !r.getSource(t) && r.addSource(t, {\n    type: \"geojson\",\n    data: e.data\n  });\n  const o = e.lineWidth ?? 3, i = e.lineColor ?? dr(), s = e.lineOpacity ?? 1, l = e.lineBlur ?? 0, u = e.lineGapWidth ?? 0;\n  let c = e.lineDashArray ?? null;\n  const p = e.outlineWidth ?? 1, d = e.outlineColor ?? \"#FFFFFF\", f = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0;\n  if (typeof c == \"string\" && (c = An(c)), e.outline === !0) {\n    const m = `${n}_outline`;\n    a.polylineOutlineLayerId = m, r.addLayer(\n      {\n        id: m,\n        type: \"line\",\n        source: t,\n        layout: {\n          \"line-join\": e.lineJoin ?? \"round\",\n          \"line-cap\": e.lineCap ?? \"round\"\n        },\n        minzoom: e.minzoom ?? 0,\n        maxzoom: e.maxzoom ?? 23,\n        paint: {\n          \"line-opacity\": typeof f == \"number\" ? f : F(f),\n          \"line-color\": typeof d == \"string\" ? d : Fe(d),\n          \"line-width\": Vo(o, p),\n          \"line-blur\": typeof h == \"number\" ? h : F(h)\n        }\n      },\n      e.beforeId\n    );\n  }\n  return r.addLayer(\n    {\n      id: n,\n      type: \"line\",\n      source: t,\n      layout: {\n        \"line-join\": e.lineJoin ?? \"round\",\n        \"line-cap\": e.lineCap ?? \"round\"\n      },\n      minzoom: e.minzoom ?? 0,\n      maxzoom: e.maxzoom ?? 23,\n      paint: {\n        \"line-opacity\": typeof s == \"number\" ? s : F(s),\n        \"line-color\": typeof i == \"string\" ? i : Fe(i),\n        \"line-width\": typeof o == \"number\" ? o : F(o),\n        \"line-blur\": typeof l == \"number\" ? l : F(l),\n        \"line-gap-width\": typeof u == \"number\" ? u : F(u),\n        // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n        // results in no showing the line while it should have the same behavior\n        // of not adding the property \"line-dasharray\" as all.\n        // As a workaround, we are inlining the addition of the prop with a conditional\n        // which is less readable.\n        ...c && { \"line-dasharray\": c }\n      }\n    },\n    e.beforeId\n  ), a;\n}\nfunction bc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? It(), n = e.layerId ?? Mt(), a = {\n    polygonLayerId: n,\n    polygonOutlineLayerId: e.outline ? `${n}_outline` : \"\",\n    polygonSourceId: t\n  };\n  if (e.data && !r.getSource(t)) {\n    let m = e.data;\n    typeof m == \"string\" && Yt(m) && (m = `https://api.maptiler.com/data/${m}/features.json?key=${j.apiKey}`), r.addSource(t, {\n      type: \"geojson\",\n      data: m\n    });\n  }\n  let o = e.outlineDashArray ?? null;\n  const i = e.outlineWidth ?? 1, s = e.outlineColor ?? \"#FFFFFF\", l = e.outlineOpacity ?? 1, u = e.outlineBlur ?? 0, c = e.fillColor ?? dr(), p = e.fillOpacity ?? 1, d = e.outlinePosition ?? \"center\", f = e.pattern ?? null;\n  typeof o == \"string\" && (o = An(o));\n  const h = (m = null) => {\n    if (r.addLayer(\n      {\n        id: n,\n        type: \"fill\",\n        source: t,\n        minzoom: e.minzoom ?? 0,\n        maxzoom: e.maxzoom ?? 23,\n        paint: {\n          \"fill-color\": typeof c == \"string\" ? c : Fe(c),\n          \"fill-opacity\": typeof p == \"number\" ? p : F(p),\n          // Adding a pattern if provided\n          ...m && { \"fill-pattern\": m }\n        }\n      },\n      e.beforeId\n    ), e.outline === !0) {\n      let y;\n      d === \"inside\" ? typeof i == \"number\" ? y = 0.5 * i : y = F(\n        i.map(({ zoom: w, value: g }) => ({\n          zoom: w,\n          value: 0.5 * g\n        }))\n      ) : d === \"outside\" ? typeof i == \"number\" ? y = -0.5 * i : y = F(\n        i.map((w) => ({\n          zoom: w.zoom,\n          value: -0.5 * w.value\n        }))\n      ) : y = 0, r.addLayer(\n        {\n          id: a.polygonOutlineLayerId,\n          type: \"line\",\n          source: t,\n          layout: {\n            \"line-join\": e.outlineJoin ?? \"round\",\n            \"line-cap\": e.outlineCap ?? \"butt\"\n          },\n          minzoom: e.minzoom ?? 0,\n          maxzoom: e.maxzoom ?? 23,\n          paint: {\n            \"line-opacity\": typeof l == \"number\" ? l : F(l),\n            \"line-color\": typeof s == \"string\" ? s : Fe(s),\n            \"line-width\": typeof i == \"number\" ? i : F(i),\n            \"line-blur\": typeof u == \"number\" ? u : F(u),\n            \"line-offset\": y,\n            // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n            // results in no showing the line while it should have the same behavior\n            // of not adding the property \"line-dasharray\" as all.\n            // As a workaround, we are inlining the addition of the prop with a conditional\n            // which is less readable.\n            ...o && {\n              \"line-dasharray\": o\n            }\n          }\n        },\n        e.beforeId\n      );\n    }\n  };\n  return f ? r.hasImage(f) ? h(f) : r.loadImage(f).then((m) => {\n    r.addImage(f, m.data), h(f);\n  }).catch((m) => {\n    console.error(\"Could not load the pattern image.\", m.message), h();\n  }) : h(), a;\n}\nfunction wc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.minPointRadius ?? 10, n = e.maxPointRadius ?? 50, a = e.cluster ?? !1, o = 20, i = Array.isArray(e.pointColor) ? e.pointColor : Xo.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample(\"ease-out-square\"), s = i.getBounds(), l = e.sourceId ?? It(), u = e.layerId ?? Mt(), c = e.showLabel ?? a, p = e.alignOnViewport ?? !0, d = e.outline ?? !1, f = e.outlineOpacity ?? 1, h = e.outlineWidth ?? 1, m = e.outlineColor ?? \"#FFFFFF\";\n  let y;\n  const w = e.zoomCompensation ?? !0, g = e.minzoom ?? 0, x = e.maxzoom ?? 23;\n  typeof e.pointOpacity == \"number\" ? y = e.pointOpacity : Array.isArray(e.pointOpacity) ? y = F(e.pointOpacity) : e.cluster ? y = Qr(i, \"point_count\") : e.property ? y = Qr(i, e.property) : y = F([\n    { zoom: g, value: 0 },\n    { zoom: g + 0.25, value: 1 },\n    { zoom: x - 0.25, value: 1 },\n    { zoom: x, value: 0 }\n  ]);\n  const E = {\n    pointLayerId: u,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: l\n  };\n  if (e.data && !r.getSource(l)) {\n    let C = e.data;\n    typeof C == \"string\" && Yt(C) && (C = `https://api.maptiler.com/data/${C}/features.json?key=${j.apiKey}`), r.addSource(l, {\n      type: \"geojson\",\n      data: C,\n      cluster: a\n    });\n  }\n  if (a) {\n    E.clusterLayerId = `${u}_cluster`;\n    const C = Array.from({ length: o }, (T, N) => {\n      const ve = s.min + N * (s.max - s.min) / (o - 1);\n      return {\n        value: ve,\n        pointRadius: t + (n - t) * (N / (o - 1)) ** 0.5,\n        color: i.getColorHex(ve)\n      };\n    });\n    r.addLayer(\n      {\n        id: E.clusterLayerId,\n        type: \"circle\",\n        source: l,\n        filter: [\"has\", \"point_count\"],\n        paint: {\n          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-color\": typeof e.pointColor == \"string\" ? e.pointColor : Wr(C, \"point_count\"),\n          \"circle-radius\": typeof e.pointRadius == \"number\" ? e.pointRadius : Array.isArray(e.pointRadius) ? F(e.pointRadius) : Jr(C, \"point_count\", !1),\n          \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-opacity\": y,\n          ...d && {\n            \"circle-stroke-opacity\": typeof f == \"number\" ? f : F(f),\n            \"circle-stroke-width\": typeof h == \"number\" ? h : F(h),\n            \"circle-stroke-color\": typeof m == \"string\" ? m : Fe(m)\n          }\n        },\n        minzoom: g,\n        maxzoom: x\n      },\n      e.beforeId\n    ), r.addLayer(\n      {\n        id: E.pointLayerId,\n        type: \"circle\",\n        source: l,\n        filter: [\"!\", [\"has\", \"point_count\"]],\n        paint: {\n          \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n          \"circle-color\": typeof e.pointColor == \"string\" ? e.pointColor : i.getColorHex(i.getBounds().min),\n          \"circle-radius\": typeof e.pointRadius == \"number\" ? e.pointRadius : Array.isArray(e.pointRadius) ? F(e.pointRadius) : C[0].pointRadius * 0.75,\n          \"circle-opacity\": y,\n          ...d && {\n            \"circle-stroke-opacity\": typeof f == \"number\" ? f : F(f),\n            \"circle-stroke-width\": typeof h == \"number\" ? h : F(h),\n            \"circle-stroke-color\": typeof m == \"string\" ? m : Fe(m)\n          }\n        },\n        minzoom: g,\n        maxzoom: x\n      },\n      e.beforeId\n    );\n  } else {\n    let C = typeof e.pointColor == \"string\" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : dr(), T = typeof e.pointRadius == \"number\" ? w ? F([\n      { zoom: 0, value: e.pointRadius * 0.025 },\n      { zoom: 2, value: e.pointRadius * 0.05 },\n      { zoom: 4, value: e.pointRadius * 0.1 },\n      { zoom: 8, value: e.pointRadius * 0.25 },\n      { zoom: 16, value: e.pointRadius * 1 }\n    ]) : e.pointRadius : Array.isArray(e.pointRadius) ? F(e.pointRadius) : w ? F([\n      { zoom: 0, value: t * 0.05 },\n      { zoom: 2, value: t * 0.1 },\n      { zoom: 4, value: t * 0.2 },\n      { zoom: 8, value: t * 0.5 },\n      { zoom: 16, value: t * 1 }\n    ]) : t;\n    if (e.property && Array.isArray(e.pointColor)) {\n      const N = Array.from({ length: o }, (ve, Ye) => {\n        const We = s.min + Ye * (s.max - s.min) / (o - 1);\n        return {\n          value: We,\n          pointRadius: typeof e.pointRadius == \"number\" ? e.pointRadius : t + (n - t) * (Ye / (o - 1)) ** 0.5,\n          color: typeof e.pointColor == \"string\" ? e.pointColor : i.getColorHex(We)\n        };\n      });\n      C = Wr(N, e.property), T = Jr(N, e.property, w);\n    }\n    r.addLayer(\n      {\n        id: E.pointLayerId,\n        type: \"circle\",\n        source: l,\n        layout: {\n          // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n          \"circle-sort-key\": e.property ? [\"/\", 1, [\"get\", e.property]] : 0\n        },\n        paint: {\n          \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\",\n          // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-color\": C,\n          \"circle-opacity\": y,\n          \"circle-radius\": T,\n          ...d && {\n            \"circle-stroke-opacity\": typeof f == \"number\" ? f : F(f),\n            \"circle-stroke-width\": typeof h == \"number\" ? h : F(h),\n            \"circle-stroke-color\": typeof m == \"string\" ? m : Fe(m)\n          }\n        },\n        minzoom: g,\n        maxzoom: x\n      },\n      e.beforeId\n    );\n  }\n  if (c !== !1 && (e.cluster || e.property)) {\n    E.labelLayerId = `${u}_label`;\n    const C = e.labelColor ?? \"#fff\", T = e.labelSize ?? 12;\n    r.addLayer(\n      {\n        id: E.labelLayerId,\n        type: \"symbol\",\n        source: l,\n        filter: [\"has\", e.cluster ? \"point_count\" : e.property],\n        layout: {\n          \"text-field\": e.cluster ? \"{point_count_abbreviated}\" : `{${e.property}}`,\n          \"text-font\": [\"Noto Sans Regular\"],\n          \"text-size\": T,\n          \"text-pitch-alignment\": p ? \"viewport\" : \"map\",\n          \"symbol-sort-key\": [\"/\", 1, [\"get\", e.cluster ? \"point_count\" : e.property]]\n          // so that the largest value goes on top\n        },\n        paint: {\n          \"text-color\": C,\n          \"text-opacity\": y\n        },\n        minzoom: g,\n        maxzoom: x\n      },\n      e.beforeId\n    );\n  }\n  return E;\n}\nfunction Sc(r, e) {\n  if (e.layerId && r.getLayer(e.layerId))\n    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? It(), n = e.layerId ?? Mt(), a = e.minzoom ?? 0, o = e.maxzoom ?? 23, i = e.zoomCompensation ?? !0, s = e.opacity ?? [\n    { zoom: a, value: 0 },\n    { zoom: a + 0.25, value: 1 },\n    { zoom: o - 0.25, value: 1 },\n    { zoom: o, value: 0 }\n  ];\n  let l = Array.isArray(e.colorRamp) ? e.colorRamp : Xo.TURBO.transparentStart();\n  const u = l.getBounds();\n  (u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());\n  const c = e.intensity ?? [\n    { zoom: 0, value: 0.01 },\n    { zoom: 4, value: 0.2 },\n    { zoom: 16, value: 1 }\n  ], p = e.property ?? null, d = e.weight ?? 1;\n  let f = 1;\n  p ? typeof d == \"number\" ? (f = d, typeof e.weight == \"number\" && console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\")) : Array.isArray(d) ? f = Go(d, p) : console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\") : typeof d == \"number\" ? f = d : Array.isArray(d) && console.warn(\"The options `.propertyValueWeights` can only be used when `.property` is provided.\");\n  const h = [\n    { zoom: 0, value: 50 * 0.025 },\n    { zoom: 2, value: 50 * 0.05 },\n    { zoom: 4, value: 50 * 0.1 },\n    { zoom: 8, value: 50 * 0.25 },\n    { zoom: 16, value: 50 }\n  ], m = e.radius ?? (i ? h : 10);\n  let y = 1;\n  typeof m == \"number\" ? y = m : Array.isArray(m) && \"zoom\" in m[0] ? y = F(m) : p && Array.isArray(m) && \"propertyValue\" in m[0] ? y = Ho(m, p, i) : !p && Array.isArray(m) && \"propertyValue\" in m[0] ? (y = F(h), console.warn(\"The option `.radius` can only be property-driven if the option `.property` is provided.\")) : y = F(h);\n  const w = {\n    heatmapLayerId: n,\n    heatmapSourceId: t\n  };\n  if (e.data && !r.getSource(t)) {\n    let g = e.data;\n    typeof g == \"string\" && Yt(g) && (g = `https://api.maptiler.com/data/${g}/features.json?key=${j.apiKey}`), r.addSource(t, {\n      type: \"geojson\",\n      data: g\n    });\n  }\n  return r.addLayer(\n    {\n      id: n,\n      type: \"heatmap\",\n      source: t,\n      minzoom: a,\n      maxzoom: o,\n      paint: {\n        \"heatmap-weight\": f,\n        \"heatmap-intensity\": typeof c == \"number\" ? c : F(c),\n        \"heatmap-color\": Zo(l),\n        \"heatmap-radius\": y,\n        \"heatmap-opacity\": typeof s == \"number\" ? s : F(s)\n      }\n    },\n    e.beforeId\n  ), w;\n}\nconst Qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  addHeatmap: Sc,\n  addPoint: wc,\n  addPolygon: bc,\n  addPolyline: gc,\n  colorDrivenByProperty: Wr,\n  colorPalettes: Kr,\n  computeRampedOutlineWidth: Vo,\n  dashArrayMaker: An,\n  generateRandomLayerName: Mt,\n  generateRandomSourceName: It,\n  getRandomColor: dr,\n  heatmapIntensityFromColorRamp: Zo,\n  lerpZoomNumberValues: Yr,\n  opacityDrivenByProperty: Qr,\n  paintColorOptionsToPaintSpec: Fe,\n  radiusDrivenByProperty: Jr,\n  radiusDrivenByPropertyHeatmap: Ho,\n  rampedOptionsToLayerPaintSpec: F,\n  rampedPropertyValueWeight: Go,\n  takeScreenshot: hc\n}, Symbol.toStringTag, { value: \"Module\" }));\nwi();\nfunction xc() {\n  return \"3.8.0\";\n}\nconst ep = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map, tp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker, rp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup, np = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Style, ap = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CanvasSource, op = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeoJSONSource, ip = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ImageSource, sp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterTileSource, lp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.RasterDEMTileSource, up = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VectorTileSource, cp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.VideoSource, pp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl, fp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.GeolocateControl, dp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl, hp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.LogoControl, mp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScaleControl, yp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.FullscreenControl, gp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TerrainControl, vp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.BoxZoomHandler, bp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.ScrollZoomHandler, wp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.CooperativeGesturesHandler, Sp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.KeyboardHandler, xp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.TwoFingersTouchPitchHandler, kp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapWheelEvent, Lp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapTouchEvent, Cp = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.MapMouseEvent, Ep = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.config, Ap = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.getVersion, {\n  setRTLTextPlugin: Tp,\n  getRTLTextPluginStatus: _p,\n  LngLat: kc,\n  LngLatBounds: Ip,\n  MercatorCoordinate: en,\n  Evented: Mp,\n  AJAXError: Pp,\n  prewarm: Rp,\n  clearPrewarmedResources: zp,\n  Hash: Fp,\n  Point: Ko,\n  EdgeInsets: $p,\n  DragRotateHandler: Op,\n  DragPanHandler: Np,\n  TwoFingersTouchZoomRotateHandler: jp,\n  DoubleClickZoomHandler: Up,\n  TwoFingersTouchZoomHandler: Dp,\n  TwoFingersTouchRotateHandler: Bp,\n  getWorkerCount: qp,\n  setWorkerCount: Vp,\n  getMaxParallelImageRequests: Gp,\n  setMaxParallelImageRequests: Hp,\n  getWorkerUrl: Zp,\n  setWorkerUrl: Xp,\n  addSourceType: Kp,\n  importScriptInWorkers: Yp,\n  addProtocol: Wp,\n  removeProtocol: Jp\n} = maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\n\n//# sourceMappingURL=maptiler-sdk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hcHRpbGVyL3Nkay9kaXN0L21hcHRpbGVyLXNkay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUM0QjtBQUMyUDtBQUNzVztBQUNybUI7QUFDUTtBQUNTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEtBQUssc0RBQUU7QUFDUDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YseUVBQUU7QUFDbEY7QUFDQTtBQUNBLHlGQUF5Rix5RUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQUU7QUFDYixpQkFBaUIsbUNBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlBBQTJQLGFBQWE7QUFDeFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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LFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjLFFBQVEsZ0JBQWdCLFFBQVEsZ0JBQWdCLFFBQVEsaUJBQWlCLFNBQVMsZUFBZSxTQUFTLDhCQUE4QixTQUFTLGdCQUFnQixRQUFRLGVBQWUsU0FBUyxlQUFlLFNBQVMsa0JBQWtCLFNBQVMsbUJBQW1CLFNBQVMsaUJBQWlCLFNBQVMsb0JBQW9CLFNBQVMscUJBQXFCLFNBQVMsdUJBQXVCLFNBQVM7QUFDaGE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRSxJQUFJLElBQUksc0RBQXNELEVBQUU7QUFDL0csSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU0sWUFBWSxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUksVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFvRCxHQUFHLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUxBQW1MLGdEQUFnRDtBQUNuTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxpQkFBaUIsTUFBTSxnQkFBZ0I7QUFDM0csb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhLFFBQVEsYUFBYTtBQUM1RztBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EscUZBQXFGLEVBQUUsS0FBSyxLQUFLLE9BQU8sRUFBRSxLQUFLLEtBQUs7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2T0FBNk8sd0JBQXdCLDBEQUEwRCw2REFBNkQ7QUFDNVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0RBQXdELEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxhQUFhLGNBQWMsU0FBUztBQUMxRixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RkFBdUYsa0JBQWtCO0FBQ3JIO0FBQ0E7QUFDQSw4REFBOEQsNkNBQTZDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCw2Q0FBNkM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNkNBQTZDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRiw2Q0FBNkM7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCxNQUFNLG9LQUFvSyxJQUFJLDBEQUEwRCxVQUFVO0FBQ2xQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTLEVBQUUsaUJBQWlCLEVBQUUsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLEVBQUUsZ0JBQWdCLEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsR0FBRztBQUNuRDtBQUNBLGdEQUFnRCxHQUFHLElBQUksYUFBYTtBQUNwRTtBQUNBLCtEQUErRCxHQUFHO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0EsdUtBQXVLLFdBQVc7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFNBQVM7QUFDL0c7QUFDQSx1RkFBdUYsU0FBUztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxXQUFXO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLFNBQVM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVGQUF1RixTQUFTO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsd0JBQXdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixXQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsU0FBUztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUE4RDtBQUN2RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxNQUFNO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLDRDQUE0QyxVQUFVO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsNENBQTRDLFVBQVU7QUFDN0Y7QUFDQSxnREFBZ0QsVUFBVSxTQUFTLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUUsMkRBQTJELE9BQU8sSUFBSSxPQUFPO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG9CQUFvQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyRUFBMkU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixjQUFjO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQSw2SkFBNkosYUFBYTtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSx1QkFBdUIsVUFBVTtBQUN6RTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRSxlQUFlLGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQ0FBZ0Msb0JBQW9CLFNBQVMsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHVFQUF1RSxjQUFjLG1CQUFtQjtBQUMzSjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILDJCQUEyQjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxFQUFFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLEdBQUcsRUFBRTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxPQUFPO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxZQUFZLDZCQUE2QjtBQUN6QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDhCQUE4QjtBQUN6QyxlQUFlLGtDQUFrQztBQUNqRCxjQUFjLGlDQUFpQztBQUMvQyxlQUFlLGtDQUFrQztBQUNqRCxXQUFXLHNDQUFzQztBQUNqRCxhQUFhLDRDQUE0QztBQUN6RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsd0ZBQXdGLFVBQVUsMkNBQTJDLFVBQVU7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkNBQTZDLEVBQUUsVUFBVSxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNI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QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LE9BQU8sb0VBQTZCLE9BQU8sc0RBQWUsT0FBTyxzREFBZSxPQUFPLHNEQUFlLE9BQU8sK0NBQVEsT0FBTyxtREFBWTtBQUN4bkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsd0NBQUM7QUFrSkg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cHBsaWVyLWRpcmVjdG9yeS8uL25vZGVfbW9kdWxlcy9AbWFwdGlsZXIvc2RrL2Rpc3QvbWFwdGlsZXItc2RrLm1qcz8wN2I5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBuaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBUbiA9IChyKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihyKTtcbn07XG52YXIgYWkgPSAociwgZSwgdCkgPT4gZSBpbiByID8gbmkociwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IHJbZV0gPSB0O1xudmFyIHYgPSAociwgZSwgdCkgPT4gYWkociwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgdCksIGhyID0gKHIsIGUsIHQpID0+IGUuaGFzKHIpIHx8IFRuKFwiQ2Fubm90IFwiICsgdCk7XG52YXIgayA9IChyLCBlLCB0KSA9PiAoaHIociwgZSwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgdCA/IHQuY2FsbChyKSA6IGUuZ2V0KHIpKSwgWiA9IChyLCBlLCB0KSA9PiBlLmhhcyhyKSA/IFRuKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKSA6IGUgaW5zdGFuY2VvZiBXZWFrU2V0ID8gZS5hZGQocikgOiBlLnNldChyLCB0KSwgSyA9IChyLCBlLCB0LCBuKSA9PiAoaHIociwgZSwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBuID8gbi5jYWxsKHIsIHQpIDogZS5zZXQociwgdCksIHQpLCBZID0gKHIsIGUsIHQpID0+IChocihyLCBlLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKSwgdCk7XG5pbXBvcnQgTCBmcm9tIFwibWFwbGlicmUtZ2xcIjtcbmltcG9ydCB7IExhbmd1YWdlIGFzIG9pLCBnZXRMYW5ndWFnZUluZm9Gcm9tQ29kZSBhcyBfbiwgY29uZmlnIGFzIG1yLCBNYXBTdHlsZSBhcyBmdCwgbWFwU3R5bGVQcmVzZXRMaXN0IGFzIHlyLCBleHBhbmRNYXBTdHlsZSBhcyBpaSwgTWFwU3R5bGVWYXJpYW50IGFzIHNpLCBSZWZlcmVuY2VNYXBTdHlsZSBhcyBsaSwgdG9MYW5ndWFnZUluZm8gYXMgSW4sIGdldExhbmd1YWdlSW5mb0Zyb21GbGFnIGFzIHVpLCBnZW9sb2NhdGlvbiBhcyBNbiB9IGZyb20gXCJAbWFwdGlsZXIvY2xpZW50XCI7XG5pbXBvcnQgeyBNYXBTdHlsZSBhcyB0ZiwgTWFwU3R5bGVWYXJpYW50IGFzIHJmLCBSZWZlcmVuY2VNYXBTdHlsZSBhcyBuZiwgU2VydmljZUVycm9yIGFzIGFmLCBhcmVTYW1lTGFuZ3VhZ2VzIGFzIG9mLCBidWZmZXJUb1BpeGVsRGF0YUJyb3dzZXIgYXMgc2YsIGNhblBhcnNlUGl4ZWxEYXRhIGFzIGxmLCBjaXJjdW1mZXJlbmNlQXRMYXRpdHVkZSBhcyB1ZiwgY29vcmRpbmF0ZXMgYXMgY2YsIGRhdGEgYXMgcGYsIGVsZXZhdGlvbiBhcyBmZiwgZXhwYW5kTWFwU3R5bGUgYXMgZGYsIGdlb2NvZGluZyBhcyBoZiwgZ2VvbG9jYXRpb24gYXMgbWYsIGdldEF1dG9MYW5ndWFnZSBhcyB5ZiwgZ2V0QnVmZmVyVG9QaXhlbERhdGFQYXJzZXIgYXMgZ2YsIGdldExhbmd1YWdlSW5mb0Zyb21Db2RlIGFzIHZmLCBnZXRMYW5ndWFnZUluZm9Gcm9tRmxhZyBhcyBiZiwgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUtleSBhcyB3ZiwgZ2V0VGlsZUNhY2hlIGFzIFNmLCBpc0xhbmd1YWdlSW5mbyBhcyB4ZiwgbWFwU3R5bGVQcmVzZXRMaXN0IGFzIGtmLCBtYXRoIGFzIExmLCBtaXNjIGFzIENmLCBzdGF0aWNNYXBzIGFzIEVmLCBzdHlsZVRvU3R5bGUgYXMgQWYsIHRvTGFuZ3VhZ2VJbmZvIGFzIFRmIH0gZnJvbSBcIkBtYXB0aWxlci9jbGllbnRcIjtcbmltcG9ydCBjaSBmcm9tIFwiZXZlbnRzXCI7XG5pbXBvcnQgeyB2NCBhcyBwaSB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBCYXNlNjQgYXMgZmkgfSBmcm9tIFwianMtYmFzZTY0XCI7XG5jb25zdCB6ID0ge1xuICAvKipcbiAgICogTGFuZ3VhZ2UgbW9kZSB0byBkaXNwbGF5IGxhYmVscyBpbiBib3RoIHRoZSBsb2NhbCBsYW5ndWFnZSBhbmQgdGhlIGxhbmd1YWdlIG9mIHRoZSB2aXNpdG9yJ3MgZGV2aWNlLCBjb25jYXRlbmF0ZWQuXG4gICAqIE5vdGUgdGhhdCBpZiB0aG9zZSB0d28gbGFuZ3VhZ2VzIGFyZSB0aGUgc2FtZSwgbGFiZWxzIHdvbid0IGJlIGR1cGxpY2F0ZWQuXG4gICAqL1xuICBWSVNJVE9SOiB7XG4gICAgY29kZTogbnVsbCxcbiAgICBmbGFnOiBcInZpc2l0b3JcIixcbiAgICBuYW1lOiBcIlZpc2l0b3JcIixcbiAgICBsYXRpbjogITAsXG4gICAgaXNNb2RlOiAhMCxcbiAgICBnZW9jb2Rpbmc6ICExXG4gIH0sXG4gIC8qKlxuICAgKiBMYW5ndWFnZSBtb2RlIHRvIGRpc3BsYXkgbGFiZWxzIGluIGJvdGggdGhlIGxvY2FsIGxhbmd1YWdlIGFuZCBFbmdsaXNoLCBjb25jYXRlbmF0ZWQuXG4gICAqIE5vdGUgdGhhdCBpZiB0aG9zZSB0d28gbGFuZ3VhZ2VzIGFyZSB0aGUgc2FtZSwgbGFiZWxzIHdvbid0IGJlIGR1cGxpY2F0ZWQuXG4gICAqL1xuICBWSVNJVE9SX0VOR0xJU0g6IHtcbiAgICBjb2RlOiBudWxsLFxuICAgIGZsYWc6IFwidmlzaXRvcl9lblwiLFxuICAgIG5hbWU6IFwiVmlzaXRvciBFbmdsaXNoXCIsXG4gICAgbGF0aW46ICEwLFxuICAgIGlzTW9kZTogITAsXG4gICAgZ2VvY29kaW5nOiAhMVxuICB9LFxuICAvKipcbiAgICogTGFuZ3VhZ2UgbW9kZSB0byBkaXNwbGF5IGxhYmVscyBpbiBhIGxhbmd1YWdlIGVuZm9yY2VkIGluIHRoZSBzdHlsZS5cbiAgICovXG4gIFNUWUxFOiB7XG4gICAgY29kZTogbnVsbCxcbiAgICBmbGFnOiBcInN0eWxlXCIsXG4gICAgbmFtZTogXCJTdHlsZVwiLFxuICAgIGxhdGluOiAhMSxcbiAgICBpc01vZGU6ICEwLFxuICAgIGdlb2NvZGluZzogITFcbiAgfSxcbiAgLyoqXG4gICAqIExhbmd1YWdlIG1vZGUgdG8gZGlzcGxheSBsYWJlbHMgaW4gYSBsYW5ndWFnZSBlbmZvcmNlZCBpbiB0aGUgc3R5bGUuIFRoZSBsYW5ndWFnZSBjYW5ub3QgYmUgZnVydGhlciBtb2RpZmllZC5cbiAgICovXG4gIFNUWUxFX0xPQ0s6IHtcbiAgICBjb2RlOiBudWxsLFxuICAgIGZsYWc6IFwic3R5bGVfbG9ja1wiLFxuICAgIG5hbWU6IFwiU3R5bGUgTG9ja1wiLFxuICAgIGxhdGluOiAhMSxcbiAgICBpc01vZGU6ICEwLFxuICAgIGdlb2NvZGluZzogITFcbiAgfSxcbiAgLi4ub2lcbn07XG5mdW5jdGlvbiBQbigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPiBcInVcIikge1xuICAgIGNvbnN0IGUgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlLnNwbGl0KFwiLVwiKVswXSwgdCA9IF9uKGUpO1xuICAgIHJldHVybiB0IHx8IHouRU5HTElTSDtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG5hdmlnYXRvci5sYW5ndWFnZXMubWFwKChlKSA9PiBlLnNwbGl0KFwiLVwiKVswXSkpKS5tYXAoKGUpID0+IF9uKGUpKS5maWx0ZXIoKGUpID0+IGUpWzBdID8/IHouTE9DQUw7XG59XG5jb25zdCBYID0ge1xuICBtYXB0aWxlckxvZ29VUkw6IFwiaHR0cHM6Ly9hcGkubWFwdGlsZXIuY29tL3Jlc291cmNlcy9sb2dvLnN2Z1wiLFxuICBtYXB0aWxlclVSTDogXCJodHRwczovL3d3dy5tYXB0aWxlci5jb20vXCIsXG4gIG1hcHRpbGVyQXBpSG9zdDogXCJhcGkubWFwdGlsZXIuY29tXCIsXG4gIHRlbGVtZXRyeVVSTDogXCJodHRwczovL2FwaS5tYXB0aWxlci5jb20vbWV0cmljc1wiLFxuICBydGxQbHVnaW5VUkw6IFwiaHR0cHM6Ly9jZG4ubWFwdGlsZXIuY29tL21hcGJveC1nbC1ydGwtdGV4dC92MC4yLjMvbWFwYm94LWdsLXJ0bC10ZXh0Lm1pbi5qc1wiLFxuICBwcmltYXJ5TGFuZ3VhZ2U6IHouU1RZTEUsXG4gIHNlY29uZGFyeUxhbmd1YWdlOiB6LkxPQ0FMLFxuICB0ZXJyYWluU291cmNlVVJMOiBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS90aWxlcy90ZXJyYWluLXJnYi12Mi90aWxlcy5qc29uXCIsXG4gIHRlcnJhaW5Tb3VyY2VJZDogXCJtYXB0aWxlci10ZXJyYWluXCJcbn07XG5PYmplY3QuZnJlZXplKFgpO1xuY29uc3QgdG4gPSBwaSgpO1xuY2xhc3MgZGkgZXh0ZW5kcyBjaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbGFuZ3VhZ2UuIEJ5IGRlZmF1bHQsIHRoZSBsYW5ndWFnZSBvZiB0aGUgd2ViIGJyb3dzZXIgaXMgdXNlZC5cbiAgICAgKi9cbiAgICB2KHRoaXMsIFwicHJpbWFyeUxhbmd1YWdlXCIsIFgucHJpbWFyeUxhbmd1YWdlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kYXJ5IGxhbmd1YWdlLCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgZGVmaW5lZCBpbiB0aGUgbWFwIHN0eWxlLlxuICAgICAqIFRoaXMgc2V0dGluZ3MgaXMgaGlnaGx5IGRlcGVuZGFudCBvbiB0aGUgc3R5bGUgY29tcGF0aWJpbGl0eSBhbmQgbWF5IG5vdCB3b3JrIGluIG1vc3QgY2FzZXMuXG4gICAgICovXG4gICAgdih0aGlzLCBcInNlY29uZGFyeUxhbmd1YWdlXCIpO1xuICAgIC8qKlxuICAgICAqIFNldHRpbmcgb24gd2hldGhlciBvZiBub3QgdGhlIFNESyBydW5zIHdpdGggYSBzZXNzaW9uIGxvZ2ljLlxuICAgICAqIEEgXCJzZXNzaW9uXCIgaXMgc3RhcnRlZCBhdCB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIFNESyBhbmQgZmluaXNoZWQgd2hlbiB0aGUgYnJvd3NlclxuICAgICAqIHBhZ2UgaXMgYmVpbmcgcmVmcmVzaGVkLlxuICAgICAqIFdoZW4gYHNlc3Npb25gIGlzIGVuYWJsZWQgKGRlZmF1bHQ6IHRydWUpLCB0aGUgZXh0cmEgVVJMIHBhcmFtIGBtdHNpZGAgaXMgYWRkZWQgdG8gcXVlcmllc1xuICAgICAqIG9uIHRoZSBNYXBUaWxlciBDbG91ZCBBUEkuIFRoaXMgYWxsb3dzIE1hcFRpbGVyIHRvIGVuYWJsZSBcInNlc3Npb24gYmFzZWQgYmlsbGluZ1wiLlxuICAgICAqL1xuICAgIHYodGhpcywgXCJzZXNzaW9uXCIsICEwKTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGNsaWVudC1zaWRlIGNhY2hpbmcgb2YgcmVxdWVzdHMgZm9yIHRpbGVzIGFuZCBmb250cy5cbiAgICAgKiBUaGUgY2FjaGVkIHJlcXVlc3RzIHBlcnNpc3QgbXVsdGlwbGUgYnJvd3NlciBzZXNzaW9ucyBhbmQgd2lsbCBiZSByZXVzZWQgd2hlbiBwb3NzaWJsZS5cbiAgICAgKiBXb3JrcyBvbmx5IGZvciByZXF1ZXN0cyB0byB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJIHdoZW4gc2Vzc2lvbnMgYXJlIGVuYWJsZWQuXG4gICAgICovXG4gICAgdih0aGlzLCBcImNhY2hpbmdcIiwgITApO1xuICAgIC8qKlxuICAgICAqIFRlbGVtZXRyeSBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgYnV0IGNhbiBiZSBvcHRlZC1vdXQgYnkgc2V0dGluZyB0aGlzIHZhbHVlIHRvIGBmYWxzZWAuXG4gICAgICogVGhlIHRlbGVtZXRyeSBpcyB2ZXJ5IHZhbHVhYmxlIHRvIHRoZSB0ZWFtIGF0IE1hcFRpbGVyIGJlY2F1c2UgaXQgc2hhcmVzIGluZm9ybWF0aW9uXG4gICAgICogYWJvdXQgd2hlcmUgdG8gYWRkIHRoZSBleHRyYSBlZmZvcnQuIEl0IGFsc28gaGVscHMgc3BvdHRpbmcgc29tZSBpbmNvbXBhdGliaWxpdHkgaXNzdWVzXG4gICAgICogdGhhdCBtYXkgYXJpc2UgYmV0d2VlbiB0aGUgU0RLIGFuZCBhIHNwZWNpZmljIHZlcnNpb24gb2YgYSBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBJdCBjb25zaXN0cyBpbiBzZW5kaW5nIG1ldHJpY3MgYWJvdXQgdXNhZ2Ugb2YgdGhlIGZvbGxvd2luZyBmZWF0dXJlczpcbiAgICAgKiAtIFNESyB2ZXJzaW9uIFtzdHJpbmddXG4gICAgICogLSBBUEkga2V5IFtzdHJpbmddXG4gICAgICogLSBNYXBUaWxlciBzZXNpb24gSUQgKGlmIG9wdGVkLWluKSBbc3RyaW5nXVxuICAgICAqIC0gaWYgdGlsZSBjYWNoaW5nIGlzIGVuYWJsZWQgW2Jvb2xlYW5dXG4gICAgICogLSBpZiBsYW5ndWFnZSBzcGVjaWZpZWQgYXQgaW5pdGlhbGl6YXRpb24gW2Jvb2xlYW5dXG4gICAgICogLSBpZiB0ZXJyYWluIGlzIGFjdGl2YXRlZCBhdCBpbml0aWFsaXphdGlvbiBbYm9vbGVhbl1cbiAgICAgKiAtIGlmIGdsb2JlIHByb2plY3Rpb24gaXMgYWN0aXZhdGVkIGF0IGluaXRpYWxpemF0aW9uIFtib29sZWFuXVxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24sIGVhY2ggb2ZmaWNpYWwgbW9kdWxlIHdpbGwgYmUgYWRkZWQgdG8gYSBsaXN0LCBhbG9uZ3NpZGUgaXRzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIHYodGhpcywgXCJ0ZWxlbWV0cnlcIiwgITApO1xuICAgIC8qKlxuICAgICAqIFVuaXQgdG8gYmUgdXNlZFxuICAgICAqL1xuICAgIHYodGhpcywgXCJfdW5pdFwiLCBcIm1ldHJpY1wiKTtcbiAgICAvKipcbiAgICAgKiBNYXBUaWxlciBDbG91ZCBBUEkga2V5XG4gICAgICovXG4gICAgdih0aGlzLCBcIl9hcGlLZXlcIiwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdW5pdCBzeXN0ZW1cbiAgICovXG4gIHNldCB1bml0KHQpIHtcbiAgICB0aGlzLl91bml0ID0gdCwgdGhpcy5lbWl0KFwidW5pdFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB1bml0IHN5c3RlbVxuICAgKi9cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaXQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgTWFwVGlsZXIgQ2xvdWQgQVBJIGtleVxuICAgKi9cbiAgc2V0IGFwaUtleSh0KSB7XG4gICAgdGhpcy5fYXBpS2V5ID0gdCwgbXIuYXBpS2V5ID0gdCwgdGhpcy5lbWl0KFwiYXBpS2V5XCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIE1hcFRpbGVyIENsb3VkIEFQSSBrZXlcbiAgICovXG4gIGdldCBhcGlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwaUtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgdGhlIGN1c3RvbSBmZXRjaCBmdW5jdGlvbiB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG9uZVxuICAgKi9cbiAgc2V0IGZldGNoKHQpIHtcbiAgICBtci5mZXRjaCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmV0Y2ggZnVjbnRpb25cbiAgICovXG4gIGdldCBmZXRjaCgpIHtcbiAgICByZXR1cm4gbXIuZmV0Y2g7XG4gIH1cbn1cbmNvbnN0IGogPSBuZXcgZGkoKSwgenIgPSBcImxvY2FsY2FjaGVfc291cmNlXCIsIEZyID0gXCJsb2NhbGNhY2hlXCIsIGhpID0gXCJtYXB0aWxlcl9zZGtcIiwgbWkgPSAxZTMsIHlpID0gMTAwLCAkciA9IHR5cGVvZiBjYWNoZXMgPCBcInVcIiwgeyBhZGRQcm90b2NvbDogUm4gfSA9IEw7XG5mdW5jdGlvbiBnaShyLCBlKSB7XG4gIGlmICgkciAmJiBqLmNhY2hpbmcgJiYgai5zZXNzaW9uICYmIHIuaG9zdCA9PT0gWC5tYXB0aWxlckFwaUhvc3QpIHtcbiAgICBpZiAoZSA9PT0gXCJTb3VyY2VcIiAmJiByLmhyZWYuaW5jbHVkZXMoXCJ0aWxlcy5qc29uXCIpKVxuICAgICAgcmV0dXJuIHIuaHJlZi5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgYCR7enJ9Oi8vYCk7XG4gICAgaWYgKGUgPT09IFwiVGlsZVwiIHx8IGUgPT09IFwiR2x5cGhzXCIpXG4gICAgICByZXR1cm4gci5ocmVmLnJlcGxhY2UoXCJodHRwczovL1wiLCBgJHtGcn06Ly9gKTtcbiAgfVxuICByZXR1cm4gci5ocmVmO1xufVxubGV0IGdyO1xuYXN5bmMgZnVuY3Rpb24gX2EoKSB7XG4gIHJldHVybiBnciB8fCAoZ3IgPSBhd2FpdCBjYWNoZXMub3BlbihoaSkpLCBncjtcbn1cbmxldCB6biA9IDA7XG5hc3luYyBmdW5jdGlvbiB2aSgpIHtcbiAgY29uc3QgciA9IGF3YWl0IF9hKCksIGUgPSBhd2FpdCByLmtleXMoKSwgdCA9IGUuc2xpY2UoMCwgTWF0aC5tYXgoZS5sZW5ndGggLSBtaSwgMCkpO1xuICBmb3IgKGNvbnN0IG4gb2YgdClcbiAgICByLmRlbGV0ZShuKTtcbn1cbmZ1bmN0aW9uIGJpKCkge1xuICBSbihcbiAgICB6cixcbiAgICBhc3luYyAociwgZSkgPT4ge1xuICAgICAgaWYgKCFyLnVybCkgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgci51cmwgPSByLnVybC5yZXBsYWNlKGAke3pyfTovL2AsIFwiaHR0cHM6Ly9cIik7XG4gICAgICBjb25zdCB0ID0gcjtcbiAgICAgIHQuc2lnbmFsID0gZS5zaWduYWw7XG4gICAgICBjb25zdCBuID0gYXdhaXQgZmV0Y2goci51cmwsIHQpLCBhID0gYXdhaXQgbi5qc29uKCk7XG4gICAgICByZXR1cm4gYS50aWxlcyAmJiBhLnRpbGVzLmxlbmd0aCA+IDAgJiYgKGEudGlsZXNbMF0gKz0gYCZsYXN0LW1vZGlmaWVkPSR7bi5oZWFkZXJzLmdldChcIkxhc3QtTW9kaWZpZWRcIil9YCksIHtcbiAgICAgICAgZGF0YTogYSxcbiAgICAgICAgY2FjaGVDb250cm9sOiBuLmhlYWRlcnMuZ2V0KFwiQ2FjaGUtQ29udHJvbFwiKSxcbiAgICAgICAgZXhwaXJlczogbi5oZWFkZXJzLmdldChcIkV4cGlyZXNcIilcbiAgICAgIH07XG4gICAgfVxuICApLCBSbihGciwgYXN5bmMgKHIsIGUpID0+IHtcbiAgICBpZiAoIXIudXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgci51cmwgPSByLnVybC5yZXBsYWNlKGAke0ZyfTovL2AsIFwiaHR0cHM6Ly9cIik7XG4gICAgY29uc3QgdCA9IG5ldyBVUkwoci51cmwpLCBuID0gbmV3IFVSTCh0KTtcbiAgICBuLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJtdHNpZFwiKSwgbi5zZWFyY2hQYXJhbXMuZGVsZXRlKFwia2V5XCIpO1xuICAgIGNvbnN0IGEgPSBuLnRvU3RyaW5nKCksIG8gPSBuZXcgVVJMKHQpO1xuICAgIG8uc2VhcmNoUGFyYW1zLmRlbGV0ZShcImxhc3QtbW9kaWZpZWRcIik7XG4gICAgY29uc3QgaSA9IG8udG9TdHJpbmcoKSwgcyA9IGFzeW5jIChkKSA9PiAoe1xuICAgICAgZGF0YTogYXdhaXQgZC5hcnJheUJ1ZmZlcigpLFxuICAgICAgY2FjaGVDb250cm9sOiBkLmhlYWRlcnMuZ2V0KFwiQ2FjaGUtQ29udHJvbFwiKSxcbiAgICAgIGV4cGlyZXM6IGQuaGVhZGVycy5nZXQoXCJFeHBpcmVzXCIpXG4gICAgfSksIGwgPSBhd2FpdCBfYSgpLCB1ID0gYXdhaXQgbC5tYXRjaChhKTtcbiAgICBpZiAodSlcbiAgICAgIHJldHVybiBzKHUpO1xuICAgIGNvbnN0IGMgPSByO1xuICAgIGMuc2lnbmFsID0gZS5zaWduYWw7XG4gICAgY29uc3QgcCA9IGF3YWl0IGZldGNoKGksIGMpO1xuICAgIHJldHVybiBwLnN0YXR1cyA+PSAyMDAgJiYgcC5zdGF0dXMgPCAzMDAgJiYgKGwucHV0KGEsIHAuY2xvbmUoKSkuY2F0Y2goKCkgPT4ge1xuICAgIH0pLCArK3puID4geWkgJiYgKHZpKCksIHpuID0gMCkpLCBzKHApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdpKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA+IFwidVwiKSByZXR1cm47XG4gIGNvbnN0IHIgPSBMLmdldFJUTFRleHRQbHVnaW5TdGF0dXMoKTtcbiAgaWYgKHIgPT09IFwidW5hdmFpbGFibGVcIiB8fCByID09PSBcInJlcXVlc3RlZFwiKVxuICAgIHRyeSB7XG4gICAgICBMLnNldFJUTFRleHRQbHVnaW4oWC5ydGxQbHVnaW5VUkwsICEwKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG59XG5mdW5jdGlvbiBTaShyLCBlKSB7XG4gIGZvciAoY29uc3QgdCBvZiByKVxuICAgIHR5cGVvZiBlW3RdID09IFwiZnVuY3Rpb25cIiAmJiAoZVt0XSA9IGVbdF0uYmluZChlKSk7XG59XG5mdW5jdGlvbiBGbihyLCBlKSB7XG4gIGxldCB0ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB0ID0gbmV3IFVSTChyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHQuaG9zdCA9PT0gWC5tYXB0aWxlckFwaUhvc3QgJiYgKHQuc2VhcmNoUGFyYW1zLmhhcyhcImtleVwiKSB8fCB0LnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJrZXlcIiwgai5hcGlLZXkpLCBqLnNlc3Npb24gJiYgdC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibXRzaWRcIiwgdG4pKSwge1xuICAgIHVybDogZ2kodCwgZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRuKHIpIHtcbiAgcmV0dXJuIChlLCB0KSA9PiB7XG4gICAgaWYgKHIgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbiA9IHIoZSwgdCksIGEgPSBGbigobiA9PSBudWxsID8gdm9pZCAwIDogbi51cmwpID8/IFwiXCIsIHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubixcbiAgICAgICAgLi4uYVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIEZuKGUsIHQpO1xuICB9O1xufVxuZnVuY3Rpb24gSWEoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG59XG5mdW5jdGlvbiBZdChyKSB7XG4gIHJldHVybiAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvZ2kudGVzdChyKTtcbn1cbmZ1bmN0aW9uIHhpKHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyKTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBraSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIndlYmdsMlwiKSA/IG51bGwgOiB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA8IFwidVwiID8gXCJHcmFwaGljIHJlbmRlcmluZyB3aXRoIFdlYkdMMiBoYXMgYmVlbiBkaXNhYmxlZCBvciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgZ3JhcGhpYyBjYXJkLiBUaGUgbWFwIGNhbm5vdCBiZSBkaXNwbGF5ZWQuXCIgOiBcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGdyYXBoaWMgcmVuZGVyaW5nIHdpdGggV2ViR0wyLiBUaGUgbWFwIGNhbm5vdCBiZSBkaXNwbGF5ZWQuXCI7XG59XG5mdW5jdGlvbiBMaShyKSB7XG4gIGNvbnN0IGUgPSBraSgpO1xuICBpZiAoIWUpIHJldHVybjtcbiAgbGV0IHQgPSBudWxsO1xuICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKSA6IHIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAodCA9IHIpLCAhdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgTWFwIGNvbnRhaW5lciBtdXN0IGJlIHByb3ZpZGVkLlwiKTtcbiAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHRocm93IG4uaW5uZXJIVE1MID0gZSwgbi5jbGFzc0xpc3QuYWRkKFwid2ViZ2wtd2FybmluZy1kaXZcIiksIHQuYXBwZW5kQ2hpbGQobiksIG5ldyBFcnJvcihlKTtcbn1cbmZ1bmN0aW9uIEljKHIpIHtcbiAgY29uc3QgZSA9IFwiVGhlIFdlYkdMIGNvbnRleHQgd2FzIGxvc3QuXCIsIHQgPSByLmdldENvbnRhaW5lcigpLCBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbi5pbm5lckhUTUwgPSBlLCBuLmNsYXNzTGlzdC5hZGQoXCJ3ZWJnbC13YXJuaW5nLWRpdlwiKSwgdC5hcHBlbmRDaGlsZChuKTtcbn1cbmZ1bmN0aW9uIE9uKHIsIGUpIHtcbiAgcmV0dXJuICEoIUFycmF5LmlzQXJyYXkocikgfHwgci5sZW5ndGggIT09IDIgfHwgclswXSAhPT0gXCJnZXRcIiB8fCB0eXBlb2YgclsxXSAhPSBcInN0cmluZ1wiIHx8IGUgJiYgIXJbMV0uc3RhcnRzV2l0aChcIm5hbWU6XCIpIHx8ICFlICYmIHJbMV0gIT09IFwibmFtZVwiKTtcbn1cbmZ1bmN0aW9uIENpKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHN0cnVjdHVyZWRDbG9uZShyKSwgYSA9IChvKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvICE9IFwic3RyaW5nXCIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIE9uKG9baV0sIHQpID8gb1tpXSA9IHN0cnVjdHVyZWRDbG9uZShlKSA6IGEob1tpXSk7XG4gIH07XG4gIHJldHVybiBPbihuLCB0KSA/IGUgOiAoYShuKSwgbik7XG59XG5mdW5jdGlvbiBFaShyLCBlKSB7XG4gIGNvbnN0IHQgPSBlID8gL1xce25hbWU6XFxTK1xcfS8gOiAvXFx7bmFtZVxcfS87XG4gIHJldHVybiB7XG4gICAgY29udGFpbnM6IHQudGVzdChyKSxcbiAgICBleGFjdE1hdGNoOiBuZXcgUmVnRXhwKGBeJHt0LnNvdXJjZX0kYCkudGVzdChyKVxuICB9O1xufVxuZnVuY3Rpb24gQWkociwgZSwgdCkge1xuICBjb25zdCBuID0gdCA/IC9cXHtuYW1lOlxcUytcXH0vIDogL1xce25hbWVcXH0vLCBhID0gci5zcGxpdChuKTtcbiAgcmV0dXJuIFtcImNvbmNhdFwiLCAuLi5hLmZsYXRNYXAoKHMsIGwpID0+IGwgPT09IGEubGVuZ3RoIC0gMSA/IFtzXSA6IFtzLCBlXSldO1xufVxuZnVuY3Rpb24gVGkocikge1xuICB2YXIgbjtcbiAgY29uc3QgZSA9IC9cXHtuYW1lKD86Oig/PGxhbmd1YWdlPlxcUyspKT9cXH0vZywgdCA9IFtdO1xuICBmb3IgKDsgOyApIHtcbiAgICBjb25zdCBhID0gZS5leGVjKHIpO1xuICAgIGlmICghYSkgYnJlYWs7XG4gICAgY29uc3QgbyA9ICgobiA9IGEuZ3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogbi5sYW5ndWFnZSkgPz8gbnVsbDtcbiAgICB0LnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfaShyKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShyKSB8fCByLmxlbmd0aCAhPT0gMiB8fCByWzBdICE9PSBcImdldFwiIHx8IHR5cGVvZiByWzFdICE9IFwic3RyaW5nXCIgPyBudWxsIDogclsxXS50cmltKCkgPT09IFwibmFtZVwiID8ge1xuICAgIGlzTGFuZ3VhZ2U6ICEwLFxuICAgIGxvY2FsaXphdGlvbjogbnVsbFxuICB9IDogclsxXS50cmltKCkuc3RhcnRzV2l0aChcIm5hbWU6XCIpID8ge1xuICAgIGlzTGFuZ3VhZ2U6ICEwLFxuICAgIGxvY2FsaXphdGlvbjogclsxXS50cmltKCkuc3BsaXQoXCI6XCIpLnBvcCgpXG4gIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gSWkocikge1xuICBjb25zdCBlID0gW10sIHQgPSBzdHJ1Y3R1cmVkQ2xvbmUociksIG4gPSAoYSkgPT4ge1xuICAgIGlmICh0eXBlb2YgYSAhPSBcInN0cmluZ1wiKVxuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBhLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgIGNvbnN0IGkgPSBfaShhW29dKTtcbiAgICAgICAgaSA/IGUucHVzaChpLmxvY2FsaXphdGlvbikgOiBuKGFbb10pO1xuICAgICAgfVxuICB9O1xuICByZXR1cm4gbihbdF0pLCBlO1xufVxuZnVuY3Rpb24gTWkociwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIGZvciAoY29uc3QgbyBvZiByKSB7XG4gICAgaWYgKG8udHlwZSAhPT0gXCJzeW1ib2xcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGkgPSBvLCB7IGlkOiBzLCBsYXlvdXQ6IGwgfSA9IGk7XG4gICAgaWYgKCFsIHx8ICEoXCJ0ZXh0LWZpZWxkXCIgaW4gbCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB1ID0gZS5nZXRMYXlvdXRQcm9wZXJ0eShzLCBcInRleHQtZmllbGRcIik7XG4gICAgaWYgKHUpXG4gICAgICBpZiAodHlwZW9mIHUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBjID0gVGkodSk7XG4gICAgICAgIHQucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGMgPSBJaSh1KTtcbiAgICAgICAgdC5wdXNoKGMpO1xuICAgICAgfVxuICB9XG4gIGNvbnN0IG4gPSB0LmZsYXQoKSwgYSA9IHtcbiAgICB1bmxvY2FsaXplZDogMCxcbiAgICBsb2NhbGl6ZWQ6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgbyBvZiBuKVxuICAgIG8gPT09IG51bGwgPyBhLnVubG9jYWxpemVkICs9IDEgOiAobyBpbiBhLmxvY2FsaXplZCB8fCAoYS5sb2NhbGl6ZWRbb10gPSAwKSwgYS5sb2NhbGl6ZWRbb10gKz0gMSk7XG4gIHJldHVybiBhO1xufVxubGV0IE1jID0gY2xhc3MgZXh0ZW5kcyBMLk1hcmtlciB7XG4gIGFkZFRvKGUpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkVG8oZSk7XG4gIH1cbn07XG5jbGFzcyBSYyBleHRlbmRzIEwuUG9wdXAge1xuICBhZGRUbyhlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmFkZFRvKGUpO1xuICB9XG59XG5jbGFzcyB6YyBleHRlbmRzIEwuU3R5bGUge1xuICBjb25zdHJ1Y3RvcihlLCB0ID0ge30pIHtcbiAgICBzdXBlcihlLCB0KTtcbiAgfVxufVxuY2xhc3MgRmMgZXh0ZW5kcyBMLkNhbnZhc1NvdXJjZSB7XG4gIG9uQWRkKGUpIHtcbiAgICBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgJGMgZXh0ZW5kcyBMLkdlb0pTT05Tb3VyY2Uge1xuICBvbkFkZChlKSB7XG4gICAgc3VwZXIub25BZGQoZSk7XG4gIH1cbn1cbmNsYXNzIE9jIGV4dGVuZHMgTC5JbWFnZVNvdXJjZSB7XG4gIG9uQWRkKGUpIHtcbiAgICBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgTmMgZXh0ZW5kcyBMLlJhc3RlclRpbGVTb3VyY2Uge1xuICBvbkFkZChlKSB7XG4gICAgc3VwZXIub25BZGQoZSk7XG4gIH1cbn1cbmNsYXNzIGpjIGV4dGVuZHMgTC5SYXN0ZXJERU1UaWxlU291cmNlIHtcbiAgb25BZGQoZSkge1xuICAgIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBVYyBleHRlbmRzIEwuVmVjdG9yVGlsZVNvdXJjZSB7XG4gIG9uQWRkKGUpIHtcbiAgICBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgRGMgZXh0ZW5kcyBMLlZpZGVvU291cmNlIHtcbiAgb25BZGQoZSkge1xuICAgIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBNYSBleHRlbmRzIEwuTmF2aWdhdGlvbkNvbnRyb2wge1xuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBQaSBleHRlbmRzIEwuR2VvbG9jYXRlQ29udHJvbCB7XG4gIG9uQWRkKGUpIHtcbiAgICByZXR1cm4gc3VwZXIub25BZGQoZSk7XG4gIH1cbn1cbmNsYXNzIEJjIGV4dGVuZHMgTC5BdHRyaWJ1dGlvbkNvbnRyb2wge1xuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyBSaSBleHRlbmRzIEwuTG9nb0NvbnRyb2wge1xuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHN1cGVyLm9uQWRkKGUpO1xuICB9XG59XG5jbGFzcyB6aSBleHRlbmRzIEwuU2NhbGVDb250cm9sIHtcbiAgb25BZGQoZSkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgRmkgZXh0ZW5kcyBMLkZ1bGxzY3JlZW5Db250cm9sIHtcbiAgb25BZGQoZSkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgcWMgZXh0ZW5kcyBMLlRlcnJhaW5Db250cm9sIHtcbiAgb25BZGQoZSkge1xuICAgIHJldHVybiBzdXBlci5vbkFkZChlKTtcbiAgfVxufVxuY2xhc3MgVmMgZXh0ZW5kcyBMLkJveFpvb21IYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpO1xuICB9XG59XG5jbGFzcyBHYyBleHRlbmRzIEwuU2Nyb2xsWm9vbUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCk7XG4gIH1cbn1cbmNsYXNzIEhjIGV4dGVuZHMgTC5Db29wZXJhdGl2ZUdlc3R1cmVzSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KTtcbiAgfVxufVxuY2xhc3MgWmMgZXh0ZW5kcyBMLktleWJvYXJkSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgfVxufVxuY2xhc3MgWGMgZXh0ZW5kcyBMLlR3b0ZpbmdlcnNUb3VjaFBpdGNoSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKTtcbiAgfVxufVxuY2xhc3MgS2MgZXh0ZW5kcyBMLk1hcFdoZWVsRXZlbnQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgc3VwZXIoZSwgdCwgbik7XG4gIH1cbn1cbmNsYXNzIFljIGV4dGVuZHMgTC5NYXBUb3VjaEV2ZW50IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHN1cGVyKGUsIHQsIG4pO1xuICB9XG59XG5jbGFzcyBXYyBleHRlbmRzIEwuTWFwTW91c2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEgPSB7fSkge1xuICAgIHN1cGVyKGUsIHQsIG4sIGEpO1xuICB9XG59XG5jbGFzcyBObiBleHRlbmRzIFJpIHtcbiAgY29uc3RydWN0b3IodCA9IHt9KSB7XG4gICAgc3VwZXIodCk7XG4gICAgdih0aGlzLCBcImxvZ29VUkxcIiwgXCJcIik7XG4gICAgdih0aGlzLCBcImxpbmtVUkxcIiwgXCJcIik7XG4gICAgdGhpcy5sb2dvVVJMID0gdC5sb2dvVVJMID8/IFgubWFwdGlsZXJMb2dvVVJMLCB0aGlzLmxpbmtVUkwgPSB0LmxpbmtVUkwgPz8gWC5tYXB0aWxlclVSTDtcbiAgfVxuICBvbkFkZCh0KSB7XG4gICAgdGhpcy5fbWFwID0gdCwgdGhpcy5fY29tcGFjdCA9IHRoaXMub3B0aW9ucy5jb21wYWN0ID8/ICExLCB0aGlzLl9jb250YWluZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5fY29udGFpbmVyLmNsYXNzTmFtZSA9IFwibWFwbGlicmVnbC1jdHJsXCI7XG4gICAgY29uc3QgbiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICByZXR1cm4gbi5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gXCJuby1yZXBlYXRcIiwgbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIiwgbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCBuLnN0eWxlLmhlaWdodCA9IFwiMjNweFwiLCBuLnN0eWxlLm1hcmdpbiA9IFwiMCAwIC00cHggLTRweFwiLCBuLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgbi5zdHlsZS53aWR0aCA9IFwiODhweFwiLCBuLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHt0aGlzLmxvZ29VUkx9KWAsIG4uc3R5bGUuYmFja2dyb3VuZFNpemUgPSBcIjEwMHB4IDMwcHhcIiwgbi5zdHlsZS53aWR0aCA9IFwiMTAwcHhcIiwgbi5zdHlsZS5oZWlnaHQgPSBcIjMwcHhcIiwgbi50YXJnZXQgPSBcIl9ibGFua1wiLCBuLnJlbCA9IFwibm9vcGVuZXJcIiwgbi5ocmVmID0gdGhpcy5saW5rVVJMLCBuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJNYXBUaWxlciBsb2dvXCIpLCBuLnNldEF0dHJpYnV0ZShcInJlbFwiLCBcIm5vb3BlbmVyXCIpLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobiksIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLl9tYXAub24oXCJyZXNpemVcIiwgdGhpcy5fdXBkYXRlQ29tcGFjdCksIHRoaXMuX3VwZGF0ZUNvbXBhY3QoKSwgdGhpcy5fY29udGFpbmVyO1xuICB9XG59XG52YXIgJGkgPSA4LCBPaSA9IHtcbiAgdmVyc2lvbjoge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IFtcbiAgICAgIDhcbiAgICBdXG4gIH0sXG4gIG5hbWU6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIG1ldGFkYXRhOiB7XG4gICAgdHlwZTogXCIqXCJcbiAgfSxcbiAgY2VudGVyOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiXG4gIH0sXG4gIGNlbnRlckFsdGl0dWRlOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIlxuICB9LFxuICB6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIlxuICB9LFxuICBiZWFyaW5nOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIHBlcmlvZDogMzYwLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIlxuICB9LFxuICBwaXRjaDoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICB1bml0czogXCJkZWdyZWVzXCJcbiAgfSxcbiAgcm9sbDoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICB1bml0czogXCJkZWdyZWVzXCJcbiAgfSxcbiAgc3RhdGU6IHtcbiAgICB0eXBlOiBcInN0YXRlXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSxcbiAgbGlnaHQ6IHtcbiAgICB0eXBlOiBcImxpZ2h0XCJcbiAgfSxcbiAgc2t5OiB7XG4gICAgdHlwZTogXCJza3lcIlxuICB9LFxuICBwcm9qZWN0aW9uOiB7XG4gICAgdHlwZTogXCJwcm9qZWN0aW9uXCJcbiAgfSxcbiAgdGVycmFpbjoge1xuICAgIHR5cGU6IFwidGVycmFpblwiXG4gIH0sXG4gIHNvdXJjZXM6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJzb3VyY2VzXCJcbiAgfSxcbiAgc3ByaXRlOiB7XG4gICAgdHlwZTogXCJzcHJpdGVcIlxuICB9LFxuICBnbHlwaHM6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIHRyYW5zaXRpb246IHtcbiAgICB0eXBlOiBcInRyYW5zaXRpb25cIlxuICB9LFxuICBsYXllcnM6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcImxheWVyXCJcbiAgfVxufSwgTmkgPSB7XG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCJzb3VyY2VcIlxuICB9XG59LCBqaSA9IFtcbiAgXCJzb3VyY2VfdmVjdG9yXCIsXG4gIFwic291cmNlX3Jhc3RlclwiLFxuICBcInNvdXJjZV9yYXN0ZXJfZGVtXCIsXG4gIFwic291cmNlX2dlb2pzb25cIixcbiAgXCJzb3VyY2VfdmlkZW9cIixcbiAgXCJzb3VyY2VfaW1hZ2VcIlxuXSwgVWkgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2ZWN0b3I6IHt9XG4gICAgfVxuICB9LFxuICB1cmw6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIHRpbGVzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgZGVmYXVsdDogW1xuICAgICAgLTE4MCxcbiAgICAgIC04NS4wNTExMjksXG4gICAgICAxODAsXG4gICAgICA4NS4wNTExMjlcbiAgICBdXG4gIH0sXG4gIHNjaGVtZToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgeHl6OiB7fSxcbiAgICAgIHRtczoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwieHl6XCJcbiAgfSxcbiAgbWluem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LFxuICBtYXh6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAyMlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgcHJvbW90ZUlkOiB7XG4gICAgdHlwZTogXCJwcm9tb3RlSWRcIlxuICB9LFxuICB2b2xhdGlsZToge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sXG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCIqXCJcbiAgfVxufSwgRGkgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICByYXN0ZXI6IHt9XG4gICAgfVxuICB9LFxuICB1cmw6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIHRpbGVzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgZGVmYXVsdDogW1xuICAgICAgLTE4MCxcbiAgICAgIC04NS4wNTExMjksXG4gICAgICAxODAsXG4gICAgICA4NS4wNTExMjlcbiAgICBdXG4gIH0sXG4gIG1pbnpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMjJcbiAgfSxcbiAgdGlsZVNpemU6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDUxMixcbiAgICB1bml0czogXCJwaXhlbHNcIlxuICB9LFxuICBzY2hlbWU6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHh5ejoge30sXG4gICAgICB0bXM6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInh5elwiXG4gIH0sXG4gIGF0dHJpYnV0aW9uOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICB2b2xhdGlsZToge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sXG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCIqXCJcbiAgfVxufSwgQmkgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBcInJhc3Rlci1kZW1cIjoge31cbiAgICB9XG4gIH0sXG4gIHVybDoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgdGlsZXM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCJcbiAgfSxcbiAgYm91bmRzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogNCxcbiAgICBkZWZhdWx0OiBbXG4gICAgICAtMTgwLFxuICAgICAgLTg1LjA1MTEyOSxcbiAgICAgIDE4MCxcbiAgICAgIDg1LjA1MTEyOVxuICAgIF1cbiAgfSxcbiAgbWluem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LFxuICBtYXh6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAyMlxuICB9LFxuICB0aWxlU2l6ZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogNTEyLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiXG4gIH0sXG4gIGF0dHJpYnV0aW9uOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LFxuICBlbmNvZGluZzoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdGVycmFyaXVtOiB7fSxcbiAgICAgIG1hcGJveDoge30sXG4gICAgICBjdXN0b206IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm1hcGJveFwiXG4gIH0sXG4gIHJlZEZhY3Rvcjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMVxuICB9LFxuICBibHVlRmFjdG9yOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxXG4gIH0sXG4gIGdyZWVuRmFjdG9yOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxXG4gIH0sXG4gIGJhc2VTaGlmdDoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LFxuICB2b2xhdGlsZToge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sXG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCIqXCJcbiAgfVxufSwgcWkgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBnZW9qc29uOiB7fVxuICAgIH1cbiAgfSxcbiAgZGF0YToge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcIipcIlxuICB9LFxuICBtYXh6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxOFxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgYnVmZmVyOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxMjgsXG4gICAgbWF4aW11bTogNTEyLFxuICAgIG1pbmltdW06IDBcbiAgfSxcbiAgZmlsdGVyOiB7XG4gICAgdHlwZTogXCIqXCJcbiAgfSxcbiAgdG9sZXJhbmNlOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLjM3NVxuICB9LFxuICBjbHVzdGVyOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSxcbiAgY2x1c3RlclJhZGl1czoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogNTAsXG4gICAgbWluaW11bTogMFxuICB9LFxuICBjbHVzdGVyTWF4Wm9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgfSxcbiAgY2x1c3Rlck1pblBvaW50czoge1xuICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgfSxcbiAgY2x1c3RlclByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiBcIipcIlxuICB9LFxuICBsaW5lTWV0cmljczoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sXG4gIGdlbmVyYXRlSWQ6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LFxuICBwcm9tb3RlSWQ6IHtcbiAgICB0eXBlOiBcInByb21vdGVJZFwiXG4gIH1cbn0sIFZpID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlkZW86IHt9XG4gICAgfVxuICB9LFxuICB1cmxzOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICB9LFxuICBjb29yZGluYXRlczoge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBsZW5ndGg6IDIsXG4gICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgIH1cbiAgfVxufSwgR2kgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogITAsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBpbWFnZToge31cbiAgICB9XG4gIH0sXG4gIHVybDoge1xuICAgIHJlcXVpcmVkOiAhMCxcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sXG4gIGNvb3JkaW5hdGVzOiB7XG4gICAgcmVxdWlyZWQ6ICEwLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGxlbmd0aDogMixcbiAgICAgIHZhbHVlOiBcIm51bWJlclwiXG4gICAgfVxuICB9XG59LCBIaSA9IHtcbiAgaWQ6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHJlcXVpcmVkOiAhMFxuICB9LFxuICB0eXBlOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBmaWxsOiB7fSxcbiAgICAgIGxpbmU6IHt9LFxuICAgICAgc3ltYm9sOiB7fSxcbiAgICAgIGNpcmNsZToge30sXG4gICAgICBoZWF0bWFwOiB7fSxcbiAgICAgIFwiZmlsbC1leHRydXNpb25cIjoge30sXG4gICAgICByYXN0ZXI6IHt9LFxuICAgICAgaGlsbHNoYWRlOiB7fSxcbiAgICAgIFwiY29sb3ItcmVsaWVmXCI6IHt9LFxuICAgICAgYmFja2dyb3VuZDoge31cbiAgICB9LFxuICAgIHJlcXVpcmVkOiAhMFxuICB9LFxuICBtZXRhZGF0YToge1xuICAgIHR5cGU6IFwiKlwiXG4gIH0sXG4gIHNvdXJjZToge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgXCJzb3VyY2UtbGF5ZXJcIjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfSxcbiAgbWluem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAyNFxuICB9LFxuICBtYXh6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDI0XG4gIH0sXG4gIGZpbHRlcjoge1xuICAgIHR5cGU6IFwiZmlsdGVyXCJcbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAgdHlwZTogXCJsYXlvdXRcIlxuICB9LFxuICBwYWludDoge1xuICAgIHR5cGU6IFwicGFpbnRcIlxuICB9XG59LCBaaSA9IFtcbiAgXCJsYXlvdXRfZmlsbFwiLFxuICBcImxheW91dF9saW5lXCIsXG4gIFwibGF5b3V0X2NpcmNsZVwiLFxuICBcImxheW91dF9oZWF0bWFwXCIsXG4gIFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCIsXG4gIFwibGF5b3V0X3N5bWJvbFwiLFxuICBcImxheW91dF9yYXN0ZXJcIixcbiAgXCJsYXlvdXRfaGlsbHNoYWRlXCIsXG4gIFwibGF5b3V0X2NvbG9yLXJlbGllZlwiLFxuICBcImxheW91dF9iYWNrZ3JvdW5kXCJcbl0sIFhpID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIEtpID0ge1xuICBcImZpbGwtc29ydC1rZXlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHt9LFxuICAgICAgbm9uZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufSwgWWkgPSB7XG4gIFwiY2lyY2xlLXNvcnQta2V5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIFdpID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7fSxcbiAgICAgIG5vbmU6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn0sIEppID0ge1xuICBcImxpbmUtY2FwXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGJ1dHQ6IHt9LFxuICAgICAgcm91bmQ6IHt9LFxuICAgICAgc3F1YXJlOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJidXR0XCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtam9pblwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBiZXZlbDoge30sXG4gICAgICByb3VuZDoge30sXG4gICAgICBtaXRlcjoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibWl0ZXJcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIHtcbiAgICAgICAgXCJsaW5lLWpvaW5cIjogXCJtaXRlclwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLjA1LFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwibGluZS1qb2luXCI6IFwicm91bmRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtc29ydC1rZXlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHt9LFxuICAgICAgbm9uZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufSwgUWkgPSB7XG4gIFwic3ltYm9sLXBsYWNlbWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBwb2ludDoge30sXG4gICAgICBsaW5lOiB7fSxcbiAgICAgIFwibGluZS1jZW50ZXJcIjoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwicG9pbnRcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic3ltYm9sLXNwYWNpbmdcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMjUwLFxuICAgIG1pbmltdW06IDEsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic3ltYm9sLXNvcnQta2V5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInN5bWJvbC16LW9yZGVyXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGF1dG86IHt9LFxuICAgICAgXCJ2aWV3cG9ydC15XCI6IHt9LFxuICAgICAgc291cmNlOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITEsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAge1xuICAgICAgICBcIiFcIjogXCJpY29uLW92ZXJsYXBcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tb3ZlcmxhcFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBuZXZlcjoge30sXG4gICAgICBhbHdheXM6IHt9LFxuICAgICAgY29vcGVyYXRpdmU6IHt9XG4gICAgfSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tb3B0aW9uYWxcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIixcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgIGF1dG86IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLXNpemVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcImZhY3RvciBvZiB0aGUgb3JpZ2luYWwgaWNvbiBzaXplXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXRleHQtZml0XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG5vbmU6IHt9LFxuICAgICAgd2lkdGg6IHt9LFxuICAgICAgaGVpZ2h0OiB7fSxcbiAgICAgIGJvdGg6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm5vbmVcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogNCxcbiAgICBkZWZhdWx0OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwXG4gICAgXSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCIsXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCJpY29uLXRleHQtZml0XCI6IFtcbiAgICAgICAgICBcImJvdGhcIixcbiAgICAgICAgICBcIndpZHRoXCIsXG4gICAgICAgICAgXCJoZWlnaHRcIlxuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1pbWFnZVwiOiB7XG4gICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgdG9rZW5zOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIHBlcmlvZDogMzYwLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tcGFkZGluZ1wiOiB7XG4gICAgdHlwZTogXCJwYWRkaW5nXCIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMlxuICAgIF0sXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITEsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAge1xuICAgICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXG4gICAgICAgICAgXCJsaW5lXCIsXG4gICAgICAgICAgXCJsaW5lLWNlbnRlclwiXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBkZWZhdWx0OiBbXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0sXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBjZW50ZXI6IHt9LFxuICAgICAgbGVmdDoge30sXG4gICAgICByaWdodDoge30sXG4gICAgICB0b3A6IHt9LFxuICAgICAgYm90dG9tOiB7fSxcbiAgICAgIFwidG9wLWxlZnRcIjoge30sXG4gICAgICBcInRvcC1yaWdodFwiOiB7fSxcbiAgICAgIFwiYm90dG9tLWxlZnRcIjoge30sXG4gICAgICBcImJvdHRvbS1yaWdodFwiOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJjZW50ZXJcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge30sXG4gICAgICBhdXRvOiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgIGF1dG86IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9LFxuICAgICAgXCJ2aWV3cG9ydC1nbHlwaFwiOiB7fSxcbiAgICAgIGF1dG86IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWZpZWxkXCI6IHtcbiAgICB0eXBlOiBcImZvcm1hdHRlZFwiLFxuICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgdG9rZW5zOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWZvbnRcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJzdHJpbmdcIixcbiAgICBkZWZhdWx0OiBbXG4gICAgICBcIk9wZW4gU2FucyBSZWd1bGFyXCIsXG4gICAgICBcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXG4gICAgXSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtc2l6ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxNixcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1tYXgtd2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMTAsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJlbXNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtbGluZS1oZWlnaHRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMS4yLFxuICAgIHVuaXRzOiBcImVtc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICB1bml0czogXCJlbXNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtanVzdGlmeVwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBhdXRvOiB7fSxcbiAgICAgIGxlZnQ6IHt9LFxuICAgICAgY2VudGVyOiB7fSxcbiAgICAgIHJpZ2h0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJjZW50ZXJcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtcmFkaWFsLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICB1bml0czogXCJlbXNcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwidGV4dC12YXJpYWJsZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBjZW50ZXI6IHt9LFxuICAgICAgbGVmdDoge30sXG4gICAgICByaWdodDoge30sXG4gICAgICB0b3A6IHt9LFxuICAgICAgYm90dG9tOiB7fSxcbiAgICAgIFwidG9wLWxlZnRcIjoge30sXG4gICAgICBcInRvcC1yaWdodFwiOiB7fSxcbiAgICAgIFwiYm90dG9tLWxlZnRcIjoge30sXG4gICAgICBcImJvdHRvbS1yaWdodFwiOiB7fVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAge1xuICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuICAgICAgICAgIFwicG9pbnRcIlxuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC12YXJpYWJsZS1hbmNob3Itb2Zmc2V0XCI6IHtcbiAgICB0eXBlOiBcInZhcmlhYmxlQW5jaG9yT2Zmc2V0Q29sbGVjdGlvblwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcbiAgICAgICAgICBcInBvaW50XCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgY2VudGVyOiB7fSxcbiAgICAgIGxlZnQ6IHt9LFxuICAgICAgcmlnaHQ6IHt9LFxuICAgICAgdG9wOiB7fSxcbiAgICAgIGJvdHRvbToge30sXG4gICAgICBcInRvcC1sZWZ0XCI6IHt9LFxuICAgICAgXCJ0b3AtcmlnaHRcIjoge30sXG4gICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgXCJib3R0b20tcmlnaHRcIjoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAge1xuICAgICAgICBcIiFcIjogXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiA0NSxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAge1xuICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuICAgICAgICAgIFwibGluZVwiLFxuICAgICAgICAgIFwibGluZS1jZW50ZXJcIlxuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC13cml0aW5nLW1vZGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBob3Jpem9udGFsOiB7fSxcbiAgICAgIHZlcnRpY2FsOiB7fVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAge1xuICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1xuICAgICAgICAgIFwicG9pbnRcIlxuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1yb3RhdGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMixcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZWZhdWx0OiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICB7XG4gICAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogXCJtYXBcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcbiAgICAgICAgICBcImxpbmVcIixcbiAgICAgICAgICBcImxpbmUtY2VudGVyXCJcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG5vbmU6IHt9LFxuICAgICAgdXBwZXJjYXNlOiB7fSxcbiAgICAgIGxvd2VyY2FzZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibm9uZVwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1vZmZzZXRcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICB1bml0czogXCJlbXNcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMCxcbiAgICAgIDBcbiAgICBdLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwidGV4dC1yYWRpYWwtb2Zmc2V0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITEsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAge1xuICAgICAgICBcIiFcIjogXCJ0ZXh0LW92ZXJsYXBcIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtb3ZlcmxhcFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBuZXZlcjoge30sXG4gICAgICBhbHdheXM6IHt9LFxuICAgICAgY29vcGVyYXRpdmU6IHt9XG4gICAgfSxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtb3B0aW9uYWxcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlZmF1bHQ6ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHt9LFxuICAgICAgbm9uZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufSwgZXMgPSB7XG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHt9LFxuICAgICAgbm9uZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufSwgdHMgPSB7XG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHt9LFxuICAgICAgbm9uZToge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufSwgcnMgPSB7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgdmFsdWU6IFwiKlwiXG59LCBucyA9IHtcbiAgdHlwZTogXCJlbnVtXCIsXG4gIHZhbHVlczoge1xuICAgIFwiPT1cIjoge30sXG4gICAgXCIhPVwiOiB7fSxcbiAgICBcIj5cIjoge30sXG4gICAgXCI+PVwiOiB7fSxcbiAgICBcIjxcIjoge30sXG4gICAgXCI8PVwiOiB7fSxcbiAgICBpbjoge30sXG4gICAgXCIhaW5cIjoge30sXG4gICAgYWxsOiB7fSxcbiAgICBhbnk6IHt9LFxuICAgIG5vbmU6IHt9LFxuICAgIGhhczoge30sXG4gICAgXCIhaGFzXCI6IHt9XG4gIH1cbn0sIGFzID0ge1xuICB0eXBlOiBcImVudW1cIixcbiAgdmFsdWVzOiB7XG4gICAgUG9pbnQ6IHt9LFxuICAgIExpbmVTdHJpbmc6IHt9LFxuICAgIFBvbHlnb246IHt9XG4gIH1cbn0sIG9zID0ge1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG1pbmltdW06IDAsXG4gIG1heGltdW06IDI0LFxuICB2YWx1ZTogW1xuICAgIFwibnVtYmVyXCIsXG4gICAgXCJjb2xvclwiXG4gIF0sXG4gIGxlbmd0aDogMlxufSwgaXMgPSB7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgdmFsdWU6IFwiKlwiLFxuICBtaW5pbXVtOiAxXG59LCBzcyA9IHtcbiAgYW5jaG9yOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgZGVmYXVsdDogXCJ2aWV3cG9ydFwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIHRyYW5zaXRpb246ICExLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfVxuICB9LFxuICBwb3NpdGlvbjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBkZWZhdWx0OiBbXG4gICAgICAxLjE1LFxuICAgICAgMjEwLFxuICAgICAgMzBcbiAgICBdLFxuICAgIGxlbmd0aDogMyxcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBkZWZhdWx0OiBcIiNmZmZmZmZcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogITBcbiAgfSxcbiAgaW50ZW5zaXR5OiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgZGVmYXVsdDogMC41LFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogITBcbiAgfVxufSwgbHMgPSB7XG4gIFwic2t5LWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IFwiIzg4QzZGQ1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAhMFxuICB9LFxuICBcImhvcml6b24tY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgZGVmYXVsdDogXCIjZmZmZmZmXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH0sXG4gIFwiZm9nLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IFwiI2ZmZmZmZlwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAhMFxuICB9LFxuICBcImZvZy1ncm91bmQtYmxlbmRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IDAuNSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH0sXG4gIFwiaG9yaXpvbi1mb2ctYmxlbmRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IDAuOCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH0sXG4gIFwic2t5LWhvcml6b24tYmxlbmRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIGRlZmF1bHQ6IDAuOCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246ICEwXG4gIH0sXG4gIFwiYXRtb3NwaGVyZS1ibGVuZFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgZGVmYXVsdDogMC44LFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogITBcbiAgfVxufSwgdXMgPSB7XG4gIHNvdXJjZToge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgcmVxdWlyZWQ6ICEwXG4gIH0sXG4gIGV4YWdnZXJhdGlvbjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgbWluaW11bTogMCxcbiAgICBkZWZhdWx0OiAxXG4gIH1cbn0sIGNzID0ge1xuICB0eXBlOiB7XG4gICAgdHlwZTogXCJwcm9qZWN0aW9uRGVmaW5pdGlvblwiLFxuICAgIGRlZmF1bHQ6IFwibWVyY2F0b3JcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgdHJhbnNpdGlvbjogITEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9XG4gIH1cbn0sIHBzID0gW1xuICBcInBhaW50X2ZpbGxcIixcbiAgXCJwYWludF9saW5lXCIsXG4gIFwicGFpbnRfY2lyY2xlXCIsXG4gIFwicGFpbnRfaGVhdG1hcFwiLFxuICBcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCIsXG4gIFwicGFpbnRfc3ltYm9sXCIsXG4gIFwicGFpbnRfcmFzdGVyXCIsXG4gIFwicGFpbnRfaGlsbHNoYWRlXCIsXG4gIFwicGFpbnRfY29sb3ItcmVsaWVmXCIsXG4gIFwicGFpbnRfYmFja2dyb3VuZFwiXG5dLCBmcyA9IHtcbiAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiZmlsbC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiZmlsbC1vdXRsaW5lLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogITBcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJmaWxsLXRyYW5zbGF0ZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBkZWZhdWx0OiBbXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0sXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImZpbGwtdHJhbnNsYXRlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJmaWxsLXBhdHRlcm5cIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICB9XG59LCBkcyA9IHtcbiAgXCJsaW5lLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAge1xuICAgICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIDAsXG4gICAgICAwXG4gICAgXSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtd2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWdhcC13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtb2Zmc2V0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJsaW5lIHdpZHRoc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG4gICAgICB9XG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWRcIlxuICB9LFxuICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1ncmFkaWVudFwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIHRyYW5zaXRpb246ICExLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcImxpbmUtZGFzaGFycmF5XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzb3VyY2U6IFwiZ2VvanNvblwiLFxuICAgICAgICBoYXM6IHtcbiAgICAgICAgICBsaW5lTWV0cmljczogITBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJsaW5lLXByb2dyZXNzXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuICB9XG59LCBocyA9IHtcbiAgXCJjaXJjbGUtcmFkaXVzXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDUsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1ibHVyXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIGRlZmF1bHQ6IFtcbiAgICAgIDAsXG4gICAgICAwXG4gICAgXSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7fSxcbiAgICAgIHZpZXdwb3J0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInZpZXdwb3J0XCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImNpcmNsZS1zdHJva2Utd2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1zdHJva2Utb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH1cbn0sIG1zID0ge1xuICBcImhlYXRtYXAtcmFkaXVzXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDMwLFxuICAgIG1pbmltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImhlYXRtYXAtd2VpZ2h0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaGVhdG1hcC1pbnRlbnNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoZWF0bWFwLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgXCJpbnRlcnBvbGF0ZVwiLFxuICAgICAgW1xuICAgICAgICBcImxpbmVhclwiXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImhlYXRtYXAtZGVuc2l0eVwiXG4gICAgICBdLFxuICAgICAgMCxcbiAgICAgIFwicmdiYSgwLCAwLCAyNTUsIDApXCIsXG4gICAgICAwLjEsXG4gICAgICBcInJveWFsYmx1ZVwiLFxuICAgICAgMC4zLFxuICAgICAgXCJjeWFuXCIsXG4gICAgICAwLjUsXG4gICAgICBcImxpbWVcIixcbiAgICAgIDAuNyxcbiAgICAgIFwieWVsbG93XCIsXG4gICAgICAxLFxuICAgICAgXCJyZWRcIlxuICAgIF0sXG4gICAgdHJhbnNpdGlvbjogITEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJoZWF0bWFwLWRlbnNpdHlcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gIH0sXG4gIFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufSwgeXMgPSB7XG4gIFwiaWNvbi1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkZWZhdWx0OiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWhhbG8td2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcImljb24taW1hZ2VcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24taGFsby1ibHVyXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJpY29uLWltYWdlXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXRyYW5zbGF0ZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBkZWZhdWx0OiBbXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0sXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgXCJpY29uLXRyYW5zbGF0ZVwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgIFwiZmVhdHVyZVwiLFxuICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBvdmVycmlkYWJsZTogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICByZXF1aXJlczogW1xuICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiLFxuICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgXSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIixcbiAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgIFwiZmVhdHVyZS1zdGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgZGVmYXVsdDogW1xuICAgICAgMCxcbiAgICAgIDBcbiAgICBdLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgdmlld3BvcnQ6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICBcInRleHQtZmllbGRcIixcbiAgICAgIFwidGV4dC10cmFuc2xhdGVcIlxuICAgIF0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59LCBncyA9IHtcbiAgXCJyYXN0ZXItb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWJyaWdodG5lc3MtbWF4XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IC0xLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1jb250cmFzdFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLFxuICAgIG1pbmltdW06IC0xLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1yZXNhbXBsaW5nXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGxpbmVhcjoge30sXG4gICAgICBuZWFyZXN0OiB7fVxuICAgIH0sXG4gICAgZGVmYXVsdDogXCJsaW5lYXJcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMzAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogITEsXG4gICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59LCB2cyA9IHtcbiAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJBcnJheVwiLFxuICAgIGRlZmF1bHQ6IDMzNSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDM1OSxcbiAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbHRpdHVkZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJBcnJheVwiLFxuICAgIGRlZmF1bHQ6IDQ1LFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogOTAsXG4gICAgdHJhbnNpdGlvbjogITEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge30sXG4gICAgICB2aWV3cG9ydDoge31cbiAgICB9LFxuICAgIGRlZmF1bHQ6IFwidmlld3BvcnRcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAwLjUsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoaWxsc2hhZGUtc2hhZG93LWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yQXJyYXlcIixcbiAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvckFycmF5XCIsXG4gICAgZGVmYXVsdDogXCIjRkZGRkZGXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1hY2NlbnQtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICBcInpvb21cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLW1ldGhvZFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBzdGFuZGFyZDoge30sXG4gICAgICBiYXNpYzoge30sXG4gICAgICBjb21iaW5lZDoge30sXG4gICAgICBpZ29yOiB7fSxcbiAgICAgIG11bHRpZGlyZWN0aW9uYWw6IHt9XG4gICAgfSxcbiAgICBkZWZhdWx0OiBcInN0YW5kYXJkXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgXCJ6b29tXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59LCBicyA9IHtcbiAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogITAsXG4gICAgcmVxdWlyZXM6IFtcbiAgICAgIHtcbiAgICAgICAgXCIhXCI6IFwiYmFja2dyb3VuZC1wYXR0ZXJuXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG4gIH0sXG4gIFwiYmFja2dyb3VuZC1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRlZmF1bHQ6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246ICEwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgIFwiem9vbVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufSwgd3MgPSB7XG4gIGR1cmF0aW9uOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkZWZhdWx0OiAzMDAsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIlxuICB9LFxuICBkZWxheToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiXG4gIH1cbn0sIFNzID0ge1xuICBcIipcIjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfVxufSwgeHMgPSB7XG4gICR2ZXJzaW9uOiAkaSxcbiAgJHJvb3Q6IE9pLFxuICBzb3VyY2VzOiBOaSxcbiAgc291cmNlOiBqaSxcbiAgc291cmNlX3ZlY3RvcjogVWksXG4gIHNvdXJjZV9yYXN0ZXI6IERpLFxuICBzb3VyY2VfcmFzdGVyX2RlbTogQmksXG4gIHNvdXJjZV9nZW9qc29uOiBxaSxcbiAgc291cmNlX3ZpZGVvOiBWaSxcbiAgc291cmNlX2ltYWdlOiBHaSxcbiAgbGF5ZXI6IEhpLFxuICBsYXlvdXQ6IFppLFxuICBsYXlvdXRfYmFja2dyb3VuZDogWGksXG4gIGxheW91dF9maWxsOiBLaSxcbiAgbGF5b3V0X2NpcmNsZTogWWksXG4gIGxheW91dF9oZWF0bWFwOiBXaSxcbiAgXCJsYXlvdXRfZmlsbC1leHRydXNpb25cIjoge1xuICAgIHZpc2liaWxpdHk6IHtcbiAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICBub25lOiB7fVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgIH1cbiAgfSxcbiAgbGF5b3V0X2xpbmU6IEppLFxuICBsYXlvdXRfc3ltYm9sOiBRaSxcbiAgbGF5b3V0X3Jhc3RlcjogZXMsXG4gIGxheW91dF9oaWxsc2hhZGU6IHRzLFxuICBcImxheW91dF9jb2xvci1yZWxpZWZcIjoge1xuICAgIHZpc2liaWxpdHk6IHtcbiAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICBub25lOiB7fVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgIH1cbiAgfSxcbiAgZmlsdGVyOiBycyxcbiAgZmlsdGVyX29wZXJhdG9yOiBucyxcbiAgZ2VvbWV0cnlfdHlwZTogYXMsXG4gIGZ1bmN0aW9uOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdHlwZTogXCJleHByZXNzaW9uXCJcbiAgICB9LFxuICAgIHN0b3BzOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICB2YWx1ZTogXCJmdW5jdGlvbl9zdG9wXCJcbiAgICB9LFxuICAgIGJhc2U6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgcHJvcGVydHk6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkZWZhdWx0OiBcIiR6b29tXCJcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIGlkZW50aXR5OiB7fSxcbiAgICAgICAgZXhwb25lbnRpYWw6IHt9LFxuICAgICAgICBpbnRlcnZhbDoge30sXG4gICAgICAgIGNhdGVnb3JpY2FsOiB7fVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFwiZXhwb25lbnRpYWxcIlxuICAgIH0sXG4gICAgY29sb3JTcGFjZToge1xuICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgcmdiOiB7fSxcbiAgICAgICAgbGFiOiB7fSxcbiAgICAgICAgaGNsOiB7fVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFwicmdiXCJcbiAgICB9LFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHR5cGU6IFwiKlwiLFxuICAgICAgcmVxdWlyZWQ6ICExXG4gICAgfVxuICB9LFxuICBmdW5jdGlvbl9zdG9wOiBvcyxcbiAgZXhwcmVzc2lvbjogaXMsXG4gIGxpZ2h0OiBzcyxcbiAgc2t5OiBscyxcbiAgdGVycmFpbjogdXMsXG4gIHByb2plY3Rpb246IGNzLFxuICBwYWludDogcHMsXG4gIHBhaW50X2ZpbGw6IGZzLFxuICBcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCI6IHtcbiAgICBcImZpbGwtZXh0cnVzaW9uLW9wYWNpdHlcIjoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgIH0sXG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgcmVxdWlyZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgbGVuZ3RoOiAyLFxuICAgICAgZGVmYXVsdDogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICBtYXA6IHt9LFxuICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgcmVxdWlyZXM6IFtcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIlxuICAgICAgXSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiem9vbVwiXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiOiB7XG4gICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgICAgXCJmZWF0dXJlXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCI6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIHVuaXRzOiBcIm1ldGVyc1wiLFxuICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICBcInpvb21cIixcbiAgICAgICAgICBcImZlYXR1cmVcIixcbiAgICAgICAgICBcImZlYXR1cmUtc3RhdGVcIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgIH0sXG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIHVuaXRzOiBcIm1ldGVyc1wiLFxuICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICByZXF1aXJlczogW1xuICAgICAgICBcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiXG4gICAgICBdLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCIsXG4gICAgICAgICAgXCJmZWF0dXJlXCIsXG4gICAgICAgICAgXCJmZWF0dXJlLXN0YXRlXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnRcIjoge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiAhMCxcbiAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICAgICAgXCJ6b29tXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgIH1cbiAgfSxcbiAgcGFpbnRfbGluZTogZHMsXG4gIHBhaW50X2NpcmNsZTogaHMsXG4gIHBhaW50X2hlYXRtYXA6IG1zLFxuICBwYWludF9zeW1ib2w6IHlzLFxuICBwYWludF9yYXN0ZXI6IGdzLFxuICBwYWludF9oaWxsc2hhZGU6IHZzLFxuICBcInBhaW50X2NvbG9yLXJlbGllZlwiOiB7XG4gICAgXCJjb2xvci1yZWxpZWYtb3BhY2l0eVwiOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICBcInpvb21cIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgfSxcbiAgICBcImNvbG9yLXJlbGllZi1jb2xvclwiOiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIFwiZWxldmF0aW9uXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuICAgIH1cbiAgfSxcbiAgcGFpbnRfYmFja2dyb3VuZDogYnMsXG4gIHRyYW5zaXRpb246IHdzLFxuICBcInByb3BlcnR5LXR5cGVcIjoge1xuICAgIFwiZGF0YS1kcml2ZW5cIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICB9LFxuICAgIFwiY3Jvc3MtZmFkZWRcIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICB9LFxuICAgIFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICB9LFxuICAgIFwiY29sb3ItcmFtcFwiOiB7XG4gICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIlxuICAgIH0sXG4gICAgXCJkYXRhLWNvbnN0YW50XCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgfSxcbiAgICBjb25zdGFudDoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICB9XG4gIH0sXG4gIHByb21vdGVJZDogU3Ncbn07XG5jbGFzcyBiIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSkge1xuICAgIHRoaXMubWVzc2FnZSA9IChlID8gYCR7ZX06IGAgOiBcIlwiKSArIG4sIGEgJiYgKHRoaXMuaWRlbnRpZmllciA9IGEpLCB0ICE9IG51bGwgJiYgdC5fX2xpbmVfXyAmJiAodGhpcy5saW5lID0gdC5fX2xpbmVfXyk7XG4gIH1cbn1cbmZ1bmN0aW9uIER0KHIsIC4uLmUpIHtcbiAgZm9yIChjb25zdCB0IG9mIGUpXG4gICAgZm9yIChjb25zdCBuIGluIHQpXG4gICAgICByW25dID0gdFtuXTtcbiAgcmV0dXJuIHI7XG59XG5jbGFzcyBiZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKHQpLCB0aGlzLm1lc3NhZ2UgPSB0LCB0aGlzLmtleSA9IGU7XG4gIH1cbn1cbmNsYXNzIHJuIHtcbiAgY29uc3RydWN0b3IoZSwgdCA9IFtdKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBlLCB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgZm9yIChjb25zdCBbbiwgYV0gb2YgdClcbiAgICAgIHRoaXMuYmluZGluZ3Nbbl0gPSBhO1xuICB9XG4gIGNvbmNhdChlKSB7XG4gICAgcmV0dXJuIG5ldyBybih0aGlzLCBlKTtcbiAgfVxuICBnZXQoZSkge1xuICAgIGlmICh0aGlzLmJpbmRpbmdzW2VdKVxuICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbZV07XG4gICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gbm90IGZvdW5kIGluIHNjb3BlLmApO1xuICB9XG4gIGhhcyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbZV0gPyAhMCA6IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaGFzKGUpIDogITE7XG4gIH1cbn1cbmNvbnN0IFd0ID0geyBraW5kOiBcIm51bGxcIiB9LCBTID0geyBraW5kOiBcIm51bWJlclwiIH0sIFAgPSB7IGtpbmQ6IFwic3RyaW5nXCIgfSwgTSA9IHsga2luZDogXCJib29sZWFuXCIgfSwgd2UgPSB7IGtpbmQ6IFwiY29sb3JcIiB9LCBKdCA9IHsga2luZDogXCJwcm9qZWN0aW9uRGVmaW5pdGlvblwiIH0sIEJlID0geyBraW5kOiBcIm9iamVjdFwiIH0sIEkgPSB7IGtpbmQ6IFwidmFsdWVcIiB9LCBrcyA9IHsga2luZDogXCJlcnJvclwiIH0sIFF0ID0geyBraW5kOiBcImNvbGxhdG9yXCIgfSwgZXIgPSB7IGtpbmQ6IFwiZm9ybWF0dGVkXCIgfSwgdHIgPSB7IGtpbmQ6IFwicGFkZGluZ1wiIH0sIHl0ID0geyBraW5kOiBcImNvbG9yQXJyYXlcIiB9LCByciA9IHsga2luZDogXCJudW1iZXJBcnJheVwiIH0sIEF0ID0geyBraW5kOiBcInJlc29sdmVkSW1hZ2VcIiB9LCBuciA9IHsga2luZDogXCJ2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb25cIiB9O1xuZnVuY3Rpb24gdGUociwgZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwiYXJyYXlcIixcbiAgICBpdGVtVHlwZTogcixcbiAgICBOOiBlXG4gIH07XG59XG5mdW5jdGlvbiBVKHIpIHtcbiAgaWYgKHIua2luZCA9PT0gXCJhcnJheVwiKSB7XG4gICAgY29uc3QgZSA9IFUoci5pdGVtVHlwZSk7XG4gICAgcmV0dXJuIHR5cGVvZiByLk4gPT0gXCJudW1iZXJcIiA/IGBhcnJheTwke2V9LCAke3IuTn0+YCA6IHIuaXRlbVR5cGUua2luZCA9PT0gXCJ2YWx1ZVwiID8gXCJhcnJheVwiIDogYGFycmF5PCR7ZX0+YDtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIHIua2luZDtcbn1cbmNvbnN0IExzID0gW1xuICBXdCxcbiAgUyxcbiAgUCxcbiAgTSxcbiAgd2UsXG4gIEp0LFxuICBlcixcbiAgQmUsXG4gIHRlKEkpLFxuICB0cixcbiAgcnIsXG4gIHl0LFxuICBBdCxcbiAgbnJcbl07XG5mdW5jdGlvbiBndChyLCBlKSB7XG4gIGlmIChlLmtpbmQgPT09IFwiZXJyb3JcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHIua2luZCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKGUua2luZCA9PT0gXCJhcnJheVwiICYmIChlLk4gPT09IDAgJiYgZS5pdGVtVHlwZS5raW5kID09PSBcInZhbHVlXCIgfHwgIWd0KHIuaXRlbVR5cGUsIGUuaXRlbVR5cGUpKSAmJiAodHlwZW9mIHIuTiAhPSBcIm51bWJlclwiIHx8IHIuTiA9PT0gZS5OKSlcbiAgICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIGlmIChyLmtpbmQgPT09IGUua2luZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChyLmtpbmQgPT09IFwidmFsdWVcIikge1xuICAgICAgZm9yIChjb25zdCB0IG9mIExzKVxuICAgICAgICBpZiAoIWd0KHQsIGUpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYEV4cGVjdGVkICR7VShyKX0gYnV0IGZvdW5kICR7VShlKX0gaW5zdGVhZC5gO1xufVxuZnVuY3Rpb24gbm4ociwgZSkge1xuICByZXR1cm4gZS5zb21lKCh0KSA9PiB0LmtpbmQgPT09IHIua2luZCk7XG59XG5mdW5jdGlvbiBxZShyLCBlKSB7XG4gIHJldHVybiBlLnNvbWUoKHQpID0+IHQgPT09IFwibnVsbFwiID8gciA9PT0gbnVsbCA6IHQgPT09IFwiYXJyYXlcIiA/IEFycmF5LmlzQXJyYXkocikgOiB0ID09PSBcIm9iamVjdFwiID8gciAmJiAhQXJyYXkuaXNBcnJheShyKSAmJiB0eXBlb2YgciA9PSBcIm9iamVjdFwiIDogdCA9PT0gdHlwZW9mIHIpO1xufVxuZnVuY3Rpb24gRWUociwgZSkge1xuICByZXR1cm4gci5raW5kID09PSBcImFycmF5XCIgJiYgZS5raW5kID09PSBcImFycmF5XCIgPyByLml0ZW1UeXBlLmtpbmQgPT09IGUuaXRlbVR5cGUua2luZCAmJiB0eXBlb2Ygci5OID09IFwibnVtYmVyXCIgOiByLmtpbmQgPT09IGUua2luZDtcbn1cbmNvbnN0IFBhID0gMC45NjQyMiwgUmEgPSAxLCB6YSA9IDAuODI1MjEsIEZhID0gNCAvIDI5LCB0dCA9IDYgLyAyOSwgJGEgPSAzICogdHQgKiB0dCwgQ3MgPSB0dCAqIHR0ICogdHQsIEVzID0gTWF0aC5QSSAvIDE4MCwgQXMgPSAxODAgLyBNYXRoLlBJO1xuZnVuY3Rpb24gT2Eocikge1xuICByZXR1cm4gciA9IHIgJSAzNjAsIHIgPCAwICYmIChyICs9IDM2MCksIHI7XG59XG5mdW5jdGlvbiBOYShbciwgZSwgdCwgbl0pIHtcbiAgciA9IHZyKHIpLCBlID0gdnIoZSksIHQgPSB2cih0KTtcbiAgbGV0IGEsIG87XG4gIGNvbnN0IGkgPSBicigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGUgKyAwLjA2MDYxNjkgKiB0KSAvIFJhKTtcbiAgciA9PT0gZSAmJiBlID09PSB0ID8gYSA9IG8gPSBpIDogKGEgPSBicigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGUgKyAwLjE0MzA4MDQgKiB0KSAvIFBhKSwgbyA9IGJyKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZSArIDAuNzE0MTczMyAqIHQpIC8gemEpKTtcbiAgY29uc3QgcyA9IDExNiAqIGkgLSAxNjtcbiAgcmV0dXJuIFtzIDwgMCA/IDAgOiBzLCA1MDAgKiAoYSAtIGkpLCAyMDAgKiAoaSAtIG8pLCBuXTtcbn1cbmZ1bmN0aW9uIHZyKHIpIHtcbiAgcmV0dXJuIHIgPD0gMC4wNDA0NSA/IHIgLyAxMi45MiA6IE1hdGgucG93KChyICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5mdW5jdGlvbiBicihyKSB7XG4gIHJldHVybiByID4gQ3MgPyBNYXRoLnBvdyhyLCAxIC8gMykgOiByIC8gJGEgKyBGYTtcbn1cbmZ1bmN0aW9uIGphKFtyLCBlLCB0LCBuXSkge1xuICBsZXQgYSA9IChyICsgMTYpIC8gMTE2LCBvID0gaXNOYU4oZSkgPyBhIDogYSArIGUgLyA1MDAsIGkgPSBpc05hTih0KSA/IGEgOiBhIC0gdCAvIDIwMDtcbiAgcmV0dXJuIGEgPSBSYSAqIFNyKGEpLCBvID0gUGEgKiBTcihvKSwgaSA9IHphICogU3IoaSksIFtcbiAgICB3cigzLjEzMzg1NjEgKiBvIC0gMS42MTY4NjY3ICogYSAtIDAuNDkwNjE0NiAqIGkpLFxuICAgIC8vIEQ1MCAtPiBzUkdCXG4gICAgd3IoLTAuOTc4NzY4NCAqIG8gKyAxLjkxNjE0MTUgKiBhICsgMC4wMzM0NTQgKiBpKSxcbiAgICB3cigwLjA3MTk0NTMgKiBvIC0gMC4yMjg5OTE0ICogYSArIDEuNDA1MjQyNyAqIGkpLFxuICAgIG5cbiAgXTtcbn1cbmZ1bmN0aW9uIHdyKHIpIHtcbiAgcmV0dXJuIHIgPSByIDw9IDMwNGUtNSA/IDEyLjkyICogciA6IDEuMDU1ICogTWF0aC5wb3cociwgMSAvIDIuNCkgLSAwLjA1NSwgciA8IDAgPyAwIDogciA+IDEgPyAxIDogcjtcbn1cbmZ1bmN0aW9uIFNyKHIpIHtcbiAgcmV0dXJuIHIgPiB0dCA/IHIgKiByICogciA6ICRhICogKHIgLSBGYSk7XG59XG5mdW5jdGlvbiBUcyhyKSB7XG4gIGNvbnN0IFtlLCB0LCBuLCBhXSA9IE5hKHIpLCBvID0gTWF0aC5zcXJ0KHQgKiB0ICsgbiAqIG4pO1xuICByZXR1cm4gW01hdGgucm91bmQobyAqIDFlNCkgPyBPYShNYXRoLmF0YW4yKG4sIHQpICogQXMpIDogTmFOLCBvLCBlLCBhXTtcbn1cbmZ1bmN0aW9uIF9zKFtyLCBlLCB0LCBuXSkge1xuICByZXR1cm4gciA9IGlzTmFOKHIpID8gMCA6IHIgKiBFcywgamEoW3QsIE1hdGguY29zKHIpICogZSwgTWF0aC5zaW4ocikgKiBlLCBuXSk7XG59XG5mdW5jdGlvbiBJcyhbciwgZSwgdCwgbl0pIHtcbiAgciA9IE9hKHIpLCBlIC89IDEwMCwgdCAvPSAxMDA7XG4gIGZ1bmN0aW9uIGEobykge1xuICAgIGNvbnN0IGkgPSAobyArIHIgLyAzMCkgJSAxMiwgcyA9IGUgKiBNYXRoLm1pbih0LCAxIC0gdCk7XG4gICAgcmV0dXJuIHQgLSBzICogTWF0aC5tYXgoLTEsIE1hdGgubWluKGkgLSAzLCA5IC0gaSwgMSkpO1xuICB9XG4gIHJldHVybiBbYSgwKSwgYSg4KSwgYSg0KSwgbl07XG59XG5jb25zdCBNcyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpO1xufTtcbmZ1bmN0aW9uIGR0KHIsIGUpIHtcbiAgcmV0dXJuIE1zKHIsIGUpID8gcltlXSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIFBzKHIpIHtcbiAgaWYgKHIgPSByLnRvTG93ZXJDYXNlKCkudHJpbSgpLCByID09PSBcInRyYW5zcGFyZW50XCIpXG4gICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgY29uc3QgZSA9IGR0KFJzLCByKTtcbiAgaWYgKGUpIHtcbiAgICBjb25zdCBbYSwgbywgaV0gPSBlO1xuICAgIHJldHVybiBbYSAvIDI1NSwgbyAvIDI1NSwgaSAvIDI1NSwgMV07XG4gIH1cbiAgaWYgKHIuc3RhcnRzV2l0aChcIiNcIikgJiYgL14jKD86WzAtOWEtZl17Myw0fXxbMC05YS1mXXs2fXxbMC05YS1mXXs4fSkkLy50ZXN0KHIpKSB7XG4gICAgY29uc3QgbyA9IHIubGVuZ3RoIDwgNiA/IDEgOiAyO1xuICAgIGxldCBpID0gMTtcbiAgICByZXR1cm4gW1xuICAgICAgUHQoci5zbGljZShpLCBpICs9IG8pKSxcbiAgICAgIFB0KHIuc2xpY2UoaSwgaSArPSBvKSksXG4gICAgICBQdChyLnNsaWNlKGksIGkgKz0gbykpLFxuICAgICAgUHQoci5zbGljZShpLCBpICsgbykgfHwgXCJmZlwiKVxuICAgIF07XG4gIH1cbiAgaWYgKHIuc3RhcnRzV2l0aChcInJnYlwiKSkge1xuICAgIGNvbnN0IGEgPSAvXnJnYmE/XFwoXFxzKihbXFxkZS4rLV0rKSglKT8oPzpcXHMrfFxccyooLClcXHMqKShbXFxkZS4rLV0rKSglKT8oPzpcXHMrfFxccyooLClcXHMqKShbXFxkZS4rLV0rKSglKT8oPzpcXHMqKFssXFwvXSlcXHMqKFtcXGRlListXSspKCUpPyk/XFxzKlxcKSQvLCBvID0gci5tYXRjaChhKTtcbiAgICBpZiAobykge1xuICAgICAgY29uc3QgW1xuICAgICAgICBpLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBzLFxuICAgICAgICAvLyA8bnVtZXJpYz5cbiAgICAgICAgbCxcbiAgICAgICAgLy8gJSAgICAgICAgIChvcHRpb25hbClcbiAgICAgICAgdSxcbiAgICAgICAgLy8gLCAgICAgICAgIChvcHRpb25hbClcbiAgICAgICAgYyxcbiAgICAgICAgLy8gPG51bWVyaWM+XG4gICAgICAgIHAsXG4gICAgICAgIC8vICUgICAgICAgICAob3B0aW9uYWwpXG4gICAgICAgIGQsXG4gICAgICAgIC8vICwgICAgICAgICAob3B0aW9uYWwpXG4gICAgICAgIGYsXG4gICAgICAgIC8vIDxudW1lcmljPlxuICAgICAgICBoLFxuICAgICAgICAvLyAlICAgICAgICAgKG9wdGlvbmFsKVxuICAgICAgICBtLFxuICAgICAgICAvLyAsfC8gICAgICAgKG9wdGlvbmFsKVxuICAgICAgICB5LFxuICAgICAgICAvLyA8bnVtZXJpYz4gKG9wdGlvbmFsKVxuICAgICAgICB3XG4gICAgICAgIC8vICUgICAgICAgICAob3B0aW9uYWwpXG4gICAgICBdID0gbywgZyA9IFt1IHx8IFwiIFwiLCBkIHx8IFwiIFwiLCBtXS5qb2luKFwiXCIpO1xuICAgICAgaWYgKGcgPT09IFwiICBcIiB8fCBnID09PSBcIiAgL1wiIHx8IGcgPT09IFwiLCxcIiB8fCBnID09PSBcIiwsLFwiKSB7XG4gICAgICAgIGNvbnN0IHggPSBbbCwgcCwgaF0uam9pbihcIlwiKSwgRSA9IHggPT09IFwiJSUlXCIgPyAxMDAgOiB4ID09PSBcIlwiID8gMjU1IDogMDtcbiAgICAgICAgaWYgKEUpIHtcbiAgICAgICAgICBjb25zdCBDID0gW1xuICAgICAgICAgICAgUWUoK3MgLyBFLCAwLCAxKSxcbiAgICAgICAgICAgIFFlKCtjIC8gRSwgMCwgMSksXG4gICAgICAgICAgICBRZSgrZiAvIEUsIDAsIDEpLFxuICAgICAgICAgICAgeSA/IGpuKCt5LCB3KSA6IDFcbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmIChVbihDKSlcbiAgICAgICAgICAgIHJldHVybiBDO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHQgPSAvXmhzbGE/XFwoXFxzKihbXFxkZS4rLV0rKSg/OmRlZyk/KD86XFxzK3xcXHMqKCwpXFxzKikoW1xcZGUuKy1dKyklKD86XFxzK3xcXHMqKCwpXFxzKikoW1xcZGUuKy1dKyklKD86XFxzKihbLFxcL10pXFxzKihbXFxkZS4rLV0rKSglKT8pP1xccypcXCkkLywgbiA9IHIubWF0Y2godCk7XG4gIGlmIChuKSB7XG4gICAgY29uc3QgW1xuICAgICAgYSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICBvLFxuICAgICAgLy8gPG51bWVyaWM+XG4gICAgICBpLFxuICAgICAgLy8gLCAgICAgICAgIChvcHRpb25hbClcbiAgICAgIHMsXG4gICAgICAvLyA8bnVtZXJpYz5cbiAgICAgIGwsXG4gICAgICAvLyAsICAgICAgICAgKG9wdGlvbmFsKVxuICAgICAgdSxcbiAgICAgIC8vIDxudW1lcmljPlxuICAgICAgYyxcbiAgICAgIC8vICx8LyAgICAgICAob3B0aW9uYWwpXG4gICAgICBwLFxuICAgICAgLy8gPG51bWVyaWM+IChvcHRpb25hbClcbiAgICAgIGRcbiAgICAgIC8vICUgICAgICAgICAob3B0aW9uYWwpXG4gICAgXSA9IG4sIGYgPSBbaSB8fCBcIiBcIiwgbCB8fCBcIiBcIiwgY10uam9pbihcIlwiKTtcbiAgICBpZiAoZiA9PT0gXCIgIFwiIHx8IGYgPT09IFwiICAvXCIgfHwgZiA9PT0gXCIsLFwiIHx8IGYgPT09IFwiLCwsXCIpIHtcbiAgICAgIGNvbnN0IGggPSBbXG4gICAgICAgICtvLFxuICAgICAgICBRZSgrcywgMCwgMTAwKSxcbiAgICAgICAgUWUoK3UsIDAsIDEwMCksXG4gICAgICAgIHAgPyBqbigrcCwgZCkgOiAxXG4gICAgICBdO1xuICAgICAgaWYgKFVuKGgpKVxuICAgICAgICByZXR1cm4gSXMoaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBQdChyKSB7XG4gIHJldHVybiBwYXJzZUludChyLnBhZEVuZCgyLCByKSwgMTYpIC8gMjU1O1xufVxuZnVuY3Rpb24gam4ociwgZSkge1xuICByZXR1cm4gUWUoZSA/IHIgLyAxMDAgOiByLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIFFlKHIsIGUsIHQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGUsIHIpLCB0KTtcbn1cbmZ1bmN0aW9uIFVuKHIpIHtcbiAgcmV0dXJuICFyLnNvbWUoTnVtYmVyLmlzTmFOKTtcbn1cbmNvbnN0IFJzID0ge1xuICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gIGJsdWU6IFswLCAwLCAyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogWzI1NSwgMCwgMF0sXG4gIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn07XG5mdW5jdGlvbiB6ZShyLCBlLCB0KSB7XG4gIHJldHVybiByICsgdCAqIChlIC0gcik7XG59XG5mdW5jdGlvbiBhdChyLCBlLCB0KSB7XG4gIHJldHVybiByLm1hcCgobiwgYSkgPT4gemUobiwgZVthXSwgdCkpO1xufVxuY2xhc3MgJCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gciBSZWQgY29tcG9uZW50IHByZW11bHRpcGxpZWQgYnkgYGFscGhhYCAwLi4xXG4gICAqIEBwYXJhbSBnIEdyZWVuIGNvbXBvbmVudCBwcmVtdWx0aXBsaWVkIGJ5IGBhbHBoYWAgMC4uMVxuICAgKiBAcGFyYW0gYiBCbHVlIGNvbXBvbmVudCBwcmVtdWx0aXBsaWVkIGJ5IGBhbHBoYWAgMC4uMVxuICAgKiBAcGFyYW0gW2FscGhhPTFdIEFscGhhIGNvbXBvbmVudCAwLi4xXG4gICAqIEBwYXJhbSBbcHJlbXVsdGlwbGllZD10cnVlXSBXaGV0aGVyIHRoZSBgcmAsIGBnYCBhbmQgYGJgIHZhbHVlcyBoYXZlIGFscmVhZHlcbiAgICogYmVlbiBtdWx0aXBsaWVkIGJ5IGFscGhhLiBJZiBgdHJ1ZWAgbm90aGluZyBoYXBwZW5zIGlmIGBmYWxzZWAgdGhlbiB0aGV5IHdpbGxcbiAgICogYmUgbXVsdGlwbGllZCBhdXRvbWF0aWNhbGx5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSA9IDEsIG8gPSAhMCkge1xuICAgIHRoaXMuciA9IGUsIHRoaXMuZyA9IHQsIHRoaXMuYiA9IG4sIHRoaXMuYSA9IGEsIG8gfHwgKHRoaXMuciAqPSBhLCB0aGlzLmcgKj0gYSwgdGhpcy5iICo9IGEsIGEgfHwgdGhpcy5vdmVyd3JpdGVHZXR0ZXIoXCJyZ2JcIiwgW2UsIHQsIG4sIGFdKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBDU1MgY29sb3Igc3RyaW5ncyBhbmQgY29udmVydHMgY29sb3JzIHRvIHNSR0IgY29sb3Igc3BhY2UgaWYgbmVlZGVkLlxuICAgKiBPZmZpY2lhbGx5IHN1cHBvcnRlZCBjb2xvciBmb3JtYXRzOlxuICAgKiAtIGtleXdvcmQsIGUuZy4gJ2FxdWFtYXJpbmUnIG9yICdzdGVlbGJsdWUnXG4gICAqIC0gaGV4ICh3aXRoIDMsIDQsIDYgb3IgOCBkaWdpdHMpLCBlLmcuICcjZjBmJyBvciAnI2U5YmViZWE5J1xuICAgKiAtIHJnYiBhbmQgcmdiYSwgZS5nLiAncmdiKDAsMjQwLDEyMCknIG9yICdyZ2JhKDAlLDk0JSw0NyUsMC4xKScgb3IgJ3JnYigwIDI0MCAxMjAgLyAuMyknXG4gICAqIC0gaHNsIGFuZCBoc2xhLCBlLmcuICdoc2woMCwwJSw4MyUpJyBvciAnaHNsYSgwLDAlLDgzJSwuNSknIG9yICdoc2woMCAwJSA4MyUgLyAyMCUpJ1xuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgQ1NTIGNvbG9yIHN0cmluZyB0byBwYXJzZS5cbiAgICogQHJldHVybnMgQSBgQ29sb3JgIGluc3RhbmNlLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgY29sb3Igc3RyaW5nLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mICQpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gUHMoZSk7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm4gbmV3ICQoLi4udCwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGluIGNvbG9yIGludGVycG9sYXRpb24gYW5kIGJ5ICd0by1yZ2JhJyBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBHaWVuIGNvbG9yLCB3aXRoIHJldmVyc2VkIGFscGhhIGJsZW5kaW5nLCBpbiBzUkdCIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZ2V0IHJnYigpIHtcbiAgICBjb25zdCB7IHI6IGUsIGc6IHQsIGI6IG4sIGEgfSA9IHRoaXMsIG8gPSBhIHx8IDEgLyAwO1xuICAgIHJldHVybiB0aGlzLm92ZXJ3cml0ZUdldHRlcihcInJnYlwiLCBbZSAvIG8sIHQgLyBvLCBuIC8gbywgYV0pO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGluIGNvbG9yIGludGVycG9sYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIEdpZW4gY29sb3IsIHdpdGggcmV2ZXJzZWQgYWxwaGEgYmxlbmRpbmcsIGluIEhDTCBjb2xvciBzcGFjZS5cbiAgICovXG4gIGdldCBoY2woKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcndyaXRlR2V0dGVyKFwiaGNsXCIsIFRzKHRoaXMucmdiKSk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgaW4gY29sb3IgaW50ZXJwb2xhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgR2llbiBjb2xvciwgd2l0aCByZXZlcnNlZCBhbHBoYSBibGVuZGluZywgaW4gTEFCIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZ2V0IGxhYigpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVyd3JpdGVHZXR0ZXIoXCJsYWJcIiwgTmEodGhpcy5yZ2IpKTtcbiAgfVxuICAvKipcbiAgICogTGF6eSBnZXR0ZXIgcGF0dGVybi4gV2hlbiBnZXR0ZXIgaXMgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBsYXp5IHZhbHVlXG4gICAqIGlzIGNhbGN1bGF0ZWQgYW5kIHRoZW4gb3ZlcndyaXRlcyBnZXR0ZXIgZnVuY3Rpb24gaW4gZ2l2ZW4gb2JqZWN0IGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZTpcbiAgICogY29uc3QgcmVkQ29sb3IgPSBDb2xvci5wYXJzZSgncmVkJyk7XG4gICAqIGxldCB4ID0gcmVkQ29sb3IuaGNsOyAvLyB0aGlzIHdpbGwgaW52b2tlIGBnZXQgaGNsKClgLCB3aGljaCB3aWxsIGNhbGN1bGF0ZVxuICAgKiAvLyB0aGUgdmFsdWUgb2YgcmVkIGluIEhDTCBzcGFjZSBhbmQgaW52b2tlIHRoaXMgYG92ZXJ3cml0ZUdldHRlcmAgZnVuY3Rpb25cbiAgICogLy8gd2hpY2ggaW4gdHVybiB3aWxsIHNldCBhIGZpZWxkIHdpdGggYSBrZXkgJ2hjbCcgaW4gdGhlIGByZWRDb2xvcmAgb2JqZWN0LlxuICAgKiAvLyBJbiBvdGhlciB3b3JkcyBpdCB3aWxsIG92ZXJyaWRlIGBnZXQgaGNsKClgIGZyb20gaXRzIGBDb2xvcmAgcHJvdG90eXBlXG4gICAqIC8vIHdpdGggaXRzIG93biBwcm9wZXJ0eTogaGNsID0gW2NhbGN1bGF0ZWQgcmVkIHZhbHVlIGluIGhjbF0uXG4gICAqIGxldCB5ID0gcmVkQ29sb3IuaGNsOyAvLyBuZXh0IGNhbGwgd2lsbCBubyBsb25nZXIgaW52b2tlIGdldHRlciBidXQgc2ltcGx5XG4gICAqIC8vIHJldHVybiB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIHZhbHVlXG4gICAqIHggPT09IHk7IC8vIHRydWUgLSBgeGAgaXMgZXhhY3RseSB0aGUgc2FtZSBvYmplY3QgYXMgYHlgXG4gICAqXG4gICAqIEBwYXJhbSBnZXR0ZXJLZXkgR2V0dGVyIGtleVxuICAgKiBAcGFyYW0gbGF6eVZhbHVlIExhemlseSBjYWxjdWxhdGVkIHZhbHVlIHRvIGJlIG1lbW9pemVkIGJ5IGN1cnJlbnQgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG92ZXJ3cml0ZUdldHRlcihlLCB0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBlLCB7IHZhbHVlOiB0IH0pLCB0O1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5ICd0by1zdHJpbmcnIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEByZXR1cm5zIFNlcmlhbGl6ZWQgY29sb3IgaW4gZm9ybWF0IGByZ2JhKHIsZyxiLGEpYFxuICAgKiB3aGVyZSByLGcsYiBhcmUgbnVtYmVycyB3aXRoaW4gMC4uMjU1IGFuZCBhbHBoYSBpcyBudW1iZXIgd2l0aGluIDEuLjBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHB1cnBsZSA9IG5ldyBDb2xvci5wYXJzZSgncHVycGxlJyk7XG4gICAqIHB1cnBsZS50b1N0cmluZzsgLy8gPSBcInJnYmEoMTI4LDAsMTI4LDEpXCJcbiAgICogdmFyIHRyYW5zbHVjZW50R3JlZW4gPSBuZXcgQ29sb3IucGFyc2UoJ3JnYmEoMjYsIDIwNywgMjYsIC43MyknKTtcbiAgICogdHJhbnNsdWNlbnRHcmVlbi50b1N0cmluZygpOyAvLyA9IFwicmdiYSgyNiwyMDcsMjYsMC43MylcIlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgW2UsIHQsIG4sIGFdID0gdGhpcy5yZ2I7XG4gICAgcmV0dXJuIGByZ2JhKCR7W2UsIHQsIG5dLm1hcCgobykgPT4gTWF0aC5yb3VuZChvICogMjU1KSkuam9pbihcIixcIil9LCR7YX0pYDtcbiAgfVxuICBzdGF0aWMgaW50ZXJwb2xhdGUoZSwgdCwgbiwgYSA9IFwicmdiXCIpIHtcbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2UgXCJyZ2JcIjoge1xuICAgICAgICBjb25zdCBbbywgaSwgcywgbF0gPSBhdChlLnJnYiwgdC5yZ2IsIG4pO1xuICAgICAgICByZXR1cm4gbmV3ICQobywgaSwgcywgbCwgITEpO1xuICAgICAgfVxuICAgICAgY2FzZSBcImhjbFwiOiB7XG4gICAgICAgIGNvbnN0IFtvLCBpLCBzLCBsXSA9IGUuaGNsLCBbdSwgYywgcCwgZF0gPSB0LmhjbDtcbiAgICAgICAgbGV0IGYsIGg7XG4gICAgICAgIGlmICghaXNOYU4obykgJiYgIWlzTmFOKHUpKSB7XG4gICAgICAgICAgbGV0IHggPSB1IC0gbztcbiAgICAgICAgICB1ID4gbyAmJiB4ID4gMTgwID8geCAtPSAzNjAgOiB1IDwgbyAmJiBvIC0gdSA+IDE4MCAmJiAoeCArPSAzNjApLCBmID0gbyArIG4gKiB4O1xuICAgICAgICB9IGVsc2UgaXNOYU4obykgPyBpc05hTih1KSA/IGYgPSBOYU4gOiAoZiA9IHUsIChzID09PSAxIHx8IHMgPT09IDApICYmIChoID0gYykpIDogKGYgPSBvLCAocCA9PT0gMSB8fCBwID09PSAwKSAmJiAoaCA9IGkpKTtcbiAgICAgICAgY29uc3QgW20sIHksIHcsIGddID0gX3MoW1xuICAgICAgICAgIGYsXG4gICAgICAgICAgaCA/PyB6ZShpLCBjLCBuKSxcbiAgICAgICAgICB6ZShzLCBwLCBuKSxcbiAgICAgICAgICB6ZShsLCBkLCBuKVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG5ldyAkKG0sIHksIHcsIGcsICExKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJcIjoge1xuICAgICAgICBjb25zdCBbbywgaSwgcywgbF0gPSBqYShhdChlLmxhYiwgdC5sYWIsIG4pKTtcbiAgICAgICAgcmV0dXJuIG5ldyAkKG8sIGksIHMsIGwsICExKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiQuYmxhY2sgPSBuZXcgJCgwLCAwLCAwLCAxKTtcbiQud2hpdGUgPSBuZXcgJCgxLCAxLCAxLCAxKTtcbiQudHJhbnNwYXJlbnQgPSBuZXcgJCgwLCAwLCAwLCAwKTtcbiQucmVkID0gbmV3ICQoMSwgMCwgMCwgMSk7XG5jbGFzcyBhbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBlID8gdGhpcy5zZW5zaXRpdml0eSA9IHQgPyBcInZhcmlhbnRcIiA6IFwiY2FzZVwiIDogdGhpcy5zZW5zaXRpdml0eSA9IHQgPyBcImFjY2VudFwiIDogXCJiYXNlXCIsIHRoaXMubG9jYWxlID0gbiwgdGhpcy5jb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSwgeyBzZW5zaXRpdml0eTogdGhpcy5zZW5zaXRpdml0eSwgdXNhZ2U6IFwic2VhcmNoXCIgfSk7XG4gIH1cbiAgY29tcGFyZShlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGF0b3IuY29tcGFyZShlLCB0KTtcbiAgfVxuICByZXNvbHZlZExvY2FsZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gIH1cbn1cbmNvbnN0IHpzID0gW1wiYm90dG9tXCIsIFwiY2VudGVyXCIsIFwidG9wXCJdO1xuY2xhc3MgT3Ige1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgdGhpcy50ZXh0ID0gZSwgdGhpcy5pbWFnZSA9IHQsIHRoaXMuc2NhbGUgPSBuLCB0aGlzLmZvbnRTdGFjayA9IGEsIHRoaXMudGV4dENvbG9yID0gbywgdGhpcy52ZXJ0aWNhbEFsaWduID0gaTtcbiAgfVxufVxuY2xhc3Mga2Uge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5zZWN0aW9ucyA9IGU7XG4gIH1cbiAgc3RhdGljIGZyb21TdHJpbmcoZSkge1xuICAgIHJldHVybiBuZXcga2UoW25ldyBPcihlLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKV0pO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwID8gITAgOiAhdGhpcy5zZWN0aW9ucy5zb21lKChlKSA9PiBlLnRleHQubGVuZ3RoICE9PSAwIHx8IGUuaW1hZ2UgJiYgZS5pbWFnZS5uYW1lLmxlbmd0aCAhPT0gMCk7XG4gIH1cbiAgc3RhdGljIGZhY3RvcnkoZSkge1xuICAgIHJldHVybiBlIGluc3RhbmNlb2Yga2UgPyBlIDoga2UuZnJvbVN0cmluZyhlKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT09IDAgPyBcIlwiIDogdGhpcy5zZWN0aW9ucy5tYXAoKGUpID0+IGUudGV4dCkuam9pbihcIlwiKTtcbiAgfVxufVxuY2xhc3Mgb2Uge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBlLnNsaWNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE51bWVyaWMgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGlucHV0IEEgcGFkZGluZyB2YWx1ZVxuICAgKiBAcmV0dXJucyBBIGBQYWRkaW5nYCBpbnN0YW5jZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIHBhZGRpbmcgdmFsdWUuXG4gICAqL1xuICBzdGF0aWMgcGFyc2UoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2Ygb2UpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBuZXcgb2UoW2UsIGUsIGUsIGVdKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSAmJiAhKGUubGVuZ3RoIDwgMSB8fCBlLmxlbmd0aCA+IDQpKSB7XG4gICAgICBmb3IgKGNvbnN0IHQgb2YgZSlcbiAgICAgICAgaWYgKHR5cGVvZiB0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgc3dpdGNoIChlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZSA9IFtlWzBdLCBlWzBdLCBlWzBdLCBlWzBdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGUgPSBbZVswXSwgZVsxXSwgZVswXSwgZVsxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBlID0gW2VbMF0sIGVbMV0sIGVbMl0sIGVbMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBvZShlKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgaW50ZXJwb2xhdGUoZSwgdCwgbikge1xuICAgIHJldHVybiBuZXcgb2UoYXQoZS52YWx1ZXMsIHQudmFsdWVzLCBuKSk7XG4gIH1cbn1cbmNsYXNzIGllIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudmFsdWVzID0gZS5zbGljZSgpO1xuICB9XG4gIC8qKlxuICAgKiBOdW1lcmljIE51bWJlckFycmF5IHZhbHVlc1xuICAgKiBAcGFyYW0gaW5wdXQgQSBOdW1iZXJBcnJheSB2YWx1ZVxuICAgKiBAcmV0dXJucyBBIGBOdW1iZXJBcnJheWAgaW5zdGFuY2UsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCBOdW1iZXJBcnJheSB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBwYXJzZShlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBpZSlcbiAgICAgIHJldHVybiBlO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIG5ldyBpZShbZV0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHQgb2YgZSlcbiAgICAgICAgaWYgKHR5cGVvZiB0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIG5ldyBpZShlKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgaW50ZXJwb2xhdGUoZSwgdCwgbikge1xuICAgIHJldHVybiBuZXcgaWUoYXQoZS52YWx1ZXMsIHQudmFsdWVzLCBuKSk7XG4gIH1cbn1cbmNsYXNzIFEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBlLnNsaWNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbG9yQXJyYXkgdmFsdWVzXG4gICAqIEBwYXJhbSBpbnB1dCBBIENvbG9yQXJyYXkgdmFsdWVcbiAgICogQHJldHVybnMgQSBgQ29sb3JBcnJheWAgaW5zdGFuY2UsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCBDb2xvckFycmF5IHZhbHVlLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFEpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgbiA9ICQucGFyc2UoZSk7XG4gICAgICByZXR1cm4gbiA/IG5ldyBRKFtuXSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGUpIHtcbiAgICAgIGlmICh0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhID0gJC5wYXJzZShuKTtcbiAgICAgIGlmICghYSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdC5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFEodCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKTtcbiAgfVxuICBzdGF0aWMgaW50ZXJwb2xhdGUoZSwgdCwgbiwgYSA9IFwicmdiXCIpIHtcbiAgICBjb25zdCBvID0gW107XG4gICAgaWYgKGUudmFsdWVzLmxlbmd0aCAhPSB0LnZhbHVlcy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbG9yQXJyYXk6IEFycmF5cyBoYXZlIG1pc21hdGNoZWQgbGVuZ3RoICgke2UudmFsdWVzLmxlbmd0aH0gdnMuICR7dC52YWx1ZXMubGVuZ3RofSksIGNhbm5vdCBpbnRlcnBvbGF0ZS5gKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGUudmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgby5wdXNoKCQuaW50ZXJwb2xhdGUoZS52YWx1ZXNbaV0sIHQudmFsdWVzW2ldLCBuLCBhKSk7XG4gICAgcmV0dXJuIG5ldyBRKG8pO1xuICB9XG59XG5jbGFzcyBEIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSksIHRoaXMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbn1cbmNvbnN0IEZzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiY2VudGVyXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwidG9wLWxlZnRcIiwgXCJ0b3AtcmlnaHRcIiwgXCJib3R0b20tbGVmdFwiLCBcImJvdHRvbS1yaWdodFwiXSk7XG5jbGFzcyBtZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnZhbHVlcyA9IGUuc2xpY2UoKTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgbWUpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAoISghQXJyYXkuaXNBcnJheShlKSB8fCBlLmxlbmd0aCA8IDEgfHwgZS5sZW5ndGggJSAyICE9PSAwKSkge1xuICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4gPSBlW3RdLCBhID0gZVt0ICsgMV07XG4gICAgICAgIGlmICh0eXBlb2YgbiAhPSBcInN0cmluZ1wiIHx8ICFGcy5oYXMobikgfHwgIUFycmF5LmlzQXJyYXkoYSkgfHwgYS5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGFbMF0gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYVsxXSAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgbWUoZSk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlcyk7XG4gIH1cbiAgc3RhdGljIGludGVycG9sYXRlKGUsIHQsIG4pIHtcbiAgICBjb25zdCBhID0gZS52YWx1ZXMsIG8gPSB0LnZhbHVlcztcbiAgICBpZiAoYS5sZW5ndGggIT09IG8ubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEQoYENhbm5vdCBpbnRlcnBvbGF0ZSB2YWx1ZXMgb2YgZGlmZmVyZW50IGxlbmd0aC4gZnJvbTogJHtlLnRvU3RyaW5nKCl9LCB0bzogJHt0LnRvU3RyaW5nKCl9YCk7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMgKz0gMikge1xuICAgICAgaWYgKGFbc10gIT09IG9bc10pXG4gICAgICAgIHRocm93IG5ldyBEKGBDYW5ub3QgaW50ZXJwb2xhdGUgdmFsdWVzIGNvbnRhaW5pbmcgbWlzbWF0Y2hlZCBhbmNob3JzLiBmcm9tWyR7c31dOiAke2Fbc119LCB0b1ske3N9XTogJHtvW3NdfWApO1xuICAgICAgaS5wdXNoKGFbc10pO1xuICAgICAgY29uc3QgW2wsIHVdID0gYVtzICsgMV0sIFtjLCBwXSA9IG9bcyArIDFdO1xuICAgICAgaS5wdXNoKFt6ZShsLCBjLCBuKSwgemUodSwgcCwgbildKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBtZShpKTtcbiAgfVxufVxuY2xhc3MgJGUge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5uYW1lID0gZS5uYW1lLCB0aGlzLmF2YWlsYWJsZSA9IGUuYXZhaWxhYmxlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgc3RhdGljIGZyb21TdHJpbmcoZSkge1xuICAgIHJldHVybiBlID8gbmV3ICRlKHsgbmFtZTogZSwgYXZhaWxhYmxlOiAhMSB9KSA6IG51bGw7XG4gIH1cbn1cbmNsYXNzIGZlIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHRoaXMuZnJvbSA9IGUsIHRoaXMudG8gPSB0LCB0aGlzLnRyYW5zaXRpb24gPSBuO1xuICB9XG4gIHN0YXRpYyBpbnRlcnBvbGF0ZShlLCB0LCBuKSB7XG4gICAgcmV0dXJuIG5ldyBmZShlLCB0LCBuKTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgZmUpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSAmJiBlLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgZVswXSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlWzFdID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVbMl0gPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBuZXcgZmUoZVswXSwgZVsxXSwgZVsyXSk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGUuZnJvbSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlLnRvID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGUudHJhbnNpdGlvbiA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIG5ldyBmZShlLmZyb20sIGUudG8sIGUudHJhbnNpdGlvbik7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gbmV3IGZlKGUsIGUsIDEpO1xuICB9XG59XG5mdW5jdGlvbiBVYShyLCBlLCB0LCBuKSB7XG4gIHJldHVybiB0eXBlb2YgciA9PSBcIm51bWJlclwiICYmIHIgPj0gMCAmJiByIDw9IDI1NSAmJiB0eXBlb2YgZSA9PSBcIm51bWJlclwiICYmIGUgPj0gMCAmJiBlIDw9IDI1NSAmJiB0eXBlb2YgdCA9PSBcIm51bWJlclwiICYmIHQgPj0gMCAmJiB0IDw9IDI1NSA/IHR5cGVvZiBuID4gXCJ1XCIgfHwgdHlwZW9mIG4gPT0gXCJudW1iZXJcIiAmJiBuID49IDAgJiYgbiA8PSAxID8gbnVsbCA6IGBJbnZhbGlkIHJnYmEgdmFsdWUgWyR7W3IsIGUsIHQsIG5dLmpvaW4oXCIsIFwiKX1dOiAnYScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuYCA6IGBJbnZhbGlkIHJnYmEgdmFsdWUgWyR7KHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyBbciwgZSwgdCwgbl0gOiBbciwgZSwgdF0pLmpvaW4oXCIsIFwiKX1dOiAncicsICdnJywgYW5kICdiJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1LmA7XG59XG5mdW5jdGlvbiB2dChyKSB7XG4gIGlmIChyID09PSBudWxsIHx8IHR5cGVvZiByID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHIgPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHIgPT0gXCJudW1iZXJcIiB8fCByIGluc3RhbmNlb2YgZmUgfHwgciBpbnN0YW5jZW9mICQgfHwgciBpbnN0YW5jZW9mIGFuIHx8IHIgaW5zdGFuY2VvZiBrZSB8fCByIGluc3RhbmNlb2Ygb2UgfHwgciBpbnN0YW5jZW9mIGllIHx8IHIgaW5zdGFuY2VvZiBRIHx8IHIgaW5zdGFuY2VvZiBtZSB8fCByIGluc3RhbmNlb2YgJGUpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkge1xuICAgIGZvciAoY29uc3QgZSBvZiByKVxuICAgICAgaWYgKCF2dChlKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgciA9PSBcIm9iamVjdFwiKSB7XG4gICAgZm9yIChjb25zdCBlIGluIHIpXG4gICAgICBpZiAoIXZ0KHJbZV0pKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9IGVsc2VcbiAgICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBxKHIpIHtcbiAgaWYgKHIgPT09IG51bGwpXG4gICAgcmV0dXJuIFd0O1xuICBpZiAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gUDtcbiAgaWYgKHR5cGVvZiByID09IFwiYm9vbGVhblwiKVxuICAgIHJldHVybiBNO1xuICBpZiAodHlwZW9mIHIgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gUztcbiAgaWYgKHIgaW5zdGFuY2VvZiAkKVxuICAgIHJldHVybiB3ZTtcbiAgaWYgKHIgaW5zdGFuY2VvZiBmZSlcbiAgICByZXR1cm4gSnQ7XG4gIGlmIChyIGluc3RhbmNlb2YgYW4pXG4gICAgcmV0dXJuIFF0O1xuICBpZiAociBpbnN0YW5jZW9mIGtlKVxuICAgIHJldHVybiBlcjtcbiAgaWYgKHIgaW5zdGFuY2VvZiBvZSlcbiAgICByZXR1cm4gdHI7XG4gIGlmIChyIGluc3RhbmNlb2YgaWUpXG4gICAgcmV0dXJuIHJyO1xuICBpZiAociBpbnN0YW5jZW9mIFEpXG4gICAgcmV0dXJuIHl0O1xuICBpZiAociBpbnN0YW5jZW9mIG1lKVxuICAgIHJldHVybiBucjtcbiAgaWYgKHIgaW5zdGFuY2VvZiAkZSlcbiAgICByZXR1cm4gQXQ7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSB7XG4gICAgY29uc3QgZSA9IHIubGVuZ3RoO1xuICAgIGxldCB0O1xuICAgIGZvciAoY29uc3QgbiBvZiByKSB7XG4gICAgICBjb25zdCBhID0gcShuKTtcbiAgICAgIGlmICghdClcbiAgICAgICAgdCA9IGE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHQgPT09IGEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHQgPSBJO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlKHQgfHwgSSwgZSk7XG4gIH0gZWxzZVxuICAgIHJldHVybiBCZTtcbn1cbmZ1bmN0aW9uIGh0KHIpIHtcbiAgY29uc3QgZSA9IHR5cGVvZiByO1xuICByZXR1cm4gciA9PT0gbnVsbCA/IFwiXCIgOiBlID09PSBcInN0cmluZ1wiIHx8IGUgPT09IFwibnVtYmVyXCIgfHwgZSA9PT0gXCJib29sZWFuXCIgPyBTdHJpbmcocikgOiByIGluc3RhbmNlb2YgJCB8fCByIGluc3RhbmNlb2YgZmUgfHwgciBpbnN0YW5jZW9mIGtlIHx8IHIgaW5zdGFuY2VvZiBvZSB8fCByIGluc3RhbmNlb2YgaWUgfHwgciBpbnN0YW5jZW9mIFEgfHwgciBpbnN0YW5jZW9mIG1lIHx8IHIgaW5zdGFuY2VvZiAkZSA/IHIudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHIpO1xufVxuY2xhc3Mgb3Qge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy52YWx1ZSA9IHQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihgJ2xpdGVyYWwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBpZiAoIXZ0KGVbMV0pKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIpO1xuICAgIGNvbnN0IG4gPSBlWzFdO1xuICAgIGxldCBhID0gcShuKTtcbiAgICBjb25zdCBvID0gdC5leHBlY3RlZFR5cGU7XG4gICAgcmV0dXJuIGEua2luZCA9PT0gXCJhcnJheVwiICYmIGEuTiA9PT0gMCAmJiBvICYmIG8ua2luZCA9PT0gXCJhcnJheVwiICYmICh0eXBlb2Ygby5OICE9IFwibnVtYmVyXCIgfHwgby5OID09PSAwKSAmJiAoYSA9IG8pLCBuZXcgb3QoYSwgbik7XG4gIH1cbiAgZXZhbHVhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbiAgZWFjaENoaWxkKCkge1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jb25zdCBSdCA9IHtcbiAgc3RyaW5nOiBQLFxuICBudW1iZXI6IFMsXG4gIGJvb2xlYW46IE0sXG4gIG9iamVjdDogQmVcbn07XG5jbGFzcyBkZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLmFyZ3MgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICBsZXQgbiA9IDEsIGE7XG4gICAgY29uc3QgbyA9IGVbMF07XG4gICAgaWYgKG8gPT09IFwiYXJyYXlcIikge1xuICAgICAgbGV0IHM7XG4gICAgICBpZiAoZS5sZW5ndGggPiAyKSB7XG4gICAgICAgIGNvbnN0IHUgPSBlWzFdO1xuICAgICAgICBpZiAodHlwZW9mIHUgIT0gXCJzdHJpbmdcIiB8fCAhKHUgaW4gUnQpIHx8IHUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIHQuZXJyb3IoJ1RoZSBpdGVtIHR5cGUgYXJndW1lbnQgb2YgXCJhcnJheVwiIG11c3QgYmUgb25lIG9mIHN0cmluZywgbnVtYmVyLCBib29sZWFuJywgMSk7XG4gICAgICAgIHMgPSBSdFt1XSwgbisrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHMgPSBJO1xuICAgICAgbGV0IGw7XG4gICAgICBpZiAoZS5sZW5ndGggPiAzKSB7XG4gICAgICAgIGlmIChlWzJdICE9PSBudWxsICYmICh0eXBlb2YgZVsyXSAhPSBcIm51bWJlclwiIHx8IGVbMl0gPCAwIHx8IGVbMl0gIT09IE1hdGguZmxvb3IoZVsyXSkpKVxuICAgICAgICAgIHJldHVybiB0LmVycm9yKCdUaGUgbGVuZ3RoIGFyZ3VtZW50IHRvIFwiYXJyYXlcIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7XG4gICAgICAgIGwgPSBlWzJdLCBuKys7XG4gICAgICB9XG4gICAgICBhID0gdGUocywgbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghUnRbb10pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZXMgZG9lc24ndCBjb250YWluIG5hbWUgPSAke299YCk7XG4gICAgICBhID0gUnRbb107XG4gICAgfVxuICAgIGNvbnN0IGkgPSBbXTtcbiAgICBmb3IgKDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvbnN0IHMgPSB0LnBhcnNlKGVbbl0sIG4sIEkpO1xuICAgICAgaWYgKCFzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGkucHVzaChzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBkZShhLCBpKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmFyZ3MubGVuZ3RoOyB0KyspIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmFyZ3NbdF0uZXZhbHVhdGUoZSk7XG4gICAgICBpZiAoZ3QodGhpcy50eXBlLCBxKG4pKSkge1xuICAgICAgICBpZiAodCA9PT0gdGhpcy5hcmdzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgdGhyb3cgbmV3IEQoYEV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgJHtVKHRoaXMudHlwZSl9LCBidXQgZm91bmQgJHtVKHEobikpfSBpbnN0ZWFkLmApO1xuICAgICAgfSBlbHNlIHJldHVybiBuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIHRoaXMuYXJncy5mb3JFYWNoKGUpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeSgoZSkgPT4gZS5vdXRwdXREZWZpbmVkKCkpO1xuICB9XG59XG5jb25zdCBEbiA9IHtcbiAgXCJ0by1ib29sZWFuXCI6IE0sXG4gIFwidG8tY29sb3JcIjogd2UsXG4gIFwidG8tbnVtYmVyXCI6IFMsXG4gIFwidG8tc3RyaW5nXCI6IFBcbn07XG5jbGFzcyBQZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLmFyZ3MgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICBjb25zdCBuID0gZVswXTtcbiAgICBpZiAoIURuW25dKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwYXJzZSAke259IGFzIGl0IGlzIG5vdCBwYXJ0IG9mIHRoZSBrbm93biB0eXBlc2ApO1xuICAgIGlmICgobiA9PT0gXCJ0by1ib29sZWFuXCIgfHwgbiA9PT0gXCJ0by1zdHJpbmdcIikgJiYgZS5sZW5ndGggIT09IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIG9uZSBhcmd1bWVudC5cIik7XG4gICAgY29uc3QgYSA9IERuW25dLCBvID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzID0gdC5wYXJzZShlW2ldLCBpLCBJKTtcbiAgICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBvLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGUoYSwgbyk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIHN3aXRjaCAodGhpcy50eXBlLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiAhIXRoaXMuYXJnc1swXS5ldmFsdWF0ZShlKTtcbiAgICAgIGNhc2UgXCJjb2xvclwiOiB7XG4gICAgICAgIGxldCB0LCBuO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgdGhpcy5hcmdzKSB7XG4gICAgICAgICAgaWYgKHQgPSBhLmV2YWx1YXRlKGUpLCBuID0gbnVsbCwgdCBpbnN0YW5jZW9mICQpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgbyA9IGUucGFyc2VDb2xvcih0KTtcbiAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodCkgJiYgKHQubGVuZ3RoIDwgMyB8fCB0Lmxlbmd0aCA+IDQgPyBuID0gYEludmFsaWQgcmdiYSB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KHQpfTogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy5gIDogbiA9IFVhKHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pLCAhbikpXG4gICAgICAgICAgICByZXR1cm4gbmV3ICQodFswXSAvIDI1NSwgdFsxXSAvIDI1NSwgdFsyXSAvIDI1NSwgdFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEQobiB8fCBgQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgJyR7dHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiBKU09OLnN0cmluZ2lmeSh0KX0nYCk7XG4gICAgICB9XG4gICAgICBjYXNlIFwicGFkZGluZ1wiOiB7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hcmdzKSB7XG4gICAgICAgICAgdCA9IG4uZXZhbHVhdGUoZSk7XG4gICAgICAgICAgY29uc3QgYSA9IG9lLnBhcnNlKHQpO1xuICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEQoYENvdWxkIG5vdCBwYXJzZSBwYWRkaW5nIGZyb20gdmFsdWUgJyR7dHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQgOiBKU09OLnN0cmluZ2lmeSh0KX0nYCk7XG4gICAgICB9XG4gICAgICBjYXNlIFwibnVtYmVyQXJyYXlcIjoge1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMuYXJncykge1xuICAgICAgICAgIHQgPSBuLmV2YWx1YXRlKGUpO1xuICAgICAgICAgIGNvbnN0IGEgPSBpZS5wYXJzZSh0KTtcbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBEKGBDb3VsZCBub3QgcGFyc2UgbnVtYmVyQXJyYXkgZnJvbSB2YWx1ZSAnJHt0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IEpTT04uc3RyaW5naWZ5KHQpfSdgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjb2xvckFycmF5XCI6IHtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmFyZ3MpIHtcbiAgICAgICAgICB0ID0gbi5ldmFsdWF0ZShlKTtcbiAgICAgICAgICBjb25zdCBhID0gUS5wYXJzZSh0KTtcbiAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBEKGBDb3VsZCBub3QgcGFyc2UgY29sb3JBcnJheSBmcm9tIHZhbHVlICcke3R5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogSlNPTi5zdHJpbmdpZnkodCl9J2ApO1xuICAgICAgfVxuICAgICAgY2FzZSBcInZhcmlhYmxlQW5jaG9yT2Zmc2V0Q29sbGVjdGlvblwiOiB7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5hcmdzKSB7XG4gICAgICAgICAgdCA9IG4uZXZhbHVhdGUoZSk7XG4gICAgICAgICAgY29uc3QgYSA9IG1lLnBhcnNlKHQpO1xuICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEQoYENvdWxkIG5vdCBwYXJzZSB2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb24gZnJvbSB2YWx1ZSAnJHt0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IEpTT04uc3RyaW5naWZ5KHQpfSdgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJudW1iZXJcIjoge1xuICAgICAgICBsZXQgdCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmFyZ3MpIHtcbiAgICAgICAgICBpZiAodCA9IG4uZXZhbHVhdGUoZSksIHQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjb25zdCBhID0gTnVtYmVyKHQpO1xuICAgICAgICAgIGlmICghaXNOYU4oYSkpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRChgQ291bGQgbm90IGNvbnZlcnQgJHtKU09OLnN0cmluZ2lmeSh0KX0gdG8gbnVtYmVyLmApO1xuICAgICAgfVxuICAgICAgY2FzZSBcImZvcm1hdHRlZFwiOlxuICAgICAgICByZXR1cm4ga2UuZnJvbVN0cmluZyhodCh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoZSkpKTtcbiAgICAgIGNhc2UgXCJyZXNvbHZlZEltYWdlXCI6XG4gICAgICAgIHJldHVybiAkZS5mcm9tU3RyaW5nKGh0KHRoaXMuYXJnc1swXS5ldmFsdWF0ZShlKSkpO1xuICAgICAgY2FzZSBcInByb2plY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gaHQodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGUpKTtcbiAgICB9XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChlKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoKGUpID0+IGUub3V0cHV0RGVmaW5lZCgpKTtcbiAgfVxufVxuY29uc3QgJHMgPSBbXCJVbmtub3duXCIsIFwiUG9pbnRcIiwgXCJMaW5lU3RyaW5nXCIsIFwiUG9seWdvblwiXTtcbmNsYXNzIERhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nbG9iYWxzID0gbnVsbCwgdGhpcy5mZWF0dXJlID0gbnVsbCwgdGhpcy5mZWF0dXJlU3RhdGUgPSBudWxsLCB0aGlzLmZvcm1hdHRlZFNlY3Rpb24gPSBudWxsLCB0aGlzLl9wYXJzZUNvbG9yQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IG51bGwsIHRoaXMuY2Fub25pY2FsID0gbnVsbDtcbiAgfVxuICBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmIFwiaWRcIiBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuaWQgOiBudWxsO1xuICB9XG4gIGdlb21ldHJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlID8gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID09IFwibnVtYmVyXCIgPyAkc1t0aGlzLmZlYXR1cmUudHlwZV0gOiB0aGlzLmZlYXR1cmUudHlwZSA6IG51bGw7XG4gIH1cbiAgZ2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiBcImdlb21ldHJ5XCIgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmdlb21ldHJ5IDogbnVsbDtcbiAgfVxuICBjYW5vbmljYWxJRCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5vbmljYWw7XG4gIH1cbiAgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzIHx8IHt9O1xuICB9XG4gIHBhcnNlQ29sb3IoZSkge1xuICAgIGxldCB0ID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlLmdldChlKTtcbiAgICByZXR1cm4gdCB8fCAodCA9ICQucGFyc2UoZSksIHRoaXMuX3BhcnNlQ29sb3JDYWNoZS5zZXQoZSwgdCkpLCB0O1xuICB9XG59XG5jbGFzcyBhciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4gPSBbXSwgYSwgbyA9IG5ldyBybigpLCBpID0gW10pIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gZSwgdGhpcy5wYXRoID0gbiwgdGhpcy5rZXkgPSBuLm1hcCgocykgPT4gYFske3N9XWApLmpvaW4oXCJcIiksIHRoaXMuc2NvcGUgPSBvLCB0aGlzLmVycm9ycyA9IGksIHRoaXMuZXhwZWN0ZWRUeXBlID0gYSwgdGhpcy5faXNDb25zdGFudCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBleHByIHRoZSBKU09OIGV4cHJlc3Npb24gdG8gcGFyc2VcbiAgICogQHBhcmFtIGluZGV4IHRoZSBvcHRpb25hbCBhcmd1bWVudCBpbmRleCBpZiB0aGlzIGV4cHJlc3Npb24gaXMgYW4gYXJndW1lbnQgb2YgYSBwYXJlbnQgZXhwcmVzc2lvbiB0aGF0J3MgYmVpbmcgcGFyc2VkXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLm9taXRUeXBlQW5ub3RhdGlvbnMgc2V0IHRydWUgdG8gb21pdCBpbmZlcnJlZCB0eXBlIGFubm90YXRpb25zLiAgQ2FsbGVyIGJld2FyZTogd2l0aCB0aGlzIG9wdGlvbiBzZXQsIHRoZSBwYXJzZWQgZXhwcmVzc2lvbidzIHR5cGUgd2lsbCBOT1Qgc2F0aXNmeSBgZXhwZWN0ZWRUeXBlYCBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB3cmFwcGVkIGluIGFuIGluZmVycmVkIGFubm90YXRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZShlLCB0LCBuLCBhLCBvID0ge30pIHtcbiAgICByZXR1cm4gdCA/IHRoaXMuY29uY2F0KHQsIG4sIGEpLl9wYXJzZShlLCBvKSA6IHRoaXMuX3BhcnNlKGUsIG8pO1xuICB9XG4gIF9wYXJzZShlLCB0KSB7XG4gICAgKGUgPT09IG51bGwgfHwgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZSA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgZSA9PSBcIm51bWJlclwiKSAmJiAoZSA9IFtcImxpdGVyYWxcIiwgZV0pO1xuICAgIGZ1bmN0aW9uIG4oYSwgbywgaSkge1xuICAgICAgcmV0dXJuIGkgPT09IFwiYXNzZXJ0XCIgPyBuZXcgZGUobywgW2FdKSA6IGkgPT09IFwiY29lcmNlXCIgPyBuZXcgUGUobywgW2FdKSA6IGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBpZiAoZS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgW11dLicpO1xuICAgICAgY29uc3QgYSA9IGVbMF07XG4gICAgICBpZiAodHlwZW9mIGEgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYEV4cHJlc3Npb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZm91bmQgJHt0eXBlb2YgYX0gaW5zdGVhZC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS5gLCAwKSwgbnVsbDtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnJlZ2lzdHJ5W2FdO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgbGV0IGkgPSBvLnBhcnNlKGUsIHRoaXMpO1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmV4cGVjdGVkVHlwZSkge1xuICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLmV4cGVjdGVkVHlwZSwgbCA9IGkudHlwZTtcbiAgICAgICAgICBpZiAoKHMua2luZCA9PT0gXCJzdHJpbmdcIiB8fCBzLmtpbmQgPT09IFwibnVtYmVyXCIgfHwgcy5raW5kID09PSBcImJvb2xlYW5cIiB8fCBzLmtpbmQgPT09IFwib2JqZWN0XCIgfHwgcy5raW5kID09PSBcImFycmF5XCIpICYmIGwua2luZCA9PT0gXCJ2YWx1ZVwiKVxuICAgICAgICAgICAgaSA9IG4oaSwgcywgdC50eXBlQW5ub3RhdGlvbiB8fCBcImFzc2VydFwiKTtcbiAgICAgICAgICBlbHNlIGlmIChzLmtpbmQgPT09IFwicHJvamVjdGlvbkRlZmluaXRpb25cIiAmJiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXS5pbmNsdWRlcyhsLmtpbmQpIHx8IFtcImNvbG9yXCIsIFwiZm9ybWF0dGVkXCIsIFwicmVzb2x2ZWRJbWFnZVwiXS5pbmNsdWRlcyhzLmtpbmQpICYmIFtcInZhbHVlXCIsIFwic3RyaW5nXCJdLmluY2x1ZGVzKGwua2luZCkgfHwgW1wicGFkZGluZ1wiLCBcIm51bWJlckFycmF5XCJdLmluY2x1ZGVzKHMua2luZCkgJiYgW1widmFsdWVcIiwgXCJudW1iZXJcIiwgXCJhcnJheVwiXS5pbmNsdWRlcyhsLmtpbmQpIHx8IHMua2luZCA9PT0gXCJjb2xvckFycmF5XCIgJiYgW1widmFsdWVcIiwgXCJzdHJpbmdcIiwgXCJhcnJheVwiXS5pbmNsdWRlcyhsLmtpbmQpIHx8IHMua2luZCA9PT0gXCJ2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb25cIiAmJiBbXCJ2YWx1ZVwiLCBcImFycmF5XCJdLmluY2x1ZGVzKGwua2luZCkpXG4gICAgICAgICAgICBpID0gbihpLCBzLCB0LnR5cGVBbm5vdGF0aW9uIHx8IFwiY29lcmNlXCIpO1xuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2hlY2tTdWJ0eXBlKHMsIGwpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoaSBpbnN0YW5jZW9mIG90KSAmJiBpLnR5cGUua2luZCAhPT0gXCJyZXNvbHZlZEltYWdlXCIgJiYgdGhpcy5faXNDb25zdGFudChpKSkge1xuICAgICAgICAgIGNvbnN0IHMgPSBuZXcgRGEoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaSA9IG5ldyBvdChpLnR5cGUsIGkuZXZhbHVhdGUocykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKGwubWVzc2FnZSksIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYFVua25vd24gZXhwcmVzc2lvbiBcIiR7YX1cIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS5gLCAwKTtcbiAgICB9IGVsc2UgcmV0dXJuIHR5cGVvZiBlID4gXCJ1XCIgPyB0aGlzLmVycm9yKFwiJ3VuZGVmaW5lZCcgdmFsdWUgaW52YWxpZC4gVXNlIG51bGwgaW5zdGVhZC5cIikgOiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gdGhpcy5lcnJvcignQmFyZSBvYmplY3RzIGludmFsaWQuIFVzZSBbXCJsaXRlcmFsXCIsIHsuLi59XSBpbnN0ZWFkLicpIDogdGhpcy5lcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCBmb3VuZCAke3R5cGVvZiBlfSBpbnN0ZWFkLmApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIGNvbnRleHQgc3VpdGFibGUgZm9yIHBhcnNpbmcgdGhlIHN1YmV4cHJlc3Npb24gYXRcbiAgICogaW5kZXggYGluZGV4YCwgb3B0aW9uYWxseSBhcHBlbmRpbmcgdG8gJ2xldCcgYmluZGluZyBtYXAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBgZXJyb3JzYCBwcm9wZXJ0eSwgaW50ZW5kZWQgZm9yIGNvbGxlY3RpbmcgZXJyb3JzIHdoaWxlXG4gICAqIHBhcnNpbmcsIGlzIGNvcGllZCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gY2xvbmVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uY2F0KGUsIHQsIG4pIHtcbiAgICBjb25zdCBhID0gdHlwZW9mIGUgPT0gXCJudW1iZXJcIiA/IHRoaXMucGF0aC5jb25jYXQoZSkgOiB0aGlzLnBhdGgsIG8gPSBuID8gdGhpcy5zY29wZS5jb25jYXQobikgOiB0aGlzLnNjb3BlO1xuICAgIHJldHVybiBuZXcgYXIodGhpcy5yZWdpc3RyeSwgdGhpcy5faXNDb25zdGFudCwgYSwgdCB8fCBudWxsLCBvLCB0aGlzLmVycm9ycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1c2ggYSBwYXJzaW5nIChvciB0eXBlIGNoZWNraW5nKSBlcnJvciBpbnRvIHRoZSBgdGhpcy5lcnJvcnNgXG4gICAqIEBwYXJhbSBlcnJvciBUaGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ga2V5cyBPcHRpb25hbGx5IHNwZWNpZnkgdGhlIHNvdXJjZSBvZiB0aGUgZXJyb3IgYXQgYSBjaGlsZFxuICAgKiBvZiB0aGUgY3VycmVudCBleHByZXNzaW9uIGF0IGB0aGlzLmtleWAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlcnJvcihlLCAuLi50KSB7XG4gICAgY29uc3QgbiA9IGAke3RoaXMua2V5fSR7dC5tYXAoKGEpID0+IGBbJHthfV1gKS5qb2luKFwiXCIpfWA7XG4gICAgdGhpcy5lcnJvcnMucHVzaChuZXcgYmUobiwgZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bGwgaWYgYHRgIGlzIGEgc3VidHlwZSBvZiBgZXhwZWN0ZWRgOyBvdGhlcndpc2UgcmV0dXJucyBhblxuICAgKiBlcnJvciBtZXNzYWdlIGFuZCBhbHNvIHB1c2hlcyBpdCB0byBgdGhpcy5lcnJvcnNgLlxuICAgKiBAcGFyYW0gZXhwZWN0ZWQgVGhlIGV4cGVjdGVkIHR5cGVcbiAgICogQHBhcmFtIHQgVGhlIGFjdHVhbCB0eXBlXG4gICAqIEByZXR1cm5zIG51bGwgaWYgYHRgIGlzIGEgc3VidHlwZSBvZiBgZXhwZWN0ZWRgOyBvdGhlcndpc2UgcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjaGVja1N1YnR5cGUoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBndChlLCB0KTtcbiAgICByZXR1cm4gbiAmJiB0aGlzLmVycm9yKG4pLCBuO1xuICB9XG59XG5jbGFzcyBvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSB0LnR5cGUsIHRoaXMuYmluZGluZ3MgPSBbXS5jb25jYXQoZSksIHRoaXMucmVzdWx0ID0gdDtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmV2YWx1YXRlKGUpO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuYmluZGluZ3MpXG4gICAgICBlKHRbMV0pO1xuICAgIGUodGhpcy5yZXN1bHQpO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDwgNClcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kICR7ZS5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuICAgIGNvbnN0IG4gPSBbXTtcbiAgICBmb3IgKGxldCBvID0gMTsgbyA8IGUubGVuZ3RoIC0gMTsgbyArPSAyKSB7XG4gICAgICBjb25zdCBpID0gZVtvXTtcbiAgICAgIGlmICh0eXBlb2YgaSAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBidXQgZm91bmQgJHt0eXBlb2YgaX0gaW5zdGVhZC5gLCBvKTtcbiAgICAgIGlmICgvW15hLXpBLVowLTlfXS8udGVzdChpKSlcbiAgICAgICAgcmV0dXJuIHQuZXJyb3IoXCJWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciAnXycuXCIsIG8pO1xuICAgICAgY29uc3QgcyA9IHQucGFyc2UoZVtvICsgMV0sIG8gKyAxKTtcbiAgICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBuLnB1c2goW2ksIHNdKTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHQucGFyc2UoZVtlLmxlbmd0aCAtIDFdLCBlLmxlbmd0aCAtIDEsIHQuZXhwZWN0ZWRUeXBlLCBuKTtcbiAgICByZXR1cm4gYSA/IG5ldyBvcihuLCBhKSA6IG51bGw7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3V0cHV0RGVmaW5lZCgpO1xuICB9XG59XG5jbGFzcyBpciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSB0LnR5cGUsIHRoaXMubmFtZSA9IGUsIHRoaXMuYm91bmRFeHByZXNzaW9uID0gdDtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMiB8fCB0eXBlb2YgZVsxXSAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCIndmFyJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIHN0cmluZyBsaXRlcmFsIGFyZ3VtZW50LlwiKTtcbiAgICBjb25zdCBuID0gZVsxXTtcbiAgICByZXR1cm4gdC5zY29wZS5oYXMobikgPyBuZXcgaXIobiwgdC5zY29wZS5nZXQobikpIDogdC5lcnJvcihgVW5rbm93biB2YXJpYWJsZSBcIiR7bn1cIi4gTWFrZSBzdXJlIFwiJHtufVwiIGhhcyBiZWVuIGJvdW5kIGluIGFuIGVuY2xvc2luZyBcImxldFwiIGV4cHJlc3Npb24gYmVmb3JlIHVzaW5nIGl0LmAsIDEpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZEV4cHJlc3Npb24uZXZhbHVhdGUoZSk7XG4gIH1cbiAgZWFjaENoaWxkKCkge1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyBvbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLmluZGV4ID0gdCwgdGhpcy5pbnB1dCA9IG47XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDMpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBjb25zdCBuID0gdC5wYXJzZShlWzFdLCAxLCBTKSwgYSA9IHQucGFyc2UoZVsyXSwgMiwgdGUodC5leHBlY3RlZFR5cGUgfHwgSSkpO1xuICAgIGlmICghbiB8fCAhYSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG8gPSBhLnR5cGU7XG4gICAgcmV0dXJuIG5ldyBvbihvLml0ZW1UeXBlLCBuLCBhKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5kZXguZXZhbHVhdGUoZSksIG4gPSB0aGlzLmlucHV0LmV2YWx1YXRlKGUpO1xuICAgIGlmICh0IDwgMClcbiAgICAgIHRocm93IG5ldyBEKGBBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAke3R9IDwgMC5gKTtcbiAgICBpZiAodCA+PSBuLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBEKGBBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiAke3R9ID4gJHtuLmxlbmd0aCAtIDF9LmApO1xuICAgIGlmICh0ICE9PSBNYXRoLmZsb29yKHQpKVxuICAgICAgdGhyb3cgbmV3IEQoYEFycmF5IGluZGV4IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGZvdW5kICR7dH0gaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gblt0XTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5pbmRleCksIGUodGhpcy5pbnB1dCk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNsYXNzIHNuIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMudHlwZSA9IE0sIHRoaXMubmVlZGxlID0gZSwgdGhpcy5oYXlzdGFjayA9IHQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDMpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBjb25zdCBuID0gdC5wYXJzZShlWzFdLCAxLCBJKSwgYSA9IHQucGFyc2UoZVsyXSwgMiwgSSk7XG4gICAgcmV0dXJuICFuIHx8ICFhID8gbnVsbCA6IG5uKG4udHlwZSwgW00sIFAsIFMsIFd0LCBJXSkgPyBuZXcgc24obiwgYSkgOiB0LmVycm9yKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAke1Uobi50eXBlKX0gaW5zdGVhZGApO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUoZSksIG4gPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGUpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoIXFlKHQsIFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJudWxsXCJdKSlcbiAgICAgIHRocm93IG5ldyBEKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCAke1UocSh0KSl9IGluc3RlYWQuYCk7XG4gICAgaWYgKCFxZShuLCBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSkpXG4gICAgICB0aHJvdyBuZXcgRChgRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgJHtVKHEobikpfSBpbnN0ZWFkLmApO1xuICAgIHJldHVybiBuLmluZGV4T2YodCkgPj0gMDtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5uZWVkbGUpLCBlKHRoaXMuaGF5c3RhY2spO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jbGFzcyBCdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICB0aGlzLnR5cGUgPSBTLCB0aGlzLm5lZWRsZSA9IGUsIHRoaXMuaGF5c3RhY2sgPSB0LCB0aGlzLmZyb21JbmRleCA9IG47XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggPD0gMiB8fCBlLmxlbmd0aCA+PSA1KVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBjb25zdCBuID0gdC5wYXJzZShlWzFdLCAxLCBJKSwgYSA9IHQucGFyc2UoZVsyXSwgMiwgSSk7XG4gICAgaWYgKCFuIHx8ICFhKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFubihuLnR5cGUsIFtNLCBQLCBTLCBXdCwgSV0pKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kICR7VShuLnR5cGUpfSBpbnN0ZWFkYCk7XG4gICAgaWYgKGUubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBvID0gdC5wYXJzZShlWzNdLCAzLCBTKTtcbiAgICAgIHJldHVybiBvID8gbmV3IEJ0KG4sIGEsIG8pIDogbnVsbDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBuZXcgQnQobiwgYSk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShlKSwgbiA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoZSk7XG4gICAgaWYgKCFxZSh0LCBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwibnVsbFwiXSkpXG4gICAgICB0aHJvdyBuZXcgRChgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgJHtVKHEodCkpfSBpbnN0ZWFkLmApO1xuICAgIGxldCBhO1xuICAgIGlmICh0aGlzLmZyb21JbmRleCAmJiAoYSA9IHRoaXMuZnJvbUluZGV4LmV2YWx1YXRlKGUpKSwgcWUobiwgW1wic3RyaW5nXCJdKSkge1xuICAgICAgY29uc3QgbyA9IG4uaW5kZXhPZih0LCBhKTtcbiAgICAgIHJldHVybiBvID09PSAtMSA/IC0xIDogWy4uLm4uc2xpY2UoMCwgbyldLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHFlKG4sIFtcImFycmF5XCJdKSlcbiAgICAgICAgcmV0dXJuIG4uaW5kZXhPZih0LCBhKTtcbiAgICAgIHRocm93IG5ldyBEKGBFeHBlY3RlZCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAke1UocShuKSl9IGluc3RlYWQuYCk7XG4gICAgfVxuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLm5lZWRsZSksIGUodGhpcy5oYXlzdGFjayksIHRoaXMuZnJvbUluZGV4ICYmIGUodGhpcy5mcm9tSW5kZXgpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyBsbiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICB0aGlzLmlucHV0VHlwZSA9IGUsIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5wdXQgPSBuLCB0aGlzLmNhc2VzID0gYSwgdGhpcy5vdXRwdXRzID0gbywgdGhpcy5vdGhlcndpc2UgPSBpO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDwgNSlcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHtlLmxlbmd0aCAtIDF9LmApO1xuICAgIGlmIChlLmxlbmd0aCAlIDIgIT09IDEpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgbGV0IG4sIGE7XG4gICAgdC5leHBlY3RlZFR5cGUgJiYgdC5leHBlY3RlZFR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIChhID0gdC5leHBlY3RlZFR5cGUpO1xuICAgIGNvbnN0IG8gPSB7fSwgaSA9IFtdO1xuICAgIGZvciAobGV0IHUgPSAyOyB1IDwgZS5sZW5ndGggLSAxOyB1ICs9IDIpIHtcbiAgICAgIGxldCBjID0gZVt1XTtcbiAgICAgIGNvbnN0IHAgPSBlW3UgKyAxXTtcbiAgICAgIEFycmF5LmlzQXJyYXkoYykgfHwgKGMgPSBbY10pO1xuICAgICAgY29uc3QgZCA9IHQuY29uY2F0KHUpO1xuICAgICAgaWYgKGMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gZC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBicmFuY2ggbGFiZWwuXCIpO1xuICAgICAgZm9yIChjb25zdCBoIG9mIGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBoICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGggIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gZC5lcnJvcihcIkJyYW5jaCBsYWJlbHMgbXVzdCBiZSBudW1iZXJzIG9yIHN0cmluZ3MuXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGggPT0gXCJudW1iZXJcIiAmJiBNYXRoLmFicyhoKSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgIHJldHVybiBkLmVycm9yKGBCcmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlcnMgbm8gbGFyZ2VyIHRoYW4gJHtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUn0uYCk7XG4gICAgICAgIGlmICh0eXBlb2YgaCA9PSBcIm51bWJlclwiICYmIE1hdGguZmxvb3IoaCkgIT09IGgpXG4gICAgICAgICAgcmV0dXJuIGQuZXJyb3IoXCJOdW1lcmljIGJyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VyIHZhbHVlcy5cIik7XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICBuID0gcShoKTtcbiAgICAgICAgZWxzZSBpZiAoZC5jaGVja1N1YnR5cGUobiwgcShoKSkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygb1tTdHJpbmcoaCldIDwgXCJ1XCIpXG4gICAgICAgICAgcmV0dXJuIGQuZXJyb3IoXCJCcmFuY2ggbGFiZWxzIG11c3QgYmUgdW5pcXVlLlwiKTtcbiAgICAgICAgb1tTdHJpbmcoaCldID0gaS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjb25zdCBmID0gdC5wYXJzZShwLCB1LCBhKTtcbiAgICAgIGlmICghZilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBhID0gYSB8fCBmLnR5cGUsIGkucHVzaChmKTtcbiAgICB9XG4gICAgY29uc3QgcyA9IHQucGFyc2UoZVsxXSwgMSwgSSk7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbCA9IHQucGFyc2UoZVtlLmxlbmd0aCAtIDFdLCBlLmxlbmd0aCAtIDEsIGEpO1xuICAgIHJldHVybiAhbCB8fCBzLnR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIHQuY29uY2F0KDEpLmNoZWNrU3VidHlwZShuLCBzLnR5cGUpID8gbnVsbCA6IG5ldyBsbihuLCBhLCBzLCBvLCBpLCBsKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoZSk7XG4gICAgcmV0dXJuIChxKHQpID09PSB0aGlzLmlucHV0VHlwZSAmJiB0aGlzLm91dHB1dHNbdGhpcy5jYXNlc1t0XV0gfHwgdGhpcy5vdGhlcndpc2UpLmV2YWx1YXRlKGUpO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLmlucHV0KSwgdGhpcy5vdXRwdXRzLmZvckVhY2goZSksIGUodGhpcy5vdGhlcndpc2UpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeSgoZSkgPT4gZS5vdXRwdXREZWZpbmVkKCkpICYmIHRoaXMub3RoZXJ3aXNlLm91dHB1dERlZmluZWQoKTtcbiAgfVxufVxuY2xhc3MgdW4ge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy5icmFuY2hlcyA9IHQsIHRoaXMub3RoZXJ3aXNlID0gbjtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8IDQpXG4gICAgICByZXR1cm4gdC5lcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5ICR7ZS5sZW5ndGggLSAxfS5gKTtcbiAgICBpZiAoZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgbGV0IG47XG4gICAgdC5leHBlY3RlZFR5cGUgJiYgdC5leHBlY3RlZFR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIChuID0gdC5leHBlY3RlZFR5cGUpO1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGUubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBzID0gdC5wYXJzZShlW2ldLCBpLCBNKTtcbiAgICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBsID0gdC5wYXJzZShlW2kgKyAxXSwgaSArIDEsIG4pO1xuICAgICAgaWYgKCFsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGEucHVzaChbcywgbF0pLCBuID0gbiB8fCBsLnR5cGU7XG4gICAgfVxuICAgIGNvbnN0IG8gPSB0LnBhcnNlKGVbZS5sZW5ndGggLSAxXSwgZS5sZW5ndGggLSAxLCBuKTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBpbmZlciBvdXRwdXQgdHlwZVwiKTtcbiAgICByZXR1cm4gbmV3IHVuKG4sIGEsIG8pO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBmb3IgKGNvbnN0IFt0LCBuXSBvZiB0aGlzLmJyYW5jaGVzKVxuICAgICAgaWYgKHQuZXZhbHVhdGUoZSkpXG4gICAgICAgIHJldHVybiBuLmV2YWx1YXRlKGUpO1xuICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShlKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGZvciAoY29uc3QgW3QsIG5dIG9mIHRoaXMuYnJhbmNoZXMpXG4gICAgICBlKHQpLCBlKG4pO1xuICAgIGUodGhpcy5vdGhlcndpc2UpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJhbmNoZXMuZXZlcnkoKFtlLCB0XSkgPT4gdC5vdXRwdXREZWZpbmVkKCkpICYmIHRoaXMub3RoZXJ3aXNlLm91dHB1dERlZmluZWQoKTtcbiAgfVxufVxuY2xhc3MgcXQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuLCBhKSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy5pbnB1dCA9IHQsIHRoaXMuYmVnaW5JbmRleCA9IG4sIHRoaXMuZW5kSW5kZXggPSBhO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoIDw9IDIgfHwgZS5sZW5ndGggPj0gNSlcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCAzIG9yIDQgYXJndW1lbnRzLCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSwgSSksIGEgPSB0LnBhcnNlKGVbMl0sIDIsIFMpO1xuICAgIGlmICghbiB8fCAhYSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICghbm4obi50eXBlLCBbdGUoSSksIFAsIEldKSlcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kICR7VShuLnR5cGUpfSBpbnN0ZWFkYCk7XG4gICAgaWYgKGUubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBvID0gdC5wYXJzZShlWzNdLCAzLCBTKTtcbiAgICAgIHJldHVybiBvID8gbmV3IHF0KG4udHlwZSwgbiwgYSwgbykgOiBudWxsO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG5ldyBxdChuLnR5cGUsIG4sIGEpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShlKSwgbiA9IHRoaXMuYmVnaW5JbmRleC5ldmFsdWF0ZShlKTtcbiAgICBsZXQgYTtcbiAgICBpZiAodGhpcy5lbmRJbmRleCAmJiAoYSA9IHRoaXMuZW5kSW5kZXguZXZhbHVhdGUoZSkpLCBxZSh0LCBbXCJzdHJpbmdcIl0pKVxuICAgICAgcmV0dXJuIFsuLi50XS5zbGljZShuLCBhKS5qb2luKFwiXCIpO1xuICAgIGlmIChxZSh0LCBbXCJhcnJheVwiXSkpXG4gICAgICByZXR1cm4gdC5zbGljZShuLCBhKTtcbiAgICB0aHJvdyBuZXcgRChgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCAke1UocSh0KSl9IGluc3RlYWQuYCk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMuaW5wdXQpLCBlKHRoaXMuYmVnaW5JbmRleCksIHRoaXMuZW5kSW5kZXggJiYgZSh0aGlzLmVuZEluZGV4KTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gQmEociwgZSkge1xuICBjb25zdCB0ID0gci5sZW5ndGggLSAxO1xuICBsZXQgbiA9IDAsIGEgPSB0LCBvID0gMCwgaSwgcztcbiAgZm9yICg7IG4gPD0gYTsgKVxuICAgIGlmIChvID0gTWF0aC5mbG9vcigobiArIGEpIC8gMiksIGkgPSByW29dLCBzID0gcltvICsgMV0sIGkgPD0gZSkge1xuICAgICAgaWYgKG8gPT09IHQgfHwgZSA8IHMpXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgbiA9IG8gKyAxO1xuICAgIH0gZWxzZSBpZiAoaSA+IGUpXG4gICAgICBhID0gbyAtIDE7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEQoXCJJbnB1dCBpcyBub3QgYSBudW1iZXIuXCIpO1xuICByZXR1cm4gMDtcbn1cbmNsYXNzIHNyIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMuaW5wdXQgPSB0LCB0aGlzLmxhYmVscyA9IFtdLCB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFthLCBvXSBvZiBuKVxuICAgICAgdGhpcy5sYWJlbHMucHVzaChhKSwgdGhpcy5vdXRwdXRzLnB1c2gobyk7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggLSAxIDwgNClcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHtlLmxlbmd0aCAtIDF9LmApO1xuICAgIGlmICgoZS5sZW5ndGggLSAxKSAlIDIgIT09IDApXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgY29uc3QgbiA9IHQucGFyc2UoZVsxXSwgMSwgUyk7XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIGxldCBvID0gbnVsbDtcbiAgICB0LmV4cGVjdGVkVHlwZSAmJiB0LmV4cGVjdGVkVHlwZS5raW5kICE9PSBcInZhbHVlXCIgJiYgKG8gPSB0LmV4cGVjdGVkVHlwZSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBzID0gaSA9PT0gMSA/IC0xIC8gMCA6IGVbaV0sIGwgPSBlW2kgKyAxXSwgdSA9IGksIGMgPSBpICsgMTtcbiAgICAgIGlmICh0eXBlb2YgcyAhPSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCB1KTtcbiAgICAgIGlmIChhLmxlbmd0aCAmJiBhW2EubGVuZ3RoIC0gMV1bMF0gPj0gcylcbiAgICAgICAgcmV0dXJuIHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgdSk7XG4gICAgICBjb25zdCBwID0gdC5wYXJzZShsLCBjLCBvKTtcbiAgICAgIGlmICghcClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBvID0gbyB8fCBwLnR5cGUsIGEucHVzaChbcywgcF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHNyKG8sIG4sIGEpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5sYWJlbHMsIG4gPSB0aGlzLm91dHB1dHM7XG4gICAgaWYgKHQubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIG5bMF0uZXZhbHVhdGUoZSk7XG4gICAgY29uc3QgYSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoZSk7XG4gICAgaWYgKGEgPD0gdFswXSlcbiAgICAgIHJldHVybiBuWzBdLmV2YWx1YXRlKGUpO1xuICAgIGNvbnN0IG8gPSB0Lmxlbmd0aDtcbiAgICBpZiAoYSA+PSB0W28gLSAxXSlcbiAgICAgIHJldHVybiBuW28gLSAxXS5ldmFsdWF0ZShlKTtcbiAgICBjb25zdCBpID0gQmEodCwgYSk7XG4gICAgcmV0dXJuIG5baV0uZXZhbHVhdGUoZSk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMuaW5wdXQpO1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLm91dHB1dHMpXG4gICAgICBlKHQpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeSgoZSkgPT4gZS5vdXRwdXREZWZpbmVkKCkpO1xuICB9XG59XG5mdW5jdGlvbiBPcyhyKSB7XG4gIHJldHVybiByICYmIHIuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgXCJkZWZhdWx0XCIpID8gci5kZWZhdWx0IDogcjtcbn1cbnZhciB4ciwgQm47XG5mdW5jdGlvbiBOcygpIHtcbiAgaWYgKEJuKSByZXR1cm4geHI7XG4gIEJuID0gMSwgeHIgPSByO1xuICBmdW5jdGlvbiByKGUsIHQsIG4sIGEpIHtcbiAgICB0aGlzLmN4ID0gMyAqIGUsIHRoaXMuYnggPSAzICogKG4gLSBlKSAtIHRoaXMuY3gsIHRoaXMuYXggPSAxIC0gdGhpcy5jeCAtIHRoaXMuYngsIHRoaXMuY3kgPSAzICogdCwgdGhpcy5ieSA9IDMgKiAoYSAtIHQpIC0gdGhpcy5jeSwgdGhpcy5heSA9IDEgLSB0aGlzLmN5IC0gdGhpcy5ieSwgdGhpcy5wMXggPSBlLCB0aGlzLnAxeSA9IHQsIHRoaXMucDJ4ID0gbiwgdGhpcy5wMnkgPSBhO1xuICB9XG4gIHJldHVybiByLnByb3RvdHlwZSA9IHtcbiAgICBzYW1wbGVDdXJ2ZVg6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiAoKHRoaXMuYXggKiBlICsgdGhpcy5ieCkgKiBlICsgdGhpcy5jeCkgKiBlO1xuICAgIH0sXG4gICAgc2FtcGxlQ3VydmVZOiBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gKCh0aGlzLmF5ICogZSArIHRoaXMuYnkpICogZSArIHRoaXMuY3kpICogZTtcbiAgICB9LFxuICAgIHNhbXBsZUN1cnZlRGVyaXZhdGl2ZVg6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiAoMyAqIHRoaXMuYXggKiBlICsgMiAqIHRoaXMuYngpICogZSArIHRoaXMuY3g7XG4gICAgfSxcbiAgICBzb2x2ZUN1cnZlWDogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgaWYgKHQgPT09IHZvaWQgMCAmJiAodCA9IDFlLTYpLCBlIDwgMCkgcmV0dXJuIDA7XG4gICAgICBpZiAoZSA+IDEpIHJldHVybiAxO1xuICAgICAgZm9yICh2YXIgbiA9IGUsIGEgPSAwOyBhIDwgODsgYSsrKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5zYW1wbGVDdXJ2ZVgobikgLSBlO1xuICAgICAgICBpZiAoTWF0aC5hYnMobykgPCB0KSByZXR1cm4gbjtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgobik7XG4gICAgICAgIGlmIChNYXRoLmFicyhpKSA8IDFlLTYpIGJyZWFrO1xuICAgICAgICBuID0gbiAtIG8gLyBpO1xuICAgICAgfVxuICAgICAgdmFyIHMgPSAwLCBsID0gMTtcbiAgICAgIGZvciAobiA9IGUsIGEgPSAwOyBhIDwgMjAgJiYgKG8gPSB0aGlzLnNhbXBsZUN1cnZlWChuKSwgIShNYXRoLmFicyhvIC0gZSkgPCB0KSk7IGErKylcbiAgICAgICAgZSA+IG8gPyBzID0gbiA6IGwgPSBuLCBuID0gKGwgLSBzKSAqIDAuNSArIHM7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIHNvbHZlOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWChlLCB0KSk7XG4gICAgfVxuICB9LCB4cjtcbn1cbnZhciBqcyA9IE5zKCksIFVzID0gLyogQF9fUFVSRV9fICovIE9zKGpzKTtcbmNsYXNzIFNlIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSwgbykge1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMub3BlcmF0b3IgPSB0LCB0aGlzLmludGVycG9sYXRpb24gPSBuLCB0aGlzLmlucHV0ID0gYSwgdGhpcy5sYWJlbHMgPSBbXSwgdGhpcy5vdXRwdXRzID0gW107XG4gICAgZm9yIChjb25zdCBbaSwgc10gb2YgbylcbiAgICAgIHRoaXMubGFiZWxzLnB1c2goaSksIHRoaXMub3V0cHV0cy5wdXNoKHMpO1xuICB9XG4gIHN0YXRpYyBpbnRlcnBvbGF0aW9uRmFjdG9yKGUsIHQsIG4sIGEpIHtcbiAgICBsZXQgbyA9IDA7XG4gICAgaWYgKGUubmFtZSA9PT0gXCJleHBvbmVudGlhbFwiKVxuICAgICAgbyA9IGtyKHQsIGUuYmFzZSwgbiwgYSk7XG4gICAgZWxzZSBpZiAoZS5uYW1lID09PSBcImxpbmVhclwiKVxuICAgICAgbyA9IGtyKHQsIDEsIG4sIGEpO1xuICAgIGVsc2UgaWYgKGUubmFtZSA9PT0gXCJjdWJpYy1iZXppZXJcIikge1xuICAgICAgY29uc3QgaSA9IGUuY29udHJvbFBvaW50cztcbiAgICAgIG8gPSBuZXcgVXMoaVswXSwgaVsxXSwgaVsyXSwgaVszXSkuc29sdmUoa3IodCwgMSwgbiwgYSkpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGxldCBbbiwgYSwgbywgLi4uaV0gPSBlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSB8fCBhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0LmVycm9yKFwiRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uXCIsIDEpO1xuICAgIGlmIChhWzBdID09PSBcImxpbmVhclwiKVxuICAgICAgYSA9IHsgbmFtZTogXCJsaW5lYXJcIiB9O1xuICAgIGVsc2UgaWYgKGFbMF0gPT09IFwiZXhwb25lbnRpYWxcIikge1xuICAgICAgY29uc3QgdSA9IGFbMV07XG4gICAgICBpZiAodHlwZW9mIHUgIT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBvbmVudGlhbCBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGEgbnVtZXJpYyBiYXNlLlwiLCAxLCAxKTtcbiAgICAgIGEgPSB7XG4gICAgICAgIG5hbWU6IFwiZXhwb25lbnRpYWxcIixcbiAgICAgICAgYmFzZTogdVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGFbMF0gPT09IFwiY3ViaWMtYmV6aWVyXCIpIHtcbiAgICAgIGNvbnN0IHUgPSBhLnNsaWNlKDEpO1xuICAgICAgaWYgKHUubGVuZ3RoICE9PSA0IHx8IHUuc29tZSgoYykgPT4gdHlwZW9mIGMgIT0gXCJudW1iZXJcIiB8fCBjIDwgMCB8fCBjID4gMSkpXG4gICAgICAgIHJldHVybiB0LmVycm9yKFwiQ3ViaWMgYmV6aWVyIGludGVycG9sYXRpb24gcmVxdWlyZXMgZm91ciBudW1lcmljIGFyZ3VtZW50cyB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXCIsIDEpO1xuICAgICAgYSA9IHtcbiAgICAgICAgbmFtZTogXCJjdWJpYy1iZXppZXJcIixcbiAgICAgICAgY29udHJvbFBvaW50czogdVxuICAgICAgfTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiB0LmVycm9yKGBVbmtub3duIGludGVycG9sYXRpb24gdHlwZSAke1N0cmluZyhhWzBdKX1gLCAxLCAwKTtcbiAgICBpZiAoZS5sZW5ndGggLSAxIDwgNClcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgJHtlLmxlbmd0aCAtIDF9LmApO1xuICAgIGlmICgoZS5sZW5ndGggLSAxKSAlIDIgIT09IDApXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgaWYgKG8gPSB0LnBhcnNlKG8sIDIsIFMpLCAhbylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHMgPSBbXTtcbiAgICBsZXQgbCA9IG51bGw7XG4gICAgKG4gPT09IFwiaW50ZXJwb2xhdGUtaGNsXCIgfHwgbiA9PT0gXCJpbnRlcnBvbGF0ZS1sYWJcIikgJiYgdC5leHBlY3RlZFR5cGUgIT0geXQgPyBsID0gd2UgOiB0LmV4cGVjdGVkVHlwZSAmJiB0LmV4cGVjdGVkVHlwZS5raW5kICE9PSBcInZhbHVlXCIgJiYgKGwgPSB0LmV4cGVjdGVkVHlwZSk7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBpLmxlbmd0aDsgdSArPSAyKSB7XG4gICAgICBjb25zdCBjID0gaVt1XSwgcCA9IGlbdSArIDFdLCBkID0gdSArIDMsIGYgPSB1ICsgNDtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgZCk7XG4gICAgICBpZiAocy5sZW5ndGggJiYgc1tzLmxlbmd0aCAtIDFdWzBdID49IGMpXG4gICAgICAgIHJldHVybiB0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBkKTtcbiAgICAgIGNvbnN0IGggPSB0LnBhcnNlKHAsIGYsIGwpO1xuICAgICAgaWYgKCFoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGwgPSBsIHx8IGgudHlwZSwgcy5wdXNoKFtjLCBoXSk7XG4gICAgfVxuICAgIHJldHVybiAhRWUobCwgUykgJiYgIUVlKGwsIEp0KSAmJiAhRWUobCwgd2UpICYmICFFZShsLCB0cikgJiYgIUVlKGwsIHJyKSAmJiAhRWUobCwgeXQpICYmICFFZShsLCBucikgJiYgIUVlKGwsIHRlKFMpKSA/IHQuZXJyb3IoYFR5cGUgJHtVKGwpfSBpcyBub3QgaW50ZXJwb2xhdGFibGUuYCkgOiBuZXcgU2UobCwgbiwgYSwgbywgcyk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmxhYmVscywgbiA9IHRoaXMub3V0cHV0cztcbiAgICBpZiAodC5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gblswXS5ldmFsdWF0ZShlKTtcbiAgICBjb25zdCBhID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShlKTtcbiAgICBpZiAoYSA8PSB0WzBdKVxuICAgICAgcmV0dXJuIG5bMF0uZXZhbHVhdGUoZSk7XG4gICAgY29uc3QgbyA9IHQubGVuZ3RoO1xuICAgIGlmIChhID49IHRbbyAtIDFdKVxuICAgICAgcmV0dXJuIG5bbyAtIDFdLmV2YWx1YXRlKGUpO1xuICAgIGNvbnN0IGkgPSBCYSh0LCBhKSwgcyA9IHRbaV0sIGwgPSB0W2kgKyAxXSwgdSA9IFNlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uLCBhLCBzLCBsKSwgYyA9IG5baV0uZXZhbHVhdGUoZSksIHAgPSBuW2kgKyAxXS5ldmFsdWF0ZShlKTtcbiAgICBzd2l0Y2ggKHRoaXMub3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgXCJpbnRlcnBvbGF0ZVwiOlxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIHplKGMsIHAsIHUpO1xuICAgICAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICAgICAgcmV0dXJuICQuaW50ZXJwb2xhdGUoYywgcCwgdSk7XG4gICAgICAgICAgY2FzZSBcInBhZGRpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBvZS5pbnRlcnBvbGF0ZShjLCBwLCB1KTtcbiAgICAgICAgICBjYXNlIFwiY29sb3JBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIFEuaW50ZXJwb2xhdGUoYywgcCwgdSk7XG4gICAgICAgICAgY2FzZSBcIm51bWJlckFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gaWUuaW50ZXJwb2xhdGUoYywgcCwgdSk7XG4gICAgICAgICAgY2FzZSBcInZhcmlhYmxlQW5jaG9yT2Zmc2V0Q29sbGVjdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG1lLmludGVycG9sYXRlKGMsIHAsIHUpO1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIGF0KGMsIHAsIHUpO1xuICAgICAgICAgIGNhc2UgXCJwcm9qZWN0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGZlLmludGVycG9sYXRlKGMsIHAsIHUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiaW50ZXJwb2xhdGUtaGNsXCI6XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgICAgIHJldHVybiAkLmludGVycG9sYXRlKGMsIHAsIHUsIFwiaGNsXCIpO1xuICAgICAgICAgIGNhc2UgXCJjb2xvckFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gUS5pbnRlcnBvbGF0ZShjLCBwLCB1LCBcImhjbFwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImludGVycG9sYXRlLWxhYlwiOlxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgICAgICByZXR1cm4gJC5pbnRlcnBvbGF0ZShjLCBwLCB1LCBcImxhYlwiKTtcbiAgICAgICAgICBjYXNlIFwiY29sb3JBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIFEuaW50ZXJwb2xhdGUoYywgcCwgdSwgXCJsYWJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMuaW5wdXQpO1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLm91dHB1dHMpXG4gICAgICBlKHQpO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeSgoZSkgPT4gZS5vdXRwdXREZWZpbmVkKCkpO1xuICB9XG59XG5mdW5jdGlvbiBrcihyLCBlLCB0LCBuKSB7XG4gIGNvbnN0IGEgPSBuIC0gdCwgbyA9IHIgLSB0O1xuICByZXR1cm4gYSA9PT0gMCA/IDAgOiBlID09PSAxID8gbyAvIGEgOiAoTWF0aC5wb3coZSwgbykgLSAxKSAvIChNYXRoLnBvdyhlLCBhKSAtIDEpO1xufVxuJC5pbnRlcnBvbGF0ZSwgb2UuaW50ZXJwb2xhdGUsIGllLmludGVycG9sYXRlLCBRLmludGVycG9sYXRlLCBtZS5pbnRlcnBvbGF0ZTtcbmNsYXNzIGJ0IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMudHlwZSA9IGUsIHRoaXMuYXJncyA9IHQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgIGxldCBuID0gbnVsbDtcbiAgICBjb25zdCBhID0gdC5leHBlY3RlZFR5cGU7XG4gICAgYSAmJiBhLmtpbmQgIT09IFwidmFsdWVcIiAmJiAobiA9IGEpO1xuICAgIGNvbnN0IG8gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgZS5zbGljZSgxKSkge1xuICAgICAgY29uc3QgbCA9IHQucGFyc2UocywgMSArIG8ubGVuZ3RoLCBuLCB2b2lkIDAsIHsgdHlwZUFubm90YXRpb246IFwib21pdFwiIH0pO1xuICAgICAgaWYgKCFsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG4gPSBuIHx8IGwudHlwZSwgby5wdXNoKGwpO1xuICAgIH1cbiAgICBpZiAoIW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZVwiKTtcbiAgICByZXR1cm4gYSAmJiBvLnNvbWUoKHMpID0+IGd0KGEsIHMudHlwZSkpID8gbmV3IGJ0KEksIG8pIDogbmV3IGJ0KG4sIG8pO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBsZXQgdCA9IG51bGwsIG4gPSAwLCBhO1xuICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLmFyZ3MpXG4gICAgICBpZiAobisrLCB0ID0gby5ldmFsdWF0ZShlKSwgdCAmJiB0IGluc3RhbmNlb2YgJGUgJiYgIXQuYXZhaWxhYmxlICYmIChhIHx8IChhID0gdC5uYW1lKSwgdCA9IG51bGwsIG4gPT09IHRoaXMuYXJncy5sZW5ndGggJiYgKHQgPSBhKSksIHQgIT09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgIHJldHVybiB0O1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgdGhpcy5hcmdzLmZvckVhY2goZSk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KChlKSA9PiBlLm91dHB1dERlZmluZWQoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHFuKHIsIGUpIHtcbiAgcmV0dXJuIHIgPT09IFwiPT1cIiB8fCByID09PSBcIiE9XCIgPyBlLmtpbmQgPT09IFwiYm9vbGVhblwiIHx8IGUua2luZCA9PT0gXCJzdHJpbmdcIiB8fCBlLmtpbmQgPT09IFwibnVtYmVyXCIgfHwgZS5raW5kID09PSBcIm51bGxcIiB8fCBlLmtpbmQgPT09IFwidmFsdWVcIiA6IGUua2luZCA9PT0gXCJzdHJpbmdcIiB8fCBlLmtpbmQgPT09IFwibnVtYmVyXCIgfHwgZS5raW5kID09PSBcInZhbHVlXCI7XG59XG5mdW5jdGlvbiBEcyhyLCBlLCB0KSB7XG4gIHJldHVybiBlID09PSB0O1xufVxuZnVuY3Rpb24gQnMociwgZSwgdCkge1xuICByZXR1cm4gZSAhPT0gdDtcbn1cbmZ1bmN0aW9uIHFzKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGUgPCB0O1xufVxuZnVuY3Rpb24gVnMociwgZSwgdCkge1xuICByZXR1cm4gZSA+IHQ7XG59XG5mdW5jdGlvbiBHcyhyLCBlLCB0KSB7XG4gIHJldHVybiBlIDw9IHQ7XG59XG5mdW5jdGlvbiBIcyhyLCBlLCB0KSB7XG4gIHJldHVybiBlID49IHQ7XG59XG5mdW5jdGlvbiBxYShyLCBlLCB0LCBuKSB7XG4gIHJldHVybiBuLmNvbXBhcmUoZSwgdCkgPT09IDA7XG59XG5mdW5jdGlvbiBacyhyLCBlLCB0LCBuKSB7XG4gIHJldHVybiAhcWEociwgZSwgdCwgbik7XG59XG5mdW5jdGlvbiBYcyhyLCBlLCB0LCBuKSB7XG4gIHJldHVybiBuLmNvbXBhcmUoZSwgdCkgPCAwO1xufVxuZnVuY3Rpb24gS3MociwgZSwgdCwgbikge1xuICByZXR1cm4gbi5jb21wYXJlKGUsIHQpID4gMDtcbn1cbmZ1bmN0aW9uIFlzKHIsIGUsIHQsIG4pIHtcbiAgcmV0dXJuIG4uY29tcGFyZShlLCB0KSA8PSAwO1xufVxuZnVuY3Rpb24gV3MociwgZSwgdCwgbikge1xuICByZXR1cm4gbi5jb21wYXJlKGUsIHQpID49IDA7XG59XG5mdW5jdGlvbiBzdChyLCBlLCB0KSB7XG4gIGNvbnN0IG4gPSByICE9PSBcIj09XCIgJiYgciAhPT0gXCIhPVwiO1xuICByZXR1cm4gY2xhc3MgVmEge1xuICAgIGNvbnN0cnVjdG9yKG8sIGksIHMpIHtcbiAgICAgIHRoaXMudHlwZSA9IE0sIHRoaXMubGhzID0gbywgdGhpcy5yaHMgPSBpLCB0aGlzLmNvbGxhdG9yID0gcywgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQgPSBvLnR5cGUua2luZCA9PT0gXCJ2YWx1ZVwiIHx8IGkudHlwZS5raW5kID09PSBcInZhbHVlXCI7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShvLCBpKSB7XG4gICAgICBpZiAoby5sZW5ndGggIT09IDMgJiYgby5sZW5ndGggIT09IDQpXG4gICAgICAgIHJldHVybiBpLmVycm9yKFwiRXhwZWN0ZWQgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cIik7XG4gICAgICBjb25zdCBzID0gb1swXTtcbiAgICAgIGxldCBsID0gaS5wYXJzZShvWzFdLCAxLCBJKTtcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoIXFuKHMsIGwudHlwZSkpXG4gICAgICAgIHJldHVybiBpLmNvbmNhdCgxKS5lcnJvcihgXCIke3N9XCIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJyR7VShsLnR5cGUpfScuYCk7XG4gICAgICBsZXQgdSA9IGkucGFyc2Uob1syXSwgMiwgSSk7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKCFxbihzLCB1LnR5cGUpKVxuICAgICAgICByZXR1cm4gaS5jb25jYXQoMikuZXJyb3IoYFwiJHtzfVwiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICcke1UodS50eXBlKX0nLmApO1xuICAgICAgaWYgKGwudHlwZS5raW5kICE9PSB1LnR5cGUua2luZCAmJiBsLnR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiICYmIHUudHlwZS5raW5kICE9PSBcInZhbHVlXCIpXG4gICAgICAgIHJldHVybiBpLmVycm9yKGBDYW5ub3QgY29tcGFyZSB0eXBlcyAnJHtVKGwudHlwZSl9JyBhbmQgJyR7VSh1LnR5cGUpfScuYCk7XG4gICAgICBuICYmIChsLnR5cGUua2luZCA9PT0gXCJ2YWx1ZVwiICYmIHUudHlwZS5raW5kICE9PSBcInZhbHVlXCIgPyBsID0gbmV3IGRlKHUudHlwZSwgW2xdKSA6IGwudHlwZS5raW5kICE9PSBcInZhbHVlXCIgJiYgdS50eXBlLmtpbmQgPT09IFwidmFsdWVcIiAmJiAodSA9IG5ldyBkZShsLnR5cGUsIFt1XSkpKTtcbiAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgIGlmIChvLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBpZiAobC50eXBlLmtpbmQgIT09IFwic3RyaW5nXCIgJiYgdS50eXBlLmtpbmQgIT09IFwic3RyaW5nXCIgJiYgbC50eXBlLmtpbmQgIT09IFwidmFsdWVcIiAmJiB1LnR5cGUua2luZCAhPT0gXCJ2YWx1ZVwiKVxuICAgICAgICAgIHJldHVybiBpLmVycm9yKFwiQ2Fubm90IHVzZSBjb2xsYXRvciB0byBjb21wYXJlIG5vbi1zdHJpbmcgdHlwZXMuXCIpO1xuICAgICAgICBpZiAoYyA9IGkucGFyc2Uob1szXSwgMywgUXQpLCAhYylcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVmEobCwgdSwgYyk7XG4gICAgfVxuICAgIGV2YWx1YXRlKG8pIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmxocy5ldmFsdWF0ZShvKSwgcyA9IHRoaXMucmhzLmV2YWx1YXRlKG8pO1xuICAgICAgaWYgKG4gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgY29uc3QgbCA9IHEoaSksIHUgPSBxKHMpO1xuICAgICAgICBpZiAobC5raW5kICE9PSB1LmtpbmQgfHwgIShsLmtpbmQgPT09IFwic3RyaW5nXCIgfHwgbC5raW5kID09PSBcIm51bWJlclwiKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRChgRXhwZWN0ZWQgYXJndW1lbnRzIGZvciBcIiR7cn1cIiB0byBiZSAoc3RyaW5nLCBzdHJpbmcpIG9yIChudW1iZXIsIG51bWJlciksIGJ1dCBmb3VuZCAoJHtsLmtpbmR9LCAke3Uua2luZH0pIGluc3RlYWQuYCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhbiAmJiB0aGlzLmhhc1VudHlwZWRBcmd1bWVudCkge1xuICAgICAgICBjb25zdCBsID0gcShpKSwgdSA9IHEocyk7XG4gICAgICAgIGlmIChsLmtpbmQgIT09IFwic3RyaW5nXCIgfHwgdS5raW5kICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBlKG8sIGksIHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IgPyB0KG8sIGksIHMsIHRoaXMuY29sbGF0b3IuZXZhbHVhdGUobykpIDogZShvLCBpLCBzKTtcbiAgICB9XG4gICAgZWFjaENoaWxkKG8pIHtcbiAgICAgIG8odGhpcy5saHMpLCBvKHRoaXMucmhzKSwgdGhpcy5jb2xsYXRvciAmJiBvKHRoaXMuY29sbGF0b3IpO1xuICAgIH1cbiAgICBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEpzID0gc3QoXCI9PVwiLCBEcywgcWEpLCBRcyA9IHN0KFwiIT1cIiwgQnMsIFpzKSwgZWwgPSBzdChcIjxcIiwgcXMsIFhzKSwgdGwgPSBzdChcIj5cIiwgVnMsIEtzKSwgcmwgPSBzdChcIjw9XCIsIEdzLCBZcyksIG5sID0gc3QoXCI+PVwiLCBIcywgV3MpO1xuY2xhc3MgbHIge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgdGhpcy50eXBlID0gUXQsIHRoaXMubG9jYWxlID0gbiwgdGhpcy5jYXNlU2Vuc2l0aXZlID0gZSwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCBvbmUgYXJndW1lbnQuXCIpO1xuICAgIGNvbnN0IG4gPSBlWzFdO1xuICAgIGlmICh0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkobikpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkNvbGxhdG9yIG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgIGNvbnN0IGEgPSB0LnBhcnNlKG5bXCJjYXNlLXNlbnNpdGl2ZVwiXSA9PT0gdm9pZCAwID8gITEgOiBuW1wiY2FzZS1zZW5zaXRpdmVcIl0sIDEsIE0pO1xuICAgIGlmICghYSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG8gPSB0LnBhcnNlKG5bXCJkaWFjcml0aWMtc2Vuc2l0aXZlXCJdID09PSB2b2lkIDAgPyAhMSA6IG5bXCJkaWFjcml0aWMtc2Vuc2l0aXZlXCJdLCAxLCBNKTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaSA9IG51bGw7XG4gICAgcmV0dXJuIG4ubG9jYWxlICYmIChpID0gdC5wYXJzZShuLmxvY2FsZSwgMSwgUCksICFpKSA/IG51bGwgOiBuZXcgbHIoYSwgbywgaSk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIHJldHVybiBuZXcgYW4odGhpcy5jYXNlU2Vuc2l0aXZlLmV2YWx1YXRlKGUpLCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5ldmFsdWF0ZShlKSwgdGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShlKSA6IG51bGwpO1xuICB9XG4gIGVhY2hDaGlsZChlKSB7XG4gICAgZSh0aGlzLmNhc2VTZW5zaXRpdmUpLCBlKHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlKSwgdGhpcy5sb2NhbGUgJiYgZSh0aGlzLmxvY2FsZSk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNsYXNzIGNuIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSwgbykge1xuICAgIHRoaXMudHlwZSA9IFAsIHRoaXMubnVtYmVyID0gZSwgdGhpcy5sb2NhbGUgPSB0LCB0aGlzLmN1cnJlbmN5ID0gbiwgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA9IGEsIHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPSBvO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAzKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICBjb25zdCBuID0gdC5wYXJzZShlWzFdLCAxLCBTKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBhID0gZVsyXTtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGEpKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoXCJOdW1iZXJGb3JtYXQgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgbGV0IG8gPSBudWxsO1xuICAgIGlmIChhLmxvY2FsZSAmJiAobyA9IHQucGFyc2UoYS5sb2NhbGUsIDEsIFApLCAhbykpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaSA9IG51bGw7XG4gICAgaWYgKGEuY3VycmVuY3kgJiYgKGkgPSB0LnBhcnNlKGEuY3VycmVuY3ksIDEsIFApLCAhaSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcyA9IG51bGw7XG4gICAgaWYgKGFbXCJtaW4tZnJhY3Rpb24tZGlnaXRzXCJdICYmIChzID0gdC5wYXJzZShhW1wibWluLWZyYWN0aW9uLWRpZ2l0c1wiXSwgMSwgUyksICFzKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBsID0gbnVsbDtcbiAgICByZXR1cm4gYVtcIm1heC1mcmFjdGlvbi1kaWdpdHNcIl0gJiYgKGwgPSB0LnBhcnNlKGFbXCJtYXgtZnJhY3Rpb24tZGlnaXRzXCJdLCAxLCBTKSwgIWwpID8gbnVsbCA6IG5ldyBjbihuLCBvLCBpLCBzLCBsKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlLmV2YWx1YXRlKGUpIDogW10sIHtcbiAgICAgIHN0eWxlOiB0aGlzLmN1cnJlbmN5ID8gXCJjdXJyZW5jeVwiIDogXCJkZWNpbWFsXCIsXG4gICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUoZSkgOiB2b2lkIDAsXG4gICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWluRnJhY3Rpb25EaWdpdHMgPyB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzLmV2YWx1YXRlKGUpIDogdm9pZCAwLFxuICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID8gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShlKSA6IHZvaWQgMFxuICAgIH0pLmZvcm1hdCh0aGlzLm51bWJlci5ldmFsdWF0ZShlKSk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICBlKHRoaXMubnVtYmVyKSwgdGhpcy5sb2NhbGUgJiYgZSh0aGlzLmxvY2FsZSksIHRoaXMuY3VycmVuY3kgJiYgZSh0aGlzLmN1cnJlbmN5KSwgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyAmJiBlKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpLCB0aGlzLm1heEZyYWN0aW9uRGlnaXRzICYmIGUodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNsYXNzIHBuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudHlwZSA9IGVyLCB0aGlzLnNlY3Rpb25zID0gZTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCA8IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgY29uc3QgbiA9IGVbMV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG4pICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gaW1hZ2Ugb3IgdGV4dCBzZWN0aW9uLlwiKTtcbiAgICBjb25zdCBhID0gW107XG4gICAgbGV0IG8gPSAhMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgY29uc3QgcyA9IGVbaV07XG4gICAgICBpZiAobyAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHMpKSB7XG4gICAgICAgIG8gPSAhMTtcbiAgICAgICAgbGV0IGwgPSBudWxsO1xuICAgICAgICBpZiAoc1tcImZvbnQtc2NhbGVcIl0gJiYgKGwgPSB0LnBhcnNlKHNbXCJmb250LXNjYWxlXCJdLCAxLCBTKSwgIWwpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdSA9IG51bGw7XG4gICAgICAgIGlmIChzW1widGV4dC1mb250XCJdICYmICh1ID0gdC5wYXJzZShzW1widGV4dC1mb250XCJdLCAxLCB0ZShQKSksICF1KSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGMgPSBudWxsO1xuICAgICAgICBpZiAoc1tcInRleHQtY29sb3JcIl0gJiYgKGMgPSB0LnBhcnNlKHNbXCJ0ZXh0LWNvbG9yXCJdLCAxLCB3ZSksICFjKSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHAgPSBudWxsO1xuICAgICAgICBpZiAoc1tcInZlcnRpY2FsLWFsaWduXCJdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzW1widmVydGljYWwtYWxpZ25cIl0gPT0gXCJzdHJpbmdcIiAmJiAhenMuaW5jbHVkZXMoc1tcInZlcnRpY2FsLWFsaWduXCJdKSlcbiAgICAgICAgICAgIHJldHVybiB0LmVycm9yKGAndmVydGljYWwtYWxpZ24nIG11c3QgYmUgb25lIG9mOiAnYm90dG9tJywgJ2NlbnRlcicsICd0b3AnIGJ1dCBmb3VuZCAnJHtzW1widmVydGljYWwtYWxpZ25cIl19JyBpbnN0ZWFkLmApO1xuICAgICAgICAgIGlmIChwID0gdC5wYXJzZShzW1widmVydGljYWwtYWxpZ25cIl0sIDEsIFApLCAhcClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQgPSBhW2EubGVuZ3RoIC0gMV07XG4gICAgICAgIGQuc2NhbGUgPSBsLCBkLmZvbnQgPSB1LCBkLnRleHRDb2xvciA9IGMsIGQudmVydGljYWxBbGlnbiA9IHA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gdC5wYXJzZShlW2ldLCAxLCBJKTtcbiAgICAgICAgaWYgKCFsKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB1ID0gbC50eXBlLmtpbmQ7XG4gICAgICAgIGlmICh1ICE9PSBcInN0cmluZ1wiICYmIHUgIT09IFwidmFsdWVcIiAmJiB1ICE9PSBcIm51bGxcIiAmJiB1ICE9PSBcInJlc29sdmVkSW1hZ2VcIilcbiAgICAgICAgICByZXR1cm4gdC5lcnJvcihcIkZvcm1hdHRlZCB0ZXh0IHR5cGUgbXVzdCBiZSAnc3RyaW5nJywgJ3ZhbHVlJywgJ2ltYWdlJyBvciAnbnVsbCcuXCIpO1xuICAgICAgICBvID0gITAsIGEucHVzaCh7IGNvbnRlbnQ6IGwsIHNjYWxlOiBudWxsLCBmb250OiBudWxsLCB0ZXh0Q29sb3I6IG51bGwsIHZlcnRpY2FsQWxpZ246IG51bGwgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgcG4oYSk7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGNvbnN0IHQgPSAobikgPT4ge1xuICAgICAgY29uc3QgYSA9IG4uY29udGVudC5ldmFsdWF0ZShlKTtcbiAgICAgIHJldHVybiBxKGEpID09PSBBdCA/IG5ldyBPcihcIlwiLCBhLCBudWxsLCBudWxsLCBudWxsLCBuLnZlcnRpY2FsQWxpZ24gPyBuLnZlcnRpY2FsQWxpZ24uZXZhbHVhdGUoZSkgOiBudWxsKSA6IG5ldyBPcihodChhKSwgbnVsbCwgbi5zY2FsZSA/IG4uc2NhbGUuZXZhbHVhdGUoZSkgOiBudWxsLCBuLmZvbnQgPyBuLmZvbnQuZXZhbHVhdGUoZSkuam9pbihcIixcIikgOiBudWxsLCBuLnRleHRDb2xvciA/IG4udGV4dENvbG9yLmV2YWx1YXRlKGUpIDogbnVsbCwgbi52ZXJ0aWNhbEFsaWduID8gbi52ZXJ0aWNhbEFsaWduLmV2YWx1YXRlKGUpIDogbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IGtlKHRoaXMuc2VjdGlvbnMubWFwKHQpKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLnNlY3Rpb25zKVxuICAgICAgZSh0LmNvbnRlbnQpLCB0LnNjYWxlICYmIGUodC5zY2FsZSksIHQuZm9udCAmJiBlKHQuZm9udCksIHQudGV4dENvbG9yICYmIGUodC50ZXh0Q29sb3IpLCB0LnZlcnRpY2FsQWxpZ24gJiYgZSh0LnZlcnRpY2FsQWxpZ24pO1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyBmbiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnR5cGUgPSBBdCwgdGhpcy5pbnB1dCA9IGU7XG4gIH1cbiAgc3RhdGljIHBhcnNlKGUsIHQpIHtcbiAgICBpZiAoZS5sZW5ndGggIT09IDIpXG4gICAgICByZXR1cm4gdC5lcnJvcihcIkV4cGVjdGVkIHR3byBhcmd1bWVudHMuXCIpO1xuICAgIGNvbnN0IG4gPSB0LnBhcnNlKGVbMV0sIDEsIFApO1xuICAgIHJldHVybiBuID8gbmV3IGZuKG4pIDogdC5lcnJvcihcIk5vIGltYWdlIG5hbWUgcHJvdmlkZWQuXCIpO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShlKSwgbiA9ICRlLmZyb21TdHJpbmcodCk7XG4gICAgcmV0dXJuIG4gJiYgZS5hdmFpbGFibGVJbWFnZXMgJiYgKG4uYXZhaWxhYmxlID0gZS5hdmFpbGFibGVJbWFnZXMuaW5kZXhPZih0KSA+IC0xKSwgbjtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5pbnB1dCk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNsYXNzIGRuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudHlwZSA9IFMsIHRoaXMuaW5wdXQgPSBlO1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYEV4cGVjdGVkIDEgYXJndW1lbnQsIGJ1dCBmb3VuZCAke2UubGVuZ3RoIC0gMX0gaW5zdGVhZC5gKTtcbiAgICBjb25zdCBuID0gdC5wYXJzZShlWzFdLCAxKTtcbiAgICByZXR1cm4gbiA/IG4udHlwZS5raW5kICE9PSBcImFycmF5XCIgJiYgbi50eXBlLmtpbmQgIT09IFwic3RyaW5nXCIgJiYgbi50eXBlLmtpbmQgIT09IFwidmFsdWVcIiA/IHQuZXJyb3IoYEV4cGVjdGVkIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgJHtVKG4udHlwZSl9IGluc3RlYWQuYCkgOiBuZXcgZG4obikgOiBudWxsO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShlKTtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBbLi4udF0ubGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHQpKVxuICAgICAgcmV0dXJuIHQubGVuZ3RoO1xuICAgIHRocm93IG5ldyBEKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kICR7VShxKHQpKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBlYWNoQ2hpbGQoZSkge1xuICAgIGUodGhpcy5pbnB1dCk7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IHhlID0gODE5MjtcbmZ1bmN0aW9uIGFsKHIsIGUpIHtcbiAgY29uc3QgdCA9IG9sKHJbMF0pLCBuID0gc2woclsxXSksIGEgPSBNYXRoLnBvdygyLCBlLnopO1xuICByZXR1cm4gW01hdGgucm91bmQodCAqIGEgKiB4ZSksIE1hdGgucm91bmQobiAqIGEgKiB4ZSldO1xufVxuZnVuY3Rpb24gaG4ociwgZSkge1xuICBjb25zdCB0ID0gTWF0aC5wb3coMiwgZS56KSwgbiA9IChyWzBdIC8geGUgKyBlLngpIC8gdCwgYSA9IChyWzFdIC8geGUgKyBlLnkpIC8gdDtcbiAgcmV0dXJuIFtpbChuKSwgbGwoYSldO1xufVxuZnVuY3Rpb24gb2wocikge1xuICByZXR1cm4gKDE4MCArIHIpIC8gMzYwO1xufVxuZnVuY3Rpb24gaWwocikge1xuICByZXR1cm4gciAqIDM2MCAtIDE4MDtcbn1cbmZ1bmN0aW9uIHNsKHIpIHtcbiAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyByICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDtcbn1cbmZ1bmN0aW9uIGxsKHIpIHtcbiAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoKDE4MCAtIHIgKiAzNjApICogTWF0aC5QSSAvIDE4MCkpIC0gOTA7XG59XG5mdW5jdGlvbiBUdChyLCBlKSB7XG4gIHJbMF0gPSBNYXRoLm1pbihyWzBdLCBlWzBdKSwgclsxXSA9IE1hdGgubWluKHJbMV0sIGVbMV0pLCByWzJdID0gTWF0aC5tYXgoclsyXSwgZVswXSksIHJbM10gPSBNYXRoLm1heChyWzNdLCBlWzFdKTtcbn1cbmZ1bmN0aW9uIHd0KHIsIGUpIHtcbiAgcmV0dXJuICEoclswXSA8PSBlWzBdIHx8IHJbMl0gPj0gZVsyXSB8fCByWzFdIDw9IGVbMV0gfHwgclszXSA+PSBlWzNdKTtcbn1cbmZ1bmN0aW9uIHVsKHIsIGUsIHQpIHtcbiAgcmV0dXJuIGVbMV0gPiByWzFdICE9IHRbMV0gPiByWzFdICYmIHJbMF0gPCAodFswXSAtIGVbMF0pICogKHJbMV0gLSBlWzFdKSAvICh0WzFdIC0gZVsxXSkgKyBlWzBdO1xufVxuZnVuY3Rpb24gY2wociwgZSwgdCkge1xuICBjb25zdCBuID0gclswXSAtIGVbMF0sIGEgPSByWzFdIC0gZVsxXSwgbyA9IHJbMF0gLSB0WzBdLCBpID0gclsxXSAtIHRbMV07XG4gIHJldHVybiBuICogaSAtIG8gKiBhID09PSAwICYmIG4gKiBvIDw9IDAgJiYgYSAqIGkgPD0gMDtcbn1cbmZ1bmN0aW9uIHVyKHIsIGUsIHQsIG4pIHtcbiAgY29uc3QgYSA9IFtlWzBdIC0gclswXSwgZVsxXSAtIHJbMV1dLCBvID0gW25bMF0gLSB0WzBdLCBuWzFdIC0gdFsxXV07XG4gIHJldHVybiBobChvLCBhKSA9PT0gMCA/ICExIDogISEoVm4ociwgZSwgdCwgbikgJiYgVm4odCwgbiwgciwgZSkpO1xufVxuZnVuY3Rpb24gcGwociwgZSwgdCkge1xuICBmb3IgKGNvbnN0IG4gb2YgdClcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IG4ubGVuZ3RoIC0gMTsgKythKVxuICAgICAgaWYgKHVyKHIsIGUsIG5bYV0sIG5bYSArIDFdKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBsdChyLCBlLCB0ID0gITEpIHtcbiAgbGV0IG4gPSAhMTtcbiAgZm9yIChjb25zdCBhIG9mIGUpXG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBhLmxlbmd0aCAtIDE7IG8rKykge1xuICAgICAgaWYgKGNsKHIsIGFbb10sIGFbbyArIDFdKSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB1bChyLCBhW29dLCBhW28gKyAxXSkgJiYgKG4gPSAhbik7XG4gICAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGZsKHIsIGUpIHtcbiAgZm9yIChjb25zdCB0IG9mIGUpXG4gICAgaWYgKGx0KHIsIHQpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBHYShyLCBlKSB7XG4gIGZvciAoY29uc3QgdCBvZiByKVxuICAgIGlmICghbHQodCwgZSkpXG4gICAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgci5sZW5ndGggLSAxOyArK3QpXG4gICAgaWYgKHBsKHJbdF0sIHJbdCArIDFdLCBlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gZGwociwgZSkge1xuICBmb3IgKGNvbnN0IHQgb2YgZSlcbiAgICBpZiAoR2EociwgdCkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGhsKHIsIGUpIHtcbiAgcmV0dXJuIHJbMF0gKiBlWzFdIC0gclsxXSAqIGVbMF07XG59XG5mdW5jdGlvbiBWbihyLCBlLCB0LCBuKSB7XG4gIGNvbnN0IGEgPSByWzBdIC0gdFswXSwgbyA9IHJbMV0gLSB0WzFdLCBpID0gZVswXSAtIHRbMF0sIHMgPSBlWzFdIC0gdFsxXSwgbCA9IG5bMF0gLSB0WzBdLCB1ID0gblsxXSAtIHRbMV0sIGMgPSBhICogdSAtIGwgKiBvLCBwID0gaSAqIHUgLSBsICogcztcbiAgcmV0dXJuIGMgPiAwICYmIHAgPCAwIHx8IGMgPCAwICYmIHAgPiAwO1xufVxuZnVuY3Rpb24gbW4ociwgZSwgdCkge1xuICBjb25zdCBuID0gW107XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgci5sZW5ndGg7IGErKykge1xuICAgIGNvbnN0IG8gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJbYV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHMgPSBhbChyW2FdW2ldLCB0KTtcbiAgICAgIFR0KGUsIHMpLCBvLnB1c2gocyk7XG4gICAgfVxuICAgIG4ucHVzaChvKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEhhKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IFtdO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHIubGVuZ3RoOyBhKyspIHtcbiAgICBjb25zdCBvID0gbW4oclthXSwgZSwgdCk7XG4gICAgbi5wdXNoKG8pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gWmEociwgZSwgdCwgbikge1xuICBpZiAoclswXSA8IHRbMF0gfHwgclswXSA+IHRbMl0pIHtcbiAgICBjb25zdCBhID0gbiAqIDAuNTtcbiAgICBsZXQgbyA9IHJbMF0gLSB0WzBdID4gYSA/IC1uIDogdFswXSAtIHJbMF0gPiBhID8gbiA6IDA7XG4gICAgbyA9PT0gMCAmJiAobyA9IHJbMF0gLSB0WzJdID4gYSA/IC1uIDogdFsyXSAtIHJbMF0gPiBhID8gbiA6IDApLCByWzBdICs9IG87XG4gIH1cbiAgVHQoZSwgcik7XG59XG5mdW5jdGlvbiBtbChyKSB7XG4gIHJbMF0gPSByWzFdID0gMSAvIDAsIHJbMl0gPSByWzNdID0gLTEgLyAwO1xufVxuZnVuY3Rpb24gR24ociwgZSwgdCwgbikge1xuICBjb25zdCBhID0gTWF0aC5wb3coMiwgbi56KSAqIHhlLCBvID0gW24ueCAqIHhlLCBuLnkgKiB4ZV0sIGkgPSBbXTtcbiAgZm9yIChjb25zdCBzIG9mIHIpXG4gICAgZm9yIChjb25zdCBsIG9mIHMpIHtcbiAgICAgIGNvbnN0IHUgPSBbbC54ICsgb1swXSwgbC55ICsgb1sxXV07XG4gICAgICBaYSh1LCBlLCB0LCBhKSwgaS5wdXNoKHUpO1xuICAgIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBIbihyLCBlLCB0LCBuKSB7XG4gIGNvbnN0IGEgPSBNYXRoLnBvdygyLCBuLnopICogeGUsIG8gPSBbbi54ICogeGUsIG4ueSAqIHhlXSwgaSA9IFtdO1xuICBmb3IgKGNvbnN0IHMgb2Ygcikge1xuICAgIGNvbnN0IGwgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygcykge1xuICAgICAgY29uc3QgYyA9IFt1LnggKyBvWzBdLCB1LnkgKyBvWzFdXTtcbiAgICAgIFR0KGUsIGMpLCBsLnB1c2goYyk7XG4gICAgfVxuICAgIGkucHVzaChsKTtcbiAgfVxuICBpZiAoZVsyXSAtIGVbMF0gPD0gYSAvIDIpIHtcbiAgICBtbChlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgaSlcbiAgICAgIGZvciAoY29uc3QgbCBvZiBzKVxuICAgICAgICBaYShsLCBlLCB0LCBhKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHlsKHIsIGUpIHtcbiAgY29uc3QgdCA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSwgbiA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSwgYSA9IHIuY2Fub25pY2FsSUQoKTtcbiAgaWYgKGUudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICBjb25zdCBvID0gbW4oZS5jb29yZGluYXRlcywgbiwgYSksIGkgPSBHbihyLmdlb21ldHJ5KCksIHQsIG4sIGEpO1xuICAgIGlmICghd3QodCwgbikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yIChjb25zdCBzIG9mIGkpXG4gICAgICBpZiAoIWx0KHMsIG8pKVxuICAgICAgICByZXR1cm4gITE7XG4gIH1cbiAgaWYgKGUudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikge1xuICAgIGNvbnN0IG8gPSBIYShlLmNvb3JkaW5hdGVzLCBuLCBhKSwgaSA9IEduKHIuZ2VvbWV0cnkoKSwgdCwgbiwgYSk7XG4gICAgaWYgKCF3dCh0LCBuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgaSlcbiAgICAgIGlmICghZmwocywgbykpXG4gICAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBnbChyLCBlKSB7XG4gIGNvbnN0IHQgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sIG4gPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sIGEgPSByLmNhbm9uaWNhbElEKCk7XG4gIGlmIChlLnR5cGUgPT09IFwiUG9seWdvblwiKSB7XG4gICAgY29uc3QgbyA9IG1uKGUuY29vcmRpbmF0ZXMsIG4sIGEpLCBpID0gSG4oci5nZW9tZXRyeSgpLCB0LCBuLCBhKTtcbiAgICBpZiAoIXd0KHQsIG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoY29uc3QgcyBvZiBpKVxuICAgICAgaWYgKCFHYShzLCBvKSlcbiAgICAgICAgcmV0dXJuICExO1xuICB9XG4gIGlmIChlLnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIHtcbiAgICBjb25zdCBvID0gSGEoZS5jb29yZGluYXRlcywgbiwgYSksIGkgPSBIbihyLmdlb21ldHJ5KCksIHQsIG4sIGEpO1xuICAgIGlmICghd3QodCwgbikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yIChjb25zdCBzIG9mIGkpXG4gICAgICBpZiAoIWRsKHMsIG8pKVxuICAgICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuY2xhc3MgVmUge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy50eXBlID0gTSwgdGhpcy5nZW9qc29uID0gZSwgdGhpcy5nZW9tZXRyaWVzID0gdDtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybiB0LmVycm9yKGAnd2l0aGluJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgaWYgKHZ0KGVbMV0pKSB7XG4gICAgICBjb25zdCBuID0gZVsxXTtcbiAgICAgIGlmIChuLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiBuLmZlYXR1cmVzKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlOiBpLCBjb29yZGluYXRlczogcyB9ID0gby5nZW9tZXRyeTtcbiAgICAgICAgICBpID09PSBcIlBvbHlnb25cIiAmJiBhLnB1c2gocyksIGkgPT09IFwiTXVsdGlQb2x5Z29uXCIgJiYgYS5wdXNoKC4uLnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IG8gPSB7XG4gICAgICAgICAgICB0eXBlOiBcIk11bHRpUG9seWdvblwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBuZXcgVmUobiwgbyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobi50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgICAgICBjb25zdCBhID0gbi5nZW9tZXRyeS50eXBlO1xuICAgICAgICBpZiAoYSA9PT0gXCJQb2x5Z29uXCIgfHwgYSA9PT0gXCJNdWx0aVBvbHlnb25cIilcbiAgICAgICAgICByZXR1cm4gbmV3IFZlKG4sIG4uZ2VvbWV0cnkpO1xuICAgICAgfSBlbHNlIGlmIChuLnR5cGUgPT09IFwiUG9seWdvblwiIHx8IG4udHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIilcbiAgICAgICAgcmV0dXJuIG5ldyBWZShuLCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIHQuZXJyb3IoXCInd2l0aGluJyBleHByZXNzaW9uIHJlcXVpcmVzIHZhbGlkIGdlb2pzb24gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9seWdvbiBnZW9tZXRyeSB0eXBlLlwiKTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgaWYgKGUuZ2VvbWV0cnkoKSAhPSBudWxsICYmIGUuY2Fub25pY2FsSUQoKSAhPSBudWxsKSB7XG4gICAgICBpZiAoZS5nZW9tZXRyeVR5cGUoKSA9PT0gXCJQb2ludFwiKVxuICAgICAgICByZXR1cm4geWwoZSwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgIGlmIChlLmdlb21ldHJ5VHlwZSgpID09PSBcIkxpbmVTdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGdsKGUsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBlYWNoQ2hpbGQoKSB7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmNsYXNzIFhhIHtcbiAgY29uc3RydWN0b3IoZSA9IFtdLCB0ID0gKG4sIGEpID0+IG4gPCBhID8gLTEgOiBuID4gYSA/IDEgOiAwKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9IGUsIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCwgdGhpcy5jb21wYXJlID0gdCwgdGhpcy5sZW5ndGggPiAwKVxuICAgICAgZm9yIChsZXQgbiA9ICh0aGlzLmxlbmd0aCA+PiAxKSAtIDE7IG4gPj0gMDsgbi0tKSB0aGlzLl9kb3duKG4pO1xuICB9XG4gIHB1c2goZSkge1xuICAgIHRoaXMuZGF0YS5wdXNoKGUpLCB0aGlzLl91cCh0aGlzLmxlbmd0aCsrKTtcbiAgfVxuICBwb3AoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YVswXSwgdCA9IHRoaXMuZGF0YS5wb3AoKTtcbiAgICByZXR1cm4gLS10aGlzLmxlbmd0aCA+IDAgJiYgKHRoaXMuZGF0YVswXSA9IHQsIHRoaXMuX2Rvd24oMCkpLCBlO1xuICB9XG4gIHBlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcbiAgfVxuICBfdXAoZSkge1xuICAgIGNvbnN0IHsgZGF0YTogdCwgY29tcGFyZTogbiB9ID0gdGhpcywgYSA9IHRbZV07XG4gICAgZm9yICg7IGUgPiAwOyApIHtcbiAgICAgIGNvbnN0IG8gPSBlIC0gMSA+PiAxLCBpID0gdFtvXTtcbiAgICAgIGlmIChuKGEsIGkpID49IDApIGJyZWFrO1xuICAgICAgdFtlXSA9IGksIGUgPSBvO1xuICAgIH1cbiAgICB0W2VdID0gYTtcbiAgfVxuICBfZG93bihlKSB7XG4gICAgY29uc3QgeyBkYXRhOiB0LCBjb21wYXJlOiBuIH0gPSB0aGlzLCBhID0gdGhpcy5sZW5ndGggPj4gMSwgbyA9IHRbZV07XG4gICAgZm9yICg7IGUgPCBhOyApIHtcbiAgICAgIGxldCBpID0gKGUgPDwgMSkgKyAxO1xuICAgICAgY29uc3QgcyA9IGkgKyAxO1xuICAgICAgaWYgKHMgPCB0aGlzLmxlbmd0aCAmJiBuKHRbc10sIHRbaV0pIDwgMCAmJiAoaSA9IHMpLCBuKHRbaV0sIG8pID49IDApIGJyZWFrO1xuICAgICAgdFtlXSA9IHRbaV0sIGUgPSBpO1xuICAgIH1cbiAgICB0W2VdID0gbztcbiAgfVxufVxuZnVuY3Rpb24gdmwociwgZSkge1xuICBpZiAoci5sZW5ndGggPD0gMSlcbiAgICByZXR1cm4gW3JdO1xuICBjb25zdCBuID0gW107XG4gIGxldCBhLCBvO1xuICBmb3IgKGNvbnN0IGkgb2Ygcikge1xuICAgIGNvbnN0IHMgPSBibChpKTtcbiAgICBzICE9PSAwICYmIChpLmFyZWEgPSBNYXRoLmFicyhzKSwgbyA9PT0gdm9pZCAwICYmIChvID0gcyA8IDApLCBvID09PSBzIDwgMCA/IChhICYmIG4ucHVzaChhKSwgYSA9IFtpXSkgOiBhLnB1c2goaSkpO1xuICB9XG4gIHJldHVybiBhICYmIG4ucHVzaChhKSwgbjtcbn1cbmZ1bmN0aW9uIGJsKHIpIHtcbiAgbGV0IGUgPSAwO1xuICBmb3IgKGxldCB0ID0gMCwgbiA9IHIubGVuZ3RoLCBhID0gbiAtIDEsIG8sIGk7IHQgPCBuOyBhID0gdCsrKVxuICAgIG8gPSByW3RdLCBpID0gclthXSwgZSArPSAoaS54IC0gby54KSAqIChvLnkgKyBpLnkpO1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IHdsID0gNjM3OC4xMzcsIFpuID0gMSAvIDI5OC4yNTcyMjM1NjMsIFhuID0gWm4gKiAoMiAtIFpuKSwgS24gPSBNYXRoLlBJIC8gMTgwO1xuY2xhc3MgeW4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgY29uc3QgdCA9IEtuICogd2wgKiAxZTMsIG4gPSBNYXRoLmNvcyhlICogS24pLCBhID0gMSAvICgxIC0gWG4gKiAoMSAtIG4gKiBuKSksIG8gPSBNYXRoLnNxcnQoYSk7XG4gICAgdGhpcy5reCA9IHQgKiBvICogbiwgdGhpcy5reSA9IHQgKiBvICogYSAqICgxIC0gWG4pO1xuICB9XG4gIC8qKlxuICAgKiBHaXZlbiB0d28gcG9pbnRzIG9mIHRoZSBmb3JtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSwgcmV0dXJucyB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBhIC0gcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAqIEBwYXJhbSBiIC0gcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAqIEByZXR1cm5zIGRpc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRpc3RhbmNlID0gcnVsZXIuZGlzdGFuY2UoWzMwLjUsIDUwLjVdLCBbMzAuNTEsIDUwLjQ5XSk7XG4gICAqIC8vPWRpc3RhbmNlXG4gICAqL1xuICBkaXN0YW5jZShlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMud3JhcChlWzBdIC0gdFswXSkgKiB0aGlzLmt4LCBhID0gKGVbMV0gLSB0WzFdKSAqIHRoaXMua3k7XG4gICAgcmV0dXJuIE1hdGguc3FydChuICogbiArIGEgKiBhKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgdGhlIGZvcm0ge3BvaW50LCBpbmRleCwgdH0sIHdoZXJlIHBvaW50IGlzIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmVcbiAgICogZnJvbSB0aGUgZ2l2ZW4gcG9pbnQsIGluZGV4IGlzIHRoZSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCB3aXRoIHRoZSBjbG9zZXN0IHBvaW50LFxuICAgKiBhbmQgdCBpcyBhIHBhcmFtZXRlciBmcm9tIDAgdG8gMSB0aGF0IGluZGljYXRlcyB3aGVyZSB0aGUgY2xvc2VzdCBwb2ludCBpcyBvbiB0aGF0IHNlZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBsaW5lIC0gYW4gYXJyYXkgb2YgcG9pbnRzIHRoYXQgZm9ybSB0aGUgbGluZVxuICAgKiBAcGFyYW0gcCAtIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgKiBAcmV0dXJucyB0aGUgbmVhcmVzdCBwb2ludCwgaXRzIGluZGV4IGluIHRoZSBhcnJheSBhbmQgdGhlIHByb3BvcnRpb24gYWxvbmcgdGhlIGxpbmVcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcG9pbnQgPSBydWxlci5wb2ludE9uTGluZShsaW5lLCBbLTY3LjA0LCA1MC41XSkucG9pbnQ7XG4gICAqIC8vPXBvaW50XG4gICAqL1xuICBwb2ludE9uTGluZShlLCB0KSB7XG4gICAgbGV0IG4gPSAxIC8gMCwgYSwgbywgaSwgcztcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGUubGVuZ3RoIC0gMTsgbCsrKSB7XG4gICAgICBsZXQgdSA9IGVbbF1bMF0sIGMgPSBlW2xdWzFdLCBwID0gdGhpcy53cmFwKGVbbCArIDFdWzBdIC0gdSkgKiB0aGlzLmt4LCBkID0gKGVbbCArIDFdWzFdIC0gYykgKiB0aGlzLmt5LCBmID0gMDtcbiAgICAgIChwICE9PSAwIHx8IGQgIT09IDApICYmIChmID0gKHRoaXMud3JhcCh0WzBdIC0gdSkgKiB0aGlzLmt4ICogcCArICh0WzFdIC0gYykgKiB0aGlzLmt5ICogZCkgLyAocCAqIHAgKyBkICogZCksIGYgPiAxID8gKHUgPSBlW2wgKyAxXVswXSwgYyA9IGVbbCArIDFdWzFdKSA6IGYgPiAwICYmICh1ICs9IHAgLyB0aGlzLmt4ICogZiwgYyArPSBkIC8gdGhpcy5reSAqIGYpKSwgcCA9IHRoaXMud3JhcCh0WzBdIC0gdSkgKiB0aGlzLmt4LCBkID0gKHRbMV0gLSBjKSAqIHRoaXMua3k7XG4gICAgICBjb25zdCBoID0gcCAqIHAgKyBkICogZDtcbiAgICAgIGggPCBuICYmIChuID0gaCwgYSA9IHUsIG8gPSBjLCBpID0gbCwgcyA9IGYpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IFthLCBvXSxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgdDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcykpXG4gICAgfTtcbiAgfVxuICB3cmFwKGUpIHtcbiAgICBmb3IgKDsgZSA8IC0xODA7IClcbiAgICAgIGUgKz0gMzYwO1xuICAgIGZvciAoOyBlID4gMTgwOyApXG4gICAgICBlIC09IDM2MDtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuY29uc3QgTnIgPSAxMDAsIGpyID0gNTA7XG5mdW5jdGlvbiBLYShyLCBlKSB7XG4gIHJldHVybiBlWzBdIC0gclswXTtcbn1cbmZ1bmN0aW9uIFZ0KHIpIHtcbiAgcmV0dXJuIHJbMV0gLSByWzBdICsgMTtcbn1cbmZ1bmN0aW9uIENlKHIsIGUpIHtcbiAgcmV0dXJuIHJbMV0gPj0gclswXSAmJiByWzFdIDwgZTtcbn1cbmZ1bmN0aW9uIFVyKHIsIGUpIHtcbiAgaWYgKHJbMF0gPiByWzFdKVxuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIGNvbnN0IHQgPSBWdChyKTtcbiAgaWYgKGUpIHtcbiAgICBpZiAodCA9PT0gMilcbiAgICAgIHJldHVybiBbciwgbnVsbF07XG4gICAgY29uc3QgYSA9IE1hdGguZmxvb3IodCAvIDIpO1xuICAgIHJldHVybiBbXG4gICAgICBbclswXSwgclswXSArIGFdLFxuICAgICAgW3JbMF0gKyBhLCByWzFdXVxuICAgIF07XG4gIH1cbiAgaWYgKHQgPT09IDEpXG4gICAgcmV0dXJuIFtyLCBudWxsXTtcbiAgY29uc3QgbiA9IE1hdGguZmxvb3IodCAvIDIpIC0gMTtcbiAgcmV0dXJuIFtcbiAgICBbclswXSwgclswXSArIG5dLFxuICAgIFtyWzBdICsgbiArIDEsIHJbMV1dXG4gIF07XG59XG5mdW5jdGlvbiBEcihyLCBlKSB7XG4gIGlmICghQ2UoZSwgci5sZW5ndGgpKVxuICAgIHJldHVybiBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF07XG4gIGNvbnN0IHQgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF07XG4gIGZvciAobGV0IG4gPSBlWzBdOyBuIDw9IGVbMV07ICsrbilcbiAgICBUdCh0LCByW25dKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBCcihyKSB7XG4gIGNvbnN0IGUgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF07XG4gIGZvciAoY29uc3QgdCBvZiByKVxuICAgIGZvciAoY29uc3QgbiBvZiB0KVxuICAgICAgVHQoZSwgbik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gWW4ocikge1xuICByZXR1cm4gclswXSAhPT0gLTEgLyAwICYmIHJbMV0gIT09IC0xIC8gMCAmJiByWzJdICE9PSAxIC8gMCAmJiByWzNdICE9PSAxIC8gMDtcbn1cbmZ1bmN0aW9uIGduKHIsIGUsIHQpIHtcbiAgaWYgKCFZbihyKSB8fCAhWW4oZSkpXG4gICAgcmV0dXJuIE5hTjtcbiAgbGV0IG4gPSAwLCBhID0gMDtcbiAgcmV0dXJuIHJbMl0gPCBlWzBdICYmIChuID0gZVswXSAtIHJbMl0pLCByWzBdID4gZVsyXSAmJiAobiA9IHJbMF0gLSBlWzJdKSwgclsxXSA+IGVbM10gJiYgKGEgPSByWzFdIC0gZVszXSksIHJbM10gPCBlWzFdICYmIChhID0gZVsxXSAtIHJbM10pLCB0LmRpc3RhbmNlKFswLCAwXSwgW24sIGFdKTtcbn1cbmZ1bmN0aW9uIERlKHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHQucG9pbnRPbkxpbmUoZSwgcik7XG4gIHJldHVybiB0LmRpc3RhbmNlKHIsIG4ucG9pbnQpO1xufVxuZnVuY3Rpb24gdm4ociwgZSwgdCwgbiwgYSkge1xuICBjb25zdCBvID0gTWF0aC5taW4oRGUociwgW3QsIG5dLCBhKSwgRGUoZSwgW3QsIG5dLCBhKSksIGkgPSBNYXRoLm1pbihEZSh0LCBbciwgZV0sIGEpLCBEZShuLCBbciwgZV0sIGEpKTtcbiAgcmV0dXJuIE1hdGgubWluKG8sIGkpO1xufVxuZnVuY3Rpb24gU2wociwgZSwgdCwgbiwgYSkge1xuICBpZiAoIShDZShlLCByLmxlbmd0aCkgJiYgQ2UobiwgdC5sZW5ndGgpKSlcbiAgICByZXR1cm4gMSAvIDA7XG4gIGxldCBpID0gMSAvIDA7XG4gIGZvciAobGV0IHMgPSBlWzBdOyBzIDwgZVsxXTsgKytzKSB7XG4gICAgY29uc3QgbCA9IHJbc10sIHUgPSByW3MgKyAxXTtcbiAgICBmb3IgKGxldCBjID0gblswXTsgYyA8IG5bMV07ICsrYykge1xuICAgICAgY29uc3QgcCA9IHRbY10sIGQgPSB0W2MgKyAxXTtcbiAgICAgIGlmICh1cihsLCB1LCBwLCBkKSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBpID0gTWF0aC5taW4oaSwgdm4obCwgdSwgcCwgZCwgYSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHhsKHIsIGUsIHQsIG4sIGEpIHtcbiAgaWYgKCEoQ2UoZSwgci5sZW5ndGgpICYmIENlKG4sIHQubGVuZ3RoKSkpXG4gICAgcmV0dXJuIE5hTjtcbiAgbGV0IGkgPSAxIC8gMDtcbiAgZm9yIChsZXQgcyA9IGVbMF07IHMgPD0gZVsxXTsgKytzKVxuICAgIGZvciAobGV0IGwgPSBuWzBdOyBsIDw9IG5bMV07ICsrbClcbiAgICAgIGlmIChpID0gTWF0aC5taW4oaSwgYS5kaXN0YW5jZShyW3NdLCB0W2xdKSksIGkgPT09IDApXG4gICAgICAgIHJldHVybiBpO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGtsKHIsIGUsIHQpIHtcbiAgaWYgKGx0KHIsIGUsICEwKSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IG4gPSAxIC8gMDtcbiAgZm9yIChjb25zdCBhIG9mIGUpIHtcbiAgICBjb25zdCBvID0gYVswXSwgaSA9IGFbYS5sZW5ndGggLSAxXTtcbiAgICBpZiAobyAhPT0gaSAmJiAobiA9IE1hdGgubWluKG4sIERlKHIsIFtpLCBvXSwgdCkpLCBuID09PSAwKSlcbiAgICAgIHJldHVybiBuO1xuICAgIGNvbnN0IHMgPSB0LnBvaW50T25MaW5lKGEsIHIpO1xuICAgIGlmIChuID0gTWF0aC5taW4obiwgdC5kaXN0YW5jZShyLCBzLnBvaW50KSksIG4gPT09IDApXG4gICAgICByZXR1cm4gbjtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIExsKHIsIGUsIHQsIG4pIHtcbiAgaWYgKCFDZShlLCByLmxlbmd0aCkpXG4gICAgcmV0dXJuIE5hTjtcbiAgZm9yIChsZXQgbyA9IGVbMF07IG8gPD0gZVsxXTsgKytvKVxuICAgIGlmIChsdChyW29dLCB0LCAhMCkpXG4gICAgICByZXR1cm4gMDtcbiAgbGV0IGEgPSAxIC8gMDtcbiAgZm9yIChsZXQgbyA9IGVbMF07IG8gPCBlWzFdOyArK28pIHtcbiAgICBjb25zdCBpID0gcltvXSwgcyA9IHJbbyArIDFdO1xuICAgIGZvciAoY29uc3QgbCBvZiB0KVxuICAgICAgZm9yIChsZXQgdSA9IDAsIGMgPSBsLmxlbmd0aCwgcCA9IGMgLSAxOyB1IDwgYzsgcCA9IHUrKykge1xuICAgICAgICBjb25zdCBkID0gbFtwXSwgZiA9IGxbdV07XG4gICAgICAgIGlmICh1cihpLCBzLCBkLCBmKSlcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgYSA9IE1hdGgubWluKGEsIHZuKGksIHMsIGQsIGYsIG4pKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIFduKHIsIGUpIHtcbiAgZm9yIChjb25zdCB0IG9mIHIpXG4gICAgZm9yIChjb25zdCBuIG9mIHQpXG4gICAgICBpZiAobHQobiwgZSwgITApKVxuICAgICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIENsKHIsIGUsIHQsIG4gPSAxIC8gMCkge1xuICBjb25zdCBhID0gQnIociksIG8gPSBCcihlKTtcbiAgaWYgKG4gIT09IDEgLyAwICYmIGduKGEsIG8sIHQpID49IG4pXG4gICAgcmV0dXJuIG47XG4gIGlmICh3dChhLCBvKSkge1xuICAgIGlmIChXbihyLCBlKSlcbiAgICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKFduKGUsIHIpKVxuICAgIHJldHVybiAwO1xuICBsZXQgaSA9IDEgLyAwO1xuICBmb3IgKGNvbnN0IHMgb2YgcilcbiAgICBmb3IgKGxldCBsID0gMCwgdSA9IHMubGVuZ3RoLCBjID0gdSAtIDE7IGwgPCB1OyBjID0gbCsrKSB7XG4gICAgICBjb25zdCBwID0gc1tjXSwgZCA9IHNbbF07XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgZSlcbiAgICAgICAgZm9yIChsZXQgaCA9IDAsIG0gPSBmLmxlbmd0aCwgeSA9IG0gLSAxOyBoIDwgbTsgeSA9IGgrKykge1xuICAgICAgICAgIGNvbnN0IHcgPSBmW3ldLCBnID0gZltoXTtcbiAgICAgICAgICBpZiAodXIocCwgZCwgdywgZykpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBpID0gTWF0aC5taW4oaSwgdm4ocCwgZCwgdywgZywgdCkpO1xuICAgICAgICB9XG4gICAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIEpuKHIsIGUsIHQsIG4sIGEsIG8pIHtcbiAgaWYgKCFvKVxuICAgIHJldHVybjtcbiAgY29uc3QgaSA9IGduKERyKG4sIG8pLCBhLCB0KTtcbiAgaSA8IGUgJiYgci5wdXNoKFtpLCBvLCBbMCwgMF1dKTtcbn1cbmZ1bmN0aW9uIHp0KHIsIGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgaWYgKCFvIHx8ICFpKVxuICAgIHJldHVybjtcbiAgY29uc3QgcyA9IGduKERyKG4sIG8pLCBEcihhLCBpKSwgdCk7XG4gIHMgPCBlICYmIHIucHVzaChbcywgbywgaV0pO1xufVxuZnVuY3Rpb24gR3QociwgZSwgdCwgbiwgYSA9IDEgLyAwKSB7XG4gIGxldCBvID0gTWF0aC5taW4obi5kaXN0YW5jZShyWzBdLCB0WzBdWzBdKSwgYSk7XG4gIGlmIChvID09PSAwKVxuICAgIHJldHVybiBvO1xuICBjb25zdCBpID0gbmV3IFhhKFtbMCwgWzAsIHIubGVuZ3RoIC0gMV0sIFswLCAwXV1dLCBLYSksIHMgPSBCcih0KTtcbiAgZm9yICg7IGkubGVuZ3RoID4gMDsgKSB7XG4gICAgY29uc3QgbCA9IGkucG9wKCk7XG4gICAgaWYgKGxbMF0gPj0gbylcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHUgPSBsWzFdLCBjID0gZSA/IGpyIDogTnI7XG4gICAgaWYgKFZ0KHUpIDw9IGMpIHtcbiAgICAgIGlmICghQ2UodSwgci5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgY29uc3QgcCA9IExsKHIsIHUsIHQsIG4pO1xuICAgICAgICBpZiAoaXNOYU4ocCkgfHwgcCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIHApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAobGV0IHAgPSB1WzBdOyBwIDw9IHVbMV07ICsrcCkge1xuICAgICAgICAgIGNvbnN0IGQgPSBrbChyW3BdLCB0LCBuKTtcbiAgICAgICAgICBpZiAobyA9IE1hdGgubWluKG8sIGQpLCBvID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcCA9IFVyKHUsIGUpO1xuICAgICAgSm4oaSwgbywgbiwgciwgcywgcFswXSksIEpuKGksIG8sIG4sIHIsIHMsIHBbMV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEh0KHIsIGUsIHQsIG4sIGEsIG8gPSAxIC8gMCkge1xuICBsZXQgaSA9IE1hdGgubWluKG8sIGEuZGlzdGFuY2UoclswXSwgdFswXSkpO1xuICBpZiAoaSA9PT0gMClcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgcyA9IG5ldyBYYShbWzAsIFswLCByLmxlbmd0aCAtIDFdLCBbMCwgdC5sZW5ndGggLSAxXV1dLCBLYSk7XG4gIGZvciAoOyBzLmxlbmd0aCA+IDA7ICkge1xuICAgIGNvbnN0IGwgPSBzLnBvcCgpO1xuICAgIGlmIChsWzBdID49IGkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB1ID0gbFsxXSwgYyA9IGxbMl0sIHAgPSBlID8ganIgOiBOciwgZCA9IG4gPyBqciA6IE5yO1xuICAgIGlmIChWdCh1KSA8PSBwICYmIFZ0KGMpIDw9IGQpIHtcbiAgICAgIGlmICghQ2UodSwgci5sZW5ndGgpICYmIENlKGMsIHQubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIGxldCBmO1xuICAgICAgaWYgKGUgJiYgbilcbiAgICAgICAgZiA9IFNsKHIsIHUsIHQsIGMsIGEpLCBpID0gTWF0aC5taW4oaSwgZik7XG4gICAgICBlbHNlIGlmIChlICYmICFuKSB7XG4gICAgICAgIGNvbnN0IGggPSByLnNsaWNlKHVbMF0sIHVbMV0gKyAxKTtcbiAgICAgICAgZm9yIChsZXQgbSA9IGNbMF07IG0gPD0gY1sxXTsgKyttKVxuICAgICAgICAgIGlmIChmID0gRGUodFttXSwgaCwgYSksIGkgPSBNYXRoLm1pbihpLCBmKSwgaSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgfSBlbHNlIGlmICghZSAmJiBuKSB7XG4gICAgICAgIGNvbnN0IGggPSB0LnNsaWNlKGNbMF0sIGNbMV0gKyAxKTtcbiAgICAgICAgZm9yIChsZXQgbSA9IHVbMF07IG0gPD0gdVsxXTsgKyttKVxuICAgICAgICAgIGlmIChmID0gRGUoclttXSwgaCwgYSksIGkgPSBNYXRoLm1pbihpLCBmKSwgaSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGYgPSB4bChyLCB1LCB0LCBjLCBhKSwgaSA9IE1hdGgubWluKGksIGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmID0gVXIodSwgZSksIGggPSBVcihjLCBuKTtcbiAgICAgIHp0KHMsIGksIGEsIHIsIHQsIGZbMF0sIGhbMF0pLCB6dChzLCBpLCBhLCByLCB0LCBmWzBdLCBoWzFdKSwgenQocywgaSwgYSwgciwgdCwgZlsxXSwgaFswXSksIHp0KHMsIGksIGEsIHIsIHQsIGZbMV0sIGhbMV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIEVsKHIsIGUpIHtcbiAgY29uc3QgdCA9IHIuZ2VvbWV0cnkoKSwgbiA9IHQuZmxhdCgpLm1hcCgoaSkgPT4gaG4oW2kueCwgaS55XSwgci5jYW5vbmljYWwpKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBOYU47XG4gIGNvbnN0IGEgPSBuZXcgeW4oblswXVsxXSk7XG4gIGxldCBvID0gMSAvIDA7XG4gIGZvciAoY29uc3QgaSBvZiBlKSB7XG4gICAgc3dpdGNoIChpLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICBvID0gTWF0aC5taW4obywgSHQobiwgITEsIFtpLmNvb3JkaW5hdGVzXSwgITEsIGEsIG8pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICBvID0gTWF0aC5taW4obywgSHQobiwgITEsIGkuY29vcmRpbmF0ZXMsICEwLCBhLCBvKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIEd0KG4sICExLCBpLmNvb3JkaW5hdGVzLCBhLCBvKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobyA9PT0gMClcbiAgICAgIHJldHVybiBvO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gQWwociwgZSkge1xuICBjb25zdCB0ID0gci5nZW9tZXRyeSgpLCBuID0gdC5mbGF0KCkubWFwKChpKSA9PiBobihbaS54LCBpLnldLCByLmNhbm9uaWNhbCkpO1xuICBpZiAodC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIE5hTjtcbiAgY29uc3QgYSA9IG5ldyB5bihuWzBdWzFdKTtcbiAgbGV0IG8gPSAxIC8gMDtcbiAgZm9yIChjb25zdCBpIG9mIGUpIHtcbiAgICBzd2l0Y2ggKGkudHlwZSkge1xuICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgIG8gPSBNYXRoLm1pbihvLCBIdChuLCAhMCwgW2kuY29vcmRpbmF0ZXNdLCAhMSwgYSwgbykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIG8gPSBNYXRoLm1pbihvLCBIdChuLCAhMCwgaS5jb29yZGluYXRlcywgITAsIGEsIG8pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBvID0gTWF0aC5taW4obywgR3QobiwgITAsIGkuY29vcmRpbmF0ZXMsIGEsIG8pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChvID09PSAwKVxuICAgICAgcmV0dXJuIG87XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBUbChyLCBlKSB7XG4gIGNvbnN0IHQgPSByLmdlb21ldHJ5KCk7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMCB8fCB0WzBdLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gTmFOO1xuICBjb25zdCBuID0gdmwodCkubWFwKChpKSA9PiBpLm1hcCgocykgPT4gcy5tYXAoKGwpID0+IGhuKFtsLngsIGwueV0sIHIuY2Fub25pY2FsKSkpKSwgYSA9IG5ldyB5bihuWzBdWzBdWzBdWzFdKTtcbiAgbGV0IG8gPSAxIC8gMDtcbiAgZm9yIChjb25zdCBpIG9mIGUpXG4gICAgZm9yIChjb25zdCBzIG9mIG4pIHtcbiAgICAgIHN3aXRjaCAoaS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgIG8gPSBNYXRoLm1pbihvLCBHdChbaS5jb29yZGluYXRlc10sICExLCBzLCBhLCBvKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgbyA9IE1hdGgubWluKG8sIEd0KGkuY29vcmRpbmF0ZXMsICEwLCBzLCBhLCBvKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgbyA9IE1hdGgubWluKG8sIENsKHMsIGkuY29vcmRpbmF0ZXMsIGEsIG8pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvID09PSAwKVxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gTHIocikge1xuICByZXR1cm4gci50eXBlID09PSBcIk11bHRpUG9seWdvblwiID8gci5jb29yZGluYXRlcy5tYXAoKGUpID0+ICh7XG4gICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgY29vcmRpbmF0ZXM6IGVcbiAgfSkpIDogci50eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiID8gci5jb29yZGluYXRlcy5tYXAoKGUpID0+ICh7XG4gICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgY29vcmRpbmF0ZXM6IGVcbiAgfSkpIDogci50eXBlID09PSBcIk11bHRpUG9pbnRcIiA/IHIuY29vcmRpbmF0ZXMubWFwKChlKSA9PiAoe1xuICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICBjb29yZGluYXRlczogZVxuICB9KSkgOiBbcl07XG59XG5jbGFzcyBHZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnR5cGUgPSBTLCB0aGlzLmdlb2pzb24gPSBlLCB0aGlzLmdlb21ldHJpZXMgPSB0O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlLCB0KSB7XG4gICAgaWYgKGUubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYCdkaXN0YW5jZScgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kICR7ZS5sZW5ndGggLSAxfSBpbnN0ZWFkLmApO1xuICAgIGlmICh2dChlWzFdKSkge1xuICAgICAgY29uc3QgbiA9IGVbMV07XG4gICAgICBpZiAobi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIpXG4gICAgICAgIHJldHVybiBuZXcgR2Uobiwgbi5mZWF0dXJlcy5tYXAoKGEpID0+IExyKGEuZ2VvbWV0cnkpKS5mbGF0KCkpO1xuICAgICAgaWYgKG4udHlwZSA9PT0gXCJGZWF0dXJlXCIpXG4gICAgICAgIHJldHVybiBuZXcgR2UobiwgTHIobi5nZW9tZXRyeSkpO1xuICAgICAgaWYgKFwidHlwZVwiIGluIG4gJiYgXCJjb29yZGluYXRlc1wiIGluIG4pXG4gICAgICAgIHJldHVybiBuZXcgR2UobiwgTHIobikpO1xuICAgIH1cbiAgICByZXR1cm4gdC5lcnJvcihcIidkaXN0YW5jZScgZXhwcmVzc2lvbiByZXF1aXJlcyB2YWxpZCBnZW9qc29uIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvbHlnb24gZ2VvbWV0cnkgdHlwZS5cIik7XG4gIH1cbiAgZXZhbHVhdGUoZSkge1xuICAgIGlmIChlLmdlb21ldHJ5KCkgIT0gbnVsbCAmJiBlLmNhbm9uaWNhbElEKCkgIT0gbnVsbCkge1xuICAgICAgaWYgKGUuZ2VvbWV0cnlUeXBlKCkgPT09IFwiUG9pbnRcIilcbiAgICAgICAgcmV0dXJuIEVsKGUsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICBpZiAoZS5nZW9tZXRyeVR5cGUoKSA9PT0gXCJMaW5lU3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBBbChlLCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgaWYgKGUuZ2VvbWV0cnlUeXBlKCkgPT09IFwiUG9seWdvblwiKVxuICAgICAgICByZXR1cm4gVGwoZSwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBlYWNoQ2hpbGQoKSB7XG4gIH1cbiAgb3V0cHV0RGVmaW5lZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmNsYXNzIF90IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudHlwZSA9IEksIHRoaXMua2V5ID0gZTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGlmIChlLmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybiB0LmVycm9yKGBFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgJHtlLmxlbmd0aCAtIDF9IGluc3RlYWQuYCk7XG4gICAgY29uc3QgbiA9IGVbMV07XG4gICAgcmV0dXJuIG4gPT0gbnVsbCA/IHQuZXJyb3IoXCJHbG9iYWwgc3RhdGUgcHJvcGVydHkgbXVzdCBiZSBkZWZpbmVkLlwiKSA6IHR5cGVvZiBuICE9IFwic3RyaW5nXCIgPyB0LmVycm9yKGBHbG9iYWwgc3RhdGUgcHJvcGVydHkgbXVzdCBiZSBzdHJpbmcsIGJ1dCBmb3VuZCAke3R5cGVvZiBlWzFdfSBpbnN0ZWFkLmApIDogbmV3IF90KG4pO1xuICB9XG4gIGV2YWx1YXRlKGUpIHtcbiAgICB2YXIgdDtcbiAgICBjb25zdCBuID0gKHQgPSBlLmdsb2JhbHMpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQuZ2xvYmFsU3RhdGU7XG4gICAgcmV0dXJuICFuIHx8IE9iamVjdC5rZXlzKG4pLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBkdChuLCB0aGlzLmtleSk7XG4gIH1cbiAgZWFjaENoaWxkKCkge1xuICB9XG4gIG91dHB1dERlZmluZWQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBibiA9IHtcbiAgLy8gc3BlY2lhbCBmb3Jtc1xuICBcIj09XCI6IEpzLFxuICBcIiE9XCI6IFFzLFxuICBcIj5cIjogdGwsXG4gIFwiPFwiOiBlbCxcbiAgXCI+PVwiOiBubCxcbiAgXCI8PVwiOiBybCxcbiAgYXJyYXk6IGRlLFxuICBhdDogb24sXG4gIGJvb2xlYW46IGRlLFxuICBjYXNlOiB1bixcbiAgY29hbGVzY2U6IGJ0LFxuICBjb2xsYXRvcjogbHIsXG4gIGZvcm1hdDogcG4sXG4gIGltYWdlOiBmbixcbiAgaW46IHNuLFxuICBcImluZGV4LW9mXCI6IEJ0LFxuICBpbnRlcnBvbGF0ZTogU2UsXG4gIFwiaW50ZXJwb2xhdGUtaGNsXCI6IFNlLFxuICBcImludGVycG9sYXRlLWxhYlwiOiBTZSxcbiAgbGVuZ3RoOiBkbixcbiAgbGV0OiBvcixcbiAgbGl0ZXJhbDogb3QsXG4gIG1hdGNoOiBsbixcbiAgbnVtYmVyOiBkZSxcbiAgXCJudW1iZXItZm9ybWF0XCI6IGNuLFxuICBvYmplY3Q6IGRlLFxuICBzbGljZTogcXQsXG4gIHN0ZXA6IHNyLFxuICBzdHJpbmc6IGRlLFxuICBcInRvLWJvb2xlYW5cIjogUGUsXG4gIFwidG8tY29sb3JcIjogUGUsXG4gIFwidG8tbnVtYmVyXCI6IFBlLFxuICBcInRvLXN0cmluZ1wiOiBQZSxcbiAgdmFyOiBpcixcbiAgd2l0aGluOiBWZSxcbiAgZGlzdGFuY2U6IEdlLFxuICBcImdsb2JhbC1zdGF0ZVwiOiBfdFxufTtcbmNsYXNzIGhlIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSkge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMudHlwZSA9IHQsIHRoaXMuX2V2YWx1YXRlID0gbiwgdGhpcy5hcmdzID0gYTtcbiAgfVxuICBldmFsdWF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlKGUsIHRoaXMuYXJncyk7XG4gIH1cbiAgZWFjaENoaWxkKGUpIHtcbiAgICB0aGlzLmFyZ3MuZm9yRWFjaChlKTtcbiAgfVxuICBvdXRwdXREZWZpbmVkKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBlWzBdLCBhID0gaGUuZGVmaW5pdGlvbnNbbl07XG4gICAgaWYgKCFhKVxuICAgICAgcmV0dXJuIHQuZXJyb3IoYFVua25vd24gZXhwcmVzc2lvbiBcIiR7bn1cIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS5gLCAwKTtcbiAgICBjb25zdCBvID0gQXJyYXkuaXNBcnJheShhKSA/IGFbMF0gOiBhLnR5cGUsIGkgPSBBcnJheS5pc0FycmF5KGEpID8gW1thWzFdLCBhWzJdXV0gOiBhLm92ZXJsb2FkcywgcyA9IGkuZmlsdGVyKChbdV0pID0+ICFBcnJheS5pc0FycmF5KHUpIHx8IC8vIHZhcmFnc1xuICAgIHUubGVuZ3RoID09PSBlLmxlbmd0aCAtIDEpO1xuICAgIGxldCBsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IFt1LCBjXSBvZiBzKSB7XG4gICAgICBsID0gbmV3IGFyKHQucmVnaXN0cnksIFp0LCB0LnBhdGgsIG51bGwsIHQuc2NvcGUpO1xuICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgbGV0IGQgPSAhMTtcbiAgICAgIGZvciAobGV0IGYgPSAxOyBmIDwgZS5sZW5ndGg7IGYrKykge1xuICAgICAgICBjb25zdCBoID0gZVtmXSwgbSA9IEFycmF5LmlzQXJyYXkodSkgPyB1W2YgLSAxXSA6IHUudHlwZSwgeSA9IGwucGFyc2UoaCwgMSArIHAubGVuZ3RoLCBtKTtcbiAgICAgICAgaWYgKCF5KSB7XG4gICAgICAgICAgZCA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHAucHVzaCh5KTtcbiAgICAgIH1cbiAgICAgIGlmICghZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh1KSAmJiB1Lmxlbmd0aCAhPT0gcC5sZW5ndGgpIHtcbiAgICAgICAgICBsLmVycm9yKGBFeHBlY3RlZCAke3UubGVuZ3RofSBhcmd1bWVudHMsIGJ1dCBmb3VuZCAke3AubGVuZ3RofSBpbnN0ZWFkLmApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgcC5sZW5ndGg7IGYrKykge1xuICAgICAgICAgIGNvbnN0IGggPSBBcnJheS5pc0FycmF5KHUpID8gdVtmXSA6IHUudHlwZSwgbSA9IHBbZl07XG4gICAgICAgICAgbC5jb25jYXQoZiArIDEpLmNoZWNrU3VidHlwZShoLCBtLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsLmVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIG5ldyBoZShuLCBvLCBjLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMubGVuZ3RoID09PSAxKVxuICAgICAgdC5lcnJvcnMucHVzaCguLi5sLmVycm9ycyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBjID0gKHMubGVuZ3RoID8gcyA6IGkpLm1hcCgoW2RdKSA9PiBJbChkKSkuam9pbihcIiB8IFwiKSwgcCA9IFtdO1xuICAgICAgZm9yIChsZXQgZCA9IDE7IGQgPCBlLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgIGNvbnN0IGYgPSB0LnBhcnNlKGVbZF0sIDEgKyBwLmxlbmd0aCk7XG4gICAgICAgIGlmICghZilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcC5wdXNoKFUoZi50eXBlKSk7XG4gICAgICB9XG4gICAgICB0LmVycm9yKGBFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSAke2N9LCBidXQgZm91bmQgKCR7cC5qb2luKFwiLCBcIil9KSBpbnN0ZWFkLmApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgcmVnaXN0ZXIoZSwgdCkge1xuICAgIGhlLmRlZmluaXRpb25zID0gdDtcbiAgICBmb3IgKGNvbnN0IG4gaW4gdClcbiAgICAgIGVbbl0gPSBoZTtcbiAgfVxufVxuZnVuY3Rpb24gUW4ociwgW2UsIHQsIG4sIGFdKSB7XG4gIGUgPSBlLmV2YWx1YXRlKHIpLCB0ID0gdC5ldmFsdWF0ZShyKSwgbiA9IG4uZXZhbHVhdGUocik7XG4gIGNvbnN0IG8gPSBhID8gYS5ldmFsdWF0ZShyKSA6IDEsIGkgPSBVYShlLCB0LCBuLCBvKTtcbiAgaWYgKGkpXG4gICAgdGhyb3cgbmV3IEQoaSk7XG4gIHJldHVybiBuZXcgJChlIC8gMjU1LCB0IC8gMjU1LCBuIC8gMjU1LCBvLCAhMSk7XG59XG5mdW5jdGlvbiBlYShyLCBlKSB7XG4gIHJldHVybiByIGluIGU7XG59XG5mdW5jdGlvbiBDcihyLCBlKSB7XG4gIGNvbnN0IHQgPSBlW3JdO1xuICByZXR1cm4gdHlwZW9mIHQgPiBcInVcIiA/IG51bGwgOiB0O1xufVxuZnVuY3Rpb24gX2wociwgZSwgdCwgbikge1xuICBmb3IgKDsgdCA8PSBuOyApIHtcbiAgICBjb25zdCBhID0gdCArIG4gPj4gMTtcbiAgICBpZiAoZVthXSA9PT0gcilcbiAgICAgIHJldHVybiAhMDtcbiAgICBlW2FdID4gciA/IG4gPSBhIC0gMSA6IHQgPSBhICsgMTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBOZShyKSB7XG4gIHJldHVybiB7IHR5cGU6IHIgfTtcbn1cbmhlLnJlZ2lzdGVyKGJuLCB7XG4gIGVycm9yOiBbXG4gICAga3MsXG4gICAgW1BdLFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIHRocm93IG5ldyBEKGUuZXZhbHVhdGUocikpO1xuICAgIH1cbiAgXSxcbiAgdHlwZW9mOiBbXG4gICAgUCxcbiAgICBbSV0sXG4gICAgKHIsIFtlXSkgPT4gVShxKGUuZXZhbHVhdGUocikpKVxuICBdLFxuICBcInRvLXJnYmFcIjogW1xuICAgIHRlKFMsIDQpLFxuICAgIFt3ZV0sXG4gICAgKHIsIFtlXSkgPT4ge1xuICAgICAgY29uc3QgW3QsIG4sIGEsIG9dID0gZS5ldmFsdWF0ZShyKS5yZ2I7XG4gICAgICByZXR1cm4gW3QgKiAyNTUsIG4gKiAyNTUsIGEgKiAyNTUsIG9dO1xuICAgIH1cbiAgXSxcbiAgcmdiOiBbXG4gICAgd2UsXG4gICAgW1MsIFMsIFNdLFxuICAgIFFuXG4gIF0sXG4gIHJnYmE6IFtcbiAgICB3ZSxcbiAgICBbUywgUywgUywgU10sXG4gICAgUW5cbiAgXSxcbiAgaGFzOiB7XG4gICAgdHlwZTogTSxcbiAgICBvdmVybG9hZHM6IFtcbiAgICAgIFtcbiAgICAgICAgW1BdLFxuICAgICAgICAociwgW2VdKSA9PiBlYShlLmV2YWx1YXRlKHIpLCByLnByb3BlcnRpZXMoKSlcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFtQLCBCZV0sXG4gICAgICAgIChyLCBbZSwgdF0pID0+IGVhKGUuZXZhbHVhdGUociksIHQuZXZhbHVhdGUocikpXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBnZXQ6IHtcbiAgICB0eXBlOiBJLFxuICAgIG92ZXJsb2FkczogW1xuICAgICAgW1xuICAgICAgICBbUF0sXG4gICAgICAgIChyLCBbZV0pID0+IENyKGUuZXZhbHVhdGUociksIHIucHJvcGVydGllcygpKVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgW1AsIEJlXSxcbiAgICAgICAgKHIsIFtlLCB0XSkgPT4gQ3IoZS5ldmFsdWF0ZShyKSwgdC5ldmFsdWF0ZShyKSlcbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIFwiZmVhdHVyZS1zdGF0ZVwiOiBbXG4gICAgSSxcbiAgICBbUF0sXG4gICAgKHIsIFtlXSkgPT4gQ3IoZS5ldmFsdWF0ZShyKSwgci5mZWF0dXJlU3RhdGUgfHwge30pXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICBCZSxcbiAgICBbXSxcbiAgICAocikgPT4gci5wcm9wZXJ0aWVzKClcbiAgXSxcbiAgXCJnZW9tZXRyeS10eXBlXCI6IFtcbiAgICBQLFxuICAgIFtdLFxuICAgIChyKSA9PiByLmdlb21ldHJ5VHlwZSgpXG4gIF0sXG4gIGlkOiBbXG4gICAgSSxcbiAgICBbXSxcbiAgICAocikgPT4gci5pZCgpXG4gIF0sXG4gIHpvb206IFtcbiAgICBTLFxuICAgIFtdLFxuICAgIChyKSA9PiByLmdsb2JhbHMuem9vbVxuICBdLFxuICBcImhlYXRtYXAtZGVuc2l0eVwiOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAocikgPT4gci5nbG9iYWxzLmhlYXRtYXBEZW5zaXR5IHx8IDBcbiAgXSxcbiAgZWxldmF0aW9uOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAocikgPT4gci5nbG9iYWxzLmVsZXZhdGlvbiB8fCAwXG4gIF0sXG4gIFwibGluZS1wcm9ncmVzc1wiOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAocikgPT4gci5nbG9iYWxzLmxpbmVQcm9ncmVzcyB8fCAwXG4gIF0sXG4gIGFjY3VtdWxhdGVkOiBbXG4gICAgSSxcbiAgICBbXSxcbiAgICAocikgPT4gci5nbG9iYWxzLmFjY3VtdWxhdGVkID09PSB2b2lkIDAgPyBudWxsIDogci5nbG9iYWxzLmFjY3VtdWxhdGVkXG4gIF0sXG4gIFwiK1wiOiBbXG4gICAgUyxcbiAgICBOZShTKSxcbiAgICAociwgZSkgPT4ge1xuICAgICAgbGV0IHQgPSAwO1xuICAgICAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgICAgIHQgKz0gbi5ldmFsdWF0ZShyKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgXSxcbiAgXCIqXCI6IFtcbiAgICBTLFxuICAgIE5lKFMpLFxuICAgIChyLCBlKSA9PiB7XG4gICAgICBsZXQgdCA9IDE7XG4gICAgICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICAgICAgdCAqPSBuLmV2YWx1YXRlKHIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICBdLFxuICBcIi1cIjoge1xuICAgIHR5cGU6IFMsXG4gICAgb3ZlcmxvYWRzOiBbXG4gICAgICBbXG4gICAgICAgIFtTLCBTXSxcbiAgICAgICAgKHIsIFtlLCB0XSkgPT4gZS5ldmFsdWF0ZShyKSAtIHQuZXZhbHVhdGUocilcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFtTXSxcbiAgICAgICAgKHIsIFtlXSkgPT4gLWUuZXZhbHVhdGUocilcbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIFwiL1wiOiBbXG4gICAgUyxcbiAgICBbUywgU10sXG4gICAgKHIsIFtlLCB0XSkgPT4gZS5ldmFsdWF0ZShyKSAvIHQuZXZhbHVhdGUocilcbiAgXSxcbiAgXCIlXCI6IFtcbiAgICBTLFxuICAgIFtTLCBTXSxcbiAgICAociwgW2UsIHRdKSA9PiBlLmV2YWx1YXRlKHIpICUgdC5ldmFsdWF0ZShyKVxuICBdLFxuICBsbjI6IFtcbiAgICBTLFxuICAgIFtdLFxuICAgICgpID0+IE1hdGguTE4yXG4gIF0sXG4gIHBpOiBbXG4gICAgUyxcbiAgICBbXSxcbiAgICAoKSA9PiBNYXRoLlBJXG4gIF0sXG4gIGU6IFtcbiAgICBTLFxuICAgIFtdLFxuICAgICgpID0+IE1hdGguRVxuICBdLFxuICBcIl5cIjogW1xuICAgIFMsXG4gICAgW1MsIFNdLFxuICAgIChyLCBbZSwgdF0pID0+IE1hdGgucG93KGUuZXZhbHVhdGUociksIHQuZXZhbHVhdGUocikpXG4gIF0sXG4gIHNxcnQ6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLnNxcnQoZS5ldmFsdWF0ZShyKSlcbiAgXSxcbiAgbG9nMTA6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmxvZyhlLmV2YWx1YXRlKHIpKSAvIE1hdGguTE4xMFxuICBdLFxuICBsbjogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGgubG9nKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIGxvZzI6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmxvZyhlLmV2YWx1YXRlKHIpKSAvIE1hdGguTE4yXG4gIF0sXG4gIHNpbjogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGguc2luKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIGNvczogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGguY29zKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIHRhbjogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGgudGFuKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIGFzaW46IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmFzaW4oZS5ldmFsdWF0ZShyKSlcbiAgXSxcbiAgYWNvczogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IE1hdGguYWNvcyhlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBhdGFuOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5hdGFuKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIG1pbjogW1xuICAgIFMsXG4gICAgTmUoUyksXG4gICAgKHIsIGUpID0+IE1hdGgubWluKC4uLmUubWFwKCh0KSA9PiB0LmV2YWx1YXRlKHIpKSlcbiAgXSxcbiAgbWF4OiBbXG4gICAgUyxcbiAgICBOZShTKSxcbiAgICAociwgZSkgPT4gTWF0aC5tYXgoLi4uZS5tYXAoKHQpID0+IHQuZXZhbHVhdGUocikpKVxuICBdLFxuICBhYnM6IFtcbiAgICBTLFxuICAgIFtTXSxcbiAgICAociwgW2VdKSA9PiBNYXRoLmFicyhlLmV2YWx1YXRlKHIpKVxuICBdLFxuICByb3VuZDogW1xuICAgIFMsXG4gICAgW1NdLFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSBlLmV2YWx1YXRlKHIpO1xuICAgICAgcmV0dXJuIHQgPCAwID8gLU1hdGgucm91bmQoLXQpIDogTWF0aC5yb3VuZCh0KTtcbiAgICB9XG4gIF0sXG4gIGZsb29yOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5mbG9vcihlLmV2YWx1YXRlKHIpKVxuICBdLFxuICBjZWlsOiBbXG4gICAgUyxcbiAgICBbU10sXG4gICAgKHIsIFtlXSkgPT4gTWF0aC5jZWlsKGUuZXZhbHVhdGUocikpXG4gIF0sXG4gIFwiZmlsdGVyLT09XCI6IFtcbiAgICBNLFxuICAgIFtQLCBJXSxcbiAgICAociwgW2UsIHRdKSA9PiByLnByb3BlcnRpZXMoKVtlLnZhbHVlXSA9PT0gdC52YWx1ZVxuICBdLFxuICBcImZpbHRlci1pZC09PVwiOiBbXG4gICAgTSxcbiAgICBbSV0sXG4gICAgKHIsIFtlXSkgPT4gci5pZCgpID09PSBlLnZhbHVlXG4gIF0sXG4gIFwiZmlsdGVyLXR5cGUtPT1cIjogW1xuICAgIE0sXG4gICAgW1BdLFxuICAgIChyLCBbZV0pID0+IHIuZ2VvbWV0cnlUeXBlKCkgPT09IGUudmFsdWVcbiAgXSxcbiAgXCJmaWx0ZXItPFwiOiBbXG4gICAgTSxcbiAgICBbUCwgSV0sXG4gICAgKHIsIFtlLCB0XSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHIucHJvcGVydGllcygpW2UudmFsdWVdLCBhID0gdC52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgYSAmJiBuIDwgYTtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLWlkLTxcIjogW1xuICAgIE0sXG4gICAgW0ldLFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSByLmlkKCksIG4gPSBlLnZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IHR5cGVvZiBuICYmIHQgPCBuO1xuICAgIH1cbiAgXSxcbiAgXCJmaWx0ZXItPlwiOiBbXG4gICAgTSxcbiAgICBbUCwgSV0sXG4gICAgKHIsIFtlLCB0XSkgPT4ge1xuICAgICAgY29uc3QgbiA9IHIucHJvcGVydGllcygpW2UudmFsdWVdLCBhID0gdC52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgYSAmJiBuID4gYTtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLWlkLT5cIjogW1xuICAgIE0sXG4gICAgW0ldLFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSByLmlkKCksIG4gPSBlLnZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IHR5cGVvZiBuICYmIHQgPiBuO1xuICAgIH1cbiAgXSxcbiAgXCJmaWx0ZXItPD1cIjogW1xuICAgIE0sXG4gICAgW1AsIEldLFxuICAgIChyLCBbZSwgdF0pID0+IHtcbiAgICAgIGNvbnN0IG4gPSByLnByb3BlcnRpZXMoKVtlLnZhbHVlXSwgYSA9IHQudmFsdWU7XG4gICAgICByZXR1cm4gdHlwZW9mIG4gPT0gdHlwZW9mIGEgJiYgbiA8PSBhO1xuICAgIH1cbiAgXSxcbiAgXCJmaWx0ZXItaWQtPD1cIjogW1xuICAgIE0sXG4gICAgW0ldLFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSByLmlkKCksIG4gPSBlLnZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGVvZiB0ID09IHR5cGVvZiBuICYmIHQgPD0gbjtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLT49XCI6IFtcbiAgICBNLFxuICAgIFtQLCBJXSxcbiAgICAociwgW2UsIHRdKSA9PiB7XG4gICAgICBjb25zdCBuID0gci5wcm9wZXJ0aWVzKClbZS52YWx1ZV0sIGEgPSB0LnZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBhICYmIG4gPj0gYTtcbiAgICB9XG4gIF0sXG4gIFwiZmlsdGVyLWlkLT49XCI6IFtcbiAgICBNLFxuICAgIFtJXSxcbiAgICAociwgW2VdKSA9PiB7XG4gICAgICBjb25zdCB0ID0gci5pZCgpLCBuID0gZS52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSB0eXBlb2YgbiAmJiB0ID49IG47XG4gICAgfVxuICBdLFxuICBcImZpbHRlci1oYXNcIjogW1xuICAgIE0sXG4gICAgW0ldLFxuICAgIChyLCBbZV0pID0+IGUudmFsdWUgaW4gci5wcm9wZXJ0aWVzKClcbiAgXSxcbiAgXCJmaWx0ZXItaGFzLWlkXCI6IFtcbiAgICBNLFxuICAgIFtdLFxuICAgIChyKSA9PiByLmlkKCkgIT09IG51bGwgJiYgci5pZCgpICE9PSB2b2lkIDBcbiAgXSxcbiAgXCJmaWx0ZXItdHlwZS1pblwiOiBbXG4gICAgTSxcbiAgICBbdGUoUCldLFxuICAgIChyLCBbZV0pID0+IGUudmFsdWUuaW5kZXhPZihyLmdlb21ldHJ5VHlwZSgpKSA+PSAwXG4gIF0sXG4gIFwiZmlsdGVyLWlkLWluXCI6IFtcbiAgICBNLFxuICAgIFt0ZShJKV0sXG4gICAgKHIsIFtlXSkgPT4gZS52YWx1ZS5pbmRleE9mKHIuaWQoKSkgPj0gMFxuICBdLFxuICBcImZpbHRlci1pbi1zbWFsbFwiOiBbXG4gICAgTSxcbiAgICBbUCwgdGUoSSldLFxuICAgIC8vIGFzc3VtZXMgdiBpcyBhbiBhcnJheSBsaXRlcmFsXG4gICAgKHIsIFtlLCB0XSkgPT4gdC52YWx1ZS5pbmRleE9mKHIucHJvcGVydGllcygpW2UudmFsdWVdKSA+PSAwXG4gIF0sXG4gIFwiZmlsdGVyLWluLWxhcmdlXCI6IFtcbiAgICBNLFxuICAgIFtQLCB0ZShJKV0sXG4gICAgLy8gYXNzdW1lcyB2IGlzIGEgYXJyYXkgbGl0ZXJhbCB3aXRoIHZhbHVlcyBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBvZiBhIHNpbmdsZSB0eXBlXG4gICAgKHIsIFtlLCB0XSkgPT4gX2woci5wcm9wZXJ0aWVzKClbZS52YWx1ZV0sIHQudmFsdWUsIDAsIHQudmFsdWUubGVuZ3RoIC0gMSlcbiAgXSxcbiAgYWxsOiB7XG4gICAgdHlwZTogTSxcbiAgICBvdmVybG9hZHM6IFtcbiAgICAgIFtcbiAgICAgICAgW00sIE1dLFxuICAgICAgICAociwgW2UsIHRdKSA9PiBlLmV2YWx1YXRlKHIpICYmIHQuZXZhbHVhdGUocilcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIE5lKE0pLFxuICAgICAgICAociwgZSkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBlKVxuICAgICAgICAgICAgaWYgKCF0LmV2YWx1YXRlKHIpKVxuICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgXVxuICB9LFxuICBhbnk6IHtcbiAgICB0eXBlOiBNLFxuICAgIG92ZXJsb2FkczogW1xuICAgICAgW1xuICAgICAgICBbTSwgTV0sXG4gICAgICAgIChyLCBbZSwgdF0pID0+IGUuZXZhbHVhdGUocikgfHwgdC5ldmFsdWF0ZShyKVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgTmUoTSksXG4gICAgICAgIChyLCBlKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCB0IG9mIGUpXG4gICAgICAgICAgICBpZiAodC5ldmFsdWF0ZShyKSlcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIF1cbiAgfSxcbiAgXCIhXCI6IFtcbiAgICBNLFxuICAgIFtNXSxcbiAgICAociwgW2VdKSA9PiAhZS5ldmFsdWF0ZShyKVxuICBdLFxuICBcImlzLXN1cHBvcnRlZC1zY3JpcHRcIjogW1xuICAgIE0sXG4gICAgW1BdLFxuICAgIC8vIEF0IHBhcnNlIHRpbWUgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZSwgc28gd2UgbmVlZCB0byBleGNsdWRlIHRoaXMgZXhwcmVzc2lvbiB3aXRoIGlzR2xvYmFsUHJvcGVydHlDb25zdGFudFxuICAgIChyLCBbZV0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSByLmdsb2JhbHMgJiYgci5nbG9iYWxzLmlzU3VwcG9ydGVkU2NyaXB0O1xuICAgICAgcmV0dXJuIHQgPyB0KGUuZXZhbHVhdGUocikpIDogITA7XG4gICAgfVxuICBdLFxuICB1cGNhc2U6IFtcbiAgICBQLFxuICAgIFtQXSxcbiAgICAociwgW2VdKSA9PiBlLmV2YWx1YXRlKHIpLnRvVXBwZXJDYXNlKClcbiAgXSxcbiAgZG93bmNhc2U6IFtcbiAgICBQLFxuICAgIFtQXSxcbiAgICAociwgW2VdKSA9PiBlLmV2YWx1YXRlKHIpLnRvTG93ZXJDYXNlKClcbiAgXSxcbiAgY29uY2F0OiBbXG4gICAgUCxcbiAgICBOZShJKSxcbiAgICAociwgZSkgPT4gZS5tYXAoKHQpID0+IGh0KHQuZXZhbHVhdGUocikpKS5qb2luKFwiXCIpXG4gIF0sXG4gIFwicmVzb2x2ZWQtbG9jYWxlXCI6IFtcbiAgICBQLFxuICAgIFtRdF0sXG4gICAgKHIsIFtlXSkgPT4gZS5ldmFsdWF0ZShyKS5yZXNvbHZlZExvY2FsZSgpXG4gIF1cbn0pO1xuZnVuY3Rpb24gSWwocikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShyKSA/IGAoJHtyLm1hcChVKS5qb2luKFwiLCBcIil9KWAgOiBgKCR7VShyLnR5cGUpfS4uLilgO1xufVxuZnVuY3Rpb24gWnQocikge1xuICBpZiAociBpbnN0YW5jZW9mIGlyKVxuICAgIHJldHVybiBadChyLmJvdW5kRXhwcmVzc2lvbik7XG4gIGlmIChyIGluc3RhbmNlb2YgaGUgJiYgci5uYW1lID09PSBcImVycm9yXCIpXG4gICAgcmV0dXJuICExO1xuICBpZiAociBpbnN0YW5jZW9mIGxyKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHIgaW5zdGFuY2VvZiBWZSlcbiAgICByZXR1cm4gITE7XG4gIGlmIChyIGluc3RhbmNlb2YgR2UpXG4gICAgcmV0dXJuICExO1xuICBpZiAociBpbnN0YW5jZW9mIF90KVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgZSA9IHIgaW5zdGFuY2VvZiBQZSB8fCByIGluc3RhbmNlb2YgZGU7XG4gIGxldCB0ID0gITA7XG4gIHJldHVybiByLmVhY2hDaGlsZCgobikgPT4ge1xuICAgIGUgPyB0ID0gdCAmJiBadChuKSA6IHQgPSB0ICYmIG4gaW5zdGFuY2VvZiBvdDtcbiAgfSksIHQgPyBjcihyKSAmJiBwcihyLCBbXCJ6b29tXCIsIFwiaGVhdG1hcC1kZW5zaXR5XCIsIFwiZWxldmF0aW9uXCIsIFwibGluZS1wcm9ncmVzc1wiLCBcImFjY3VtdWxhdGVkXCIsIFwiaXMtc3VwcG9ydGVkLXNjcmlwdFwiXSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGNyKHIpIHtcbiAgaWYgKHIgaW5zdGFuY2VvZiBoZSkge1xuICAgIGlmIChyLm5hbWUgPT09IFwiZ2V0XCIgJiYgci5hcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoci5uYW1lID09PSBcImZlYXR1cmUtc3RhdGVcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoci5uYW1lID09PSBcImhhc1wiICYmIHIuYXJncy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHIubmFtZSA9PT0gXCJwcm9wZXJ0aWVzXCIgfHwgci5uYW1lID09PSBcImdlb21ldHJ5LXR5cGVcIiB8fCByLm5hbWUgPT09IFwiaWRcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoL15maWx0ZXItLy50ZXN0KHIubmFtZSkpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgaWYgKHIgaW5zdGFuY2VvZiBWZSB8fCByIGluc3RhbmNlb2YgR2UpXG4gICAgcmV0dXJuICExO1xuICBsZXQgZSA9ICEwO1xuICByZXR1cm4gci5lYWNoQ2hpbGQoKHQpID0+IHtcbiAgICBlICYmICFjcih0KSAmJiAoZSA9ICExKTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBTdChyKSB7XG4gIGlmIChyIGluc3RhbmNlb2YgaGUgJiYgci5uYW1lID09PSBcImZlYXR1cmUtc3RhdGVcIilcbiAgICByZXR1cm4gITE7XG4gIGxldCBlID0gITA7XG4gIHJldHVybiByLmVhY2hDaGlsZCgodCkgPT4ge1xuICAgIGUgJiYgIVN0KHQpICYmIChlID0gITEpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIHByKHIsIGUpIHtcbiAgaWYgKHIgaW5zdGFuY2VvZiBoZSAmJiBlLmluZGV4T2Yoci5uYW1lKSA+PSAwKVxuICAgIHJldHVybiAhMTtcbiAgbGV0IHQgPSAhMDtcbiAgcmV0dXJuIHIuZWFjaENoaWxkKChuKSA9PiB7XG4gICAgdCAmJiAhcHIobiwgZSkgJiYgKHQgPSAhMSk7XG4gIH0pLCB0O1xufVxuZnVuY3Rpb24gcXIocikge1xuICByZXR1cm4geyByZXN1bHQ6IFwic3VjY2Vzc1wiLCB2YWx1ZTogciB9O1xufVxuZnVuY3Rpb24gZXQocikge1xuICByZXR1cm4geyByZXN1bHQ6IFwiZXJyb3JcIiwgdmFsdWU6IHIgfTtcbn1cbmZ1bmN0aW9uIFh0KHIpIHtcbiAgcmV0dXJuIHJbXCJwcm9wZXJ0eS10eXBlXCJdID09PSBcImRhdGEtZHJpdmVuXCIgfHwgcltcInByb3BlcnR5LXR5cGVcIl0gPT09IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIjtcbn1cbmZ1bmN0aW9uIFlhKHIpIHtcbiAgcmV0dXJuICEhci5leHByZXNzaW9uICYmIHIuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoXCJ6b29tXCIpID4gLTE7XG59XG5mdW5jdGlvbiBXYShyKSB7XG4gIHJldHVybiAhIXIuZXhwcmVzc2lvbiAmJiByLmV4cHJlc3Npb24uaW50ZXJwb2xhdGVkO1xufVxuZnVuY3Rpb24gUihyKSB7XG4gIHJldHVybiByIGluc3RhbmNlb2YgTnVtYmVyID8gXCJudW1iZXJcIiA6IHIgaW5zdGFuY2VvZiBTdHJpbmcgPyBcInN0cmluZ1wiIDogciBpbnN0YW5jZW9mIEJvb2xlYW4gPyBcImJvb2xlYW5cIiA6IEFycmF5LmlzQXJyYXkocikgPyBcImFycmF5XCIgOiByID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygcjtcbn1cbmZ1bmN0aW9uIHduKHIpIHtcbiAgcmV0dXJuIHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgciAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyKSAmJiBxKHIpID09PSBCZTtcbn1cbmNsYXNzIE1sIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGUsIHRoaXMuX3dhcm5pbmdIaXN0b3J5ID0ge30sIHRoaXMuX2V2YWx1YXRvciA9IG5ldyBEYSgpLCB0aGlzLl9kZWZhdWx0VmFsdWUgPSB0ID8gemwodCkgOiBudWxsLCB0aGlzLl9lbnVtVmFsdWVzID0gdCAmJiB0LnR5cGUgPT09IFwiZW51bVwiID8gdC52YWx1ZXMgOiBudWxsO1xuICB9XG4gIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZSwgdCwgbiwgYSwgbywgaSkge1xuICAgIHJldHVybiB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGUsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gdCwgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IG4sIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBhLCB0aGlzLl9ldmFsdWF0b3IuYXZhaWxhYmxlSW1hZ2VzID0gbyB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGksIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xuICB9XG4gIGV2YWx1YXRlKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGUsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gdCB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gbiB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gYSwgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IG8gfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBpIHx8IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcbiAgICAgIGlmIChzID09IG51bGwgfHwgdHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiBzICE9PSBzKVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKHRoaXMuX2VudW1WYWx1ZXMgJiYgIShzIGluIHRoaXMuX2VudW1WYWx1ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRChgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICR7T2JqZWN0LmtleXModGhpcy5fZW51bVZhbHVlcykubWFwKChsKSA9PiBKU09OLnN0cmluZ2lmeShsKSkuam9pbihcIiwgXCIpfSwgYnV0IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkocyl9IGluc3RlYWQuYCk7XG4gICAgICByZXR1cm4gcztcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2FybmluZ0hpc3Rvcnlbcy5tZXNzYWdlXSB8fCAodGhpcy5fd2FybmluZ0hpc3Rvcnlbcy5tZXNzYWdlXSA9ICEwLCB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIGNvbnNvbGUud2FybihzLm1lc3NhZ2UpKSwgdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gSmEocikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShyKSAmJiByLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHJbMF0gPT0gXCJzdHJpbmdcIiAmJiByWzBdIGluIGJuO1xufVxuZnVuY3Rpb24gUWEociwgZSkge1xuICBjb25zdCB0ID0gbmV3IGFyKGJuLCBadCwgW10sIGUgPyBSbChlKSA6IHZvaWQgMCksIG4gPSB0LnBhcnNlKHIsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGUgJiYgZS50eXBlID09PSBcInN0cmluZ1wiID8geyB0eXBlQW5ub3RhdGlvbjogXCJjb2VyY2VcIiB9IDogdm9pZCAwKTtcbiAgcmV0dXJuIG4gPyBxcihuZXcgTWwobiwgZSkpIDogZXQodC5lcnJvcnMpO1xufVxuY2xhc3MgdGEge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdGhpcy5raW5kID0gZSwgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gdCwgdGhpcy5pc1N0YXRlRGVwZW5kZW50ID0gZSAhPT0gXCJjb25zdGFudFwiICYmICFTdCh0LmV4cHJlc3Npb24pLCB0aGlzLmdsb2JhbFN0YXRlUmVmcyA9IFNuKHQuZXhwcmVzc2lvbik7XG4gIH1cbiAgZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGUsIHQsIG4sIGEsIG8sIGkpO1xuICB9XG4gIGV2YWx1YXRlKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKGUsIHQsIG4sIGEsIG8sIGkpO1xuICB9XG59XG5jbGFzcyByYSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIGEpIHtcbiAgICB0aGlzLmtpbmQgPSBlLCB0aGlzLnpvb21TdG9wcyA9IG4sIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IHQsIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGUgIT09IFwiY2FtZXJhXCIgJiYgIVN0KHQuZXhwcmVzc2lvbiksIHRoaXMuZ2xvYmFsU3RhdGVSZWZzID0gU24odC5leHByZXNzaW9uKSwgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IGE7XG4gIH1cbiAgZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhlLCB0LCBuLCBhLCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGUsIHQsIG4sIGEsIG8sIGkpO1xuICB9XG4gIGV2YWx1YXRlKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKGUsIHQsIG4sIGEsIG8sIGkpO1xuICB9XG4gIGludGVycG9sYXRpb25GYWN0b3IoZSwgdCwgbikge1xuICAgIHJldHVybiB0aGlzLmludGVycG9sYXRpb25UeXBlID8gU2UuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb25UeXBlLCBlLCB0LCBuKSA6IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIFBsKHIsIGUpIHtcbiAgY29uc3QgdCA9IFFhKHIsIGUpO1xuICBpZiAodC5yZXN1bHQgPT09IFwiZXJyb3JcIilcbiAgICByZXR1cm4gdDtcbiAgY29uc3QgbiA9IHQudmFsdWUuZXhwcmVzc2lvbiwgYSA9IGNyKG4pO1xuICBpZiAoIWEgJiYgIVh0KGUpKVxuICAgIHJldHVybiBldChbbmV3IGJlKFwiXCIsIFwiZGF0YSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkXCIpXSk7XG4gIGNvbnN0IG8gPSBwcihuLCBbXCJ6b29tXCJdKTtcbiAgaWYgKCFvICYmICFZYShlKSlcbiAgICByZXR1cm4gZXQoW25ldyBiZShcIlwiLCBcInpvb20gZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZFwiKV0pO1xuICBjb25zdCBpID0gT3Qobik7XG4gIGlmICghaSAmJiAhbylcbiAgICByZXR1cm4gZXQoW25ldyBiZShcIlwiLCAnXCJ6b29tXCIgZXhwcmVzc2lvbiBtYXkgb25seSBiZSB1c2VkIGFzIGlucHV0IHRvIGEgdG9wLWxldmVsIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9uLicpXSk7XG4gIGlmIChpIGluc3RhbmNlb2YgYmUpXG4gICAgcmV0dXJuIGV0KFtpXSk7XG4gIGlmIChpIGluc3RhbmNlb2YgU2UgJiYgIVdhKGUpKVxuICAgIHJldHVybiBldChbbmV3IGJlKFwiXCIsICdcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgY2Fubm90IGJlIHVzZWQgd2l0aCB0aGlzIHByb3BlcnR5JyldKTtcbiAgaWYgKCFpKVxuICAgIHJldHVybiBxcihhID8gbmV3IHRhKFwiY29uc3RhbnRcIiwgdC52YWx1ZSkgOiBuZXcgdGEoXCJzb3VyY2VcIiwgdC52YWx1ZSkpO1xuICBjb25zdCBzID0gaSBpbnN0YW5jZW9mIFNlID8gaS5pbnRlcnBvbGF0aW9uIDogdm9pZCAwO1xuICByZXR1cm4gcXIoYSA/IG5ldyByYShcImNhbWVyYVwiLCB0LnZhbHVlLCBpLmxhYmVscywgcykgOiBuZXcgcmEoXCJjb21wb3NpdGVcIiwgdC52YWx1ZSwgaS5sYWJlbHMsIHMpKTtcbn1cbmZ1bmN0aW9uIE90KHIpIHtcbiAgbGV0IGUgPSBudWxsO1xuICBpZiAociBpbnN0YW5jZW9mIG9yKVxuICAgIGUgPSBPdChyLnJlc3VsdCk7XG4gIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBidCkge1xuICAgIGZvciAoY29uc3QgdCBvZiByLmFyZ3MpXG4gICAgICBpZiAoZSA9IE90KHQpLCBlKVxuICAgICAgICBicmVhaztcbiAgfSBlbHNlIChyIGluc3RhbmNlb2Ygc3IgfHwgciBpbnN0YW5jZW9mIFNlKSAmJiByLmlucHV0IGluc3RhbmNlb2YgaGUgJiYgci5pbnB1dC5uYW1lID09PSBcInpvb21cIiAmJiAoZSA9IHIpO1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIGJlIHx8IHIuZWFjaENoaWxkKCh0KSA9PiB7XG4gICAgY29uc3QgbiA9IE90KHQpO1xuICAgIG4gaW5zdGFuY2VvZiBiZSA/IGUgPSBuIDogIWUgJiYgbiA/IGUgPSBuZXcgYmUoXCJcIiwgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKSA6IGUgJiYgbiAmJiBlICE9PSBuICYmIChlID0gbmV3IGJlKFwiXCIsICdPbmx5IG9uZSB6b29tLWJhc2VkIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBzdWJleHByZXNzaW9uIG1heSBiZSB1c2VkIGluIGFuIGV4cHJlc3Npb24uJykpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFNuKHIsIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIHJldHVybiByIGluc3RhbmNlb2YgX3QgJiYgZS5hZGQoci5rZXkpLCByLmVhY2hDaGlsZCgodCkgPT4ge1xuICAgIFNuKHQsIGUpO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFJsKHIpIHtcbiAgY29uc3QgZSA9IHtcbiAgICBjb2xvcjogd2UsXG4gICAgc3RyaW5nOiBQLFxuICAgIG51bWJlcjogUyxcbiAgICBlbnVtOiBQLFxuICAgIGJvb2xlYW46IE0sXG4gICAgZm9ybWF0dGVkOiBlcixcbiAgICBwYWRkaW5nOiB0cixcbiAgICBudW1iZXJBcnJheTogcnIsXG4gICAgY29sb3JBcnJheTogeXQsXG4gICAgcHJvamVjdGlvbkRlZmluaXRpb246IEp0LFxuICAgIHJlc29sdmVkSW1hZ2U6IEF0LFxuICAgIHZhcmlhYmxlQW5jaG9yT2Zmc2V0Q29sbGVjdGlvbjogbnJcbiAgfTtcbiAgcmV0dXJuIHIudHlwZSA9PT0gXCJhcnJheVwiID8gdGUoZVtyLnZhbHVlXSB8fCBJLCByLmxlbmd0aCkgOiBlW3IudHlwZV07XG59XG5mdW5jdGlvbiB6bChyKSB7XG4gIGlmIChyLnR5cGUgPT09IFwiY29sb3JcIiAmJiB3bihyLmRlZmF1bHQpKVxuICAgIHJldHVybiBuZXcgJCgwLCAwLCAwLCAwKTtcbiAgc3dpdGNoIChyLnR5cGUpIHtcbiAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgIHJldHVybiAkLnBhcnNlKHIuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICBjYXNlIFwicGFkZGluZ1wiOlxuICAgICAgcmV0dXJuIG9lLnBhcnNlKHIuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICBjYXNlIFwibnVtYmVyQXJyYXlcIjpcbiAgICAgIHJldHVybiBpZS5wYXJzZShyLmRlZmF1bHQpIHx8IG51bGw7XG4gICAgY2FzZSBcImNvbG9yQXJyYXlcIjpcbiAgICAgIHJldHVybiBRLnBhcnNlKHIuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICBjYXNlIFwidmFyaWFibGVBbmNob3JPZmZzZXRDb2xsZWN0aW9uXCI6XG4gICAgICByZXR1cm4gbWUucGFyc2Uoci5kZWZhdWx0KSB8fCBudWxsO1xuICAgIGNhc2UgXCJwcm9qZWN0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgcmV0dXJuIGZlLnBhcnNlKHIuZGVmYXVsdCkgfHwgbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHIuZGVmYXVsdCA9PT0gdm9pZCAwID8gbnVsbCA6IHIuZGVmYXVsdDtcbiAgfVxufVxuZnVuY3Rpb24gZW8ocikge1xuICBpZiAociA9PT0gITAgfHwgciA9PT0gITEpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocikgfHwgci5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICExO1xuICBzd2l0Y2ggKHJbMF0pIHtcbiAgICBjYXNlIFwiaGFzXCI6XG4gICAgICByZXR1cm4gci5sZW5ndGggPj0gMiAmJiByWzFdICE9PSBcIiRpZFwiICYmIHJbMV0gIT09IFwiJHR5cGVcIjtcbiAgICBjYXNlIFwiaW5cIjpcbiAgICAgIHJldHVybiByLmxlbmd0aCA+PSAzICYmICh0eXBlb2YgclsxXSAhPSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoclsyXSkpO1xuICAgIGNhc2UgXCIhaW5cIjpcbiAgICBjYXNlIFwiIWhhc1wiOlxuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICByZXR1cm4gITE7XG4gICAgY2FzZSBcIj09XCI6XG4gICAgY2FzZSBcIiE9XCI6XG4gICAgY2FzZSBcIj5cIjpcbiAgICBjYXNlIFwiPj1cIjpcbiAgICBjYXNlIFwiPFwiOlxuICAgIGNhc2UgXCI8PVwiOlxuICAgICAgcmV0dXJuIHIubGVuZ3RoICE9PSAzIHx8IEFycmF5LmlzQXJyYXkoclsxXSkgfHwgQXJyYXkuaXNBcnJheShyWzJdKTtcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgY2FzZSBcImFsbFwiOlxuICAgICAgZm9yIChjb25zdCBlIG9mIHIuc2xpY2UoMSkpXG4gICAgICAgIGlmICghZW8oZSkgJiYgdHlwZW9mIGUgIT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvKHIpIHtcbiAgY29uc3QgZSA9IHIua2V5LCB0ID0gci52YWx1ZTtcbiAgcmV0dXJuIHQgPyBbbmV3IGIoZSwgdCwgXCJjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjhcIildIDogW107XG59XG5mdW5jdGlvbiBCKHIpIHtcbiAgcmV0dXJuIHIgaW5zdGFuY2VvZiBOdW1iZXIgfHwgciBpbnN0YW5jZW9mIFN0cmluZyB8fCByIGluc3RhbmNlb2YgQm9vbGVhbiA/IHIudmFsdWVPZigpIDogcjtcbn1cbmZ1bmN0aW9uIFhlKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpXG4gICAgcmV0dXJuIHIubWFwKFhlKTtcbiAgaWYgKHIgaW5zdGFuY2VvZiBPYmplY3QgJiYgIShyIGluc3RhbmNlb2YgTnVtYmVyIHx8IHIgaW5zdGFuY2VvZiBTdHJpbmcgfHwgciBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIGZvciAoY29uc3QgdCBpbiByKVxuICAgICAgZVt0XSA9IFhlKHJbdF0pO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBCKHIpO1xufVxuZnVuY3Rpb24gc2Uocikge1xuICBjb25zdCBlID0gci5rZXksIHQgPSByLnZhbHVlLCBuID0gci52YWx1ZVNwZWMgfHwge30sIGEgPSByLm9iamVjdEVsZW1lbnRWYWxpZGF0b3JzIHx8IHt9LCBvID0gci5zdHlsZSwgaSA9IHIuc3R5bGVTcGVjLCBzID0gci52YWxpZGF0ZVNwZWM7XG4gIGxldCBsID0gW107XG4gIGNvbnN0IHUgPSBSKHQpO1xuICBpZiAodSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gW25ldyBiKGUsIHQsIGBvYmplY3QgZXhwZWN0ZWQsICR7dX0gZm91bmRgKV07XG4gIGZvciAoY29uc3QgYyBpbiB0KSB7XG4gICAgY29uc3QgcCA9IGMuc3BsaXQoXCIuXCIpWzBdLCBkID0gZHQobiwgcCkgfHwgbltcIipcIl07XG4gICAgbGV0IGY7XG4gICAgaWYgKGR0KGEsIHApKVxuICAgICAgZiA9IGFbcF07XG4gICAgZWxzZSBpZiAoZHQobiwgcCkpXG4gICAgICBmID0gcztcbiAgICBlbHNlIGlmIChhW1wiKlwiXSlcbiAgICAgIGYgPSBhW1wiKlwiXTtcbiAgICBlbHNlIGlmIChuW1wiKlwiXSlcbiAgICAgIGYgPSBzO1xuICAgIGVsc2Uge1xuICAgICAgbC5wdXNoKG5ldyBiKGUsIHRbY10sIGB1bmtub3duIHByb3BlcnR5IFwiJHtjfVwiYCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGwgPSBsLmNvbmNhdChmKHtcbiAgICAgIGtleTogKGUgJiYgYCR7ZX0uYCkgKyBjLFxuICAgICAgdmFsdWU6IHRbY10sXG4gICAgICB2YWx1ZVNwZWM6IGQsXG4gICAgICBzdHlsZTogbyxcbiAgICAgIHN0eWxlU3BlYzogaSxcbiAgICAgIG9iamVjdDogdCxcbiAgICAgIG9iamVjdEtleTogYyxcbiAgICAgIHZhbGlkYXRlU3BlYzogc1xuICAgIH0sIHQpKTtcbiAgfVxuICBmb3IgKGNvbnN0IGMgaW4gbilcbiAgICBhW2NdIHx8IG5bY10ucmVxdWlyZWQgJiYgbltjXS5kZWZhdWx0ID09PSB2b2lkIDAgJiYgdFtjXSA9PT0gdm9pZCAwICYmIGwucHVzaChuZXcgYihlLCB0LCBgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7Y31cImApKTtcbiAgcmV0dXJuIGw7XG59XG5mdW5jdGlvbiB4bihyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci52YWx1ZVNwZWMsIG4gPSByLnZhbGlkYXRlU3BlYywgYSA9IHIuc3R5bGUsIG8gPSByLnN0eWxlU3BlYywgaSA9IHIua2V5LCBzID0gci5hcnJheUVsZW1lbnRWYWxpZGF0b3IgfHwgbjtcbiAgaWYgKFIoZSkgIT09IFwiYXJyYXlcIilcbiAgICByZXR1cm4gW25ldyBiKGksIGUsIGBhcnJheSBleHBlY3RlZCwgJHtSKGUpfSBmb3VuZGApXTtcbiAgaWYgKHQubGVuZ3RoICYmIGUubGVuZ3RoICE9PSB0Lmxlbmd0aClcbiAgICByZXR1cm4gW25ldyBiKGksIGUsIGBhcnJheSBsZW5ndGggJHt0Lmxlbmd0aH0gZXhwZWN0ZWQsIGxlbmd0aCAke2UubGVuZ3RofSBmb3VuZGApXTtcbiAgaWYgKHRbXCJtaW4tbGVuZ3RoXCJdICYmIGUubGVuZ3RoIDwgdFtcIm1pbi1sZW5ndGhcIl0pXG4gICAgcmV0dXJuIFtuZXcgYihpLCBlLCBgYXJyYXkgbGVuZ3RoIGF0IGxlYXN0ICR7dFtcIm1pbi1sZW5ndGhcIl19IGV4cGVjdGVkLCBsZW5ndGggJHtlLmxlbmd0aH0gZm91bmRgKV07XG4gIGxldCBsID0ge1xuICAgIHR5cGU6IHQudmFsdWUsXG4gICAgdmFsdWVzOiB0LnZhbHVlc1xuICB9O1xuICBvLiR2ZXJzaW9uIDwgNyAmJiAobC5mdW5jdGlvbiA9IHQuZnVuY3Rpb24pLCBSKHQudmFsdWUpID09PSBcIm9iamVjdFwiICYmIChsID0gdC52YWx1ZSk7XG4gIGxldCB1ID0gW107XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgZS5sZW5ndGg7IGMrKylcbiAgICB1ID0gdS5jb25jYXQocyh7XG4gICAgICBhcnJheTogZSxcbiAgICAgIGFycmF5SW5kZXg6IGMsXG4gICAgICB2YWx1ZTogZVtjXSxcbiAgICAgIHZhbHVlU3BlYzogbCxcbiAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogYSxcbiAgICAgIHN0eWxlU3BlYzogbyxcbiAgICAgIGtleTogYCR7aX1bJHtjfV1gXG4gICAgfSkpO1xuICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIGZyKHIpIHtcbiAgY29uc3QgZSA9IHIua2V5LCB0ID0gci52YWx1ZSwgbiA9IHIudmFsdWVTcGVjO1xuICBsZXQgYSA9IFIodCk7XG4gIHJldHVybiBhID09PSBcIm51bWJlclwiICYmIHQgIT09IHQgJiYgKGEgPSBcIk5hTlwiKSwgYSAhPT0gXCJudW1iZXJcIiA/IFtuZXcgYihlLCB0LCBgbnVtYmVyIGV4cGVjdGVkLCAke2F9IGZvdW5kYCldIDogXCJtaW5pbXVtXCIgaW4gbiAmJiB0IDwgbi5taW5pbXVtID8gW25ldyBiKGUsIHQsIGAke3R9IGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSAke24ubWluaW11bX1gKV0gOiBcIm1heGltdW1cIiBpbiBuICYmIHQgPiBuLm1heGltdW0gPyBbbmV3IGIoZSwgdCwgYCR7dH0gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlICR7bi5tYXhpbXVtfWApXSA6IFtdO1xufVxuZnVuY3Rpb24gcm8ocikge1xuICBjb25zdCBlID0gci52YWx1ZVNwZWMsIHQgPSBCKHIudmFsdWUudHlwZSk7XG4gIGxldCBuLCBhID0ge30sIG8sIGk7XG4gIGNvbnN0IHMgPSB0ICE9PSBcImNhdGVnb3JpY2FsXCIgJiYgci52YWx1ZS5wcm9wZXJ0eSA9PT0gdm9pZCAwLCBsID0gIXMsIHUgPSBSKHIudmFsdWUuc3RvcHMpID09PSBcImFycmF5XCIgJiYgUihyLnZhbHVlLnN0b3BzWzBdKSA9PT0gXCJhcnJheVwiICYmIFIoci52YWx1ZS5zdG9wc1swXVswXSkgPT09IFwib2JqZWN0XCIsIGMgPSBzZSh7XG4gICAga2V5OiByLmtleSxcbiAgICB2YWx1ZTogci52YWx1ZSxcbiAgICB2YWx1ZVNwZWM6IHIuc3R5bGVTcGVjLmZ1bmN0aW9uLFxuICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgc3R5bGVTcGVjOiByLnN0eWxlU3BlYyxcbiAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgc3RvcHM6IHAsXG4gICAgICBkZWZhdWx0OiBoXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHQgPT09IFwiaWRlbnRpdHlcIiAmJiBzICYmIGMucHVzaChuZXcgYihyLmtleSwgci52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJwcm9wZXJ0eVwiJykpLCB0ICE9PSBcImlkZW50aXR5XCIgJiYgIXIudmFsdWUuc3RvcHMgJiYgYy5wdXNoKG5ldyBiKHIua2V5LCByLnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInN0b3BzXCInKSksIHQgPT09IFwiZXhwb25lbnRpYWxcIiAmJiByLnZhbHVlU3BlYy5leHByZXNzaW9uICYmICFXYShyLnZhbHVlU3BlYykgJiYgYy5wdXNoKG5ldyBiKHIua2V5LCByLnZhbHVlLCBcImV4cG9uZW50aWFsIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkXCIpKSwgci5zdHlsZVNwZWMuJHZlcnNpb24gPj0gOCAmJiAobCAmJiAhWHQoci52YWx1ZVNwZWMpID8gYy5wdXNoKG5ldyBiKHIua2V5LCByLnZhbHVlLCBcInByb3BlcnR5IGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkXCIpKSA6IHMgJiYgIVlhKHIudmFsdWVTcGVjKSAmJiBjLnB1c2gobmV3IGIoci5rZXksIHIudmFsdWUsIFwiem9vbSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZFwiKSkpLCAodCA9PT0gXCJjYXRlZ29yaWNhbFwiIHx8IHUpICYmIHIudmFsdWUucHJvcGVydHkgPT09IHZvaWQgMCAmJiBjLnB1c2gobmV3IGIoci5rZXksIHIudmFsdWUsICdcInByb3BlcnR5XCIgcHJvcGVydHkgaXMgcmVxdWlyZWQnKSksIGM7XG4gIGZ1bmN0aW9uIHAobSkge1xuICAgIGlmICh0ID09PSBcImlkZW50aXR5XCIpXG4gICAgICByZXR1cm4gW25ldyBiKG0ua2V5LCBtLnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgXCJzdG9wc1wiIHByb3BlcnR5JyldO1xuICAgIGxldCB5ID0gW107XG4gICAgY29uc3QgdyA9IG0udmFsdWU7XG4gICAgcmV0dXJuIHkgPSB5LmNvbmNhdCh4bih7XG4gICAgICBrZXk6IG0ua2V5LFxuICAgICAgdmFsdWU6IHcsXG4gICAgICB2YWx1ZVNwZWM6IG0udmFsdWVTcGVjLFxuICAgICAgdmFsaWRhdGVTcGVjOiBtLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiBtLnN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBtLnN0eWxlU3BlYyxcbiAgICAgIGFycmF5RWxlbWVudFZhbGlkYXRvcjogZFxuICAgIH0pKSwgUih3KSA9PT0gXCJhcnJheVwiICYmIHcubGVuZ3RoID09PSAwICYmIHkucHVzaChuZXcgYihtLmtleSwgdywgXCJhcnJheSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN0b3BcIikpLCB5O1xuICB9XG4gIGZ1bmN0aW9uIGQobSkge1xuICAgIGxldCB5ID0gW107XG4gICAgY29uc3QgdyA9IG0udmFsdWUsIGcgPSBtLmtleTtcbiAgICBpZiAoUih3KSAhPT0gXCJhcnJheVwiKVxuICAgICAgcmV0dXJuIFtuZXcgYihnLCB3LCBgYXJyYXkgZXhwZWN0ZWQsICR7Uih3KX0gZm91bmRgKV07XG4gICAgaWYgKHcubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIFtuZXcgYihnLCB3LCBgYXJyYXkgbGVuZ3RoIDIgZXhwZWN0ZWQsIGxlbmd0aCAke3cubGVuZ3RofSBmb3VuZGApXTtcbiAgICBpZiAodSkge1xuICAgICAgaWYgKFIod1swXSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBbbmV3IGIoZywgdywgYG9iamVjdCBleHBlY3RlZCwgJHtSKHdbMF0pfSBmb3VuZGApXTtcbiAgICAgIGlmICh3WzBdLnpvb20gPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIFtuZXcgYihnLCB3LCBcIm9iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgem9vbVwiKV07XG4gICAgICBpZiAod1swXS52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gW25ldyBiKGcsIHcsIFwib2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB2YWx1ZVwiKV07XG4gICAgICBpZiAoaSAmJiBpID4gQih3WzBdLnpvb20pKVxuICAgICAgICByZXR1cm4gW25ldyBiKGcsIHdbMF0uem9vbSwgXCJzdG9wIHpvb20gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlclwiKV07XG4gICAgICBCKHdbMF0uem9vbSkgIT09IGkgJiYgKGkgPSBCKHdbMF0uem9vbSksIG8gPSB2b2lkIDAsIGEgPSB7fSksIHkgPSB5LmNvbmNhdChzZSh7XG4gICAgICAgIGtleTogYCR7Z31bMF1gLFxuICAgICAgICB2YWx1ZTogd1swXSxcbiAgICAgICAgdmFsdWVTcGVjOiB7IHpvb206IHt9IH0sXG4gICAgICAgIHZhbGlkYXRlU3BlYzogbS52YWxpZGF0ZVNwZWMsXG4gICAgICAgIHN0eWxlOiBtLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG0uc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogeyB6b29tOiBmciwgdmFsdWU6IGYgfVxuICAgICAgfSkpO1xuICAgIH0gZWxzZVxuICAgICAgeSA9IHkuY29uY2F0KGYoe1xuICAgICAgICBrZXk6IGAke2d9WzBdYCxcbiAgICAgICAgdmFsdWU6IHdbMF0sXG4gICAgICAgIHZhbGlkYXRlU3BlYzogbS52YWxpZGF0ZVNwZWMsXG4gICAgICAgIHN0eWxlOiBtLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG0uc3R5bGVTcGVjXG4gICAgICB9LCB3KSk7XG4gICAgcmV0dXJuIEphKFhlKHdbMV0pKSA/IHkuY29uY2F0KFtuZXcgYihgJHtnfVsxXWAsIHdbMV0sIFwiZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGZ1bmN0aW9uIHN0b3BzLlwiKV0pIDogeS5jb25jYXQobS52YWxpZGF0ZVNwZWMoe1xuICAgICAga2V5OiBgJHtnfVsxXWAsXG4gICAgICB2YWx1ZTogd1sxXSxcbiAgICAgIHZhbHVlU3BlYzogZSxcbiAgICAgIHZhbGlkYXRlU3BlYzogbS52YWxpZGF0ZVNwZWMsXG4gICAgICBzdHlsZTogbS5zdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogbS5zdHlsZVNwZWNcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gZihtLCB5KSB7XG4gICAgY29uc3QgdyA9IFIobS52YWx1ZSksIGcgPSBCKG0udmFsdWUpLCB4ID0gbS52YWx1ZSAhPT0gbnVsbCA/IG0udmFsdWUgOiB5O1xuICAgIGlmICghbilcbiAgICAgIG4gPSB3O1xuICAgIGVsc2UgaWYgKHcgIT09IG4pXG4gICAgICByZXR1cm4gW25ldyBiKG0ua2V5LCB4LCBgJHt3fSBzdG9wIGRvbWFpbiB0eXBlIG11c3QgbWF0Y2ggcHJldmlvdXMgc3RvcCBkb21haW4gdHlwZSAke259YCldO1xuICAgIGlmICh3ICE9PSBcIm51bWJlclwiICYmIHcgIT09IFwic3RyaW5nXCIgJiYgdyAhPT0gXCJib29sZWFuXCIpXG4gICAgICByZXR1cm4gW25ldyBiKG0ua2V5LCB4LCBcInN0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhblwiKV07XG4gICAgaWYgKHcgIT09IFwibnVtYmVyXCIgJiYgdCAhPT0gXCJjYXRlZ29yaWNhbFwiKSB7XG4gICAgICBsZXQgRSA9IGBudW1iZXIgZXhwZWN0ZWQsICR7d30gZm91bmRgO1xuICAgICAgcmV0dXJuIFh0KGUpICYmIHQgPT09IHZvaWQgMCAmJiAoRSArPSAnXFxuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGBcInR5cGVcIjogXCJjYXRlZ29yaWNhbFwiYC4nKSwgW25ldyBiKG0ua2V5LCB4LCBFKV07XG4gICAgfVxuICAgIHJldHVybiB0ID09PSBcImNhdGVnb3JpY2FsXCIgJiYgdyA9PT0gXCJudW1iZXJcIiAmJiAoIWlzRmluaXRlKGcpIHx8IE1hdGguZmxvb3IoZykgIT09IGcpID8gW25ldyBiKG0ua2V5LCB4LCBgaW50ZWdlciBleHBlY3RlZCwgZm91bmQgJHtnfWApXSA6IHQgIT09IFwiY2F0ZWdvcmljYWxcIiAmJiB3ID09PSBcIm51bWJlclwiICYmIG8gIT09IHZvaWQgMCAmJiBnIDwgbyA/IFtuZXcgYihtLmtleSwgeCwgXCJzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyXCIpXSA6IChvID0gZywgdCA9PT0gXCJjYXRlZ29yaWNhbFwiICYmIGcgaW4gYSA/IFtuZXcgYihtLmtleSwgeCwgXCJzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWVcIildIDogKGFbZ10gPSAhMCwgW10pKTtcbiAgfVxuICBmdW5jdGlvbiBoKG0pIHtcbiAgICByZXR1cm4gbS52YWxpZGF0ZVNwZWMoe1xuICAgICAga2V5OiBtLmtleSxcbiAgICAgIHZhbHVlOiBtLnZhbHVlLFxuICAgICAgdmFsdWVTcGVjOiBlLFxuICAgICAgdmFsaWRhdGVTcGVjOiBtLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiBtLnN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBtLnN0eWxlU3BlY1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpdChyKSB7XG4gIGNvbnN0IGUgPSAoci5leHByZXNzaW9uQ29udGV4dCA9PT0gXCJwcm9wZXJ0eVwiID8gUGwgOiBRYSkoWGUoci52YWx1ZSksIHIudmFsdWVTcGVjKTtcbiAgaWYgKGUucmVzdWx0ID09PSBcImVycm9yXCIpXG4gICAgcmV0dXJuIGUudmFsdWUubWFwKChuKSA9PiBuZXcgYihgJHtyLmtleX0ke24ua2V5fWAsIHIudmFsdWUsIG4ubWVzc2FnZSkpO1xuICBjb25zdCB0ID0gZS52YWx1ZS5leHByZXNzaW9uIHx8IGUudmFsdWUuX3N0eWxlRXhwcmVzc2lvbi5leHByZXNzaW9uO1xuICBpZiAoci5leHByZXNzaW9uQ29udGV4dCA9PT0gXCJwcm9wZXJ0eVwiICYmIHIucHJvcGVydHlLZXkgPT09IFwidGV4dC1mb250XCIgJiYgIXQub3V0cHV0RGVmaW5lZCgpKVxuICAgIHJldHVybiBbbmV3IGIoci5rZXksIHIudmFsdWUsIGBJbnZhbGlkIGRhdGEgZXhwcmVzc2lvbiBmb3IgXCIke3IucHJvcGVydHlLZXl9XCIuIE91dHB1dCB2YWx1ZXMgbXVzdCBiZSBjb250YWluZWQgYXMgbGl0ZXJhbHMgd2l0aGluIHRoZSBleHByZXNzaW9uLmApXTtcbiAgaWYgKHIuZXhwcmVzc2lvbkNvbnRleHQgPT09IFwicHJvcGVydHlcIiAmJiByLnByb3BlcnR5VHlwZSA9PT0gXCJsYXlvdXRcIiAmJiAhU3QodCkpXG4gICAgcmV0dXJuIFtuZXcgYihyLmtleSwgci52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBsYXlvdXQgcHJvcGVydGllcy4nKV07XG4gIGlmIChyLmV4cHJlc3Npb25Db250ZXh0ID09PSBcImZpbHRlclwiICYmICFTdCh0KSlcbiAgICByZXR1cm4gW25ldyBiKHIua2V5LCByLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGZpbHRlcnMuJyldO1xuICBpZiAoci5leHByZXNzaW9uQ29udGV4dCAmJiByLmV4cHJlc3Npb25Db250ZXh0LmluZGV4T2YoXCJjbHVzdGVyXCIpID09PSAwKSB7XG4gICAgaWYgKCFwcih0LCBbXCJ6b29tXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXSkpXG4gICAgICByZXR1cm4gW25ldyBiKHIua2V5LCByLnZhbHVlLCAnXCJ6b29tXCIgYW5kIFwiZmVhdHVyZS1zdGF0ZVwiIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggY2x1c3RlciBwcm9wZXJ0aWVzLicpXTtcbiAgICBpZiAoci5leHByZXNzaW9uQ29udGV4dCA9PT0gXCJjbHVzdGVyLWluaXRpYWxcIiAmJiAhY3IodCkpXG4gICAgICByZXR1cm4gW25ldyBiKHIua2V5LCByLnZhbHVlLCBcIkZlYXR1cmUgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGluaXRpYWwgZXhwcmVzc2lvbiBwYXJ0IG9mIGNsdXN0ZXIgcHJvcGVydGllcy5cIildO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIEZsKHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWUsIHQgPSByLmtleSwgbiA9IFIoZSk7XG4gIHJldHVybiBuICE9PSBcImJvb2xlYW5cIiA/IFtuZXcgYih0LCBlLCBgYm9vbGVhbiBleHBlY3RlZCwgJHtufSBmb3VuZGApXSA6IFtdO1xufVxuZnVuY3Rpb24gVnIocikge1xuICBjb25zdCBlID0gci5rZXksIHQgPSByLnZhbHVlLCBuID0gUih0KTtcbiAgcmV0dXJuIG4gIT09IFwic3RyaW5nXCIgPyBbbmV3IGIoZSwgdCwgYGNvbG9yIGV4cGVjdGVkLCAke259IGZvdW5kYCldIDogJC5wYXJzZShTdHJpbmcodCkpID8gW10gOiBbbmV3IGIoZSwgdCwgYGNvbG9yIGV4cGVjdGVkLCBcIiR7dH1cIiBmb3VuZGApXTtcbn1cbmZ1bmN0aW9uIHh0KHIpIHtcbiAgY29uc3QgZSA9IHIua2V5LCB0ID0gci52YWx1ZSwgbiA9IHIudmFsdWVTcGVjLCBhID0gW107XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG4udmFsdWVzKSA/IG4udmFsdWVzLmluZGV4T2YoQih0KSkgPT09IC0xICYmIGEucHVzaChuZXcgYihlLCB0LCBgZXhwZWN0ZWQgb25lIG9mIFske24udmFsdWVzLmpvaW4oXCIsIFwiKX1dLCAke0pTT04uc3RyaW5naWZ5KHQpfSBmb3VuZGApKSA6IE9iamVjdC5rZXlzKG4udmFsdWVzKS5pbmRleE9mKEIodCkpID09PSAtMSAmJiBhLnB1c2gobmV3IGIoZSwgdCwgYGV4cGVjdGVkIG9uZSBvZiBbJHtPYmplY3Qua2V5cyhuLnZhbHVlcykuam9pbihcIiwgXCIpfV0sICR7SlNPTi5zdHJpbmdpZnkodCl9IGZvdW5kYCkpLCBhO1xufVxuZnVuY3Rpb24ga24ocikge1xuICByZXR1cm4gZW8oWGUoci52YWx1ZSkpID8gaXQoRHQoe30sIHIsIHtcbiAgICBleHByZXNzaW9uQ29udGV4dDogXCJmaWx0ZXJcIixcbiAgICB2YWx1ZVNwZWM6IHsgdmFsdWU6IFwiYm9vbGVhblwiIH1cbiAgfSkpIDogbm8ocik7XG59XG5mdW5jdGlvbiBubyhyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci5rZXk7XG4gIGlmIChSKGUpICE9PSBcImFycmF5XCIpXG4gICAgcmV0dXJuIFtuZXcgYih0LCBlLCBgYXJyYXkgZXhwZWN0ZWQsICR7UihlKX0gZm91bmRgKV07XG4gIGNvbnN0IG4gPSByLnN0eWxlU3BlYztcbiAgbGV0IGEsIG8gPSBbXTtcbiAgaWYgKGUubGVuZ3RoIDwgMSlcbiAgICByZXR1cm4gW25ldyBiKHQsIGUsIFwiZmlsdGVyIGFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnRcIildO1xuICBzd2l0Y2ggKG8gPSBvLmNvbmNhdCh4dCh7XG4gICAga2V5OiBgJHt0fVswXWAsXG4gICAgdmFsdWU6IGVbMF0sXG4gICAgdmFsdWVTcGVjOiBuLmZpbHRlcl9vcGVyYXRvcixcbiAgICBzdHlsZTogci5zdHlsZSxcbiAgICBzdHlsZVNwZWM6IHIuc3R5bGVTcGVjXG4gIH0pKSwgQihlWzBdKSkge1xuICAgIGNhc2UgXCI8XCI6XG4gICAgY2FzZSBcIjw9XCI6XG4gICAgY2FzZSBcIj5cIjpcbiAgICBjYXNlIFwiPj1cIjpcbiAgICAgIGUubGVuZ3RoID49IDIgJiYgQihlWzFdKSA9PT0gXCIkdHlwZVwiICYmIG8ucHVzaChuZXcgYih0LCBlLCBgXCIkdHlwZVwiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciBcIiR7ZVswXX1cImApKTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBcIj09XCI6XG4gICAgY2FzZSBcIiE9XCI6XG4gICAgICBlLmxlbmd0aCAhPT0gMyAmJiBvLnB1c2gobmV3IGIodCwgZSwgYGZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCIke2VbMF19XCIgbXVzdCBoYXZlIDMgZWxlbWVudHNgKSk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgXCJpblwiOlxuICAgIGNhc2UgXCIhaW5cIjpcbiAgICAgIGUubGVuZ3RoID49IDIgJiYgKGEgPSBSKGVbMV0pLCBhICE9PSBcInN0cmluZ1wiICYmIG8ucHVzaChuZXcgYihgJHt0fVsxXWAsIGVbMV0sIGBzdHJpbmcgZXhwZWN0ZWQsICR7YX0gZm91bmRgKSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBlLmxlbmd0aDsgaSsrKVxuICAgICAgICBhID0gUihlW2ldKSwgQihlWzFdKSA9PT0gXCIkdHlwZVwiID8gbyA9IG8uY29uY2F0KHh0KHtcbiAgICAgICAgICBrZXk6IGAke3R9WyR7aX1dYCxcbiAgICAgICAgICB2YWx1ZTogZVtpXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IG4uZ2VvbWV0cnlfdHlwZSxcbiAgICAgICAgICBzdHlsZTogci5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHIuc3R5bGVTcGVjXG4gICAgICAgIH0pKSA6IGEgIT09IFwic3RyaW5nXCIgJiYgYSAhPT0gXCJudW1iZXJcIiAmJiBhICE9PSBcImJvb2xlYW5cIiAmJiBvLnB1c2gobmV3IGIoYCR7dH1bJHtpfV1gLCBlW2ldLCBgc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4gZXhwZWN0ZWQsICR7YX0gZm91bmRgKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgY2FzZSBcImFsbFwiOlxuICAgIGNhc2UgXCJub25lXCI6XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGUubGVuZ3RoOyBpKyspXG4gICAgICAgIG8gPSBvLmNvbmNhdChubyh7XG4gICAgICAgICAga2V5OiBgJHt0fVske2l9XWAsXG4gICAgICAgICAgdmFsdWU6IGVbaV0sXG4gICAgICAgICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiByLnN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaGFzXCI6XG4gICAgY2FzZSBcIiFoYXNcIjpcbiAgICAgIGEgPSBSKGVbMV0pLCBlLmxlbmd0aCAhPT0gMiA/IG8ucHVzaChuZXcgYih0LCBlLCBgZmlsdGVyIGFycmF5IGZvciBcIiR7ZVswXX1cIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50c2ApKSA6IGEgIT09IFwic3RyaW5nXCIgJiYgby5wdXNoKG5ldyBiKGAke3R9WzFdYCwgZVsxXSwgYHN0cmluZyBleHBlY3RlZCwgJHthfSBmb3VuZGApKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gYW8ociwgZSkge1xuICBjb25zdCB0ID0gci5rZXksIG4gPSByLnZhbGlkYXRlU3BlYywgYSA9IHIuc3R5bGUsIG8gPSByLnN0eWxlU3BlYywgaSA9IHIudmFsdWUsIHMgPSByLm9iamVjdEtleSwgbCA9IG9bYCR7ZX1fJHtyLmxheWVyVHlwZX1gXTtcbiAgaWYgKCFsKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgdSA9IHMubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG4gIGlmIChlID09PSBcInBhaW50XCIgJiYgdSAmJiBsW3VbMV1dICYmIGxbdVsxXV0udHJhbnNpdGlvbilcbiAgICByZXR1cm4gbih7XG4gICAgICBrZXk6IHQsXG4gICAgICB2YWx1ZTogaSxcbiAgICAgIHZhbHVlU3BlYzogby50cmFuc2l0aW9uLFxuICAgICAgc3R5bGU6IGEsXG4gICAgICBzdHlsZVNwZWM6IG9cbiAgICB9KTtcbiAgY29uc3QgYyA9IHIudmFsdWVTcGVjIHx8IGxbc107XG4gIGlmICghYylcbiAgICByZXR1cm4gW25ldyBiKHQsIGksIGB1bmtub3duIHByb3BlcnR5IFwiJHtzfVwiYCldO1xuICBsZXQgcDtcbiAgaWYgKFIoaSkgPT09IFwic3RyaW5nXCIgJiYgWHQoYykgJiYgIWMudG9rZW5zICYmIChwID0gL157KFtefV0rKX0kLy5leGVjKGkpKSlcbiAgICByZXR1cm4gW25ldyBiKHQsIGksIGBcIiR7c31cIiBkb2VzIG5vdCBzdXBwb3J0IGludGVycG9sYXRpb24gc3ludGF4XG5Vc2UgYW4gaWRlbnRpdHkgcHJvcGVydHkgZnVuY3Rpb24gaW5zdGVhZDogXFxgeyBcInR5cGVcIjogXCJpZGVudGl0eVwiLCBcInByb3BlcnR5XCI6ICR7SlNPTi5zdHJpbmdpZnkocFsxXSl9IH1cXGAuYCldO1xuICBjb25zdCBkID0gW107XG4gIHJldHVybiByLmxheWVyVHlwZSA9PT0gXCJzeW1ib2xcIiAmJiAocyA9PT0gXCJ0ZXh0LWZpZWxkXCIgJiYgYSAmJiAhYS5nbHlwaHMgJiYgZC5wdXNoKG5ldyBiKHQsIGksICd1c2Ugb2YgXCJ0ZXh0LWZpZWxkXCIgcmVxdWlyZXMgYSBzdHlsZSBcImdseXBoc1wiIHByb3BlcnR5JykpLCBzID09PSBcInRleHQtZm9udFwiICYmIHduKFhlKGkpKSAmJiBCKGkudHlwZSkgPT09IFwiaWRlbnRpdHlcIiAmJiBkLnB1c2gobmV3IGIodCwgaSwgJ1widGV4dC1mb250XCIgZG9lcyBub3Qgc3VwcG9ydCBpZGVudGl0eSBmdW5jdGlvbnMnKSkpLCBkLmNvbmNhdChuKHtcbiAgICBrZXk6IHIua2V5LFxuICAgIHZhbHVlOiBpLFxuICAgIHZhbHVlU3BlYzogYyxcbiAgICBzdHlsZTogYSxcbiAgICBzdHlsZVNwZWM6IG8sXG4gICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwicHJvcGVydHlcIixcbiAgICBwcm9wZXJ0eVR5cGU6IGUsXG4gICAgcHJvcGVydHlLZXk6IHNcbiAgfSkpO1xufVxuZnVuY3Rpb24gb28ocikge1xuICByZXR1cm4gYW8ociwgXCJwYWludFwiKTtcbn1cbmZ1bmN0aW9uIGlvKHIpIHtcbiAgcmV0dXJuIGFvKHIsIFwibGF5b3V0XCIpO1xufVxuZnVuY3Rpb24gc28ocikge1xuICBsZXQgZSA9IFtdO1xuICBjb25zdCB0ID0gci52YWx1ZSwgbiA9IHIua2V5LCBhID0gci5zdHlsZSwgbyA9IHIuc3R5bGVTcGVjO1xuICBpZiAoUih0KSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gW25ldyBiKG4sIHQsIGBvYmplY3QgZXhwZWN0ZWQsICR7Uih0KX0gZm91bmRgKV07XG4gICF0LnR5cGUgJiYgIXQucmVmICYmIGUucHVzaChuZXcgYihuLCB0LCAnZWl0aGVyIFwidHlwZVwiIG9yIFwicmVmXCIgaXMgcmVxdWlyZWQnKSk7XG4gIGxldCBpID0gQih0LnR5cGUpO1xuICBjb25zdCBzID0gQih0LnJlZik7XG4gIGlmICh0LmlkKSB7XG4gICAgY29uc3QgbCA9IEIodC5pZCk7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCByLmFycmF5SW5kZXg7IHUrKykge1xuICAgICAgY29uc3QgYyA9IGEubGF5ZXJzW3VdO1xuICAgICAgQihjLmlkKSA9PT0gbCAmJiBlLnB1c2gobmV3IGIobiwgdC5pZCwgYGR1cGxpY2F0ZSBsYXllciBpZCBcIiR7dC5pZH1cIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJHtjLmlkLl9fbGluZV9ffWApKTtcbiAgICB9XG4gIH1cbiAgaWYgKFwicmVmXCIgaW4gdCkge1xuICAgIFtcInR5cGVcIiwgXCJzb3VyY2VcIiwgXCJzb3VyY2UtbGF5ZXJcIiwgXCJmaWx0ZXJcIiwgXCJsYXlvdXRcIl0uZm9yRWFjaCgodSkgPT4ge1xuICAgICAgdSBpbiB0ICYmIGUucHVzaChuZXcgYihuLCB0W3VdLCBgXCIke3V9XCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVyc2ApKTtcbiAgICB9KTtcbiAgICBsZXQgbDtcbiAgICBhLmxheWVycy5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBCKHUuaWQpID09PSBzICYmIChsID0gdSk7XG4gICAgfSksIGwgPyBsLnJlZiA/IGUucHVzaChuZXcgYihuLCB0LnJlZiwgXCJyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllclwiKSkgOiBpID0gQihsLnR5cGUpIDogZS5wdXNoKG5ldyBiKG4sIHQucmVmLCBgcmVmIGxheWVyIFwiJHtzfVwiIG5vdCBmb3VuZGApKTtcbiAgfSBlbHNlIGlmIChpICE9PSBcImJhY2tncm91bmRcIilcbiAgICBpZiAoIXQuc291cmNlKVxuICAgICAgZS5wdXNoKG5ldyBiKG4sIHQsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBsID0gYS5zb3VyY2VzICYmIGEuc291cmNlc1t0LnNvdXJjZV0sIHUgPSBsICYmIEIobC50eXBlKTtcbiAgICAgIGwgPyB1ID09PSBcInZlY3RvclwiICYmIGkgPT09IFwicmFzdGVyXCIgPyBlLnB1c2gobmV3IGIobiwgdC5zb3VyY2UsIGBsYXllciBcIiR7dC5pZH1cIiByZXF1aXJlcyBhIHJhc3RlciBzb3VyY2VgKSkgOiB1ICE9PSBcInJhc3Rlci1kZW1cIiAmJiBpID09PSBcImhpbGxzaGFkZVwiID8gZS5wdXNoKG5ldyBiKG4sIHQuc291cmNlLCBgbGF5ZXIgXCIke3QuaWR9XCIgcmVxdWlyZXMgYSByYXN0ZXItZGVtIHNvdXJjZWApKSA6IHUgIT09IFwicmFzdGVyLWRlbVwiICYmIGkgPT09IFwiY29sb3ItcmVsaWVmXCIgPyBlLnB1c2gobmV3IGIobiwgdC5zb3VyY2UsIGBsYXllciBcIiR7dC5pZH1cIiByZXF1aXJlcyBhIHJhc3Rlci1kZW0gc291cmNlYCkpIDogdSA9PT0gXCJyYXN0ZXJcIiAmJiBpICE9PSBcInJhc3RlclwiID8gZS5wdXNoKG5ldyBiKG4sIHQuc291cmNlLCBgbGF5ZXIgXCIke3QuaWR9XCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlYCkpIDogdSA9PT0gXCJ2ZWN0b3JcIiAmJiAhdFtcInNvdXJjZS1sYXllclwiXSA/IGUucHVzaChuZXcgYihuLCB0LCBgbGF5ZXIgXCIke3QuaWR9XCIgbXVzdCBzcGVjaWZ5IGEgXCJzb3VyY2UtbGF5ZXJcImApKSA6IHUgPT09IFwicmFzdGVyLWRlbVwiICYmIGkgIT09IFwiaGlsbHNoYWRlXCIgJiYgaSAhPT0gXCJjb2xvci1yZWxpZWZcIiA/IGUucHVzaChuZXcgYihuLCB0LnNvdXJjZSwgXCJyYXN0ZXItZGVtIHNvdXJjZSBjYW4gb25seSBiZSB1c2VkIHdpdGggbGF5ZXIgdHlwZSAnaGlsbHNoYWRlJyBvciAnY29sb3ItcmVsaWVmJy5cIikpIDogaSA9PT0gXCJsaW5lXCIgJiYgdC5wYWludCAmJiB0LnBhaW50W1wibGluZS1ncmFkaWVudFwiXSAmJiAodSAhPT0gXCJnZW9qc29uXCIgfHwgIWwubGluZU1ldHJpY3MpICYmIGUucHVzaChuZXcgYihuLCB0LCBgbGF5ZXIgXCIke3QuaWR9XCIgc3BlY2lmaWVzIGEgbGluZS1ncmFkaWVudCwgd2hpY2ggcmVxdWlyZXMgYSBHZW9KU09OIHNvdXJjZSB3aXRoIFxcYGxpbmVNZXRyaWNzXFxgIGVuYWJsZWQuYCkpIDogZS5wdXNoKG5ldyBiKG4sIHQuc291cmNlLCBgc291cmNlIFwiJHt0LnNvdXJjZX1cIiBub3QgZm91bmRgKSk7XG4gICAgfVxuICByZXR1cm4gZSA9IGUuY29uY2F0KHNlKHtcbiAgICBrZXk6IG4sXG4gICAgdmFsdWU6IHQsXG4gICAgdmFsdWVTcGVjOiBvLmxheWVyLFxuICAgIHN0eWxlOiByLnN0eWxlLFxuICAgIHN0eWxlU3BlYzogci5zdHlsZVNwZWMsXG4gICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgXCIqXCIoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGVuZm9yY2UgdGhlIHNwZWMncyBgXCJyZXF1aXJlc1wiOiB0cnVlYCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHJlZnM7XG4gICAgICAvLyB0aGUgYWN0dWFsIHJlcXVpcmVtZW50IGlzIHZhbGlkYXRlZCBhYm92ZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy81NzcyLlxuICAgICAgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHIudmFsaWRhdGVTcGVjKHtcbiAgICAgICAgICBrZXk6IGAke259LnR5cGVgLFxuICAgICAgICAgIHZhbHVlOiB0LnR5cGUsXG4gICAgICAgICAgdmFsdWVTcGVjOiBvLmxheWVyLnR5cGUsXG4gICAgICAgICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiByLnN0eWxlU3BlYyxcbiAgICAgICAgICB2YWxpZGF0ZVNwZWM6IHIudmFsaWRhdGVTcGVjLFxuICAgICAgICAgIG9iamVjdDogdCxcbiAgICAgICAgICBvYmplY3RLZXk6IFwidHlwZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbHRlcjoga24sXG4gICAgICBsYXlvdXQobCkge1xuICAgICAgICByZXR1cm4gc2Uoe1xuICAgICAgICAgIGxheWVyOiB0LFxuICAgICAgICAgIGtleTogbC5rZXksXG4gICAgICAgICAgdmFsdWU6IGwudmFsdWUsXG4gICAgICAgICAgc3R5bGU6IGwuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiBsLnN0eWxlU3BlYyxcbiAgICAgICAgICB2YWxpZGF0ZVNwZWM6IGwudmFsaWRhdGVTcGVjLFxuICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICBcIipcIih1KSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbyhEdCh7IGxheWVyVHlwZTogaSB9LCB1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwYWludChsKSB7XG4gICAgICAgIHJldHVybiBzZSh7XG4gICAgICAgICAgbGF5ZXI6IHQsXG4gICAgICAgICAga2V5OiBsLmtleSxcbiAgICAgICAgICB2YWx1ZTogbC52YWx1ZSxcbiAgICAgICAgICBzdHlsZTogbC5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IGwuc3R5bGVTcGVjLFxuICAgICAgICAgIHZhbGlkYXRlU3BlYzogbC52YWxpZGF0ZVNwZWMsXG4gICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIFwiKlwiKHUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9vKER0KHsgbGF5ZXJUeXBlOiBpIH0sIHUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSkpLCBlO1xufVxuZnVuY3Rpb24gS2Uocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIua2V5LCBuID0gUihlKTtcbiAgcmV0dXJuIG4gIT09IFwic3RyaW5nXCIgPyBbbmV3IGIodCwgZSwgYHN0cmluZyBleHBlY3RlZCwgJHtufSBmb3VuZGApXSA6IFtdO1xufVxuZnVuY3Rpb24gJGwocikge1xuICB2YXIgZTtcbiAgY29uc3QgdCA9IChlID0gci5zb3VyY2VOYW1lKSAhPT0gbnVsbCAmJiBlICE9PSB2b2lkIDAgPyBlIDogXCJcIiwgbiA9IHIudmFsdWUsIGEgPSByLnN0eWxlU3BlYywgbyA9IGEuc291cmNlX3Jhc3Rlcl9kZW0sIGkgPSByLnN0eWxlO1xuICBsZXQgcyA9IFtdO1xuICBjb25zdCBsID0gUihuKTtcbiAgaWYgKG4gPT09IHZvaWQgMClcbiAgICByZXR1cm4gcztcbiAgaWYgKGwgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIHMucHVzaChuZXcgYihcInNvdXJjZV9yYXN0ZXJfZGVtXCIsIG4sIGBvYmplY3QgZXhwZWN0ZWQsICR7bH0gZm91bmRgKSksIHM7XG4gIGNvbnN0IGMgPSBCKG4uZW5jb2RpbmcpID09PSBcImN1c3RvbVwiLCBwID0gW1wicmVkRmFjdG9yXCIsIFwiZ3JlZW5GYWN0b3JcIiwgXCJibHVlRmFjdG9yXCIsIFwiYmFzZVNoaWZ0XCJdLCBkID0gci52YWx1ZS5lbmNvZGluZyA/IGBcIiR7ci52YWx1ZS5lbmNvZGluZ31cImAgOiBcIkRlZmF1bHRcIjtcbiAgZm9yIChjb25zdCBmIGluIG4pXG4gICAgIWMgJiYgcC5pbmNsdWRlcyhmKSA/IHMucHVzaChuZXcgYihmLCBuW2ZdLCBgSW4gXCIke3R9XCI6IFwiJHtmfVwiIGlzIG9ubHkgdmFsaWQgd2hlbiBcImVuY29kaW5nXCIgaXMgc2V0IHRvIFwiY3VzdG9tXCIuICR7ZH0gZW5jb2RpbmcgZm91bmRgKSkgOiBvW2ZdID8gcyA9IHMuY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogZixcbiAgICAgIHZhbHVlOiBuW2ZdLFxuICAgICAgdmFsdWVTcGVjOiBvW2ZdLFxuICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiBpLFxuICAgICAgc3R5bGVTcGVjOiBhXG4gICAgfSkpIDogcy5wdXNoKG5ldyBiKGYsIG5bZl0sIGB1bmtub3duIHByb3BlcnR5IFwiJHtmfVwiYCkpO1xuICByZXR1cm4gcztcbn1cbmNvbnN0IG5hID0ge1xuICBwcm9tb3RlSWQ6IE9sXG59O1xuZnVuY3Rpb24gbG8ocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIua2V5LCBuID0gci5zdHlsZVNwZWMsIGEgPSByLnN0eWxlLCBvID0gci52YWxpZGF0ZVNwZWM7XG4gIGlmICghZS50eXBlKVxuICAgIHJldHVybiBbbmV3IGIodCwgZSwgJ1widHlwZVwiIGlzIHJlcXVpcmVkJyldO1xuICBjb25zdCBpID0gQihlLnR5cGUpO1xuICBsZXQgcztcbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSBcInZlY3RvclwiOlxuICAgIGNhc2UgXCJyYXN0ZXJcIjpcbiAgICAgIHJldHVybiBzID0gc2Uoe1xuICAgICAgICBrZXk6IHQsXG4gICAgICAgIHZhbHVlOiBlLFxuICAgICAgICB2YWx1ZVNwZWM6IG5bYHNvdXJjZV8ke2kucmVwbGFjZShcIi1cIiwgXCJfXCIpfWBdLFxuICAgICAgICBzdHlsZTogci5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBuLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogbmEsXG4gICAgICAgIHZhbGlkYXRlU3BlYzogb1xuICAgICAgfSksIHM7XG4gICAgY2FzZSBcInJhc3Rlci1kZW1cIjpcbiAgICAgIHJldHVybiBzID0gJGwoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0LFxuICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogbixcbiAgICAgICAgdmFsaWRhdGVTcGVjOiBvXG4gICAgICB9KSwgcztcbiAgICBjYXNlIFwiZ2VvanNvblwiOlxuICAgICAgaWYgKHMgPSBzZSh7XG4gICAgICAgIGtleTogdCxcbiAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgIHZhbHVlU3BlYzogbi5zb3VyY2VfZ2VvanNvbixcbiAgICAgICAgc3R5bGU6IGEsXG4gICAgICAgIHN0eWxlU3BlYzogbixcbiAgICAgICAgdmFsaWRhdGVTcGVjOiBvLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogbmFcbiAgICAgIH0pLCBlLmNsdXN0ZXIpXG4gICAgICAgIGZvciAoY29uc3QgbCBpbiBlLmNsdXN0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgY29uc3QgW3UsIGNdID0gZS5jbHVzdGVyUHJvcGVydGllc1tsXSwgcCA9IHR5cGVvZiB1ID09IFwic3RyaW5nXCIgPyBbdSwgW1wiYWNjdW11bGF0ZWRcIl0sIFtcImdldFwiLCBsXV0gOiB1O1xuICAgICAgICAgIHMucHVzaCguLi5pdCh7XG4gICAgICAgICAgICBrZXk6IGAke3R9LiR7bH0ubWFwYCxcbiAgICAgICAgICAgIHZhbHVlOiBjLFxuICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwiY2x1c3Rlci1tYXBcIlxuICAgICAgICAgIH0pKSwgcy5wdXNoKC4uLml0KHtcbiAgICAgICAgICAgIGtleTogYCR7dH0uJHtsfS5yZWR1Y2VgLFxuICAgICAgICAgICAgdmFsdWU6IHAsXG4gICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogXCJjbHVzdGVyLXJlZHVjZVwiXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgIHJldHVybiBzZSh7XG4gICAgICAgIGtleTogdCxcbiAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgIHZhbHVlU3BlYzogbi5zb3VyY2VfdmlkZW8sXG4gICAgICAgIHN0eWxlOiBhLFxuICAgICAgICB2YWxpZGF0ZVNwZWM6IG8sXG4gICAgICAgIHN0eWxlU3BlYzogblxuICAgICAgfSk7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICByZXR1cm4gc2Uoe1xuICAgICAgICBrZXk6IHQsXG4gICAgICAgIHZhbHVlOiBlLFxuICAgICAgICB2YWx1ZVNwZWM6IG4uc291cmNlX2ltYWdlLFxuICAgICAgICBzdHlsZTogYSxcbiAgICAgICAgdmFsaWRhdGVTcGVjOiBvLFxuICAgICAgICBzdHlsZVNwZWM6IG5cbiAgICAgIH0pO1xuICAgIGNhc2UgXCJjYW52YXNcIjpcbiAgICAgIHJldHVybiBbbmV3IGIodCwgbnVsbCwgXCJQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLlwiLCBcInNvdXJjZS5jYW52YXNcIildO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geHQoe1xuICAgICAgICBrZXk6IGAke3R9LnR5cGVgLFxuICAgICAgICB2YWx1ZTogZS50eXBlLFxuICAgICAgICB2YWx1ZVNwZWM6IHsgdmFsdWVzOiBbXCJ2ZWN0b3JcIiwgXCJyYXN0ZXJcIiwgXCJyYXN0ZXItZGVtXCIsIFwiZ2VvanNvblwiLCBcInZpZGVvXCIsIFwiaW1hZ2VcIl0gfVxuICAgICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIE9sKHsga2V5OiByLCB2YWx1ZTogZSB9KSB7XG4gIGlmIChSKGUpID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBLZSh7IGtleTogciwgdmFsdWU6IGUgfSk7XG4gIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgZm9yIChjb25zdCBuIGluIGUpXG4gICAgICB0LnB1c2goLi4uS2UoeyBrZXk6IGAke3J9LiR7bn1gLCB2YWx1ZTogZVtuXSB9KSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVvKHIpIHtcbiAgY29uc3QgZSA9IHIudmFsdWUsIHQgPSByLnN0eWxlU3BlYywgbiA9IHQubGlnaHQsIGEgPSByLnN0eWxlO1xuICBsZXQgbyA9IFtdO1xuICBjb25zdCBpID0gUihlKTtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gbztcbiAgaWYgKGkgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG8gPSBvLmNvbmNhdChbbmV3IGIoXCJsaWdodFwiLCBlLCBgb2JqZWN0IGV4cGVjdGVkLCAke2l9IGZvdW5kYCldKSwgbztcbiAgZm9yIChjb25zdCBzIGluIGUpIHtcbiAgICBjb25zdCBsID0gcy5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcbiAgICBsICYmIG5bbFsxXV0gJiYgbltsWzFdXS50cmFuc2l0aW9uID8gbyA9IG8uY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogcyxcbiAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgdmFsdWVTcGVjOiB0LnRyYW5zaXRpb24sXG4gICAgICB2YWxpZGF0ZVNwZWM6IHIudmFsaWRhdGVTcGVjLFxuICAgICAgc3R5bGU6IGEsXG4gICAgICBzdHlsZVNwZWM6IHRcbiAgICB9KSkgOiBuW3NdID8gbyA9IG8uY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogcyxcbiAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgdmFsdWVTcGVjOiBuW3NdLFxuICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiBhLFxuICAgICAgc3R5bGVTcGVjOiB0XG4gICAgfSkpIDogbyA9IG8uY29uY2F0KFtuZXcgYihzLCBlW3NdLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7c31cImApXSk7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBjbyhyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci5zdHlsZVNwZWMsIG4gPSB0LnNreSwgYSA9IHIuc3R5bGUsIG8gPSBSKGUpO1xuICBpZiAoZSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBbXTtcbiAgaWYgKG8gIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIFtuZXcgYihcInNreVwiLCBlLCBgb2JqZWN0IGV4cGVjdGVkLCAke299IGZvdW5kYCldO1xuICBsZXQgaSA9IFtdO1xuICBmb3IgKGNvbnN0IHMgaW4gZSlcbiAgICBuW3NdID8gaSA9IGkuY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogcyxcbiAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgdmFsdWVTcGVjOiBuW3NdLFxuICAgICAgc3R5bGU6IGEsXG4gICAgICBzdHlsZVNwZWM6IHRcbiAgICB9KSkgOiBpID0gaS5jb25jYXQoW25ldyBiKHMsIGVbc10sIGB1bmtub3duIHByb3BlcnR5IFwiJHtzfVwiYCldKTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBwbyhyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci5zdHlsZVNwZWMsIG4gPSB0LnRlcnJhaW4sIGEgPSByLnN0eWxlO1xuICBsZXQgbyA9IFtdO1xuICBjb25zdCBpID0gUihlKTtcbiAgaWYgKGUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gbztcbiAgaWYgKGkgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG8gPSBvLmNvbmNhdChbbmV3IGIoXCJ0ZXJyYWluXCIsIGUsIGBvYmplY3QgZXhwZWN0ZWQsICR7aX0gZm91bmRgKV0pLCBvO1xuICBmb3IgKGNvbnN0IHMgaW4gZSlcbiAgICBuW3NdID8gbyA9IG8uY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogcyxcbiAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgdmFsdWVTcGVjOiBuW3NdLFxuICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiBhLFxuICAgICAgc3R5bGVTcGVjOiB0XG4gICAgfSkpIDogbyA9IG8uY29uY2F0KFtuZXcgYihzLCBlW3NdLCBgdW5rbm93biBwcm9wZXJ0eSBcIiR7c31cImApXSk7XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gTmwocikge1xuICByZXR1cm4gS2UocikubGVuZ3RoID09PSAwID8gW10gOiBpdChyKTtcbn1cbmZ1bmN0aW9uIGpsKHIpIHtcbiAgcmV0dXJuIEtlKHIpLmxlbmd0aCA9PT0gMCA/IFtdIDogaXQocik7XG59XG5mdW5jdGlvbiBVbChyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWU7XG4gIGlmIChSKHQpID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAodC5sZW5ndGggPCAxIHx8IHQubGVuZ3RoID4gNClcbiAgICAgIHJldHVybiBbbmV3IGIoZSwgdCwgYHBhZGRpbmcgcmVxdWlyZXMgMSB0byA0IHZhbHVlczsgJHt0Lmxlbmd0aH0gdmFsdWVzIGZvdW5kYCldO1xuICAgIGNvbnN0IGEgPSB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgfTtcbiAgICBsZXQgbyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKylcbiAgICAgIG8gPSBvLmNvbmNhdChyLnZhbGlkYXRlU3BlYyh7XG4gICAgICAgIGtleTogYCR7ZX1bJHtpfV1gLFxuICAgICAgICB2YWx1ZTogdFtpXSxcbiAgICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgICAgdmFsdWVTcGVjOiBhXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIG87XG4gIH0gZWxzZVxuICAgIHJldHVybiBmcih7XG4gICAgICBrZXk6IGUsXG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHZhbHVlU3BlYzoge31cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIERsKHIpIHtcbiAgY29uc3QgZSA9IHIua2V5LCB0ID0gci52YWx1ZTtcbiAgaWYgKFIodCkgPT09IFwiYXJyYXlcIikge1xuICAgIGNvbnN0IGEgPSB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgfTtcbiAgICBpZiAodC5sZW5ndGggPCAxKVxuICAgICAgcmV0dXJuIFtuZXcgYihlLCB0LCBcImFycmF5IGxlbmd0aCBhdCBsZWFzdCAxIGV4cGVjdGVkLCBsZW5ndGggMCBmb3VuZFwiKV07XG4gICAgbGV0IG8gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspXG4gICAgICBvID0gby5jb25jYXQoci52YWxpZGF0ZVNwZWMoe1xuICAgICAgICBrZXk6IGAke2V9WyR7aX1dYCxcbiAgICAgICAgdmFsdWU6IHRbaV0sXG4gICAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWMsXG4gICAgICAgIHZhbHVlU3BlYzogYVxuICAgICAgfSkpO1xuICAgIHJldHVybiBvO1xuICB9IGVsc2VcbiAgICByZXR1cm4gZnIoe1xuICAgICAga2V5OiBlLFxuICAgICAgdmFsdWU6IHQsXG4gICAgICB2YWx1ZVNwZWM6IHt9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBCbChyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWU7XG4gIGlmIChSKHQpID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAodC5sZW5ndGggPCAxKVxuICAgICAgcmV0dXJuIFtuZXcgYihlLCB0LCBcImFycmF5IGxlbmd0aCBhdCBsZWFzdCAxIGV4cGVjdGVkLCBsZW5ndGggMCBmb3VuZFwiKV07XG4gICAgbGV0IGEgPSBbXTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspXG4gICAgICBhID0gYS5jb25jYXQoVnIoe1xuICAgICAgICBrZXk6IGAke2V9WyR7b31dYCxcbiAgICAgICAgdmFsdWU6IHRbb11cbiAgICAgIH0pKTtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIFZyKHtcbiAgICAgIGtleTogZSxcbiAgICAgIHZhbHVlOiB0XG4gICAgfSk7XG59XG5mdW5jdGlvbiBxbChyKSB7XG4gIGNvbnN0IGUgPSByLmtleSwgdCA9IHIudmFsdWUsIG4gPSBSKHQpLCBhID0gci5zdHlsZVNwZWM7XG4gIGlmIChuICE9PSBcImFycmF5XCIgfHwgdC5sZW5ndGggPCAxIHx8IHQubGVuZ3RoICUgMiAhPT0gMClcbiAgICByZXR1cm4gW25ldyBiKGUsIHQsIFwidmFyaWFibGVBbmNob3JPZmZzZXRDb2xsZWN0aW9uIHJlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5IG9mIGV2ZW4gbGVuZ3RoXCIpXTtcbiAgbGV0IG8gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSArPSAyKVxuICAgIG8gPSBvLmNvbmNhdCh4dCh7XG4gICAgICBrZXk6IGAke2V9WyR7aX1dYCxcbiAgICAgIHZhbHVlOiB0W2ldLFxuICAgICAgdmFsdWVTcGVjOiBhLmxheW91dF9zeW1ib2xbXCJ0ZXh0LWFuY2hvclwiXVxuICAgIH0pKSwgbyA9IG8uY29uY2F0KHhuKHtcbiAgICAgIGtleTogYCR7ZX1bJHtpICsgMX1dYCxcbiAgICAgIHZhbHVlOiB0W2kgKyAxXSxcbiAgICAgIHZhbHVlU3BlYzoge1xuICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgIHZhbHVlOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAgdmFsaWRhdGVTcGVjOiByLnZhbGlkYXRlU3BlYyxcbiAgICAgIHN0eWxlOiByLnN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBhXG4gICAgfSkpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIGZvKHIpIHtcbiAgbGV0IGUgPSBbXTtcbiAgY29uc3QgdCA9IHIudmFsdWUsIG4gPSByLmtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICBjb25zdCBhID0gW10sIG8gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdCkge1xuICAgICAgdFtpXS5pZCAmJiBhLmluY2x1ZGVzKHRbaV0uaWQpICYmIGUucHVzaChuZXcgYihuLCB0LCBgYWxsIHRoZSBzcHJpdGVzJyBpZHMgbXVzdCBiZSB1bmlxdWUsIGJ1dCAke3RbaV0uaWR9IGlzIGR1cGxpY2F0ZWRgKSksIGEucHVzaCh0W2ldLmlkKSwgdFtpXS51cmwgJiYgby5pbmNsdWRlcyh0W2ldLnVybCkgJiYgZS5wdXNoKG5ldyBiKG4sIHQsIGBhbGwgdGhlIHNwcml0ZXMnIFVSTHMgbXVzdCBiZSB1bmlxdWUsIGJ1dCAke3RbaV0udXJsfSBpcyBkdXBsaWNhdGVkYCkpLCBvLnB1c2godFtpXS51cmwpO1xuICAgICAgY29uc3QgcyA9IHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIHJlcXVpcmVkOiAhMFxuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIHJlcXVpcmVkOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZSA9IGUuY29uY2F0KHNlKHtcbiAgICAgICAga2V5OiBgJHtufVske2l9XWAsXG4gICAgICAgIHZhbHVlOiB0W2ldLFxuICAgICAgICB2YWx1ZVNwZWM6IHMsXG4gICAgICAgIHZhbGlkYXRlU3BlYzogci52YWxpZGF0ZVNwZWNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0gZWxzZVxuICAgIHJldHVybiBLZSh7XG4gICAgICBrZXk6IG4sXG4gICAgICB2YWx1ZTogdFxuICAgIH0pO1xufVxuZnVuY3Rpb24gVmwocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIuc3R5bGVTcGVjLCBuID0gdC5wcm9qZWN0aW9uLCBhID0gci5zdHlsZSwgbyA9IFIoZSk7XG4gIGlmIChlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFtdO1xuICBpZiAobyAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gW25ldyBiKFwicHJvamVjdGlvblwiLCBlLCBgb2JqZWN0IGV4cGVjdGVkLCAke299IGZvdW5kYCldO1xuICBsZXQgaSA9IFtdO1xuICBmb3IgKGNvbnN0IHMgaW4gZSlcbiAgICBuW3NdID8gaSA9IGkuY29uY2F0KHIudmFsaWRhdGVTcGVjKHtcbiAgICAgIGtleTogcyxcbiAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgdmFsdWVTcGVjOiBuW3NdLFxuICAgICAgc3R5bGU6IGEsXG4gICAgICBzdHlsZVNwZWM6IHRcbiAgICB9KSkgOiBpID0gaS5jb25jYXQoW25ldyBiKHMsIGVbc10sIGB1bmtub3duIHByb3BlcnR5IFwiJHtzfVwiYCldKTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBHbChyKSB7XG4gIGNvbnN0IGUgPSByLmtleTtcbiAgbGV0IHQgPSByLnZhbHVlO1xuICB0ID0gdCBpbnN0YW5jZW9mIFN0cmluZyA/IHQudmFsdWVPZigpIDogdDtcbiAgY29uc3QgbiA9IFIodCk7XG4gIHJldHVybiBuID09PSBcImFycmF5XCIgJiYgIVpsKHQpICYmICFIbCh0KSA/IFtuZXcgYihlLCB0LCBgcHJvamVjdGlvbiBleHBlY3RlZCwgaW52YWxpZCBhcnJheSAke0pTT04uc3RyaW5naWZ5KHQpfSBmb3VuZGApXSA6IFtcImFycmF5XCIsIFwic3RyaW5nXCJdLmluY2x1ZGVzKG4pID8gW10gOiBbbmV3IGIoZSwgdCwgYHByb2plY3Rpb24gZXhwZWN0ZWQsIGludmFsaWQgdHlwZSBcIiR7bn1cIiBmb3VuZGApXTtcbn1cbmZ1bmN0aW9uIEhsKHIpIHtcbiAgcmV0dXJuICEhW1wiaW50ZXJwb2xhdGVcIiwgXCJzdGVwXCIsIFwibGl0ZXJhbFwiXS5pbmNsdWRlcyhyWzBdKTtcbn1cbmZ1bmN0aW9uIFpsKHIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocikgJiYgci5sZW5ndGggPT09IDMgJiYgdHlwZW9mIHJbMF0gPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgclsxXSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiByWzJdID09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBYbChyKSB7XG4gIHJldHVybiAhIXIgJiYgci5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuZnVuY3Rpb24gaG8ocikge1xuICByZXR1cm4gWGwoci52YWx1ZSkgPyBbXSA6IFtcbiAgICBuZXcgYihyLmtleSwgci52YWx1ZSwgYG9iamVjdCBleHBlY3RlZCwgJHtSKHIudmFsdWUpfSBmb3VuZGApXG4gIF07XG59XG5jb25zdCBhYSA9IHtcbiAgXCIqXCIoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBhcnJheTogeG4sXG4gIGJvb2xlYW46IEZsLFxuICBudW1iZXI6IGZyLFxuICBjb2xvcjogVnIsXG4gIGNvbnN0YW50czogdG8sXG4gIGVudW06IHh0LFxuICBmaWx0ZXI6IGtuLFxuICBmdW5jdGlvbjogcm8sXG4gIGxheWVyOiBzbyxcbiAgb2JqZWN0OiBzZSxcbiAgc291cmNlOiBsbyxcbiAgbGlnaHQ6IHVvLFxuICBza3k6IGNvLFxuICB0ZXJyYWluOiBwbyxcbiAgcHJvamVjdGlvbjogVmwsXG4gIHByb2plY3Rpb25EZWZpbml0aW9uOiBHbCxcbiAgc3RyaW5nOiBLZSxcbiAgZm9ybWF0dGVkOiBObCxcbiAgcmVzb2x2ZWRJbWFnZTogamwsXG4gIHBhZGRpbmc6IFVsLFxuICBudW1iZXJBcnJheTogRGwsXG4gIGNvbG9yQXJyYXk6IEJsLFxuICB2YXJpYWJsZUFuY2hvck9mZnNldENvbGxlY3Rpb246IHFsLFxuICBzcHJpdGU6IGZvLFxuICBzdGF0ZTogaG9cbn07XG5mdW5jdGlvbiBLdChyKSB7XG4gIGNvbnN0IGUgPSByLnZhbHVlLCB0ID0gci52YWx1ZVNwZWMsIG4gPSByLnN0eWxlU3BlYztcbiAgcmV0dXJuIHIudmFsaWRhdGVTcGVjID0gS3QsIHQuZXhwcmVzc2lvbiAmJiB3bihCKGUpKSA/IHJvKHIpIDogdC5leHByZXNzaW9uICYmIEphKFhlKGUpKSA/IGl0KHIpIDogdC50eXBlICYmIGFhW3QudHlwZV0gPyBhYVt0LnR5cGVdKHIpIDogc2UoRHQoe30sIHIsIHtcbiAgICB2YWx1ZVNwZWM6IHQudHlwZSA/IG5bdC50eXBlXSA6IHRcbiAgfSkpO1xufVxuZnVuY3Rpb24gbW8ocikge1xuICBjb25zdCBlID0gci52YWx1ZSwgdCA9IHIua2V5LCBuID0gS2Uocik7XG4gIHJldHVybiBuLmxlbmd0aCB8fCAoZS5pbmRleE9mKFwie2ZvbnRzdGFja31cIikgPT09IC0xICYmIG4ucHVzaChuZXcgYih0LCBlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7Zm9udHN0YWNrfVwiIHRva2VuJykpLCBlLmluZGV4T2YoXCJ7cmFuZ2V9XCIpID09PSAtMSAmJiBuLnB1c2gobmV3IGIodCwgZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpKSwgbjtcbn1cbmZ1bmN0aW9uIHJlKHIsIGUgPSB4cykge1xuICBsZXQgdCA9IFtdO1xuICByZXR1cm4gdCA9IHQuY29uY2F0KEt0KHtcbiAgICBrZXk6IFwiXCIsXG4gICAgdmFsdWU6IHIsXG4gICAgdmFsdWVTcGVjOiBlLiRyb290LFxuICAgIHN0eWxlU3BlYzogZSxcbiAgICBzdHlsZTogcixcbiAgICB2YWxpZGF0ZVNwZWM6IEt0LFxuICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICBnbHlwaHM6IG1vLFxuICAgICAgXCIqXCIoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKSwgci5jb25zdGFudHMgJiYgKHQgPSB0LmNvbmNhdCh0byh7XG4gICAga2V5OiBcImNvbnN0YW50c1wiLFxuICAgIHZhbHVlOiByLmNvbnN0YW50c1xuICB9KSkpLCB5byh0KTtcbn1cbnJlLnNvdXJjZSA9IGdlKHllKGxvKSk7XG5yZS5zcHJpdGUgPSBnZSh5ZShmbykpO1xucmUuZ2x5cGhzID0gZ2UoeWUobW8pKTtcbnJlLmxpZ2h0ID0gZ2UoeWUodW8pKTtcbnJlLnNreSA9IGdlKHllKGNvKSk7XG5yZS50ZXJyYWluID0gZ2UoeWUocG8pKTtcbnJlLnN0YXRlID0gZ2UoeWUoaG8pKTtcbnJlLmxheWVyID0gZ2UoeWUoc28pKTtcbnJlLmZpbHRlciA9IGdlKHllKGtuKSk7XG5yZS5wYWludFByb3BlcnR5ID0gZ2UoeWUob28pKTtcbnJlLmxheW91dFByb3BlcnR5ID0gZ2UoeWUoaW8pKTtcbmZ1bmN0aW9uIHllKHIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gcih7XG4gICAgICAuLi5lLFxuICAgICAgdmFsaWRhdGVTcGVjOiBLdFxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24geW8ocikge1xuICByZXR1cm4gW10uY29uY2F0KHIpLnNvcnQoKGUsIHQpID0+IGUubGluZSAtIHQubGluZSk7XG59XG5mdW5jdGlvbiBnZShyKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5lKSB7XG4gICAgcmV0dXJuIHlvKHIuYXBwbHkodGhpcywgZSkpO1xuICB9O1xufVxuZnVuY3Rpb24gb2Eocikge1xuICBpZiAoIXIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiBmdFt5clswXS5yZWZlcmVuY2VTdHlsZUlEXS5nZXREZWZhdWx0VmFyaWFudCgpLmdldEV4cGFuZGVkU3R5bGVVUkwoKSxcbiAgICAgIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogITEsXG4gICAgICAvLyBkZWZhdWx0IHN0eWxlcyBkb24ndCByZXF1aXJlIFVSTCBtb25pdG9yaW5nXG4gICAgICBpc0ZhbGxiYWNrOiAhMFxuICAgIH07XG4gIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgdCA9IFlsKHIpO1xuICAgIHJldHVybiB0LmlzVmFsaWRTdHlsZSA/IHtcbiAgICAgIHN0eWxlOiB0LnN0eWxlT2JqZWN0LFxuICAgICAgcmVxdWlyZXNVcmxNb25pdG9yaW5nOiAhMSxcbiAgICAgIGlzRmFsbGJhY2s6ICExXG4gICAgfSA6IHQuaXNWYWxpZEpTT04gPyB7XG4gICAgICBzdHlsZTogZnRbeXJbMF0ucmVmZXJlbmNlU3R5bGVJRF0uZ2V0RGVmYXVsdFZhcmlhbnQoKS5nZXRFeHBhbmRlZFN0eWxlVVJMKCksXG4gICAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICExLFxuICAgICAgLy8gZGVmYXVsdCBzdHlsZXMgZG9uJ3QgcmVxdWlyZSBVUkwgbW9uaXRvcmluZ1xuICAgICAgaXNGYWxsYmFjazogITBcbiAgICB9IDogci5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IHsgc3R5bGU6IHIsIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogITAsIGlzRmFsbGJhY2s6ICExIH0gOiByLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCIuanNvblwiKSA/IHtcbiAgICAgIHN0eWxlOiBLbChyKSxcbiAgICAgIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogITAsXG4gICAgICBpc0ZhbGxiYWNrOiAhMVxuICAgIH0gOiB7XG4gICAgICBzdHlsZTogaWkociksXG4gICAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICEwLFxuICAgICAgaXNGYWxsYmFjazogITFcbiAgICB9O1xuICB9XG4gIHJldHVybiByIGluc3RhbmNlb2Ygc2kgPyB7XG4gICAgc3R5bGU6IHIuZ2V0RXhwYW5kZWRTdHlsZVVSTCgpLFxuICAgIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogITEsXG4gICAgaXNGYWxsYmFjazogITFcbiAgfSA6IHIgaW5zdGFuY2VvZiBsaSA/IHtcbiAgICBzdHlsZTogci5nZXREZWZhdWx0VmFyaWFudCgpLmdldEV4cGFuZGVkU3R5bGVVUkwoKSxcbiAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICExLFxuICAgIGlzRmFsbGJhY2s6ICExXG4gIH0gOiByZShyKS5sZW5ndGggPT09IDAgPyB7XG4gICAgc3R5bGU6IHIsXG4gICAgcmVxdWlyZXNVcmxNb25pdG9yaW5nOiAhMSxcbiAgICBpc0ZhbGxiYWNrOiAhMVxuICB9IDoge1xuICAgIHN0eWxlOiBmdFt5clswXS5yZWZlcmVuY2VTdHlsZUlEXS5nZXREZWZhdWx0VmFyaWFudCgpLmdldEV4cGFuZGVkU3R5bGVVUkwoKSxcbiAgICByZXF1aXJlc1VybE1vbml0b3Jpbmc6ICExLFxuICAgIC8vIGRlZmF1bHQgc3R5bGVzIGRvbid0IHJlcXVpcmUgVVJMIG1vbml0b3JpbmdcbiAgICBpc0ZhbGxiYWNrOiAhMFxuICB9O1xufVxuZnVuY3Rpb24gS2wocikge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHIpLmhyZWY7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHIsIGxvY2F0aW9uLm9yaWdpbikuaHJlZjtcbn1cbmZ1bmN0aW9uIFlsKHIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlID0gSlNPTi5wYXJzZShyKSwgdCA9IHJlKGUpO1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkSlNPTjogITAsXG4gICAgICBpc1ZhbGlkU3R5bGU6IHQubGVuZ3RoID09PSAwLFxuICAgICAgc3R5bGVPYmplY3Q6IHQubGVuZ3RoID09PSAwID8gZSA6IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNWYWxpZEpTT046ICExLFxuICAgICAgaXNWYWxpZFN0eWxlOiAhMSxcbiAgICAgIHN0eWxlT2JqZWN0OiBudWxsXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gTGUociwgZSwgdCkge1xuICBjb25zdCBuID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocik7XG4gIHJldHVybiBlICE9PSB2b2lkIDAgJiYgKG4uY2xhc3NOYW1lID0gZSksIHQgJiYgdC5hcHBlbmRDaGlsZChuKSwgbjtcbn1cbmZ1bmN0aW9uIGt0KHIpIHtcbiAgci5wYXJlbnROb2RlICYmIHIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyKTtcbn1cbmNsYXNzIFdsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdih0aGlzLCBcIl9tYXBcIik7XG4gICAgdih0aGlzLCBcIl9jb250YWluZXJcIik7XG4gICAgdih0aGlzLCBcIl90ZXJyYWluQnV0dG9uXCIpO1xuICAgIFNpKFtcIl90b2dnbGVUZXJyYWluXCIsIFwiX3VwZGF0ZVRlcnJhaW5JY29uXCJdLCB0aGlzKTtcbiAgfVxuICBvbkFkZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcCA9IGUsIHRoaXMuX2NvbnRhaW5lciA9IExlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKSwgdGhpcy5fdGVycmFpbkJ1dHRvbiA9IExlKFwiYnV0dG9uXCIsIFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW5cIiwgdGhpcy5fY29udGFpbmVyKSwgTGUoXCJzcGFuXCIsIFwibWFwbGlicmVnbC1jdHJsLWljb25cIiwgdGhpcy5fdGVycmFpbkJ1dHRvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCB0aGlzLl90ZXJyYWluQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl90ZXJyYWluQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl90b2dnbGVUZXJyYWluKSwgdGhpcy5fdXBkYXRlVGVycmFpbkljb24oKSwgdGhpcy5fbWFwLm9uKFwidGVycmFpblwiLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbiksIHRoaXMuX2NvbnRhaW5lcjtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBrdCh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwidGVycmFpblwiLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbiksIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgfVxuICBfdG9nZ2xlVGVycmFpbigpIHtcbiAgICBnbyh0aGlzLl9tYXApLCB0aGlzLl91cGRhdGVUZXJyYWluSWNvbigpO1xuICB9XG4gIF91cGRhdGVUZXJyYWluSWNvbigpIHtcbiAgICB0aGlzLl90ZXJyYWluQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtdGVycmFpblwiKSwgdGhpcy5fdGVycmFpbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXRlcnJhaW4tZW5hYmxlZFwiKSwgdGhpcy5fbWFwLmhhc1RlcnJhaW4oKSA/ICh0aGlzLl90ZXJyYWluQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtdGVycmFpbi1lbmFibGVkXCIpLCB0aGlzLl90ZXJyYWluQnV0dG9uLnRpdGxlID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIlRlcnJhaW5Db250cm9sLkRpc2FibGVcIikpIDogKHRoaXMuX3RlcnJhaW5CdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC10ZXJyYWluXCIpLCB0aGlzLl90ZXJyYWluQnV0dG9uLnRpdGxlID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIlRlcnJhaW5Db250cm9sLkVuYWJsZVwiKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdvKHIpIHtcbiAgci5oYXNUZXJyYWluKCkgPyByLmRpc2FibGVUZXJyYWluKCkgOiByLmVuYWJsZVRlcnJhaW4oKTtcbn1cbmNsYXNzIEpsIGV4dGVuZHMgTWEge1xuICBjb25zdHJ1Y3Rvcih0ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBzaG93Q29tcGFzczogdC5zaG93Q29tcGFzcyA/PyAhMCxcbiAgICAgIHNob3dab29tOiB0LnNob3dab29tID8/ICEwLFxuICAgICAgdmlzdWFsaXplUGl0Y2g6IHQudmlzdWFsaXplUGl0Y2ggPz8gITBcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBPdmVybG9hZGluZzogTGltaXQgaG93IGZsYXQgdGhlIGNvbXBhc3MgaWNvbiBjYW4gZ2V0XG4gICAgICovXG4gICAgdih0aGlzLCBcIl9yb3RhdGVDb21wYXNzQXJyb3dcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX21hcC5nZXRCZWFyaW5nKCksIG4gPSB0aGlzLl9tYXAuZ2V0UGl0Y2goKSwgYSA9IHRoaXMub3B0aW9ucy52aXN1YWxpemVQaXRjaCA/IGBzY2FsZSgke01hdGgubWluKDEuNSwgMSAvIE1hdGguY29zKG4gKiAoTWF0aC5QSSAvIDE4MCkpICoqIDAuNSl9KSByb3RhdGVYKCR7TWF0aC5taW4oNzAsIG4pfWRlZykgcm90YXRlWigkey10fWRlZylgIDogYHJvdGF0ZSgkey10fWRlZylgO1xuICAgICAgdGhpcy5fY29tcGFzc0ljb24uc3R5bGUudHJhbnNmb3JtID0gYTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb21wYXNzICYmICh0aGlzLl9jb21wYXNzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jb21wYXNzLmNsaWNrRnVuY3Rpb24pLCB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAobikgPT4ge1xuICAgICAgdGhpcy5fbWFwLmdldFBpdGNoKCkgPT09IDAgPyB0aGlzLl9tYXAuZWFzZVRvKHsgcGl0Y2g6IE1hdGgubWluKHRoaXMuX21hcC5nZXRNYXhQaXRjaCgpLCA4MCkgfSkgOiB0aGlzLm9wdGlvbnMudmlzdWFsaXplUGl0Y2ggPyB0aGlzLl9tYXAucmVzZXROb3J0aFBpdGNoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IG4gfSkgOiB0aGlzLl9tYXAucmVzZXROb3J0aCh7fSwgeyBvcmlnaW5hbEV2ZW50OiBuIH0pO1xuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcmxvYWRpbmc6IHRoZSBidXR0b24gbm93IHN0b3JlcyBpdHMgY2xpY2sgY2FsbGJhY2sgc28gdGhhdCB3ZSBjYW4gbGF0ZXIgb24gZGVsZXRlIGl0IGFuZCByZXBsYWNlIGl0XG4gICAqL1xuICBfY3JlYXRlQnV0dG9uKHQsIG4pIHtcbiAgICBjb25zdCBhID0gc3VwZXIuX2NyZWF0ZUJ1dHRvbih0LCBuKTtcbiAgICByZXR1cm4gYS5jbGlja0Z1bmN0aW9uID0gbiwgYTtcbiAgfVxufVxuY29uc3QgaWEgPSBMLk1hcmtlciwgc2EgPSBMLkxuZ0xhdCwgUWwgPSBMLkxuZ0xhdEJvdW5kcztcbmNsYXNzIGV1IGV4dGVuZHMgUGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHYodGhpcywgXCJsYXN0VXBkYXRlZENlbnRlclwiLCBuZXcgc2EoMCwgMCkpO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY2FtZXJhIGxvY2F0aW9uIHRvIGNlbnRlciBvbiB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24gdGhlIEdlb2xvY2F0aW9uIEFQSSBQb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdih0aGlzLCBcIl91cGRhdGVDYW1lcmFcIiwgKHQpID0+IHtcbiAgICAgIHZhciBjO1xuICAgICAgY29uc3QgbiA9IG5ldyBzYSh0LmNvb3Jkcy5sb25naXR1ZGUsIHQuY29vcmRzLmxhdGl0dWRlKSwgYSA9IHQuY29vcmRzLmFjY3VyYWN5LCBpID0ge1xuICAgICAgICBiZWFyaW5nOiB0aGlzLl9tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAuLi50aGlzLm9wdGlvbnMuZml0Qm91bmRzT3B0aW9ucyxcbiAgICAgICAgbGluZWFyOiAhMFxuICAgICAgfSwgcyA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICBzID4gKCgoYyA9IHRoaXMub3B0aW9ucy5maXRCb3VuZHNPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogYy5tYXhab29tKSA/PyAzMCkgJiYgKGkuem9vbSA9IHMpLCB0aGlzLl9tYXAuZml0Qm91bmRzKFFsLmZyb21MbmdMYXQobiwgYSksIGksIHtcbiAgICAgICAgZ2VvbG9jYXRlU291cmNlOiAhMFxuICAgICAgICAvLyB0YWcgdGhpcyBjYW1lcmEgY2hhbmdlIHNvIGl0IHdvbid0IGNhdXNlIHRoZSBjb250cm9sIHRvIGNoYW5nZSB0byBiYWNrZ3JvdW5kIHN0YXRlXG4gICAgICB9KTtcbiAgICAgIGxldCBsID0gITE7XG4gICAgICBjb25zdCB1ID0gKCkgPT4ge1xuICAgICAgICBsID0gITA7XG4gICAgICB9O1xuICAgICAgdGhpcy5fbWFwLm9uY2UoXCJjbGlja1wiLCB1KSwgdGhpcy5fbWFwLm9uY2UoXCJkYmxjbGlja1wiLCB1KSwgdGhpcy5fbWFwLm9uY2UoXCJkcmFnc3RhcnRcIiwgdSksIHRoaXMuX21hcC5vbmNlKFwibW91c2Vkb3duXCIsIHUpLCB0aGlzLl9tYXAub25jZShcInRvdWNoc3RhcnRcIiwgdSksIHRoaXMuX21hcC5vbmNlKFwid2hlZWxcIiwgdSksIHRoaXMuX21hcC5vbmNlKFwibW92ZWVuZFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLCB1KSwgdGhpcy5fbWFwLm9mZihcImRibGNsaWNrXCIsIHUpLCB0aGlzLl9tYXAub2ZmKFwiZHJhZ3N0YXJ0XCIsIHUpLCB0aGlzLl9tYXAub2ZmKFwibW91c2Vkb3duXCIsIHUpLCB0aGlzLl9tYXAub2ZmKFwidG91Y2hzdGFydFwiLCB1KSwgdGhpcy5fbWFwLm9mZihcIndoZWVsXCIsIHUpLCAhbCAmJiAodGhpcy5sYXN0VXBkYXRlZENlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2KHRoaXMsIFwiX2ZpbmlzaFNldHVwVUlcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHQgPT09ICExKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJHZW9sb2NhdGVDb250cm9sLkxvY2F0aW9uTm90QXZhaWxhYmxlXCIpO1xuICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5kaXNhYmxlZCA9ICEwLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSBuLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuID0gdGhpcy5fbWFwLl9nZXRVSVN0cmluZyhcIkdlb2xvY2F0ZUNvbnRyb2wuRmluZE15TG9jYXRpb25cIik7XG4gICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmRpc2FibGVkID0gITEsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi50aXRsZSA9IG4sIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbiAmJiAodGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpLCB0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmICh0aGlzLl9kb3RFbGVtZW50ID0gTGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tZG90XCIpLCB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIgPSBuZXcgaWEoeyBlbGVtZW50OiB0aGlzLl9kb3RFbGVtZW50IH0pLCB0aGlzLl9jaXJjbGVFbGVtZW50ID0gTGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tYWNjdXJhY3ktY2lyY2xlXCIpLCB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlciA9IG5ldyBpYSh7XG4gICAgICAgICAgZWxlbWVudDogdGhpcy5fY2lyY2xlRWxlbWVudCxcbiAgICAgICAgICBwaXRjaEFsaWdubWVudDogXCJtYXBcIlxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uICYmICh0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fb25ab29tKSksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50cmlnZ2VyLmJpbmQodGhpcykpLCB0aGlzLl9zZXR1cCA9ICEwLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgdGhpcy5fbWFwLm9uKFwibW92ZWVuZFwiLCAobikgPT4ge1xuICAgICAgICAgIGNvbnN0IGEgPSBuLm9yaWdpbmFsRXZlbnQgJiYgbi5vcmlnaW5hbEV2ZW50LnR5cGUgPT09IFwicmVzaXplXCIsIG8gPSB0aGlzLmxhc3RVcGRhdGVkQ2VudGVyLmRpc3RhbmNlVG8odGhpcy5fbWFwLmdldENlbnRlcigpKTtcbiAgICAgICAgICAhbi5nZW9sb2NhdGVTb3VyY2UgJiYgdGhpcy5fd2F0Y2hTdGF0ZSA9PT0gXCJBQ1RJVkVfTE9DS1wiICYmICFhICYmIG8gPiAxICYmICh0aGlzLl93YXRjaFN0YXRlID0gXCJCQUNLR1JPVU5EXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLmZpcmUobmV3IEV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25lbmRcIikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdih0aGlzLCBcIl9vblpvb21cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5vcHRpb25zLnNob3dBY2N1cmFjeUNpcmNsZSAmJiB0aGlzLl91cGRhdGVDaXJjbGVSYWRpdXMoKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlQ2lyY2xlUmFkaXVzKCkge1xuICAgIGlmICh0aGlzLl93YXRjaFN0YXRlICE9PSBcIkJBQ0tHUk9VTkRcIiAmJiB0aGlzLl93YXRjaFN0YXRlICE9PSBcIkFDVElWRV9MT0NLXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IFt0aGlzLl9sYXN0S25vd25Qb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlLCB0aGlzLl9sYXN0S25vd25Qb3NpdGlvbi5jb29yZHMubGF0aXR1ZGVdLCBuID0gdGhpcy5fbWFwLnByb2plY3QodCksIGEgPSB0aGlzLl9tYXAudW5wcm9qZWN0KFtuLngsIG4ueV0pLCBvID0gdGhpcy5fbWFwLnVucHJvamVjdChbbi54ICsgMjAsIG4ueV0pLCBpID0gYS5kaXN0YW5jZVRvKG8pIC8gMjAsIHMgPSBNYXRoLmNlaWwoMiAqIHRoaXMuX2FjY3VyYWN5IC8gaSk7XG4gICAgdGhpcy5fY2lyY2xlRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3N9cHhgLCB0aGlzLl9jaXJjbGVFbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3N9cHhgO1xuICB9XG4gIC8vIFdlIGFyZSBvdmVyd3JpdGluZyB0aGUgbWV0aG9kIF9zZXRFcnJvclN0YXRlIGZyb20gTWFwbGlicmUncyBHZW9sb2NhdGVDb250cm9sIGJlY2F1c2UgdGhlXG4gIC8vIGNhc2UgQkFDS0dST1VORF9FUlJPUiBpcyBub3QgZGVhbHQgd2l0aCBpbiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kIHlpZWxkcyBhbiBlcnJvci5cbiAgLy8gUmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL21hcGxpYnJlL21hcGxpYnJlLWdsLWpzL2lzc3Vlcy8yMjk0XG4gIF9zZXRFcnJvclN0YXRlKCkge1xuICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgY2FzZSBcIldBSVRJTkdfQUNUSVZFXCI6XG4gICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkFDVElWRV9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJBQ1RJVkVfRVJST1JcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkJBQ0tHUk9VTkRcIjpcbiAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQkFDS0dST1VORF9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBQ1RJVkVfRVJST1JcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB3YXRjaFN0YXRlICR7dGhpcy5fd2F0Y2hTdGF0ZX1gKTtcbiAgICB9XG4gIH1cbn1cbnZhciBBZSwgVywgVGUsIF9lLCBydDtcbmNsYXNzIHR1IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBzZWxlY3Rvck9yRWxlbWVudCBFbGVtZW50IHRvIGJlIHVzZWQgYXMgY29udHJvbCwgc3BlY2lmaWVkIGFzIGVpdGhlciByZWZlcmVuY2UgdG8gZWxlbWVudCBpdHNlbGYgb3IgYSBDU1Mgc2VsZWN0b3IgdG8gZmluZCB0aGUgZWxlbWVudCBpbiBET01cbiAgICogQHBhcmFtIG9uQ2xpY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgY2xpY2tlZFxuICAgKiBAcGFyYW0gb25SZW5kZXIgRnVuY3Rpb24gY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHVuZGVybHlpbmcgbWFwIHJlbmRlcnMgYSBuZXcgc3RhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBaKHRoaXMsIEFlKTtcbiAgICBaKHRoaXMsIFcpO1xuICAgIFoodGhpcywgVGUpO1xuICAgIFoodGhpcywgX2UpO1xuICAgIFoodGhpcywgcnQpO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTtcbiAgICAgIGlmICghYSkgdGhyb3cgbmV3IEVycm9yKGBObyBlbGVtZW50IGhhcyBiZWVuIGZvdW5kIHdpdGggc2VsZWN0b3IgXCIke2V9XCIgd2hlbiBjcmVhdGluZyBhbiBleHRlcm5hbCBjb250cm9sLmApO1xuICAgICAgSyh0aGlzLCBXLCBhKTtcbiAgICB9IGVsc2VcbiAgICAgIEsodGhpcywgVywgZSk7XG4gICAgdCAmJiBLKHRoaXMsIFRlLCAoYSkgPT4ge1xuICAgICAgdChrKHRoaXMsIEFlKSwgayh0aGlzLCBXKSwgYSk7XG4gICAgfSksIG4gJiYgSyh0aGlzLCBfZSwgKGEpID0+IHtcbiAgICAgIG4oayh0aGlzLCBBZSksIGsodGhpcywgVyksIGEpO1xuICAgIH0pLCBLKHRoaXMsIHJ0LCBrKHRoaXMsIFcpLnBhcmVudEVsZW1lbnQpO1xuICB9XG4gIG9uQWRkKGUpIHtcbiAgICByZXR1cm4gSyh0aGlzLCBBZSwgZSksIGsodGhpcywgVGUpICYmIGsodGhpcywgVykuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGsodGhpcywgVGUpKSwgayh0aGlzLCBfZSkgJiYgayh0aGlzLCBBZSkub24oXCJyZW5kZXJcIiwgayh0aGlzLCBfZSkpLCBrdChrKHRoaXMsIFcpKSwgayh0aGlzLCBXKTtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBrKHRoaXMsIFRlKSAmJiBrKHRoaXMsIFcpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBrKHRoaXMsIFRlKSksIGsodGhpcywgX2UpICYmIGsodGhpcywgQWUpLm9mZihcInJlbmRlclwiLCBrKHRoaXMsIF9lKSksIGsodGhpcywgcnQpID8gayh0aGlzLCBydCkuYXBwZW5kQ2hpbGQoayh0aGlzLCBXKSkgOiBrdChrKHRoaXMsIFcpKTtcbiAgfVxufVxuQWUgPSBuZXcgV2Vha01hcCgpLCBXID0gbmV3IFdlYWtNYXAoKSwgVGUgPSBuZXcgV2Vha01hcCgpLCBfZSA9IG5ldyBXZWFrTWFwKCksIHJ0ID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIHJ1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdih0aGlzLCBcIm1hcFwiKTtcbiAgICB2KHRoaXMsIFwiY29udGFpbmVyXCIpO1xuICAgIHYodGhpcywgXCJwcm9qZWN0aW9uQnV0dG9uXCIpO1xuICB9XG4gIG9uQWRkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAgPSBlLCB0aGlzLmNvbnRhaW5lciA9IExlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cFwiKSwgdGhpcy5wcm9qZWN0aW9uQnV0dG9uID0gTGUoXCJidXR0b25cIiwgXCJtYXBsaWJyZWdsLWN0cmwtcHJvamVjdGlvblwiLCB0aGlzLmNvbnRhaW5lciksIExlKFwic3BhblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1pY29uXCIsIHRoaXMucHJvamVjdGlvbkJ1dHRvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCB0aGlzLnByb2plY3Rpb25CdXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMucHJvamVjdGlvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGVQcm9qZWN0aW9uLmJpbmQodGhpcykpLCBlLm9uKFwicHJvamVjdGlvbnRyYW5zaXRpb25cIiwgdGhpcy51cGRhdGVQcm9qZWN0aW9uSWNvbi5iaW5kKHRoaXMpKSwgdGhpcy51cGRhdGVQcm9qZWN0aW9uSWNvbigpLCB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBrdCh0aGlzLmNvbnRhaW5lciksIHRoaXMubWFwLm9mZihcInByb2plY3Rpb250cmFuc2l0aW9uXCIsIHRoaXMudXBkYXRlUHJvamVjdGlvbkljb24pLCB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgfVxuICB0b2dnbGVQcm9qZWN0aW9uKCkge1xuICAgIHZvKHRoaXMubWFwKSwgdGhpcy51cGRhdGVQcm9qZWN0aW9uSWNvbigpO1xuICB9XG4gIHVwZGF0ZVByb2plY3Rpb25JY29uKCkge1xuICAgIHRoaXMucHJvamVjdGlvbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXByb2plY3Rpb24tZ2xvYmVcIiksIHRoaXMucHJvamVjdGlvbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLXByb2plY3Rpb24tbWVyY2F0b3JcIiksIHRoaXMubWFwLmlzR2xvYmVQcm9qZWN0aW9uKCkgPyAodGhpcy5wcm9qZWN0aW9uQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtcHJvamVjdGlvbi1tZXJjYXRvclwiKSwgdGhpcy5wcm9qZWN0aW9uQnV0dG9uLnRpdGxlID0gXCJFbmFibGUgTWVyY2F0b3IgcHJvamVjdGlvblwiKSA6ICh0aGlzLnByb2plY3Rpb25CdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1wcm9qZWN0aW9uLWdsb2JlXCIpLCB0aGlzLnByb2plY3Rpb25CdXR0b24udGl0bGUgPSBcIkVuYWJsZSBHbG9iZSBwcm9qZWN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiB2byhyKSB7XG4gIHIuZ2V0UHJvamVjdGlvbigpID09PSB2b2lkIDAgJiYgci5zZXRQcm9qZWN0aW9uKHsgdHlwZTogXCJtZXJjYXRvclwiIH0pLCByLmlzR2xvYmVQcm9qZWN0aW9uKCkgPyByLmVuYWJsZU1lcmNhdG9yUHJvamVjdGlvbigpIDogci5lbmFibGVHbG9iZVByb2plY3Rpb24oKTtcbn1cbmNvbnN0IHV0ID0ge1xuICBcInpvb20taW5cIjogKHIpID0+IHIuem9vbUluKCksXG4gIFwiem9vbS1vdXRcIjogKHIpID0+IHIuem9vbU91dCgpLFxuICBcInRvZ2dsZS1wcm9qZWN0aW9uXCI6IHZvLFxuICBcInRvZ2dsZS10ZXJyYWluXCI6IGdvLFxuICBcInJlc2V0LXZpZXdcIjogKHIpID0+IHtcbiAgICByLmdldFBpdGNoKCkgPT09IDAgPyByLmVhc2VUbyh7IHBpdGNoOiBNYXRoLm1pbihyLmdldE1heFBpdGNoKCksIDgwKSB9KSA6IHIucmVzZXROb3J0aFBpdGNoKCk7XG4gIH0sXG4gIFwicmVzZXQtYmVhcmluZ1wiOiAocikgPT4ge1xuICAgIHIucm90YXRlVG8oMCk7XG4gIH0sXG4gIFwicmVzZXQtcGl0Y2hcIjogKHIpID0+IHtcbiAgICByLnNldFBpdGNoKDApO1xuICB9LFxuICBcInJlc2V0LXJvbGxcIjogKHIpID0+IHtcbiAgICByLnNldFJvbGwoMCk7XG4gIH1cbn07XG52YXIgQ3QsIG50O1xuY2xhc3MgR3IgZXh0ZW5kcyB0dSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEV4dGVybmFsIENvbnRyb2wgdG8gaGF2ZSBhIHByZWRlZmluZWQgZnVuY3Rpb25hbGl0eVxuICAgKiBAcGFyYW0gY29udHJvbEVsZW1lbnQgRWxlbWVudCB0byBiZSB1c2VkIGFzIGNvbnRyb2wsIHNwZWNpZmllZCBhcyByZWZlcmVuY2UgdG8gZWxlbWVudCBpdHNlbGZcbiAgICogQHBhcmFtIGNvbnRyb2xUeXBlIE9uZSBvZiB0aGUgcHJlZGVmaW5lZCB0eXBlcyBvZiBmdW5jdGlvbmFsaXR5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgaWYgKG4gJiYgIShuIGluIHV0KSkgdGhyb3cgbmV3IEVycm9yKGBkYXRhLW1hcHRpbGVyLWNvbnRyb2wgdmFsdWUgXCIke259XCIgaXMgaW52YWxpZC5gKTtcbiAgICBzdXBlcih0LCBuICYmIHV0W25dKTtcbiAgICBaKHRoaXMsIEN0KTtcbiAgICBaKHRoaXMsIG50LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBvbkFkZCh0KSB7XG4gICAgcmV0dXJuIEsodGhpcywgQ3QsIHQpLCBzdXBlci5vbkFkZCh0KTtcbiAgfVxuICBvblJlbW92ZSgpIHtcbiAgICBmb3IgKGNvbnN0IFt0LCBuXSBvZiBrKHRoaXMsIG50KSkge1xuICAgICAgY29uc3QgYSA9IHQuZGVyZWYoKTtcbiAgICAgIGEgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgbik7XG4gICAgfVxuICAgIGsodGhpcywgbnQpLmNsZWFyKCksIHN1cGVyLm9uUmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSBhIGNoaWxkIGVsZW1lbnQgdG8gYmUgcGFydCBvZiB0aGlzIGNvbnRyb2wgYW5kIHRvIGhhdmUgYSBwcmVkZWZpbmVkIGZ1bmN0aW9uYWxpdHkgYWRkZWRcbiAgICogQHBhcmFtIGNvbnRyb2xFbGVtZW50IEVsZW1lbnQgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGNvbnRyb2wgZWxlbWVudCBhbmQgdGhhdCBvcHRpb25hbGx5IHNob3VsZCBoYXZlIHNvbWUgZnVuY3Rpb25hbGl0eVxuICAgKiBAcGFyYW0gY29udHJvbFR5cGUgT25lIG9mIHRoZSBwcmVkZWZpbmVkIHR5cGVzIG9mIGZ1bmN0aW9uYWxpdHlcbiAgICovXG4gIGNvbmZpZ3VyZUdyb3VwSXRlbSh0LCBuKSB7XG4gICAgaWYgKCFuKSByZXR1cm47XG4gICAgaWYgKCEobiBpbiB1dCkpIHRocm93IG5ldyBFcnJvcihgZGF0YS1tYXB0aWxlci1jb250cm9sIHZhbHVlIFwiJHtufVwiIGlzIGludmFsaWQuYCk7XG4gICAgY29uc3QgYSA9IChvKSA9PiB7XG4gICAgICB1dFtuXShrKHRoaXMsIEN0KSwgdCwgbyk7XG4gICAgfTtcbiAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhKSwgayh0aGlzLCBudCkuc2V0KG5ldyBXZWFrUmVmKHQpLCBhKTtcbiAgfVxufVxuQ3QgPSBuZXcgV2Vha01hcCgpLCBudCA9IG5ldyBXZWFrTWFwKCksIHYoR3IsIFwiY29udHJvbENhbGxiYWNrc1wiLCB1dCk7XG52YXIgSiwgcGUsIEllLCBNZSwgZWUsIEV0LCBWLCBibywgbmUsIHdvO1xuY2xhc3MgRXIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgWih0aGlzLCBWKTtcbiAgICBaKHRoaXMsIEopO1xuICAgIHYodGhpcywgXCJtYXBcIik7XG4gICAgWih0aGlzLCBwZSk7XG4gICAgWih0aGlzLCBJZSk7XG4gICAgWih0aGlzLCBNZSk7XG4gICAgWih0aGlzLCBlZSwgITEpO1xuICAgIFoodGhpcywgRXQpO1xuICAgIGUuc3R5bGUgIT09IHZvaWQgMCAmJiBLKHRoaXMsIGVlLCAhMCksIEsodGhpcywgSiwge1xuICAgICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgICB6b29tQWRqdXN0OiAtNCxcbiAgICAgIHBvc2l0aW9uOiBcInRvcC1yaWdodFwiLFxuICAgICAgLy8gaW5oZXJpdCBtYXAgb3B0aW9uc1xuICAgICAgLi4udCxcbiAgICAgIC8vIG92ZXJyaWRlIGFueSBsaW5nZXJpbmcgY29udHJvbCBvcHRpb25zXG4gICAgICBmb3JjZU5vQXR0cmlidXRpb25Db250cm9sOiAhMCxcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogITEsXG4gICAgICBuYXZpZ2F0aW9uQ29udHJvbDogITEsXG4gICAgICBnZW9sb2NhdGVDb250cm9sOiAhMSxcbiAgICAgIG1hcHRpbGVyTG9nbzogITEsXG4gICAgICBtaW5pbWFwOiAhMSxcbiAgICAgIGhhc2g6ICExLFxuICAgICAgcGl0Y2hBZGp1c3Q6ICExLFxuICAgICAgLy8gb3ZlcnJpZGUgbWFwIG9wdGlvbnMgd2l0aCBuZXcgdXNlciBkZWZpbmVkIG1pbmltYXAgb3B0aW9uc1xuICAgICAgLi4uZSxcbiAgICAgIGNvbnRhaW5lclN0eWxlOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzAwMFwiLFxuICAgICAgICB3aWR0aDogXCI0MDBweFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMzAwcHhcIixcbiAgICAgICAgLi4uZS5jb250YWluZXJTdHlsZSA/PyB7fVxuICAgICAgfVxuICAgIH0pLCBlLmxvY2tab29tICE9PSB2b2lkIDAgJiYgKGsodGhpcywgSikubWluWm9vbSA9IGUubG9ja1pvb20sIGsodGhpcywgSikubWF4Wm9vbSA9IGUubG9ja1pvb20pO1xuICB9XG4gIHNldFN0eWxlKGUsIHQpIHtcbiAgICBrKHRoaXMsIGVlKSB8fCB0aGlzLm1hcC5zZXRTdHlsZShlLCB0KSwgWSh0aGlzLCBWLCBuZSkuY2FsbCh0aGlzKTtcbiAgfVxuICBhZGRMYXllcihlLCB0KSB7XG4gICAgcmV0dXJuIGsodGhpcywgZWUpIHx8IHRoaXMubWFwLmFkZExheWVyKGUsIHQpLCBZKHRoaXMsIFYsIG5lKS5jYWxsKHRoaXMpLCB0aGlzLm1hcDtcbiAgfVxuICBtb3ZlTGF5ZXIoZSwgdCkge1xuICAgIHJldHVybiBrKHRoaXMsIGVlKSB8fCB0aGlzLm1hcC5tb3ZlTGF5ZXIoZSwgdCksIFkodGhpcywgViwgbmUpLmNhbGwodGhpcyksIHRoaXMubWFwO1xuICB9XG4gIHJlbW92ZUxheWVyKGUpIHtcbiAgICByZXR1cm4gayh0aGlzLCBlZSkgfHwgdGhpcy5tYXAucmVtb3ZlTGF5ZXIoZSksIFkodGhpcywgViwgbmUpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgc2V0TGF5ZXJab29tUmFuZ2UoZSwgdCwgbikge1xuICAgIHJldHVybiBrKHRoaXMsIGVlKSB8fCB0aGlzLm1hcC5zZXRMYXllclpvb21SYW5nZShlLCB0LCBuKSwgWSh0aGlzLCBWLCBuZSkuY2FsbCh0aGlzKSwgdGhpcztcbiAgfVxuICBzZXRGaWx0ZXIoZSwgdCwgbikge1xuICAgIHJldHVybiBrKHRoaXMsIGVlKSB8fCB0aGlzLm1hcC5zZXRGaWx0ZXIoZSwgdCwgbiksIFkodGhpcywgViwgbmUpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgc2V0UGFpbnRQcm9wZXJ0eShlLCB0LCBuLCBhKSB7XG4gICAgcmV0dXJuIGsodGhpcywgZWUpIHx8IHRoaXMubWFwLnNldFBhaW50UHJvcGVydHkoZSwgdCwgbiwgYSksIFkodGhpcywgViwgbmUpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgc2V0TGF5b3V0UHJvcGVydHkoZSwgdCwgbiwgYSkge1xuICAgIHJldHVybiBrKHRoaXMsIGVlKSB8fCB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eShlLCB0LCBuLCBhKSwgWSh0aGlzLCBWLCBuZSkuY2FsbCh0aGlzKSwgdGhpcztcbiAgfVxuICBzZXRHbHlwaHMoZSwgdCkge1xuICAgIHJldHVybiBrKHRoaXMsIGVlKSB8fCB0aGlzLm1hcC5zZXRHbHlwaHMoZSwgdCksIFkodGhpcywgViwgbmUpLmNhbGwodGhpcyksIHRoaXM7XG4gIH1cbiAgb25BZGQoZSkge1xuICAgIEsodGhpcywgcGUsIGUpLCBLKHRoaXMsIEllLCBMZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybCBtYXBsaWJyZWdsLWN0cmwtZ3JvdXBcIikpO1xuICAgIGZvciAoY29uc3QgW3QsIG5dIG9mIE9iamVjdC5lbnRyaWVzKGsodGhpcywgSikuY29udGFpbmVyU3R5bGUpKVxuICAgICAgayh0aGlzLCBJZSkuc3R5bGUuc2V0UHJvcGVydHkodCwgbik7XG4gICAgcmV0dXJuIGsodGhpcywgSikuY29udGFpbmVyID0gayh0aGlzLCBJZSksIGsodGhpcywgSikuem9vbSA9IGUuZ2V0Wm9vbSgpICsgayh0aGlzLCBKKS56b29tQWRqdXN0LCB0aGlzLm1hcCA9IG5ldyBMbyhrKHRoaXMsIEopKSwgdGhpcy5tYXAub25jZShcInN0eWxlLmxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5tYXAucmVzaXplKCk7XG4gICAgfSksIHRoaXMubWFwLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIFkodGhpcywgViwgYm8pLmNhbGwodGhpcywgayh0aGlzLCBKKS5wYXJlbnRSZWN0KSwgSyh0aGlzLCBFdCwgWSh0aGlzLCBWLCB3bykuY2FsbCh0aGlzKSk7XG4gICAgfSksIGsodGhpcywgSWUpO1xuICB9XG4gIG9uUmVtb3ZlKCkge1xuICAgIHZhciBlO1xuICAgIChlID0gayh0aGlzLCBFdCkpID09IG51bGwgfHwgZS5jYWxsKHRoaXMpLCBrdChrKHRoaXMsIEllKSk7XG4gIH1cbn1cbkogPSBuZXcgV2Vha01hcCgpLCBwZSA9IG5ldyBXZWFrTWFwKCksIEllID0gbmV3IFdlYWtNYXAoKSwgTWUgPSBuZXcgV2Vha01hcCgpLCBlZSA9IG5ldyBXZWFrTWFwKCksIEV0ID0gbmV3IFdlYWtNYXAoKSwgViA9IG5ldyBXZWFrU2V0KCksIGJvID0gZnVuY3Rpb24oZSkge1xuICBlID09PSB2b2lkIDAgfHwgZS5saW5lUGFpbnQgPT09IHZvaWQgMCAmJiBlLmZpbGxQYWludCA9PT0gdm9pZCAwIHx8IChLKHRoaXMsIE1lLCB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgbmFtZTogXCJwYXJlbnRSZWN0XCJcbiAgICB9LFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgIGNvb3JkaW5hdGVzOiBbW1tdLCBbXSwgW10sIFtdLCBbXV1dXG4gICAgfVxuICB9KSwgdGhpcy5tYXAuYWRkU291cmNlKFwicGFyZW50UmVjdFwiLCB7XG4gICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgZGF0YTogayh0aGlzLCBNZSlcbiAgfSksIChlLmxpbmVMYXlvdXQgIT09IHZvaWQgMCB8fCBlLmxpbmVQYWludCAhPT0gdm9pZCAwKSAmJiB0aGlzLm1hcC5hZGRMYXllcih7XG4gICAgaWQ6IFwicGFyZW50UmVjdE91dGxpbmVcIixcbiAgICB0eXBlOiBcImxpbmVcIixcbiAgICBzb3VyY2U6IFwicGFyZW50UmVjdFwiLFxuICAgIGxheW91dDoge1xuICAgICAgLi4uZS5saW5lTGF5b3V0XG4gICAgfSxcbiAgICBwYWludDoge1xuICAgICAgXCJsaW5lLWNvbG9yXCI6IFwiI0ZGRlwiLFxuICAgICAgXCJsaW5lLXdpZHRoXCI6IDEsXG4gICAgICBcImxpbmUtb3BhY2l0eVwiOiAwLjg1LFxuICAgICAgLi4uZS5saW5lUGFpbnRcbiAgICB9XG4gIH0pLCBlLmZpbGxQYWludCAhPT0gdm9pZCAwICYmIHRoaXMubWFwLmFkZExheWVyKHtcbiAgICBpZDogXCJwYXJlbnRSZWN0RmlsbFwiLFxuICAgIHR5cGU6IFwiZmlsbFwiLFxuICAgIHNvdXJjZTogXCJwYXJlbnRSZWN0XCIsXG4gICAgbGF5b3V0OiB7fSxcbiAgICBwYWludDoge1xuICAgICAgXCJmaWxsLWNvbG9yXCI6IFwiIzA4RlwiLFxuICAgICAgXCJmaWxsLW9wYWNpdHlcIjogMC4xMzUsXG4gICAgICAuLi5lLmZpbGxQYWludFxuICAgIH1cbiAgfSksIFkodGhpcywgViwgbmUpLmNhbGwodGhpcykpO1xufSwgbmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGsodGhpcywgTWUpID09PSB2b2lkIDApIHJldHVybjtcbiAgY29uc3QgeyBkZXZpY2VQaXhlbFJhdGlvOiBlIH0gPSB3aW5kb3csIHQgPSBrKHRoaXMsIHBlKS5nZXRDYW52YXMoKSwgbiA9IHQud2lkdGggLyBlLCBhID0gdC5oZWlnaHQgLyBlLCBvID0gayh0aGlzLCBwZSkudW5wcm9qZWN0LmJpbmQoayh0aGlzLCBwZSkpLCBpID0gbyhbMCwgMF0pLCBzID0gbyhbbiwgMF0pLCBsID0gbyhbMCwgYV0pLCB1ID0gbyhbbiwgYV0pO1xuICBrKHRoaXMsIE1lKS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IFtbbC50b0FycmF5KCksIHUudG9BcnJheSgpLCBzLnRvQXJyYXkoKSwgaS50b0FycmF5KCksIGwudG9BcnJheSgpXV07XG4gIGNvbnN0IGMgPSB0aGlzLm1hcC5nZXRTb3VyY2UoXCJwYXJlbnRSZWN0XCIpO1xuICBjICE9PSB2b2lkIDAgJiYgYy5zZXREYXRhKGsodGhpcywgTWUpKTtcbn0sIHdvID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHsgcGl0Y2hBZGp1c3Q6IGUgfSA9IGsodGhpcywgSiksIHQgPSAoKSA9PiB7XG4gICAgaShcInBhcmVudFwiKTtcbiAgfSwgbiA9ICgpID0+IHtcbiAgICBpKFwibWluaW1hcFwiKTtcbiAgfSwgYSA9ICgpID0+IHtcbiAgICBrKHRoaXMsIHBlKS5vbihcIm1vdmVcIiwgdCksIHRoaXMubWFwLm9uKFwibW92ZVwiLCBuKTtcbiAgfSwgbyA9ICgpID0+IHtcbiAgICBrKHRoaXMsIHBlKS5vZmYoXCJtb3ZlXCIsIHQpLCB0aGlzLm1hcC5vZmYoXCJtb3ZlXCIsIG4pO1xuICB9LCBpID0gKHMpID0+IHtcbiAgICBvKCk7XG4gICAgY29uc3QgbCA9IHMgPT09IFwicGFyZW50XCIgPyBrKHRoaXMsIHBlKSA6IHRoaXMubWFwLCB1ID0gcyA9PT0gXCJwYXJlbnRcIiA/IHRoaXMubWFwIDogayh0aGlzLCBwZSksIGMgPSBsLmdldENlbnRlcigpLCBwID0gbC5nZXRab29tKCkgKyBrKHRoaXMsIEopLnpvb21BZGp1c3QgKiAocyA9PT0gXCJwYXJlbnRcIiA/IDEgOiAtMSksIGQgPSBsLmdldEJlYXJpbmcoKSwgZiA9IGwuZ2V0UGl0Y2goKTtcbiAgICB1Lmp1bXBUbyh7XG4gICAgICBjZW50ZXI6IGMsXG4gICAgICB6b29tOiBwLFxuICAgICAgYmVhcmluZzogZCxcbiAgICAgIHBpdGNoOiBlID8gZiA6IDBcbiAgICB9KSwgWSh0aGlzLCBWLCBuZSkuY2FsbCh0aGlzKSwgYSgpO1xuICB9O1xuICByZXR1cm4gYSgpLCAoKSA9PiB7XG4gICAgbygpO1xuICB9O1xufTtcbmNsYXNzIG51IHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtYXAgOiBhIE1hcCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gZGVsYXkgOiBhIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgcGF5bG9hZCBpcyBzZW50IHRvIE1hcFRpbGVyIGNsb3VkIChjYW5ub3QgYmUgbGVzcyB0aGFuIDEwMDBtcylcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQgPSAyZTMpIHtcbiAgICB2KHRoaXMsIFwibWFwXCIpO1xuICAgIHYodGhpcywgXCJyZWdpc3RlcmVkTW9kdWxlc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB2KHRoaXMsIFwidmlld2VyVHlwZVwiKTtcbiAgICB0aGlzLm1hcCA9IGUsIHRoaXMudmlld2VyVHlwZSA9IFwiTWFwXCIsIHNldFRpbWVvdXQoXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghai50ZWxlbWV0cnkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5wcmVwYXJlUGF5bG9hZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIChhd2FpdCBmZXRjaChuLCB7IG1ldGhvZDogXCJQT1NUXCIgfSkpLm9rIHx8IGNvbnNvbGUud2FybihcIlRoZSBtZXRyaWNzIGNvdWxkIG5vdCBiZSBzZW50IHRvIE1hcFRpbGVyIENsb3VkXCIpO1xuICAgICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG1ldHJpY3MgY291bGQgbm90IGJlIHNlbnQgdG8gTWFwVGlsZXIgQ2xvdWRcIiwgYSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBNYXRoLm1heCgxZTMsIHQpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBtb2R1bGUgdG8gdGhlIHRlbGVtZXRyeSBzeXN0ZW0gb2YgdGhlIFNESy5cbiAgICogVGhlIGFyZ3VtZW50cyBgbmFtZWAgYW5kIGB2ZXJzaW9uYCBsaWtlbHkgY29tZSBmcm9tIHRoZSBwYWNrYWdlLmpzb25cbiAgICogb2YgZWFjaCBtb2R1bGUuXG4gICAqL1xuICByZWdpc3Rlck1vZHVsZShlLCB0KSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTW9kdWxlcy5hZGQoYCR7ZX06JHt0fWApO1xuICB9XG4gIHJlZ2lzdGVyVmlld2VyVHlwZShlID0gXCJNYXBcIikge1xuICAgIHRoaXMudmlld2VyVHlwZSA9IGU7XG4gIH1cbiAgcHJlcGFyZVBheWxvYWQoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBVUkwoWC50ZWxlbWV0cnlVUkwpO1xuICAgIHJldHVybiBlLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzZGtcIiwgeGMoKSksIGUuc2VhcmNoUGFyYW1zLmFwcGVuZChcImtleVwiLCBqLmFwaUtleSksIGUuc2VhcmNoUGFyYW1zLmFwcGVuZChcIm10c2lkXCIsIHRuKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic2Vzc2lvblwiLCBqLnNlc3Npb24gPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2FjaGluZ1wiLCBqLmNhY2hpbmcgPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibGFuZy11cGRhdGVkXCIsIHRoaXMubWFwLmlzTGFuZ3VhZ2VVcGRhdGVkKCkgPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwidGVycmFpblwiLCB0aGlzLm1hcC5nZXRUZXJyYWluKCkgPyBcIjFcIiA6IFwiMFwiKSwgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiZ2xvYmVcIiwgdGhpcy5tYXAuaXNHbG9iZVByb2plY3Rpb24oKSA/IFwiMVwiIDogXCIwXCIpLCBlLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJ2aWV3ZXJUeXBlXCIsIHRoaXMudmlld2VyVHlwZSksIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMuc2l6ZSA+IDAgJiYgZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibW9kdWxlc1wiLCBBcnJheS5mcm9tKHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMpLmpvaW4oXCJ8XCIpKSwgZS5ocmVmO1xuICB9XG59XG52YXIgTHQgPSB0eXBlb2YgRmxvYXQzMkFycmF5IDwgXCJ1XCIgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbk1hdGguaHlwb3QgfHwgKE1hdGguaHlwb3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgciA9IDAsIGUgPSBhcmd1bWVudHMubGVuZ3RoOyBlLS07IClcbiAgICByICs9IGFyZ3VtZW50c1tlXSAqIGFyZ3VtZW50c1tlXTtcbiAgcmV0dXJuIE1hdGguc3FydChyKTtcbn0pO1xuZnVuY3Rpb24gbXQoKSB7XG4gIHZhciByID0gbmV3IEx0KDE2KTtcbiAgcmV0dXJuIEx0ICE9IEZsb2F0MzJBcnJheSAmJiAoclsxXSA9IDAsIHJbMl0gPSAwLCByWzNdID0gMCwgcls0XSA9IDAsIHJbNl0gPSAwLCByWzddID0gMCwgcls4XSA9IDAsIHJbOV0gPSAwLCByWzExXSA9IDAsIHJbMTJdID0gMCwgclsxM10gPSAwLCByWzE0XSA9IDApLCByWzBdID0gMSwgcls1XSA9IDEsIHJbMTBdID0gMSwgclsxNV0gPSAxLCByO1xufVxuZnVuY3Rpb24gYXUociwgZSwgdCwgbiwgYSwgbywgaSwgcywgbCwgdSwgYywgcCwgZCwgZiwgaCwgbSwgeSkge1xuICByZXR1cm4gclswXSA9IGUsIHJbMV0gPSB0LCByWzJdID0gbiwgclszXSA9IGEsIHJbNF0gPSBvLCByWzVdID0gaSwgcls2XSA9IHMsIHJbN10gPSBsLCByWzhdID0gdSwgcls5XSA9IGMsIHJbMTBdID0gcCwgclsxMV0gPSBkLCByWzEyXSA9IGYsIHJbMTNdID0gaCwgclsxNF0gPSBtLCByWzE1XSA9IHksIHI7XG59XG5mdW5jdGlvbiBvdShyLCBlLCB0KSB7XG4gIHZhciBuID0gZVswXSwgYSA9IGVbMV0sIG8gPSBlWzJdLCBpID0gZVszXSwgcyA9IGVbNF0sIGwgPSBlWzVdLCB1ID0gZVs2XSwgYyA9IGVbN10sIHAgPSBlWzhdLCBkID0gZVs5XSwgZiA9IGVbMTBdLCBoID0gZVsxMV0sIG0gPSBlWzEyXSwgeSA9IGVbMTNdLCB3ID0gZVsxNF0sIGcgPSBlWzE1XSwgeCA9IHRbMF0sIEUgPSB0WzFdLCBDID0gdFsyXSwgVCA9IHRbM107XG4gIHJldHVybiByWzBdID0geCAqIG4gKyBFICogcyArIEMgKiBwICsgVCAqIG0sIHJbMV0gPSB4ICogYSArIEUgKiBsICsgQyAqIGQgKyBUICogeSwgclsyXSA9IHggKiBvICsgRSAqIHUgKyBDICogZiArIFQgKiB3LCByWzNdID0geCAqIGkgKyBFICogYyArIEMgKiBoICsgVCAqIGcsIHggPSB0WzRdLCBFID0gdFs1XSwgQyA9IHRbNl0sIFQgPSB0WzddLCByWzRdID0geCAqIG4gKyBFICogcyArIEMgKiBwICsgVCAqIG0sIHJbNV0gPSB4ICogYSArIEUgKiBsICsgQyAqIGQgKyBUICogeSwgcls2XSA9IHggKiBvICsgRSAqIHUgKyBDICogZiArIFQgKiB3LCByWzddID0geCAqIGkgKyBFICogYyArIEMgKiBoICsgVCAqIGcsIHggPSB0WzhdLCBFID0gdFs5XSwgQyA9IHRbMTBdLCBUID0gdFsxMV0sIHJbOF0gPSB4ICogbiArIEUgKiBzICsgQyAqIHAgKyBUICogbSwgcls5XSA9IHggKiBhICsgRSAqIGwgKyBDICogZCArIFQgKiB5LCByWzEwXSA9IHggKiBvICsgRSAqIHUgKyBDICogZiArIFQgKiB3LCByWzExXSA9IHggKiBpICsgRSAqIGMgKyBDICogaCArIFQgKiBnLCB4ID0gdFsxMl0sIEUgPSB0WzEzXSwgQyA9IHRbMTRdLCBUID0gdFsxNV0sIHJbMTJdID0geCAqIG4gKyBFICogcyArIEMgKiBwICsgVCAqIG0sIHJbMTNdID0geCAqIGEgKyBFICogbCArIEMgKiBkICsgVCAqIHksIHJbMTRdID0geCAqIG8gKyBFICogdSArIEMgKiBmICsgVCAqIHcsIHJbMTVdID0geCAqIGkgKyBFICogYyArIEMgKiBoICsgVCAqIGcsIHI7XG59XG5mdW5jdGlvbiBpdShyLCBlLCB0KSB7XG4gIHZhciBuID0gdFswXSwgYSA9IHRbMV0sIG8gPSB0WzJdO1xuICByZXR1cm4gclswXSA9IGVbMF0gKiBuLCByWzFdID0gZVsxXSAqIG4sIHJbMl0gPSBlWzJdICogbiwgclszXSA9IGVbM10gKiBuLCByWzRdID0gZVs0XSAqIGEsIHJbNV0gPSBlWzVdICogYSwgcls2XSA9IGVbNl0gKiBhLCByWzddID0gZVs3XSAqIGEsIHJbOF0gPSBlWzhdICogbywgcls5XSA9IGVbOV0gKiBvLCByWzEwXSA9IGVbMTBdICogbywgclsxMV0gPSBlWzExXSAqIG8sIHJbMTJdID0gZVsxMl0sIHJbMTNdID0gZVsxM10sIHJbMTRdID0gZVsxNF0sIHJbMTVdID0gZVsxNV0sIHI7XG59XG5mdW5jdGlvbiBsYShyLCBlLCB0KSB7XG4gIHZhciBuID0gTWF0aC5zaW4odCksIGEgPSBNYXRoLmNvcyh0KSwgbyA9IGVbNF0sIGkgPSBlWzVdLCBzID0gZVs2XSwgbCA9IGVbN10sIHUgPSBlWzhdLCBjID0gZVs5XSwgcCA9IGVbMTBdLCBkID0gZVsxMV07XG4gIHJldHVybiBlICE9PSByICYmIChyWzBdID0gZVswXSwgclsxXSA9IGVbMV0sIHJbMl0gPSBlWzJdLCByWzNdID0gZVszXSwgclsxMl0gPSBlWzEyXSwgclsxM10gPSBlWzEzXSwgclsxNF0gPSBlWzE0XSwgclsxNV0gPSBlWzE1XSksIHJbNF0gPSBvICogYSArIHUgKiBuLCByWzVdID0gaSAqIGEgKyBjICogbiwgcls2XSA9IHMgKiBhICsgcCAqIG4sIHJbN10gPSBsICogYSArIGQgKiBuLCByWzhdID0gdSAqIGEgLSBvICogbiwgcls5XSA9IGMgKiBhIC0gaSAqIG4sIHJbMTBdID0gcCAqIGEgLSBzICogbiwgclsxMV0gPSBkICogYSAtIGwgKiBuLCByO1xufVxuZnVuY3Rpb24gc3UociwgZSwgdCkge1xuICB2YXIgbiA9IE1hdGguc2luKHQpLCBhID0gTWF0aC5jb3ModCksIG8gPSBlWzBdLCBpID0gZVsxXSwgcyA9IGVbMl0sIGwgPSBlWzNdLCB1ID0gZVs4XSwgYyA9IGVbOV0sIHAgPSBlWzEwXSwgZCA9IGVbMTFdO1xuICByZXR1cm4gZSAhPT0gciAmJiAocls0XSA9IGVbNF0sIHJbNV0gPSBlWzVdLCByWzZdID0gZVs2XSwgcls3XSA9IGVbN10sIHJbMTJdID0gZVsxMl0sIHJbMTNdID0gZVsxM10sIHJbMTRdID0gZVsxNF0sIHJbMTVdID0gZVsxNV0pLCByWzBdID0gbyAqIGEgLSB1ICogbiwgclsxXSA9IGkgKiBhIC0gYyAqIG4sIHJbMl0gPSBzICogYSAtIHAgKiBuLCByWzNdID0gbCAqIGEgLSBkICogbiwgcls4XSA9IG8gKiBuICsgdSAqIGEsIHJbOV0gPSBpICogbiArIGMgKiBhLCByWzEwXSA9IHMgKiBuICsgcCAqIGEsIHJbMTFdID0gbCAqIG4gKyBkICogYSwgcjtcbn1cbmZ1bmN0aW9uIHVhKHIsIGUsIHQpIHtcbiAgdmFyIG4gPSBNYXRoLnNpbih0KSwgYSA9IE1hdGguY29zKHQpLCBvID0gZVswXSwgaSA9IGVbMV0sIHMgPSBlWzJdLCBsID0gZVszXSwgdSA9IGVbNF0sIGMgPSBlWzVdLCBwID0gZVs2XSwgZCA9IGVbN107XG4gIHJldHVybiBlICE9PSByICYmIChyWzhdID0gZVs4XSwgcls5XSA9IGVbOV0sIHJbMTBdID0gZVsxMF0sIHJbMTFdID0gZVsxMV0sIHJbMTJdID0gZVsxMl0sIHJbMTNdID0gZVsxM10sIHJbMTRdID0gZVsxNF0sIHJbMTVdID0gZVsxNV0pLCByWzBdID0gbyAqIGEgKyB1ICogbiwgclsxXSA9IGkgKiBhICsgYyAqIG4sIHJbMl0gPSBzICogYSArIHAgKiBuLCByWzNdID0gbCAqIGEgKyBkICogbiwgcls0XSA9IHUgKiBhIC0gbyAqIG4sIHJbNV0gPSBjICogYSAtIGkgKiBuLCByWzZdID0gcCAqIGEgLSBzICogbiwgcls3XSA9IGQgKiBhIC0gbCAqIG4sIHI7XG59XG5mdW5jdGlvbiBsdShyLCBlLCB0LCBuLCBhKSB7XG4gIHZhciBvID0gMSAvIE1hdGgudGFuKGUgLyAyKSwgaTtcbiAgcmV0dXJuIHJbMF0gPSBvIC8gdCwgclsxXSA9IDAsIHJbMl0gPSAwLCByWzNdID0gMCwgcls0XSA9IDAsIHJbNV0gPSBvLCByWzZdID0gMCwgcls3XSA9IDAsIHJbOF0gPSAwLCByWzldID0gMCwgclsxMV0gPSAtMSwgclsxMl0gPSAwLCByWzEzXSA9IDAsIHJbMTVdID0gMCwgYSAhPSBudWxsICYmIGEgIT09IDEgLyAwID8gKGkgPSAxIC8gKG4gLSBhKSwgclsxMF0gPSAoYSArIG4pICogaSwgclsxNF0gPSAyICogYSAqIG4gKiBpKSA6IChyWzEwXSA9IC0xLCByWzE0XSA9IC0yICogbiksIHI7XG59XG52YXIgdXUgPSBsdTtcbmZ1bmN0aW9uIE50KCkge1xuICB2YXIgciA9IG5ldyBMdCgzKTtcbiAgcmV0dXJuIEx0ICE9IEZsb2F0MzJBcnJheSAmJiAoclswXSA9IDAsIHJbMV0gPSAwLCByWzJdID0gMCksIHI7XG59XG5mdW5jdGlvbiBjdShyLCBlLCB0KSB7XG4gIHZhciBuID0gbmV3IEx0KDMpO1xuICByZXR1cm4gblswXSA9IHIsIG5bMV0gPSBlLCBuWzJdID0gdCwgbjtcbn1cbmZ1bmN0aW9uIEFyKHIsIGUpIHtcbiAgdmFyIHQgPSBlWzBdLCBuID0gZVsxXSwgYSA9IGVbMl0sIG8gPSB0ICogdCArIG4gKiBuICsgYSAqIGE7XG4gIHJldHVybiBvID4gMCAmJiAobyA9IDEgLyBNYXRoLnNxcnQobykpLCByWzBdID0gZVswXSAqIG8sIHJbMV0gPSBlWzFdICogbywgclsyXSA9IGVbMl0gKiBvLCByO1xufVxuZnVuY3Rpb24gY2EociwgZSwgdCkge1xuICB2YXIgbiA9IGVbMF0sIGEgPSBlWzFdLCBvID0gZVsyXSwgaSA9IHRbMF0sIHMgPSB0WzFdLCBsID0gdFsyXTtcbiAgcmV0dXJuIHJbMF0gPSBhICogbCAtIG8gKiBzLCByWzFdID0gbyAqIGkgLSBuICogbCwgclsyXSA9IG4gKiBzIC0gYSAqIGksIHI7XG59XG4oZnVuY3Rpb24oKSB7XG4gIHZhciByID0gTnQoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIHQsIG4sIGEsIG8sIGkpIHtcbiAgICB2YXIgcywgbDtcbiAgICBmb3IgKHQgfHwgKHQgPSAzKSwgbiB8fCAobiA9IDApLCBhID8gbCA9IE1hdGgubWluKGEgKiB0ICsgbiwgZS5sZW5ndGgpIDogbCA9IGUubGVuZ3RoLCBzID0gbjsgcyA8IGw7IHMgKz0gdClcbiAgICAgIHJbMF0gPSBlW3NdLCByWzFdID0gZVtzICsgMV0sIHJbMl0gPSBlW3MgKyAyXSwgbyhyLCByLCBpKSwgZVtzXSA9IHJbMF0sIGVbcyArIDFdID0gclsxXSwgZVtzICsgMl0gPSByWzJdO1xuICAgIHJldHVybiBlO1xuICB9O1xufSkoKTtcbmZ1bmN0aW9uIHB1KHIpIHtcbiAgcmV0dXJuIHIgJiYgci5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLCBcImRlZmF1bHRcIikgPyByLmRlZmF1bHQgOiByO1xufVxudmFyIFRyLCBwYTtcbmZ1bmN0aW9uIGZ1KCkge1xuICByZXR1cm4gcGEgfHwgKHBhID0gMSwgVHIgPSB7XG4gICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gICAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICAgIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcbiAgICByZWQ6IFsyNTUsIDAsIDBdLFxuICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gICAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gICAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG4gIH0pLCBUcjtcbn1cbnZhciBfciwgZmE7XG5mdW5jdGlvbiBTbygpIHtcbiAgaWYgKGZhKSByZXR1cm4gX3I7XG4gIGZhID0gMTtcbiAgY29uc3QgciA9IGZ1KCksIGUgPSB7fTtcbiAgZm9yIChjb25zdCBhIG9mIE9iamVjdC5rZXlzKHIpKVxuICAgIGVbclthXV0gPSBhO1xuICBjb25zdCB0ID0ge1xuICAgIHJnYjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInJnYlwiIH0sXG4gICAgaHNsOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwiaHNsXCIgfSxcbiAgICBoc3Y6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJoc3ZcIiB9LFxuICAgIGh3YjogeyBjaGFubmVsczogMywgbGFiZWxzOiBcImh3YlwiIH0sXG4gICAgY215azogeyBjaGFubmVsczogNCwgbGFiZWxzOiBcImNteWtcIiB9LFxuICAgIHh5ejogeyBjaGFubmVsczogMywgbGFiZWxzOiBcInh5elwiIH0sXG4gICAgbGFiOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFwibGFiXCIgfSxcbiAgICBsY2g6IHsgY2hhbm5lbHM6IDMsIGxhYmVsczogXCJsY2hcIiB9LFxuICAgIGhleDogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJoZXhcIl0gfSxcbiAgICBrZXl3b3JkOiB7IGNoYW5uZWxzOiAxLCBsYWJlbHM6IFtcImtleXdvcmRcIl0gfSxcbiAgICBhbnNpMTY6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiYW5zaTE2XCJdIH0sXG4gICAgYW5zaTI1NjogeyBjaGFubmVsczogMSwgbGFiZWxzOiBbXCJhbnNpMjU2XCJdIH0sXG4gICAgaGNnOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcImhcIiwgXCJjXCIsIFwiZ1wiXSB9LFxuICAgIGFwcGxlOiB7IGNoYW5uZWxzOiAzLCBsYWJlbHM6IFtcInIxNlwiLCBcImcxNlwiLCBcImIxNlwiXSB9LFxuICAgIGdyYXk6IHsgY2hhbm5lbHM6IDEsIGxhYmVsczogW1wiZ3JheVwiXSB9XG4gIH07XG4gIF9yID0gdDtcbiAgZm9yIChjb25zdCBhIG9mIE9iamVjdC5rZXlzKHQpKSB7XG4gICAgaWYgKCEoXCJjaGFubmVsc1wiIGluIHRbYV0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogXCIgKyBhKTtcbiAgICBpZiAoIShcImxhYmVsc1wiIGluIHRbYV0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogXCIgKyBhKTtcbiAgICBpZiAodFthXS5sYWJlbHMubGVuZ3RoICE9PSB0W2FdLmNoYW5uZWxzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiBcIiArIGEpO1xuICAgIGNvbnN0IHsgY2hhbm5lbHM6IG8sIGxhYmVsczogaSB9ID0gdFthXTtcbiAgICBkZWxldGUgdFthXS5jaGFubmVscywgZGVsZXRlIHRbYV0ubGFiZWxzLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodFthXSwgXCJjaGFubmVsc1wiLCB7IHZhbHVlOiBvIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodFthXSwgXCJsYWJlbHNcIiwgeyB2YWx1ZTogaSB9KTtcbiAgfVxuICB0LnJnYi5oc2wgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAyNTUsIGkgPSBhWzFdIC8gMjU1LCBzID0gYVsyXSAvIDI1NSwgbCA9IE1hdGgubWluKG8sIGksIHMpLCB1ID0gTWF0aC5tYXgobywgaSwgcyksIGMgPSB1IC0gbDtcbiAgICBsZXQgcCwgZDtcbiAgICB1ID09PSBsID8gcCA9IDAgOiBvID09PSB1ID8gcCA9IChpIC0gcykgLyBjIDogaSA9PT0gdSA/IHAgPSAyICsgKHMgLSBvKSAvIGMgOiBzID09PSB1ICYmIChwID0gNCArIChvIC0gaSkgLyBjKSwgcCA9IE1hdGgubWluKHAgKiA2MCwgMzYwKSwgcCA8IDAgJiYgKHAgKz0gMzYwKTtcbiAgICBjb25zdCBmID0gKGwgKyB1KSAvIDI7XG4gICAgcmV0dXJuIHUgPT09IGwgPyBkID0gMCA6IGYgPD0gMC41ID8gZCA9IGMgLyAodSArIGwpIDogZCA9IGMgLyAoMiAtIHUgLSBsKSwgW3AsIGQgKiAxMDAsIGYgKiAxMDBdO1xuICB9LCB0LnJnYi5oc3YgPSBmdW5jdGlvbihhKSB7XG4gICAgbGV0IG8sIGksIHMsIGwsIHU7XG4gICAgY29uc3QgYyA9IGFbMF0gLyAyNTUsIHAgPSBhWzFdIC8gMjU1LCBkID0gYVsyXSAvIDI1NSwgZiA9IE1hdGgubWF4KGMsIHAsIGQpLCBoID0gZiAtIE1hdGgubWluKGMsIHAsIGQpLCBtID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIChmIC0geSkgLyA2IC8gaCArIDEgLyAyO1xuICAgIH07XG4gICAgcmV0dXJuIGggPT09IDAgPyAobCA9IDAsIHUgPSAwKSA6ICh1ID0gaCAvIGYsIG8gPSBtKGMpLCBpID0gbShwKSwgcyA9IG0oZCksIGMgPT09IGYgPyBsID0gcyAtIGkgOiBwID09PSBmID8gbCA9IDEgLyAzICsgbyAtIHMgOiBkID09PSBmICYmIChsID0gMiAvIDMgKyBpIC0gbyksIGwgPCAwID8gbCArPSAxIDogbCA+IDEgJiYgKGwgLT0gMSkpLCBbXG4gICAgICBsICogMzYwLFxuICAgICAgdSAqIDEwMCxcbiAgICAgIGYgKiAxMDBcbiAgICBdO1xuICB9LCB0LnJnYi5od2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhWzFdO1xuICAgIGxldCBzID0gYVsyXTtcbiAgICBjb25zdCBsID0gdC5yZ2IuaHNsKGEpWzBdLCB1ID0gMSAvIDI1NSAqIE1hdGgubWluKG8sIE1hdGgubWluKGksIHMpKTtcbiAgICByZXR1cm4gcyA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgobywgTWF0aC5tYXgoaSwgcykpLCBbbCwgdSAqIDEwMCwgcyAqIDEwMF07XG4gIH0sIHQucmdiLmNteWsgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAyNTUsIGkgPSBhWzFdIC8gMjU1LCBzID0gYVsyXSAvIDI1NSwgbCA9IE1hdGgubWluKDEgLSBvLCAxIC0gaSwgMSAtIHMpLCB1ID0gKDEgLSBvIC0gbCkgLyAoMSAtIGwpIHx8IDAsIGMgPSAoMSAtIGkgLSBsKSAvICgxIC0gbCkgfHwgMCwgcCA9ICgxIC0gcyAtIGwpIC8gKDEgLSBsKSB8fCAwO1xuICAgIHJldHVybiBbdSAqIDEwMCwgYyAqIDEwMCwgcCAqIDEwMCwgbCAqIDEwMF07XG4gIH07XG4gIGZ1bmN0aW9uIG4oYSwgbykge1xuICAgIHJldHVybiAoYVswXSAtIG9bMF0pICoqIDIgKyAoYVsxXSAtIG9bMV0pICoqIDIgKyAoYVsyXSAtIG9bMl0pICoqIDI7XG4gIH1cbiAgcmV0dXJuIHQucmdiLmtleXdvcmQgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGVbYV07XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4gbztcbiAgICBsZXQgaSA9IDEgLyAwLCBzO1xuICAgIGZvciAoY29uc3QgbCBvZiBPYmplY3Qua2V5cyhyKSkge1xuICAgICAgY29uc3QgdSA9IHJbbF0sIGMgPSBuKGEsIHUpO1xuICAgICAgYyA8IGkgJiYgKGkgPSBjLCBzID0gbCk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LCB0LmtleXdvcmQucmdiID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiByW2FdO1xuICB9LCB0LnJnYi54eXogPSBmdW5jdGlvbihhKSB7XG4gICAgbGV0IG8gPSBhWzBdIC8gMjU1LCBpID0gYVsxXSAvIDI1NSwgcyA9IGFbMl0gLyAyNTU7XG4gICAgbyA9IG8gPiAwLjA0MDQ1ID8gKChvICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IG8gLyAxMi45MiwgaSA9IGkgPiAwLjA0MDQ1ID8gKChpICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IGkgLyAxMi45MiwgcyA9IHMgPiAwLjA0MDQ1ID8gKChzICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IHMgLyAxMi45MjtcbiAgICBjb25zdCBsID0gbyAqIDAuNDEyNCArIGkgKiAwLjM1NzYgKyBzICogMC4xODA1LCB1ID0gbyAqIDAuMjEyNiArIGkgKiAwLjcxNTIgKyBzICogMC4wNzIyLCBjID0gbyAqIDAuMDE5MyArIGkgKiAwLjExOTIgKyBzICogMC45NTA1O1xuICAgIHJldHVybiBbbCAqIDEwMCwgdSAqIDEwMCwgYyAqIDEwMF07XG4gIH0sIHQucmdiLmxhYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gdC5yZ2IueHl6KGEpO1xuICAgIGxldCBpID0gb1swXSwgcyA9IG9bMV0sIGwgPSBvWzJdO1xuICAgIGkgLz0gOTUuMDQ3LCBzIC89IDEwMCwgbCAvPSAxMDguODgzLCBpID0gaSA+IDg4NTZlLTYgPyBpICoqICgxIC8gMykgOiA3Ljc4NyAqIGkgKyAxNiAvIDExNiwgcyA9IHMgPiA4ODU2ZS02ID8gcyAqKiAoMSAvIDMpIDogNy43ODcgKiBzICsgMTYgLyAxMTYsIGwgPSBsID4gODg1NmUtNiA/IGwgKiogKDEgLyAzKSA6IDcuNzg3ICogbCArIDE2IC8gMTE2O1xuICAgIGNvbnN0IHUgPSAxMTYgKiBzIC0gMTYsIGMgPSA1MDAgKiAoaSAtIHMpLCBwID0gMjAwICogKHMgLSBsKTtcbiAgICByZXR1cm4gW3UsIGMsIHBdO1xuICB9LCB0LmhzbC5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAzNjAsIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBsZXQgbCwgdSwgYztcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIHJldHVybiBjID0gcyAqIDI1NSwgW2MsIGMsIGNdO1xuICAgIHMgPCAwLjUgPyBsID0gcyAqICgxICsgaSkgOiBsID0gcyArIGkgLSBzICogaTtcbiAgICBjb25zdCBwID0gMiAqIHMgLSBsLCBkID0gWzAsIDAsIDBdO1xuICAgIGZvciAobGV0IGYgPSAwOyBmIDwgMzsgZisrKVxuICAgICAgdSA9IG8gKyAxIC8gMyAqIC0oZiAtIDEpLCB1IDwgMCAmJiB1KyssIHUgPiAxICYmIHUtLSwgNiAqIHUgPCAxID8gYyA9IHAgKyAobCAtIHApICogNiAqIHUgOiAyICogdSA8IDEgPyBjID0gbCA6IDMgKiB1IDwgMiA/IGMgPSBwICsgKGwgLSBwKSAqICgyIC8gMyAtIHUpICogNiA6IGMgPSBwLCBkW2ZdID0gYyAqIDI1NTtcbiAgICByZXR1cm4gZDtcbiAgfSwgdC5oc2wuaHN2ID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdO1xuICAgIGxldCBpID0gYVsxXSAvIDEwMCwgcyA9IGFbMl0gLyAxMDAsIGwgPSBpO1xuICAgIGNvbnN0IHUgPSBNYXRoLm1heChzLCAwLjAxKTtcbiAgICBzICo9IDIsIGkgKj0gcyA8PSAxID8gcyA6IDIgLSBzLCBsICo9IHUgPD0gMSA/IHUgOiAyIC0gdTtcbiAgICBjb25zdCBjID0gKHMgKyBpKSAvIDIsIHAgPSBzID09PSAwID8gMiAqIGwgLyAodSArIGwpIDogMiAqIGkgLyAocyArIGkpO1xuICAgIHJldHVybiBbbywgcCAqIDEwMCwgYyAqIDEwMF07XG4gIH0sIHQuaHN2LnJnYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVswXSAvIDYwLCBpID0gYVsxXSAvIDEwMDtcbiAgICBsZXQgcyA9IGFbMl0gLyAxMDA7XG4gICAgY29uc3QgbCA9IE1hdGguZmxvb3IobykgJSA2LCB1ID0gbyAtIE1hdGguZmxvb3IobyksIGMgPSAyNTUgKiBzICogKDEgLSBpKSwgcCA9IDI1NSAqIHMgKiAoMSAtIGkgKiB1KSwgZCA9IDI1NSAqIHMgKiAoMSAtIGkgKiAoMSAtIHUpKTtcbiAgICBzd2l0Y2ggKHMgKj0gMjU1LCBsKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbcywgZCwgY107XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbcCwgcywgY107XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbYywgcywgZF07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbYywgcCwgc107XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbZCwgYywgc107XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBbcywgYywgcF07XG4gICAgfVxuICB9LCB0Lmhzdi5oc2wgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMCwgbCA9IE1hdGgubWF4KHMsIDAuMDEpO1xuICAgIGxldCB1LCBjO1xuICAgIGMgPSAoMiAtIGkpICogcztcbiAgICBjb25zdCBwID0gKDIgLSBpKSAqIGw7XG4gICAgcmV0dXJuIHUgPSBpICogbCwgdSAvPSBwIDw9IDEgPyBwIDogMiAtIHAsIHUgPSB1IHx8IDAsIGMgLz0gMiwgW28sIHUgKiAxMDAsIGMgKiAxMDBdO1xuICB9LCB0Lmh3Yi5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAzNjA7XG4gICAgbGV0IGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBjb25zdCBsID0gaSArIHM7XG4gICAgbGV0IHU7XG4gICAgbCA+IDEgJiYgKGkgLz0gbCwgcyAvPSBsKTtcbiAgICBjb25zdCBjID0gTWF0aC5mbG9vcig2ICogbyksIHAgPSAxIC0gcztcbiAgICB1ID0gNiAqIG8gLSBjLCBjICYgMSAmJiAodSA9IDEgLSB1KTtcbiAgICBjb25zdCBkID0gaSArIHUgKiAocCAtIGkpO1xuICAgIGxldCBmLCBoLCBtO1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZiA9IHAsIGggPSBkLCBtID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGYgPSBkLCBoID0gcCwgbSA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBmID0gaSwgaCA9IHAsIG0gPSBkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZiA9IGksIGggPSBkLCBtID0gcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGYgPSBkLCBoID0gaSwgbSA9IHA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBmID0gcCwgaCA9IGksIG0gPSBkO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFtmICogMjU1LCBoICogMjU1LCBtICogMjU1XTtcbiAgfSwgdC5jbXlrLnJnYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVswXSAvIDEwMCwgaSA9IGFbMV0gLyAxMDAsIHMgPSBhWzJdIC8gMTAwLCBsID0gYVszXSAvIDEwMCwgdSA9IDEgLSBNYXRoLm1pbigxLCBvICogKDEgLSBsKSArIGwpLCBjID0gMSAtIE1hdGgubWluKDEsIGkgKiAoMSAtIGwpICsgbCksIHAgPSAxIC0gTWF0aC5taW4oMSwgcyAqICgxIC0gbCkgKyBsKTtcbiAgICByZXR1cm4gW3UgKiAyNTUsIGMgKiAyNTUsIHAgKiAyNTVdO1xuICB9LCB0Lnh5ei5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAxMDAsIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBsZXQgbCwgdSwgYztcbiAgICByZXR1cm4gbCA9IG8gKiAzLjI0MDYgKyBpICogLTEuNTM3MiArIHMgKiAtMC40OTg2LCB1ID0gbyAqIC0wLjk2ODkgKyBpICogMS44NzU4ICsgcyAqIDAuMDQxNSwgYyA9IG8gKiAwLjA1NTcgKyBpICogLTAuMjA0ICsgcyAqIDEuMDU3LCBsID0gbCA+IDMxMzA4ZS03ID8gMS4wNTUgKiBsICoqICgxIC8gMi40KSAtIDAuMDU1IDogbCAqIDEyLjkyLCB1ID0gdSA+IDMxMzA4ZS03ID8gMS4wNTUgKiB1ICoqICgxIC8gMi40KSAtIDAuMDU1IDogdSAqIDEyLjkyLCBjID0gYyA+IDMxMzA4ZS03ID8gMS4wNTUgKiBjICoqICgxIC8gMi40KSAtIDAuMDU1IDogYyAqIDEyLjkyLCBsID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbCksIDEpLCB1ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdSksIDEpLCBjID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYyksIDEpLCBbbCAqIDI1NSwgdSAqIDI1NSwgYyAqIDI1NV07XG4gIH0sIHQueHl6LmxhYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBsZXQgbyA9IGFbMF0sIGkgPSBhWzFdLCBzID0gYVsyXTtcbiAgICBvIC89IDk1LjA0NywgaSAvPSAxMDAsIHMgLz0gMTA4Ljg4MywgbyA9IG8gPiA4ODU2ZS02ID8gbyAqKiAoMSAvIDMpIDogNy43ODcgKiBvICsgMTYgLyAxMTYsIGkgPSBpID4gODg1NmUtNiA/IGkgKiogKDEgLyAzKSA6IDcuNzg3ICogaSArIDE2IC8gMTE2LCBzID0gcyA+IDg4NTZlLTYgPyBzICoqICgxIC8gMykgOiA3Ljc4NyAqIHMgKyAxNiAvIDExNjtcbiAgICBjb25zdCBsID0gMTE2ICogaSAtIDE2LCB1ID0gNTAwICogKG8gLSBpKSwgYyA9IDIwMCAqIChpIC0gcyk7XG4gICAgcmV0dXJuIFtsLCB1LCBjXTtcbiAgfSwgdC5sYWIueHl6ID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdLCBpID0gYVsxXSwgcyA9IGFbMl07XG4gICAgbGV0IGwsIHUsIGM7XG4gICAgdSA9IChvICsgMTYpIC8gMTE2LCBsID0gaSAvIDUwMCArIHUsIGMgPSB1IC0gcyAvIDIwMDtcbiAgICBjb25zdCBwID0gdSAqKiAzLCBkID0gbCAqKiAzLCBmID0gYyAqKiAzO1xuICAgIHJldHVybiB1ID0gcCA+IDg4NTZlLTYgPyBwIDogKHUgLSAxNiAvIDExNikgLyA3Ljc4NywgbCA9IGQgPiA4ODU2ZS02ID8gZCA6IChsIC0gMTYgLyAxMTYpIC8gNy43ODcsIGMgPSBmID4gODg1NmUtNiA/IGYgOiAoYyAtIDE2IC8gMTE2KSAvIDcuNzg3LCBsICo9IDk1LjA0NywgdSAqPSAxMDAsIGMgKj0gMTA4Ljg4MywgW2wsIHUsIGNdO1xuICB9LCB0LmxhYi5sY2ggPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0sIGkgPSBhWzFdLCBzID0gYVsyXTtcbiAgICBsZXQgbDtcbiAgICBsID0gTWF0aC5hdGFuMihzLCBpKSAqIDM2MCAvIDIgLyBNYXRoLlBJLCBsIDwgMCAmJiAobCArPSAzNjApO1xuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoaSAqIGkgKyBzICogcyk7XG4gICAgcmV0dXJuIFtvLCBjLCBsXTtcbiAgfSwgdC5sY2gubGFiID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdLCBpID0gYVsxXSwgbCA9IGFbMl0gLyAzNjAgKiAyICogTWF0aC5QSSwgdSA9IGkgKiBNYXRoLmNvcyhsKSwgYyA9IGkgKiBNYXRoLnNpbihsKTtcbiAgICByZXR1cm4gW28sIHUsIGNdO1xuICB9LCB0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbihhLCBvID0gbnVsbCkge1xuICAgIGNvbnN0IFtpLCBzLCBsXSA9IGE7XG4gICAgbGV0IHUgPSBvID09PSBudWxsID8gdC5yZ2IuaHN2KGEpWzJdIDogbztcbiAgICBpZiAodSA9IE1hdGgucm91bmQodSAvIDUwKSwgdSA9PT0gMClcbiAgICAgIHJldHVybiAzMDtcbiAgICBsZXQgYyA9IDMwICsgKE1hdGgucm91bmQobCAvIDI1NSkgPDwgMiB8IE1hdGgucm91bmQocyAvIDI1NSkgPDwgMSB8IE1hdGgucm91bmQoaSAvIDI1NSkpO1xuICAgIHJldHVybiB1ID09PSAyICYmIChjICs9IDYwKSwgYztcbiAgfSwgdC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0LnJnYi5hbnNpMTYodC5oc3YucmdiKGEpLCBhWzJdKTtcbiAgfSwgdC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVswXSwgaSA9IGFbMV0sIHMgPSBhWzJdO1xuICAgIHJldHVybiBvID09PSBpICYmIGkgPT09IHMgPyBvIDwgOCA/IDE2IDogbyA+IDI0OCA/IDIzMSA6IE1hdGgucm91bmQoKG8gLSA4KSAvIDI0NyAqIDI0KSArIDIzMiA6IDE2ICsgMzYgKiBNYXRoLnJvdW5kKG8gLyAyNTUgKiA1KSArIDYgKiBNYXRoLnJvdW5kKGkgLyAyNTUgKiA1KSArIE1hdGgucm91bmQocyAvIDI1NSAqIDUpO1xuICB9LCB0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgbGV0IG8gPSBhICUgMTA7XG4gICAgaWYgKG8gPT09IDAgfHwgbyA9PT0gNylcbiAgICAgIHJldHVybiBhID4gNTAgJiYgKG8gKz0gMy41KSwgbyA9IG8gLyAxMC41ICogMjU1LCBbbywgbywgb107XG4gICAgY29uc3QgaSA9ICh+fihhID4gNTApICsgMSkgKiAwLjUsIHMgPSAobyAmIDEpICogaSAqIDI1NSwgbCA9IChvID4+IDEgJiAxKSAqIGkgKiAyNTUsIHUgPSAobyA+PiAyICYgMSkgKiBpICogMjU1O1xuICAgIHJldHVybiBbcywgbCwgdV07XG4gIH0sIHQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgaWYgKGEgPj0gMjMyKSB7XG4gICAgICBjb25zdCB1ID0gKGEgLSAyMzIpICogMTAgKyA4O1xuICAgICAgcmV0dXJuIFt1LCB1LCB1XTtcbiAgICB9XG4gICAgYSAtPSAxNjtcbiAgICBsZXQgbztcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihhIC8gMzYpIC8gNSAqIDI1NSwgcyA9IE1hdGguZmxvb3IoKG8gPSBhICUgMzYpIC8gNikgLyA1ICogMjU1LCBsID0gbyAlIDYgLyA1ICogMjU1O1xuICAgIHJldHVybiBbaSwgcywgbF07XG4gIH0sIHQucmdiLmhleCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBpID0gKCgoTWF0aC5yb3VuZChhWzBdKSAmIDI1NSkgPDwgMTYpICsgKChNYXRoLnJvdW5kKGFbMV0pICYgMjU1KSA8PCA4KSArIChNYXRoLnJvdW5kKGFbMl0pICYgMjU1KSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIFwiMDAwMDAwXCIuc3Vic3RyaW5nKGkubGVuZ3RoKSArIGk7XG4gIH0sIHQuaGV4LnJnYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYS50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgbGV0IGkgPSBvWzBdO1xuICAgIG9bMF0ubGVuZ3RoID09PSAzICYmIChpID0gaS5zcGxpdChcIlwiKS5tYXAoKHApID0+IHAgKyBwKS5qb2luKFwiXCIpKTtcbiAgICBjb25zdCBzID0gcGFyc2VJbnQoaSwgMTYpLCBsID0gcyA+PiAxNiAmIDI1NSwgdSA9IHMgPj4gOCAmIDI1NSwgYyA9IHMgJiAyNTU7XG4gICAgcmV0dXJuIFtsLCB1LCBjXTtcbiAgfSwgdC5yZ2IuaGNnID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzBdIC8gMjU1LCBpID0gYVsxXSAvIDI1NSwgcyA9IGFbMl0gLyAyNTUsIGwgPSBNYXRoLm1heChNYXRoLm1heChvLCBpKSwgcyksIHUgPSBNYXRoLm1pbihNYXRoLm1pbihvLCBpKSwgcyksIGMgPSBsIC0gdTtcbiAgICBsZXQgcCwgZDtcbiAgICByZXR1cm4gYyA8IDEgPyBwID0gdSAvICgxIC0gYykgOiBwID0gMCwgYyA8PSAwID8gZCA9IDAgOiBsID09PSBvID8gZCA9IChpIC0gcykgLyBjICUgNiA6IGwgPT09IGkgPyBkID0gMiArIChzIC0gbykgLyBjIDogZCA9IDQgKyAobyAtIGkpIC8gYywgZCAvPSA2LCBkICU9IDEsIFtkICogMzYwLCBjICogMTAwLCBwICogMTAwXTtcbiAgfSwgdC5oc2wuaGNnID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzFdIC8gMTAwLCBpID0gYVsyXSAvIDEwMCwgcyA9IGkgPCAwLjUgPyAyICogbyAqIGkgOiAyICogbyAqICgxIC0gaSk7XG4gICAgbGV0IGwgPSAwO1xuICAgIHJldHVybiBzIDwgMSAmJiAobCA9IChpIC0gMC41ICogcykgLyAoMSAtIHMpKSwgW2FbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xuICB9LCB0Lmhzdi5oY2cgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMV0gLyAxMDAsIGkgPSBhWzJdIC8gMTAwLCBzID0gbyAqIGk7XG4gICAgbGV0IGwgPSAwO1xuICAgIHJldHVybiBzIDwgMSAmJiAobCA9IChpIC0gcykgLyAoMSAtIHMpKSwgW2FbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xuICB9LCB0LmhjZy5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMF0gLyAzNjAsIGkgPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMDtcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIHJldHVybiBbcyAqIDI1NSwgcyAqIDI1NSwgcyAqIDI1NV07XG4gICAgY29uc3QgbCA9IFswLCAwLCAwXSwgdSA9IG8gJSAxICogNiwgYyA9IHUgJSAxLCBwID0gMSAtIGM7XG4gICAgbGV0IGQgPSAwO1xuICAgIHN3aXRjaCAoTWF0aC5mbG9vcih1KSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBsWzBdID0gMSwgbFsxXSA9IGMsIGxbMl0gPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbFswXSA9IHAsIGxbMV0gPSAxLCBsWzJdID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGxbMF0gPSAwLCBsWzFdID0gMSwgbFsyXSA9IGM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBsWzBdID0gMCwgbFsxXSA9IHAsIGxbMl0gPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgbFswXSA9IGMsIGxbMV0gPSAwLCBsWzJdID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsWzBdID0gMSwgbFsxXSA9IDAsIGxbMl0gPSBwO1xuICAgIH1cbiAgICByZXR1cm4gZCA9ICgxIC0gaSkgKiBzLCBbXG4gICAgICAoaSAqIGxbMF0gKyBkKSAqIDI1NSxcbiAgICAgIChpICogbFsxXSArIGQpICogMjU1LFxuICAgICAgKGkgKiBsWzJdICsgZCkgKiAyNTVcbiAgICBdO1xuICB9LCB0LmhjZy5oc3YgPSBmdW5jdGlvbihhKSB7XG4gICAgY29uc3QgbyA9IGFbMV0gLyAxMDAsIGkgPSBhWzJdIC8gMTAwLCBzID0gbyArIGkgKiAoMSAtIG8pO1xuICAgIGxldCBsID0gMDtcbiAgICByZXR1cm4gcyA+IDAgJiYgKGwgPSBvIC8gcyksIFthWzBdLCBsICogMTAwLCBzICogMTAwXTtcbiAgfSwgdC5oY2cuaHNsID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzFdIC8gMTAwLCBzID0gYVsyXSAvIDEwMCAqICgxIC0gbykgKyAwLjUgKiBvO1xuICAgIGxldCBsID0gMDtcbiAgICByZXR1cm4gcyA+IDAgJiYgcyA8IDAuNSA/IGwgPSBvIC8gKDIgKiBzKSA6IHMgPj0gMC41ICYmIHMgPCAxICYmIChsID0gbyAvICgyICogKDEgLSBzKSkpLCBbYVswXSwgbCAqIDEwMCwgcyAqIDEwMF07XG4gIH0sIHQuaGNnLmh3YiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gYVsxXSAvIDEwMCwgaSA9IGFbMl0gLyAxMDAsIHMgPSBvICsgaSAqICgxIC0gbyk7XG4gICAgcmV0dXJuIFthWzBdLCAocyAtIG8pICogMTAwLCAoMSAtIHMpICogMTAwXTtcbiAgfSwgdC5od2IuaGNnID0gZnVuY3Rpb24oYSkge1xuICAgIGNvbnN0IG8gPSBhWzFdIC8gMTAwLCBzID0gMSAtIGFbMl0gLyAxMDAsIGwgPSBzIC0gbztcbiAgICBsZXQgdSA9IDA7XG4gICAgcmV0dXJuIGwgPCAxICYmICh1ID0gKHMgLSBsKSAvICgxIC0gbCkpLCBbYVswXSwgbCAqIDEwMCwgdSAqIDEwMF07XG4gIH0sIHQuYXBwbGUucmdiID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbYVswXSAvIDY1NTM1ICogMjU1LCBhWzFdIC8gNjU1MzUgKiAyNTUsIGFbMl0gLyA2NTUzNSAqIDI1NV07XG4gIH0sIHQucmdiLmFwcGxlID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbYVswXSAvIDI1NSAqIDY1NTM1LCBhWzFdIC8gMjU1ICogNjU1MzUsIGFbMl0gLyAyNTUgKiA2NTUzNV07XG4gIH0sIHQuZ3JheS5yZ2IgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIFthWzBdIC8gMTAwICogMjU1LCBhWzBdIC8gMTAwICogMjU1LCBhWzBdIC8gMTAwICogMjU1XTtcbiAgfSwgdC5ncmF5LmhzbCA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gWzAsIDAsIGFbMF1dO1xuICB9LCB0LmdyYXkuaHN2ID0gdC5ncmF5LmhzbCwgdC5ncmF5Lmh3YiA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gWzAsIDEwMCwgYVswXV07XG4gIH0sIHQuZ3JheS5jbXlrID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgYVswXV07XG4gIH0sIHQuZ3JheS5sYWIgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIFthWzBdLCAwLCAwXTtcbiAgfSwgdC5ncmF5LmhleCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBjb25zdCBvID0gTWF0aC5yb3VuZChhWzBdIC8gMTAwICogMjU1KSAmIDI1NSwgcyA9ICgobyA8PCAxNikgKyAobyA8PCA4KSArIG8pLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBcIjAwMDAwMFwiLnN1YnN0cmluZyhzLmxlbmd0aCkgKyBzO1xuICB9LCB0LnJnYi5ncmF5ID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBbKGFbMF0gKyBhWzFdICsgYVsyXSkgLyAzIC8gMjU1ICogMTAwXTtcbiAgfSwgX3I7XG59XG52YXIgSXIsIGRhO1xuZnVuY3Rpb24gZHUoKSB7XG4gIGlmIChkYSkgcmV0dXJuIElyO1xuICBkYSA9IDE7XG4gIGNvbnN0IHIgPSBTbygpO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIGNvbnN0IG8gPSB7fSwgaSA9IE9iamVjdC5rZXlzKHIpO1xuICAgIGZvciAobGV0IHMgPSBpLmxlbmd0aCwgbCA9IDA7IGwgPCBzOyBsKyspXG4gICAgICBvW2lbbF1dID0ge1xuICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG4gICAgICAgIC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuICAgICAgICBkaXN0YW5jZTogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgfTtcbiAgICByZXR1cm4gbztcbiAgfVxuICBmdW5jdGlvbiB0KG8pIHtcbiAgICBjb25zdCBpID0gZSgpLCBzID0gW29dO1xuICAgIGZvciAoaVtvXS5kaXN0YW5jZSA9IDA7IHMubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGwgPSBzLnBvcCgpLCB1ID0gT2JqZWN0LmtleXMocltsXSk7XG4gICAgICBmb3IgKGxldCBjID0gdS5sZW5ndGgsIHAgPSAwOyBwIDwgYzsgcCsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSB1W3BdLCBmID0gaVtkXTtcbiAgICAgICAgZi5kaXN0YW5jZSA9PT0gLTEgJiYgKGYuZGlzdGFuY2UgPSBpW2xdLmRpc3RhbmNlICsgMSwgZi5wYXJlbnQgPSBsLCBzLnVuc2hpZnQoZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICBmdW5jdGlvbiBuKG8sIGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIGkobyhzKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhKG8sIGkpIHtcbiAgICBjb25zdCBzID0gW2lbb10ucGFyZW50LCBvXTtcbiAgICBsZXQgbCA9IHJbaVtvXS5wYXJlbnRdW29dLCB1ID0gaVtvXS5wYXJlbnQ7XG4gICAgZm9yICg7IGlbdV0ucGFyZW50OyApXG4gICAgICBzLnVuc2hpZnQoaVt1XS5wYXJlbnQpLCBsID0gbihyW2lbdV0ucGFyZW50XVt1XSwgbCksIHUgPSBpW3VdLnBhcmVudDtcbiAgICByZXR1cm4gbC5jb252ZXJzaW9uID0gcywgbDtcbiAgfVxuICByZXR1cm4gSXIgPSBmdW5jdGlvbihvKSB7XG4gICAgY29uc3QgaSA9IHQobyksIHMgPSB7fSwgbCA9IE9iamVjdC5rZXlzKGkpO1xuICAgIGZvciAobGV0IHUgPSBsLmxlbmd0aCwgYyA9IDA7IGMgPCB1OyBjKyspIHtcbiAgICAgIGNvbnN0IHAgPSBsW2NdO1xuICAgICAgaVtwXS5wYXJlbnQgIT09IG51bGwgJiYgKHNbcF0gPSBhKHAsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH0sIElyO1xufVxudmFyIE1yLCBoYTtcbmZ1bmN0aW9uIGh1KCkge1xuICBpZiAoaGEpIHJldHVybiBNcjtcbiAgaGEgPSAxO1xuICBjb25zdCByID0gU28oKSwgZSA9IGR1KCksIHQgPSB7fSwgbiA9IE9iamVjdC5rZXlzKHIpO1xuICBmdW5jdGlvbiBhKGkpIHtcbiAgICBjb25zdCBzID0gZnVuY3Rpb24oLi4ubCkge1xuICAgICAgY29uc3QgdSA9IGxbMF07XG4gICAgICByZXR1cm4gdSA9PSBudWxsID8gdSA6ICh1Lmxlbmd0aCA+IDEgJiYgKGwgPSB1KSwgaShsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gXCJjb252ZXJzaW9uXCIgaW4gaSAmJiAocy5jb252ZXJzaW9uID0gaS5jb252ZXJzaW9uKSwgcztcbiAgfVxuICBmdW5jdGlvbiBvKGkpIHtcbiAgICBjb25zdCBzID0gZnVuY3Rpb24oLi4ubCkge1xuICAgICAgY29uc3QgdSA9IGxbMF07XG4gICAgICBpZiAodSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gdTtcbiAgICAgIHUubGVuZ3RoID4gMSAmJiAobCA9IHUpO1xuICAgICAgY29uc3QgYyA9IGkobCk7XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgZm9yIChsZXQgcCA9IGMubGVuZ3RoLCBkID0gMDsgZCA8IHA7IGQrKylcbiAgICAgICAgICBjW2RdID0gTWF0aC5yb3VuZChjW2RdKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gICAgcmV0dXJuIFwiY29udmVyc2lvblwiIGluIGkgJiYgKHMuY29udmVyc2lvbiA9IGkuY29udmVyc2lvbiksIHM7XG4gIH1cbiAgcmV0dXJuIG4uZm9yRWFjaCgoaSkgPT4ge1xuICAgIHRbaV0gPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRbaV0sIFwiY2hhbm5lbHNcIiwgeyB2YWx1ZTogcltpXS5jaGFubmVscyB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRbaV0sIFwibGFiZWxzXCIsIHsgdmFsdWU6IHJbaV0ubGFiZWxzIH0pO1xuICAgIGNvbnN0IHMgPSBlKGkpO1xuICAgIE9iamVjdC5rZXlzKHMpLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBzW3VdO1xuICAgICAgdFtpXVt1XSA9IG8oYyksIHRbaV1bdV0ucmF3ID0gYShjKTtcbiAgICB9KTtcbiAgfSksIE1yID0gdCwgTXI7XG59XG52YXIgbXUgPSBodSgpO1xuY29uc3QgeXUgPSAvKiBAX19QVVJFX18gKi8gcHUobXUpO1xuZnVuY3Rpb24gbWEoeyBnbDogciwgdHlwZTogZSwgc291cmNlOiB0IH0pIHtcbiAgY29uc3QgbiA9IHIuY3JlYXRlU2hhZGVyKGUpO1xuICBpZiAobiA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIHNoYWRlclwiKTtcbiAgaWYgKHIuc2hhZGVyU291cmNlKG4sIHQpLCByLmNvbXBpbGVTaGFkZXIobiksICFyLmdldFNoYWRlclBhcmFtZXRlcihuLCByLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB0aHJvdyBjb25zb2xlLmVycm9yKFwiU2hhZGVyIGNvbXBpbGF0aW9uIGVycm9yOlwiLCByLmdldFNoYWRlckluZm9Mb2cobikpLCByLmRlbGV0ZVNoYWRlcihuKSwgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXBpbGUgc2hhZGVyXCIpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGd1KHsgZ2w6IHIsIHZlcnRleFNoYWRlclNvdXJjZTogZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHQgfSkge1xuICBjb25zdCBuID0gbWEoe1xuICAgIGdsOiByLFxuICAgIHR5cGU6IHIuVkVSVEVYX1NIQURFUixcbiAgICBzb3VyY2U6IGVcbiAgfSksIGEgPSBtYSh7IGdsOiByLCB0eXBlOiByLkZSQUdNRU5UX1NIQURFUiwgc291cmNlOiB0IH0pLCBvID0gci5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmIChyLmF0dGFjaFNoYWRlcihvLCBuKSwgci5hdHRhY2hTaGFkZXIobywgYSksIHIubGlua1Byb2dyYW0obyksICFyLmdldFByb2dyYW1QYXJhbWV0ZXIobywgci5MSU5LX1NUQVRVUykpXG4gICAgdGhyb3cgY29uc29sZS5lcnJvcihcIkVycm9yOiBcIiwgci5nZXRQcm9ncmFtSW5mb0xvZyhvKSksIG5ldyBFcnJvcihcIkNhbm5vdCBsaW5rIHNoYWRlciBwcm9ncmFtXCIpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIHZ1KHIsIGUsIHQpIHtcbiAgY29uc3QgbiA9IHIuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsIHQpO1xuICBpZiAobiA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgdW5pZm9ybSBsb2NhdGlvbiBmb3IgJHt0fWApO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHhvKHtcbiAgZ2w6IHIsXG4gIHZlcnRleFNoYWRlclNvdXJjZTogZSxcbiAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHQsXG4gIGF0dHJpYnV0ZXNLZXlzOiBuLFxuICB1bmlmb3Jtc0tleXM6IGEsXG4gIHZlcnRpY2VzOiBvLFxuICBpbmRpY2VzOiBpXG59KSB7XG4gIGNvbnN0IHMgPSBndSh7IGdsOiByLCB2ZXJ0ZXhTaGFkZXJTb3VyY2U6IGUsIGZyYWdtZW50U2hhZGVyU291cmNlOiB0IH0pLCBsID0gbi5yZWR1Y2UoKGYsIGgpID0+IChmW2hdID0gci5nZXRBdHRyaWJMb2NhdGlvbihzLCBgYV8ke2h9YCksIGYpLCB7fSksIHUgPSBhLnJlZHVjZSgoZiwgaCkgPT4gKGZbaF0gPSB2dShyLCBzLCBgdV8ke2h9YCksIGYpLCB7fSksIGMgPSByLmNyZWF0ZUJ1ZmZlcigpO1xuICByLmJpbmRCdWZmZXIoci5BUlJBWV9CVUZGRVIsIGMpLCByLmJ1ZmZlckRhdGEoci5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkobyksIHIuU1RBVElDX0RSQVcpO1xuICBsZXQgcCwgZDtcbiAgcmV0dXJuIGkgIT09IHZvaWQgMCAmJiAocCA9IHIuY3JlYXRlQnVmZmVyKCksIGQgPSBpLmxlbmd0aCwgci5iaW5kQnVmZmVyKHIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHApLCByLmJ1ZmZlckRhdGEoci5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KGkpLCByLlNUQVRJQ19EUkFXKSksIHtcbiAgICBzaGFkZXJQcm9ncmFtOiBzLFxuICAgIHByb2dyYW1JbmZvOiB7XG4gICAgICBhdHRyaWJ1dGVzTG9jYXRpb25zOiBsLFxuICAgICAgdW5pZm9ybXNMb2NhdGlvbnM6IHVcbiAgICB9LFxuICAgIHBvc2l0aW9uQnVmZmVyOiBjLFxuICAgIGluZGV4QnVmZmVyOiBwLFxuICAgIGluZGV4QnVmZmVyTGVuZ3RoOiBkXG4gIH07XG59XG5mdW5jdGlvbiBqdChyKSB7XG4gIGlmICghcilcbiAgICByZXR1cm4gWzEsIDEsIDEsIDBdO1xuICBpZiAociA9PT0gXCJ0cmFuc3BhcmVudFwiKVxuICAgIHJldHVybiBbMSwgMSwgMSwgMF07XG4gIHRyeSB7XG4gICAgY29uc3QgZSA9IGJ1KHIpLCB0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSk/JC9pLmV4ZWMoZSk7XG4gICAgaWYgKHQgIT0gbnVsbCAmJiB0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgYSA9ICEhdFs0XTtcbiAgICAgIHJldHVybiBbLi4ueXUuaGV4LnJnYihlKS5tYXAoKG8pID0+IG8gLyAyNTUpLCBhID8gcGFyc2VJbnQodFs0XSwgMTYpIC8gMjU1IDogMV07XG4gICAgfVxuICAgIGNvbnN0IG4gPSBlLm1hdGNoKC8oXFxkXFwuXFxkKFxcZCspP3xcXGR7M318XFxkezJ9fFxcZHsxfSkvZ2kpID8/IFtcIjBcIiwgXCIwXCIsIFwiMFwiXTtcbiAgICBpZiAoZS5pbmNsdWRlcyhcInJnYlwiKSkge1xuICAgICAgY29uc3QgYSA9IGUuaW5jbHVkZXMoXCJyZ2JhXCIpLCBvID0gW1xuICAgICAgICAuLi5uLm1hcCgoaSkgPT4gcGFyc2VGbG9hdChpKSkubWFwKChpLCBzKSA9PiBzIDwgMyA/IGkgLyAyNTUgOiBpKVxuICAgICAgICAvLyBiZWNhdXNlIGFscGhhIGlzIGluIHRoZSByYW5nZSAwIC0gMSwgbm90IDAgLSAyNTVcbiAgICAgIF07XG4gICAgICByZXR1cm4gYSB8fCBvLnB1c2goMSksIG87XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gY29uc29sZS53YXJuKFtgW3BhcnNlQ29sb3JTdHJpbmdUb1ZlYzRdOiBDb2xvciAke3J9IGlzIGVpdGhlciBub3QgYSB2YWxpZCBjb2xvciBvciBpdHMgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLCBkZWZhdWx0aW5nIHRvIGJsYWNrYF0pLCBbMCwgMCwgMCwgMV07XG59XG5sZXQgY3Q7XG5mdW5jdGlvbiBidShyKSB7XG4gIHJldHVybiBjdCA9IGN0ID8/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpLCBjdCA/IChjdC5maWxsU3R5bGUgPSByLCBjdC5maWxsU3R5bGUpIDogXCIjMDAwMDAwXCI7XG59XG5jb25zdCBMbiA9IDEsIGxlID0gTG4gLyAyLCB1ZSA9IExuIC8gMiwgY2UgPSBMbiAvIDIsIHd1ID0gWy0wLjUsIC0wLjUsIGNlLCBsZSwgLTAuNSwgY2UsIGxlLCB1ZSwgY2UsIC0wLjUsIHVlLCBjZV0sIFN1ID0gWy0wLjUsIC0wLjUsIC0wLjUsIC0wLjUsIHVlLCAtMC41LCBsZSwgdWUsIC0wLjUsIGxlLCAtMC41LCAtMC41XSwgeHUgPSBbLTAuNSwgdWUsIC0wLjUsIC0wLjUsIHVlLCBjZSwgbGUsIHVlLCBjZSwgbGUsIHVlLCAtMC41XSwga3UgPSBbLTAuNSwgLTAuNSwgLTAuNSwgbGUsIC0wLjUsIC0wLjUsIGxlLCAtMC41LCBjZSwgLTAuNSwgLTAuNSwgY2VdLCBMdSA9IFtsZSwgLTAuNSwgLTAuNSwgbGUsIHVlLCAtMC41LCBsZSwgdWUsIGNlLCBsZSwgLTAuNSwgY2VdLCBDdSA9IFstMC41LCAtMC41LCAtMC41LCAtMC41LCAtMC41LCBjZSwgLTAuNSwgdWUsIGNlLCAtMC41LCB1ZSwgLTAuNV0sIEV1ID0gWy4uLnd1LCAuLi5TdSwgLi4ueHUsIC4uLmt1LCAuLi5MdSwgLi4uQ3VdLCBBdSA9IFtcbiAgLy8gRnJvbnRcbiAgMCxcbiAgMSxcbiAgMixcbiAgMCxcbiAgMixcbiAgMyxcbiAgLy8gQmFja1xuICA0LFxuICA1LFxuICA2LFxuICA0LFxuICA2LFxuICA3LFxuICAvLyBMZWZ0XG4gIDgsXG4gIDksXG4gIDEwLFxuICA4LFxuICAxMCxcbiAgMTEsXG4gIC8vIFJpZ2h0XG4gIDEyLFxuICAxMyxcbiAgMTQsXG4gIDEyLFxuICAxNCxcbiAgMTUsXG4gIC8vIFVwXG4gIDE2LFxuICAxNyxcbiAgMTgsXG4gIDE2LFxuICAxOCxcbiAgMTksXG4gIC8vIERvd25cbiAgMjAsXG4gIDIxLFxuICAyMixcbiAgMjAsXG4gIDIyLFxuICAyM1xuXSwgVHUgPSBgYXR0cmlidXRlIHZlYzMgYV92ZXJ0ZXhQb3NpdGlvbjtcbnZhcnlpbmcgdmVjMyB2VGV4dHVyZUNvb3JkO1xuXG51bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uTWF0cml4O1xudW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3TWF0cml4O1xuICBcbnZvaWQgbWFpbih2b2lkKSB7XG4gIHZUZXh0dXJlQ29vcmQgPSB2ZWMzKC1hX3ZlcnRleFBvc2l0aW9uLngsIGFfdmVydGV4UG9zaXRpb24ueSwgYV92ZXJ0ZXhQb3NpdGlvbi56KTtcbiAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb25NYXRyaXggKiB1X21vZGVsVmlld01hdHJpeCAqIHZlYzQoYV92ZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcbn1cbmAsIHlhID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG52YXJ5aW5nIHZlYzMgdlRleHR1cmVDb29yZDtcblxuJVVTRV9URVhUVVJFX01BQ1JPX01BUktFUiVcblxuIyBpZmRlZiBVU0VfVEVYVFVSRVxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1X2N1YmVTYW1wbGVyO1xudW5pZm9ybSBmbG9hdCB1X2ZhZGVPcGFjaXR5O1xuIyBlbmRpZlxuXG51bmlmb3JtIHZlYzQgdV9iZ0NvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICAjaWZkZWYgVVNFX1RFWFRVUkVcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKHVfY3ViZVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gbWl4KFxuICAgICAgdV9iZ0NvbG9yLFxuICAgICAgdGV4Q29sb3IsXG4gICAgICBtaW4odGV4Q29sb3IuYSwgdV9mYWRlT3BhY2l0eSlcbiAgICApO1xuXG4gICAgZ2xfRnJhZ0NvbG9yLmEgPSBtYXgoZ2xfRnJhZ0NvbG9yLmEsIHVfZmFkZU9wYWNpdHkpO1xuXG4gICNlbHNlXG4gIGdsX0ZyYWdDb2xvciA9IHVfYmdDb2xvcjtcbiAgI2VuZGlmXG59XG5gO1xudmFyIF91ID0gLyogQF9fUFVSRV9fICovICgocikgPT4gKHIuVU5JVkVSU0VfREFSSyA9IFwidW5pdmVyc2UtZGFya1wiLCByKSkoX3UgfHwge30pO1xuY29uc3QgSGUgPSB7XG4gIHN0YXJzOiB7XG4gICAgY29sb3I6IFwiaHNsKDIzMywxMDAlLDkyJSlcIixcbiAgICBwcmVzZXQ6IFwic3RhcnNcIlxuICB9LFxuICBzcGFjZToge1xuICAgIGNvbG9yOiBcImhzbCgyMTAsIDEwMCUsIDQlKVwiLFxuICAgIHByZXNldDogXCJzcGFjZVwiXG4gIH0sXG4gIG1pbGt5d2F5OiB7XG4gICAgY29sb3I6IFwiaHNsKDIzMywxMDAlLDkyJSlcIixcbiAgICBwcmVzZXQ6IFwibWlsa3l3YXlcIlxuICB9LFxuICBcIm1pbGt5d2F5LXN1YnRsZVwiOiB7XG4gICAgY29sb3I6IFwiaHNsKDIzMywxMDAlLDkyJSlcIixcbiAgICBwcmVzZXQ6IFwibWlsa3l3YXktc3VidGxlXCJcbiAgfSxcbiAgXCJtaWxreXdheS1icmlnaHRcIjoge1xuICAgIGNvbG9yOiBcImhzbCgyMzMsMTAwJSw5MiUpXCIsXG4gICAgcHJlc2V0OiBcIm1pbGt5d2F5LWJyaWdodFwiXG4gIH0sXG4gIFwibWlsa3l3YXktY29sb3JlZFwiOiB7XG4gICAgY29sb3I6IFwiYmxhY2tcIixcbiAgICBwcmVzZXQ6IFwibWlsa3l3YXktY29sb3JlZFwiXG4gIH1cbn07XG52YXIgVWUgPSAvKiBAX19QVVJFX18gKi8gKChyKSA9PiAoci5QT1NJVElWRV9YID0gXCJwWFwiLCByLk5FR0FUSVZFX1ggPSBcIm5YXCIsIHIuUE9TSVRJVkVfWSA9IFwicFlcIiwgci5ORUdBVElWRV9ZID0gXCJuWVwiLCByLlBPU0lUSVZFX1ogPSBcInBaXCIsIHIuTkVHQVRJVkVfWiA9IFwiblpcIiwgcikpKFVlIHx8IHt9KTtcbmxldCBGdCwgZ2EsIHZhO1xuZnVuY3Rpb24gSXUoeyBnbDogciwgZmFjZXM6IGUsIG9uUmVhZHk6IHQsIGZvcmNlUmVmcmVzaDogbiB9KSB7XG4gIEZ0ICYmICFuICYmIHZhID09PSBKU09OLnN0cmluZ2lmeShlKSAmJiB0KEZ0LCBnYSksIHZhID0gSlNPTi5zdHJpbmdpZnkoZSk7XG4gIGNvbnN0IGEgPSBGdCA/PyByLmNyZWF0ZVRleHR1cmUoKTtcbiAgaWYgKHIuYmluZFRleHR1cmUoci5URVhUVVJFX0NVQkVfTUFQLCBhKSwgIWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbQ3ViZW1hcExheWVyXVtsb2FkQ3ViZW1hcFRleHR1cmVdOiBGYWNlcyBhcmUgbnVsbFwiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbyA9IE9iamVjdC5rZXlzKGUpLmxlbmd0aDtcbiAgaWYgKG8gIT09IDYpIHtcbiAgICBjb25zb2xlLndhcm4oYFtDdWJlbWFwTGF5ZXJdW2xvYWRDdWJlbWFwVGV4dHVyZV06IEZhY2VzIHNob3VsZCBjb250YWluIGV4YWN0bHkgNiBpbWFnZXMsIGJ1dCBmb3VuZCAke299YCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGkgPSBPYmplY3QuZW50cmllcyhlKS5tYXAoKFtzLCBsXSkgPT4gbmV3IFByb21pc2UoKHUsIGMpID0+IHtcbiAgICBjb25zdCBwID0gcztcbiAgICBpZiAobCA9PT0gdm9pZCAwKSB7XG4gICAgICBjKG5ldyBFcnJvcihgW0N1YmVtYXBMYXllcl1bbG9hZEN1YmVtYXBUZXh0dXJlXTogRmFjZSAke3N9IGlzIHVuZGVmaW5lZGApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZCA9IG5ldyBJbWFnZSgpO1xuICAgIGQuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIGNvbnN0IGYgPSAoKSA9PiB7XG4gICAgICB1KHsgaW1hZ2U6IGQsIGtleTogcCB9KTtcbiAgICB9O1xuICAgIGQuc3JjID0gbCwgZC5jb21wbGV0ZSAmJiBkLm5hdHVyYWxXaWR0aCA+IDAgPyBmKCkgOiBkLm9ubG9hZCA9IGYsIGQub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGMobmV3IEVycm9yKGBbQ3ViZW1hcExheWVyXVtsb2FkQ3ViZW1hcFRleHR1cmVdOiBFcnJvciBsb2FkaW5nIGltYWdlICR7bH1gKSk7XG4gICAgfTtcbiAgfSkpO1xuICBQcm9taXNlLmFsbChpKS50aGVuKChzKSA9PiB7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBzLmxlbmd0aDsgdSsrKSB7XG4gICAgICBjb25zdCBwID0gci5SR0JBLCBkID0gci5SR0JBLCBmID0gci5VTlNJR05FRF9CWVRFLCB7IGltYWdlOiBoLCBrZXk6IG0gfSA9IHNbdV0gPz8ge307XG4gICAgICBpZiAoIWggfHwgIW0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0N1YmVtYXBMYXllcl1bbG9hZEN1YmVtYXBUZXh0dXJlXTogSW1hZ2Ugb3Iga2V5IGlzIG51bGxcIik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeSA9IE11KHIsIG0pO1xuICAgICAgci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfQ1VCRV9NQVAsIGEpLCByLnRleFBhcmFtZXRlcmkoci5URVhUVVJFX0NVQkVfTUFQLCByLlRFWFRVUkVfTUFHX0ZJTFRFUiwgci5MSU5FQVIpLCByLnRleFBhcmFtZXRlcmkoci5URVhUVVJFX0NVQkVfTUFQLCByLlRFWFRVUkVfTUlOX0ZJTFRFUiwgci5MSU5FQVIpLCByLnRleFBhcmFtZXRlcmkoci5URVhUVVJFX0NVQkVfTUFQLCByLlRFWFRVUkVfV1JBUF9TLCByLkNMQU1QX1RPX0VER0UpLCByLnRleFBhcmFtZXRlcmkoci5URVhUVVJFX0NVQkVfTUFQLCByLlRFWFRVUkVfV1JBUF9ULCByLkNMQU1QX1RPX0VER0UpLCByLnRleEltYWdlMkQoeSwgMCwgcCwgZCwgZiwgaCk7XG4gICAgfVxuICAgIHIuYmluZFRleHR1cmUoci5URVhUVVJFX0NVQkVfTUFQLCBhKSwgci5nZW5lcmF0ZU1pcG1hcChyLlRFWFRVUkVfQ1VCRV9NQVApLCByLnRleFBhcmFtZXRlcmkoci5URVhUVVJFX0NVQkVfTUFQLCByLlRFWFRVUkVfTUlOX0ZJTFRFUiwgci5MSU5FQVJfTUlQTUFQX0xJTkVBUiksIHIudGV4UGFyYW1ldGVyaShyLlRFWFRVUkVfQ1VCRV9NQVAsIHIuVEVYVFVSRV9NQUdfRklMVEVSLCByLkxJTkVBUik7XG4gICAgY29uc3QgbCA9IHMubWFwKCh1KSA9PiB1LmltYWdlKTtcbiAgICB0KGEsIGwpLCBnYSA9IGwsIEZ0ID0gYTtcbiAgfSkuY2F0Y2goKHMpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiW0N1YmVtYXBMYXllcl1bbG9hZEN1YmVtYXBUZXh0dXJlXTogRXJyb3IgbG9hZGluZyBjdWJlbWFwIHRleHR1cmVcIiwgcyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gTXUociwgZSkge1xuICBpZiAoZSA9PT0gVWUuUE9TSVRJVkVfWClcbiAgICByZXR1cm4gci5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1g7XG4gIGlmIChlID09PSBVZS5ORUdBVElWRV9YKVxuICAgIHJldHVybiByLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWDtcbiAgaWYgKGUgPT09IFVlLlBPU0lUSVZFX1kpXG4gICAgcmV0dXJuIHIuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZO1xuICBpZiAoZSA9PT0gVWUuTkVHQVRJVkVfWSlcbiAgICByZXR1cm4gci5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1k7XG4gIGlmIChlID09PSBVZS5QT1NJVElWRV9aKVxuICAgIHJldHVybiByLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWjtcbiAgaWYgKGUgPT09IFVlLk5FR0FUSVZFX1opXG4gICAgcmV0dXJuIHIuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aO1xuICB0aHJvdyBuZXcgRXJyb3IoYFtDdWJlbWFwTGF5ZXJdW2xvYWRDdWJlbWFwVGV4dHVyZV06IEludmFsaWQga2V5ICR7ZX1gKTtcbn1cbmZ1bmN0aW9uIFB1KHIsIGUsIHQpIHtcbiAgcmV0dXJuIFtcbiAgICBSZShyWzBdLCBlWzBdLCB0KSxcbiAgICBSZShyWzFdLCBlWzFdLCB0KSxcbiAgICBSZShyWzJdLCBlWzJdLCB0KSxcbiAgICBSZShyWzNdLCBlWzNdLCB0KVxuICBdO1xufVxuZnVuY3Rpb24gUmUociwgZSwgdCkge1xuICByZXR1cm4gciArIChlIC0gcikgKiB0O1xufVxuY29uc3QgSmUgPSBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9yZXNvdXJjZXMvc3BhY2VcIiwgUnUgPSBbXCJ2ZXJ0ZXhQb3NpdGlvblwiXSwgenUgPSBbXCJwcm9qZWN0aW9uTWF0cml4XCIsIFwibW9kZWxWaWV3TWF0cml4XCIsIFwiY3ViZVNhbXBsZXJcIiwgXCJiZ0NvbG9yXCIsIFwiZmFkZU9wYWNpdHlcIl0sIGJhID0gXCIlVVNFX1RFWFRVUkVfTUFDUk9fTUFSS0VSJVwiLCBGdSA9IFwiI2RlZmluZSBVU0VfVEVYVFVSRVwiLCB3YSA9IEhlLnN0YXJzO1xuZnVuY3Rpb24gJHUociwgZSkge1xuICBpZiAoIWtvKHIpKVxuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfTtcbiAgaWYgKHIgPT09ICEwKVxuICAgIHJldHVybiBlO1xuICBjb25zdCB0ID0ge1xuICAgIC4uLnJcbiAgfTtcbiAgaWYgKHIuZmFjZXMgfHwgci5wYXRoKVxuICAgIHJldHVybiBkZWxldGUgdC5wcmVzZXQsIHQ7XG4gIGNvbnN0IG4gPSByLnByZXNldDtcbiAgaWYgKCEobiA9PT0gdm9pZCAwKSAmJiAhKG4gaW4gSGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihgW0N1YmVtYXBMYXllcl06IEludmFsaWQgcHJlc2V0IFwiJHtufVwiLiBBdmFpbGFibGUgcHJlc2V0czogJHtPYmplY3Qua2V5cyhIZSkuam9pbihcIiwgXCIpfWApO1xuICByZXR1cm4ge1xuICAgIC4uLnQsXG4gICAgLy8gdGhpcyBfY291bGRfIGJlIG51bGxpc2hfXG4gICAgY29sb3I6IHQuY29sb3IgPz8gSGVbbl0uY29sb3IgPz8gXCJoc2woMjMzLDEwMCUsOTIlKVwiXG4gIH07XG59XG5jbGFzcyBQciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEN1YmVtYXBMYXllclxuICAgKlxuICAgKiBAcGFyYW0ge0N1YmVtYXBMYXllckNvbnN0cnVjdG9yT3B0aW9ucyB8IHRydWV9IGN1YmVtYXBDb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjdWJlbWFwIGxheWVyIG9yIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBvcHRpb25zLlxuICAgKiBDYW4gc3BlY2lmeSBmYWNlcywgcHJlc2V0LCBwYXRoLCBhbmQgY29sb3IgcHJvcGVydGllcyB0byBjb25maWd1cmUgdGhlIGN1YmVtYXAuXG4gICAqXG4gICAqIEByZW1hcmtzIFlvdSBzaG91bGRuJ3QgaGF2ZSB0byB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseS5cbiAgICogSW5zdGVhZCwgdXNlIHRoZSBgTWFwLnNldEhhbG9gIG1ldGhvZCB0byBjcmVhdGUgYW5kIGFkZCBhIGhhbG8gbGF5ZXIgdG8gdGhlIG1hcC5cbiAgICogVGhlIGNvbnN0cnVjdG9yIGluaXRpYWxpemVzIHRoZSBjdWJlbWFwIHdpdGggdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAqIEl0IHByb2Nlc3NlcyB0aGUgZmFjZXMgZGVmaW5pdGlvbiwgc2V0cyB1cCBiYWNrZ3JvdW5kIGNvbG9ycywgYW5kIGRldGVybWluZXNcbiAgICogd2hldGhlciB0byB1c2UgYSBjdWJlbWFwIHRleHR1cmUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdih0aGlzLCBcImlkXCIsIFwiQ3ViZW1hcCBMYXllclwiKTtcbiAgICB2KHRoaXMsIFwidHlwZVwiLCBcImN1c3RvbVwiKTtcbiAgICB2KHRoaXMsIFwicmVuZGVyaW5nTW9kZVwiLCBcIjNkXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBsYXllciBpcyBhZGRlZC5cbiAgICAgKiBAdHlwZSB7TWFwU0RLfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdih0aGlzLCBcIm1hcFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3ViZW1hcCBmYWNlcyBkZWZpbml0aW9uLCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgcHJlc2V0LCBwYXRoLCBvciBleHBsaWNpdCBmYWNlIFVSTHMuXG4gICAgICogQHR5cGUge0N1YmVtYXBGYWNlcyB8IG51bGx9XG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHNldCBkdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBsYXllciBhbmQgY2FuIGJlIHVwZGF0ZWQgbGF0ZXIuXG4gICAgICogSWYgbm8gZmFjZXMgYXJlIGRlZmluZWQsIGl0IHdpbGwgYmUgYG51bGxgLlxuICAgICAqL1xuICAgIHYodGhpcywgXCJmYWNlc1wiKTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0byB1c2UgYSBjdWJlbWFwIHRleHR1cmUgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwidXNlQ3ViZW1hcFRleHR1cmVcIiwgITApO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG9wYWNpdHkgb2YgdGhlIGZhZGUgZWZmZWN0IGFwcGxpZWQgdG8gdGhlIGN1YmVtYXAgaW1hZ2UgdGV4dHVyZSwgdXNlZCBmb3IgZmFkaW5nIGluIGFuZCBvdXQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IDAuMFxuICAgICAqL1xuICAgIHYodGhpcywgXCJjdXJyZW50RmFkZU9wYWNpdHlcIiwgMCk7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1YmVtYXAgbmVlZHMgdG8gYmUgdXBkYXRlZCwgdHlwaWNhbGx5IHdoZW4gdGhlIGZhY2VzIG9yIHRleHR1cmUgY2hhbmdlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgdih0aGlzLCBcImN1YmVNYXBOZWVkc1VwZGF0ZVwiLCAhMSk7XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGN1YmVtYXAgbGF5ZXIsIHJlcHJlc2VudGVkIGFzIGEgVmVjNCAoUkdCQSkuXG4gICAgICogQHR5cGUge1ZlYzR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwiYmdDb2xvclwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJldmlvdXMgYmFja2dyb3VuZCBjb2xvciB1c2VkIGZvciB0cmFuc2l0aW9uIGFuaW1hdGlvbnMuXG4gICAgICogQHR5cGUge1ZlYzR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwicHJldmlvdXNCZ0NvbG9yXCIsIFswLCAwLCAwLCAwXSk7XG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHdoaWNoIHRoZSBsYXllciB3aWxsIHRyYW5zaXRpb24uXG4gICAgICogQHR5cGUge1ZlYzR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwidGFyZ2V0QmdDb2xvclwiLCBbMCwgMCwgMCwgMF0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWx0YSB2YWx1ZSB1c2VkIGZvciB0cmFuc2l0aW9uaW5nIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLiAwID0gc3RhcnQgb2YgdHJhbnNpdGlvbiwgMSA9IGVuZCBvZiB0cmFuc2l0aW9uLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgaW5jcmVtZW50ZWQgb3ZlciB0aW1lIHRvIGNyZWF0ZSBhIHNtb290aCB0cmFuc2l0aW9uIGVmZmVjdC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdih0aGlzLCBcInRyYW5zaXRpb25EZWx0YVwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgV2ViR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGN1YmVtYXAgbGF5ZXIuXG4gICAgICogQHR5cGUge1dlYkdMQ29udGV4dH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHYodGhpcywgXCJnbFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3ViZW1hcCBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2hhZGVyIHByb2dyYW0sIGJ1ZmZlcnMgYW5kIHVuaWZvcm0gbG9jYXRpb25zIGZvciByZW5kZXJpbmcuXG4gICAgICogQHR5cGUge09iamVjdDNEfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdih0aGlzLCBcImN1YmVtYXBcIik7XG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIHRleHR1cmUgdXNlZCBmb3IgdGhlIGN1YmVtYXAsIHdoaWNoIGlzIGNyZWF0ZWQgZnJvbSB0aGUgZGVmaW5lZCBmYWNlcy5cbiAgICAgKiBUaGlzIHRleHR1cmUgaXMgdXNlZCB0byByZW5kZXIgdGhlIGN1YmVtYXAgaW4gdGhlIHNjZW5lLlxuICAgICAqIEB0eXBlIHtXZWJHTFRleHR1cmUgfCB1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwidGV4dHVyZVwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBmYWNlcyBkZWZpbml0aW9uLCB1c2VkIHRvIGRpZmYgLyB0cmFjayBjaGFuZ2VzIGluIHRoZSBjdWJlbWFwIGZhY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdih0aGlzLCBcImN1cnJlbnRGYWNlc0RlZmluaXRpb25LZXlcIiwgXCJcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGN1YmVtYXAgbGF5ZXIuXG4gICAgICogQHR5cGUge0N1YmVtYXBMYXllckNvbnN0cnVjdG9yT3B0aW9uc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHYodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIHYodGhpcywgXCJhbmltYXRpb25BY3RpdmVcIiwgITApO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBjdWJlbWFwIGltYWdlIGZhZGluZyBpbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBncmFkdWFsbHkgaW5jcmVhc2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBjdWJlbWFwIGltYWdlIHRvIGNyZWF0ZSBhIGZhZGUtaW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwiaW1hZ2VJc0FuaW1hdGluZ1wiLCAhMSk7XG4gICAgLyoqXG4gICAgICogVGhlIGRlbHRhIHZhbHVlIHVzZWQgZm9yIHRoZSBpbWFnZSBmYWRlLWluIGFuaW1hdGlvbi5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIGluY3JlbWVudGVkIG92ZXIgdGltZSB0byBjcmVhdGUgYSBzbW9vdGggZmFkZS1pbiBlZmZlY3QuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHYodGhpcywgXCJpbWFnZUZhZGVJbkRlbHRhXCIsIDApO1xuICAgIGNvbnN0IHQgPSAkdShlLCB3YSk7XG4gICAgdGhpcy5vcHRpb25zID0gdCwgdGhpcy5jdXJyZW50RmFjZXNEZWZpbml0aW9uS2V5ID0gSlNPTi5zdHJpbmdpZnkodC5mYWNlcyA/PyB0LnByZXNldCA/PyB0LnBhdGgpLCB0aGlzLmJnQ29sb3IgPSBbMCwgMCwgMCwgMF0sIHRoaXMudGFyZ2V0QmdDb2xvciA9IGp0KHQuY29sb3IpLCB0aGlzLmZhY2VzID0gU2EodCksIHRoaXMudXNlQ3ViZW1hcFRleHR1cmUgPSB0aGlzLmZhY2VzICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdWJlbWFwIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGZhY2VzIGFuZCBzaGFkZXIgY29uZmlndXJhdGlvbi5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGN1YmVtYXAgZmFjZXMgY2hhbmdlIG9yIHdoZW4gdGhlIGxheWVyIGlzIGluaXRpYWxpemVkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHJlbWFya3NcbiAgICogSXQgY3JlYXRlcyBhIG5ldyBPYmplY3QzRCBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLFxuICAgKiBhdHRyaWJ1dGVzLCBhbmQgdW5pZm9ybXMuIFRoZSBjdWJlbWFwIHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgdGhpcyBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgdXBkYXRlQ3ViZW1hcCh7IGZhY2VzTmVlZFVwZGF0ZTogZSB9ID0geyBmYWNlc05lZWRVcGRhdGU6ICEwIH0pIHtcbiAgICB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlID0gdGhpcy5mYWNlcyAhPT0gbnVsbDtcbiAgICBjb25zdCB0ID0genUuZmlsdGVyKChuKSA9PiBuID09PSBcImN1YmVTYW1wbGVyXCIgfHwgbiA9PT0gXCJmYWRlT3BhY2l0eVwiID8gdGhpcy51c2VDdWJlbWFwVGV4dHVyZSA6ICEwKTtcbiAgICB0aGlzLmN1YmVtYXAgPSB4byh7XG4gICAgICBnbDogdGhpcy5nbCxcbiAgICAgIHZlcnRleFNoYWRlclNvdXJjZTogVHUsXG4gICAgICAvLyBCZWNhdXNlIHdlIG9ubHkgd2FudCB0byB1c2UgdGhlIHJlYWQgdGhlIHRleHR1cmUgaW4gZ2wgaWYgd2UncmUgc3VwcG9zZWQgdG9cbiAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlOiB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlID8geWEucmVwbGFjZShiYSwgRnUpIDogeWEucmVwbGFjZShiYSwgXCJcIiksXG4gICAgICBhdHRyaWJ1dGVzS2V5czogUnUsXG4gICAgICB1bmlmb3Jtc0tleXM6IHQsXG4gICAgICB2ZXJ0aWNlczogRXUsXG4gICAgICBpbmRpY2VzOiBBdVxuICAgIH0pLCB0aGlzLmN1YmVNYXBOZWVkc1VwZGF0ZSA9IGUsIHRoaXMudXNlQ3ViZW1hcFRleHR1cmUgJiYgdGhpcy51cGRhdGVUZXh0dXJlKHRoaXMuZ2wsIHRoaXMuZmFjZXMpLCB0aGlzLmFuaW1hdGVDb2xvckNoYW5nZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGN1YmVtYXAgYW5kIHNldHMgdXAgdGhlIFdlYkdMIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFwU0RLfSBtYXAgLSBUaGUgbWFwIGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgbGF5ZXIgaXMgYWRkZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqL1xuICBvbkFkZChlLCB0KSB7XG4gICAgdGhpcy5tYXAgPSBlLCB0aGlzLmdsID0gdCwgdGhpcy51cGRhdGVDdWJlbWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcC5cbiAgICogQ2xlYW5zIHVwIHRoZSBjdWJlbWFwIHJlc291cmNlcyBhbmQgV2ViR0wgYnVmZmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtNYXBTREt9IF9tYXAgLSBUaGUgbWFwIGluc3RhbmNlIGZyb20gd2hpY2ggdGhpcyBsYXllciBpcyByZW1vdmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKi9cbiAgb25SZW1vdmUoZSwgdCkge1xuICAgIHRoaXMuY3ViZW1hcCAmJiAodC5kZWxldGVQcm9ncmFtKHRoaXMuY3ViZW1hcC5zaGFkZXJQcm9ncmFtKSwgdC5kZWxldGVCdWZmZXIodGhpcy5jdWJlbWFwLnBvc2l0aW9uQnVmZmVyKSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGN1YmVtYXAgdGV4dHVyZSB3aXRoIHRoZSBwcm92aWRlZCBmYWNlcy5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIGN1YmVtYXAgZmFjZXMgY2hhbmdlIG9yIHdoZW4gdGhlIGxheWVyIGlzIGluaXRpYWxpemVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7Q3ViZW1hcEZhY2VzfSBmYWNlcyAtIFRoZSBjdWJlbWFwIGZhY2VzIHRvIGJlIGxvYWRlZCBpbnRvIHRoZSB0ZXh0dXJlLlxuICAgKi9cbiAgdXBkYXRlVGV4dHVyZShlLCB0KSB7XG4gICAgaWYgKHRoaXMuY3ViZU1hcE5lZWRzVXBkYXRlID09PSAhMCAmJiAhdGhpcy5pbWFnZUlzQW5pbWF0aW5nKSB7XG4gICAgICBpZiAodGhpcy5jdWJlTWFwTmVlZHNVcGRhdGUgPSAhMSwgIXRoaXMudXNlQ3ViZW1hcFRleHR1cmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIEl1KHtcbiAgICAgICAgZ2w6IGUsXG4gICAgICAgIGZhY2VzOiB0LFxuICAgICAgICBvblJlYWR5OiAobikgPT4ge1xuICAgICAgICAgIHRoaXMudGV4dHVyZSA9IG4sIHRoaXMuYW5pbWF0ZUluKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIGJlZm9yZSB0aGUgbGF5ZXIgaXMgcmVuZGVyZWQuXG4gICAqIFVwZGF0ZXMgdGhlIGN1YmVtYXAgdGV4dHVyZSB3aXRoIHRoZSBjdXJyZW50IGZhY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7Q3VzdG9tUmVuZGVyTWV0aG9kSW5wdXR9IF9vcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVuZGVyIG1ldGhvZC5cbiAgICovXG4gIHByZXJlbmRlcihlLCB0KSB7XG4gICAgdGhpcy5mYWNlcyAmJiB0aGlzLnVwZGF0ZVRleHR1cmUodGhpcy5nbCwgdGhpcy5mYWNlcyk7XG4gIH1cbiAgLyoqXG4gICAqIExlcnBzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRyYW5zaXRpb24gb2YgdGhlIGN1YmVtYXAgbGF5ZXIuXG4gICAqIFRoaXMgbWV0aG9kIHNtb290aGx5IHRyYW5zaXRpb25zIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZyb20gdGhlIHByZXZpb3VzIGNvbG9yIHRvIHRoZSB0YXJnZXQgY29sb3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlQ29sb3JDaGFuZ2UoKSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbkRlbHRhIDwgMSAmJiAocmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpLCB0aGlzLmJnQ29sb3IgPSBQdSh0aGlzLnByZXZpb3VzQmdDb2xvciwgdGhpcy50YXJnZXRCZ0NvbG9yLCB0aGlzLnRyYW5zaXRpb25EZWx0YSksIHRoaXMudHJhbnNpdGlvbkRlbHRhICs9IDAuMDc1LCB0aGlzLm1hcC50cmlnZ2VyUmVwYWludCgpKTtcbiAgICB9O1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShlKTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgdGhlIGN1YmVtYXAgaW1hZ2UgZmFkaW5nIGluLlxuICAgKiBUaGlzIG1ldGhvZCBncmFkdWFsbHkgaW5jcmVhc2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBjdWJlbWFwIGltYWdlIHRvIGNyZWF0ZSBhIGZhZGUtaW4gZWZmZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgYW5pbWF0ZUluKCkge1xuICAgIGlmICghdGhpcy5pbWFnZUlzQW5pbWF0aW5nKSB7XG4gICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEZhZGVPcGFjaXR5ID0gMSwgdGhpcy5pbWFnZUZhZGVJbkRlbHRhID0gMSwgdGhpcy5tYXAudHJpZ2dlclJlcGFpbnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICAgIHRoaXMuaW1hZ2VJc0FuaW1hdGluZyA9ICEwO1xuICAgICAgICBjb25zdCB0ID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlRmFkZUluRGVsdGEgPSBNYXRoLm1pbih0aGlzLmltYWdlRmFkZUluRGVsdGEgKyAwLjA1LCAxKSwgdGhpcy5jdXJyZW50RmFkZU9wYWNpdHkgPSBSZSgwLCAxLCB0aGlzLmltYWdlRmFkZUluRGVsdGEpLCB0aGlzLm1hcC50cmlnZ2VyUmVwYWludCgpLCB0aGlzLmltYWdlRmFkZUluRGVsdGEgPCAxKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW1hZ2VJc0FuaW1hdGluZyA9ICExLCB0aGlzLmltYWdlRmFkZUluRGVsdGEgPSAwLCBlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgdGhlIGN1YmVtYXAgaW1hZ2UgZmFkaW5nIG91dC5cbiAgICogVGhpcyBtZXRob2QgZ3JhZHVhbGx5IGRlY3JlYXNlcyB0aGUgb3BhY2l0eSBvZiB0aGUgY3ViZW1hcCBpbWFnZSB0byBjcmVhdGUgYSBmYWRlLW91dCBlZmZlY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBhbmltYXRlT3V0KCkge1xuICAgIGlmICghKHRoaXMuaW1hZ2VJc0FuaW1hdGluZyB8fCAhdGhpcy5hbmltYXRpb25BY3RpdmUpKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaW1hZ2VGYWRlSW5EZWx0YSA9IE1hdGgubWluKHRoaXMuaW1hZ2VGYWRlSW5EZWx0YSArIDAuMDUsIDEpLCB0aGlzLmN1cnJlbnRGYWRlT3BhY2l0eSA9IFJlKDEsIDAsIHRoaXMuaW1hZ2VGYWRlSW5EZWx0YSksIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCksIHRoaXMuaW1hZ2VGYWRlSW5EZWx0YSA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlSXNBbmltYXRpbmcgPSAhMSwgdGhpcy5pbWFnZUZhZGVJbkRlbHRhID0gMCwgZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICAgIH0pO1xuICB9XG4gIHNldEFuaW1hdGlvbkFjdGl2ZShlKSB7XG4gICAgdGhpcy5hbmltYXRpb25BY3RpdmUgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjdWJlbWFwIGxheWVyIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW50ZXJuYWxseSBkdXJpbmcgdGhlIHJlbmRlcmluZyBwaGFzZSBvZiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge0N1c3RvbVJlbmRlck1ldGhvZElucHV0fSBfb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlbmRlciBtZXRob2QuXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIG1hcCwgY3ViZW1hcCwgb3IgdGV4dHVyZSBpcyB1bmRlZmluZWQuXG4gICAqL1xuICByZW5kZXIoZSwgdCkge1xuICAgIGlmICghdGhpcy5tYXAuaXNHbG9iZVByb2plY3Rpb24oKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5tYXAgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltDdWJlbWFwTGF5ZXJdOiBNYXAgaXMgdW5kZWZpbmVkXCIpO1xuICAgIGlmICh0aGlzLmN1YmVtYXAgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltDdWJlbWFwTGF5ZXJdOiBDdWJlbWFwIGlzIHVuZGVmaW5lZFwiKTtcbiAgICB0aGlzLnRleHR1cmUsIGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLCBlLmVuYWJsZShlLkJMRU5EKSwgZS5ibGVuZEZ1bmMoZS5TUkNfQUxQSEEsIGUuRFNUX0FMUEhBKSwgZS51c2VQcm9ncmFtKHRoaXMuY3ViZW1hcC5zaGFkZXJQcm9ncmFtKSwgZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLCB0aGlzLmN1YmVtYXAucG9zaXRpb25CdWZmZXIpLCBlLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5jdWJlbWFwLnByb2dyYW1JbmZvLmF0dHJpYnV0ZXNMb2NhdGlvbnMudmVydGV4UG9zaXRpb24sIDMsIGUuRkxPQVQsICExLCAwLCAwKSwgZS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmN1YmVtYXAucHJvZ3JhbUluZm8uYXR0cmlidXRlc0xvY2F0aW9ucy52ZXJ0ZXhQb3NpdGlvbik7XG4gICAgY29uc3QgbiA9IDAuMSwgYSA9IDFlNCwgbyA9IGUuY2FudmFzLCBpID0gby5jbGllbnRXaWR0aCAvIG8uY2xpZW50SGVpZ2h0LCBzID0gdGhpcy5tYXAudHJhbnNmb3JtLCBsID0gcy5mb3YgKiAoTWF0aC5QSSAvIDE4MCksIHUgPSBtdCgpO1xuICAgIHV1KHUsIGwsIGksIG4sIGEpLCB1YSh1LCB1LCBzLnJvbGxJblJhZGlhbnMpLCBsYSh1LCB1LCAtcy5waXRjaEluUmFkaWFucyksIHVhKHUsIHUsIHMuYmVhcmluZ0luUmFkaWFucyk7XG4gICAgY29uc3QgYyA9IHMuY2VudGVyLmxhdCAqIE1hdGguUEkgLyAxODAsIHAgPSBzLmNlbnRlci5sbmcgKiBNYXRoLlBJIC8gMTgwO1xuICAgIGxhKHUsIHUsIGMpLCBzdSh1LCB1LCAtcCksIGUudW5pZm9ybU1hdHJpeDRmdih0aGlzLmN1YmVtYXAucHJvZ3JhbUluZm8udW5pZm9ybXNMb2NhdGlvbnMucHJvamVjdGlvbk1hdHJpeCwgITEsIHUpO1xuICAgIGNvbnN0IGQgPSBtdCgpO1xuICAgIGlmIChlLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5jdWJlbWFwLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLm1vZGVsVmlld01hdHJpeCwgITEsIGQpLCBlLnVuaWZvcm00ZnYodGhpcy5jdWJlbWFwLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLmJnQ29sb3IsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5iZ0NvbG9yKSksIGUudW5pZm9ybTFmKHRoaXMuY3ViZW1hcC5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5mYWRlT3BhY2l0eSwgdGhpcy5jdXJyZW50RmFkZU9wYWNpdHkpLCB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlICYmIHRoaXMudGV4dHVyZSAmJiAoZS5hY3RpdmVUZXh0dXJlKGUuVEVYVFVSRTApLCBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKSwgZS51bmlmb3JtMWkodGhpcy5jdWJlbWFwLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLmN1YmVTYW1wbGVyLCAwKSksIHRoaXMuY3ViZW1hcC5pbmRleEJ1ZmZlciA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggYnVmZmVyIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBpZiAodGhpcy5jdWJlbWFwLmluZGV4QnVmZmVyTGVuZ3RoID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBidWZmZXIgbGVuZ3RoIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5jdWJlbWFwLmluZGV4QnVmZmVyKSwgZS5kcmF3RWxlbWVudHMoZS5UUklBTkdMRVMsIHRoaXMuY3ViZW1hcC5pbmRleEJ1ZmZlckxlbmd0aCwgZS5VTlNJR05FRF9TSE9SVCwgMCk7XG4gIH1cbiAgc2V0QmdDb2xvcihlKSB7XG4gICAgdGhpcy50YXJnZXRCZ0NvbG9yID0gZSwgdGhpcy5wcmV2aW91c0JnQ29sb3IgPSB0aGlzLmJnQ29sb3IsIHRoaXMudHJhbnNpdGlvbkRlbHRhID0gMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjdWJlbWFwIGxheWVyLlxuICAgKiBAcmV0dXJucyB7Q3ViZW1hcExheWVyQ29uc3RydWN0b3JPcHRpb25zfSBUaGUgY3VycmVudCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuICBhc3luYyBzZXRDdWJlbWFwRmFjZXMoZSkge1xuICAgIGlmIChhd2FpdCB0aGlzLmFuaW1hdGVPdXQoKSwgIWUuZmFjZXMgJiYgIWUucHJlc2V0ICYmICFlLnBhdGgpIHtcbiAgICAgIHRoaXMuZmFjZXMgPSBudWxsLCB0aGlzLnVzZUN1YmVtYXBUZXh0dXJlID0gITEsIHRoaXMuY3VycmVudEZhY2VzRGVmaW5pdGlvbktleSA9IFwiZW1wdHlcIiwgYXdhaXQgdGhpcy5hbmltYXRlSW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mYWNlcyA9IFNhKGUpLCB0aGlzLmN1cnJlbnRGYWNlc0RlZmluaXRpb25LZXkgPSBKU09OLnN0cmluZ2lmeShlLmZhY2VzID8/IGUucHJlc2V0ID8/IGUucGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1YmVtYXAgZm9yIHRoZSBsYXllciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGVmaW5pdGlvbi5cbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3ViZW1hcCBmYWNlcywgYmFja2dyb3VuZCBjb2xvciwgYW5kIHRyaWdnZXJzIGEgcmVwYWludCBvZiB0aGUgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge0N1YmVtYXBEZWZpbml0aW9ufSBjdWJlbWFwIC0gVGhlIGN1YmVtYXAgZGVmaW5pdGlvbiBjb250YWluaW5nIGZhY2VzLCBwcmVzZXQsIHBhdGgsIG9yIGNvbG9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3ViZW1hcCBpcyBzZXQgYW5kIHRoZSBtYXAgaXMgdXBkYXRlZC5cbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIHRoZSBwcm92aWRlZCBjdWJlbWFwIGRlZmluaXRpb24gaGFzIGEgY29sb3IsIGFuZCBpZiBzbywgaXQgdXBkYXRlcyB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGZhY2VzIGRlZmluaXRpb24gaGFzIGNoYW5nZWQgY29tcGFyZWQgdG8gdGhlIGN1cnJlbnQgb25lLFxuICAgKiBhbmQgaWYgc28sIGl0IHVwZGF0ZXMgdGhlIGN1YmVtYXAgZmFjZXMuXG4gICAqIEZpbmFsbHksIGl0IGNhbGxzIGB1cGRhdGVDdWJlbWFwYCB0byBhcHBseSB0aGUgY2hhbmdlcyBhbmQgdHJpZ2dlciBhIHJlcGFpbnQgb2YgdGhlIG1hcC5cbiAgICovXG4gIGFzeW5jIHNldEN1YmVtYXAoZSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcImJvb2xlYW5cIiA/IHdhIDogZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0O1xuICAgIGNvbnN0IG4gPSBKU09OLnN0cmluZ2lmeSh0LmZhY2VzID8/IHQucHJlc2V0ID8/IHQucGF0aCksIGEgPSB0aGlzLmN1cnJlbnRGYWNlc0RlZmluaXRpb25LZXkgIT09IG47XG4gICAgYSAmJiAoYXdhaXQgdGhpcy5zZXRDdWJlbWFwRmFjZXModCksIHRoaXMuY3ViZU1hcE5lZWRzVXBkYXRlID0gITApO1xuICAgIGNvbnN0IG8gPSBqdCh0LmNvbG9yKTtcbiAgICBpZiAodC5jb2xvciAmJiB0aGlzLnRhcmdldEJnQ29sb3IudG9TdHJpbmcoKSAhPT0gby50b1N0cmluZygpKVxuICAgICAgdGhpcy5zZXRCZ0NvbG9yKG8pO1xuICAgIGVsc2UgaWYgKCF0LmNvbG9yICYmIHQucHJlc2V0ICYmIHQucHJlc2V0IGluIEhlKSB7XG4gICAgICBjb25zdCBpID0gSGVbdC5wcmVzZXRdO1xuICAgICAgdGhpcy5zZXRCZ0NvbG9yKGp0KGkuY29sb3IpKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVDdWJlbWFwKHsgZmFjZXNOZWVkVXBkYXRlOiBhIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgY3ViZW1hcCBsYXllciBieSBzZXR0aW5nIGl0cyB2aXNpYmlsaXR5IHRvIFwidmlzaWJsZVwiLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIG1ha2UgdGhlIGN1YmVtYXAgbGF5ZXIgdmlzaWJsZSBvbiB0aGUgbWFwLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eSh0aGlzLmlkLCBcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgY3ViZW1hcCBsYXllciBieSBzZXR0aW5nIGl0cyB2aXNpYmlsaXR5IHRvIFwibm9uZVwiLlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHJlbW92ZSB0aGUgY3ViZW1hcCBsYXllciBmcm9tIHRoZSBtYXAgd2l0aG91dCBkZWxldGluZyBpdC5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5tYXAuc2V0TGF5b3V0UHJvcGVydHkodGhpcy5pZCwgXCJ2aXNpYmlsaXR5XCIsIFwibm9uZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24ga28ocikge1xuICByZXR1cm4gciA/IHR5cGVvZiByID09IFwiYm9vbGVhblwiID8gITAgOiAhKCFyLnBhdGggJiYgIXIucHJlc2V0ICYmICFyLmZhY2VzICYmICFyLmNvbG9yIHx8IHIucHJlc2V0ICYmICEoci5wcmVzZXQgaW4gSGUpIHx8IHIuZmFjZXMgJiYgKCFyLmZhY2VzLnBYIHx8ICFyLmZhY2VzLm5YIHx8ICFyLmZhY2VzLnBZIHx8ICFyLmZhY2VzLm5ZIHx8ICFyLmZhY2VzLnBaIHx8ICFyLmZhY2VzLm5aKSkgOiAhMTtcbn1cbmZ1bmN0aW9uIFNhKHIpIHtcbiAgaWYgKHIuZmFjZXMpXG4gICAgcmV0dXJuIHIuZmFjZXM7XG4gIGlmIChyLnByZXNldClcbiAgICByZXR1cm4ge1xuICAgICAgcFg6IGAke0plfS8ke3IucHJlc2V0fS9weC53ZWJwYCxcbiAgICAgIG5YOiBgJHtKZX0vJHtyLnByZXNldH0vbngud2VicGAsXG4gICAgICBwWTogYCR7SmV9LyR7ci5wcmVzZXR9L3B5LndlYnBgLFxuICAgICAgblk6IGAke0plfS8ke3IucHJlc2V0fS9ueS53ZWJwYCxcbiAgICAgIHBaOiBgJHtKZX0vJHtyLnByZXNldH0vcHoud2VicGAsXG4gICAgICBuWjogYCR7SmV9LyR7ci5wcmVzZXR9L256LndlYnBgXG4gICAgfTtcbiAgaWYgKHIucGF0aCkge1xuICAgIGNvbnN0IGUgPSByLnBhdGguYmFzZVVybCwgdCA9IHIucGF0aC5mb3JtYXQgPz8gXCJwbmdcIjtcbiAgICByZXR1cm4ge1xuICAgICAgcFg6IGAke2V9L3B4LiR7dH1gLFxuICAgICAgblg6IGAke2V9L254LiR7dH1gLFxuICAgICAgcFk6IGAke2V9L3B5LiR7dH1gLFxuICAgICAgblk6IGAke2V9L255LiR7dH1gLFxuICAgICAgcFo6IGAke2V9L3B6LiR7dH1gLFxuICAgICAgblo6IGAke2V9L256LiR7dH1gXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IE91ID0gYGF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XG5cbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcbnVuaWZvcm0gbWF0NCB1X3JvdGF0aW9uTWF0cml4O1xuXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XG5cbnZhcnlpbmcgdmVjMiB2X3BvcztcbnZhcnlpbmcgZmxvYXQgdl9zY2FsZTtcblxudm9pZCBtYWluKCkge1xuICB2X3NjYWxlID0gdV9zY2FsZTtcbiAgdl9wb3MgPSBhX3Bvc2l0aW9uLnh5ICogdV9zY2FsZTtcbiAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHVfcm90YXRpb25NYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XG59XG5gLCBOdSA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbnZhcnlpbmcgdmVjMiB2X3BvcztcbiAgICAgIFxudW5pZm9ybSBpbnQgdV9zdG9wc051bWJlcjtcbnVuaWZvcm0gZmxvYXQgdV9zdG9wc1sxMDBdO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JzWzEwMF07XG51bmlmb3JtIGZsb2F0IHVfbWF4RGlzdGFuY2U7XG5cbnZhcnlpbmcgZmxvYXQgdl9zY2FsZTtcblxuY29uc3QgZmxvYXQgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG52ZWMyIGNlbnRlciA9IHZlYzIoMC4wLCAwLjApO1xudm9pZCBtYWluKCkge1xuICBmbG9hdCByYXdEaXN0YW5jZSA9IGRpc3RhbmNlKGNlbnRlciwgdl9wb3MpO1xuICBmbG9hdCBkaXN0YW5jZUZyb21HbG9iZUVkZ2UgPSByYXdEaXN0YW5jZSAtIDEuMDtcblxuICAgIHZlYzQgY29sb3IgPSB1X2NvbG9yc1swXTtcblxuICAvLyBpZiB3ZSdyZSBmdXJ0aGVyIHRoYW4gdGhlIG1heCBkaXN0YW5jZSwgd2Ugc2hvdWxkIG5vdCByZW5kZXIgYW55dGhpbmcuXG4gIC8vIFRoaXMgaXMgdG8gYWx3YXlzIHJlbmRlciBhIGNpcmNsZSwgb3RoZXJ3aXNlIHdlIGVuZCB1cCByZW5kZXJpbmdcbiAgLy8gdG8gdGhlIGNvcm5lcnMgb2YgdGhlIHBsYW5lLlxuICBpZiAoZGlzdGFuY2UoY2VudGVyLCB2X3BvcykgPiB1X21heERpc3RhbmNlICogdl9zY2FsZSkge1xuICAgIGRpc2NhcmQ7XG4gIH1cblxuICBmb3IgKGludCBpID0gMTsgaSA8IDEwMDsgaSsrKSB7XG4gICAgLy8gaWYgd2UncmUgcGFzdCB0aGUgbGFzdCBzdG9wXG4gICAgLy8gd2Ugc2hvdWxkIGZpbGwgdG8gdGhlIGVuZCB3aXRoIHRoZSBsYXN0IHN0b3AgY29sb3JcbiAgICBpZiAoaSA+PSB1X3N0b3BzTnVtYmVyKSB7XG4gICAgICBjb2xvciA9IHVfY29sb3JzW2kgLSAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZsb2F0IHNjYWxlZFN0b3BQb3NpdGlvbiA9IHVfc3RvcHNbaV0gKiBwb3codl9zY2FsZSwgMS42KTtcbiAgICBmbG9hdCBsYXN0U3RvcFZhbHVlID0gdV9zdG9wc1tpIC0gMV07XG4gICAgZmxvYXQgdGhpc1N0b3BWYWx1ZSA9IHVfc3RvcHNbaV07XG5cbiAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIGJsZW5kaW5nIGVycm9ycyB3aGVuIHRoZSBzdG9wcyBhcmUgdGhlIHNhbWVcbiAgICAvLyBlZyB3aGVuIHlvdSB3b3VsZCB3YW50IGEgc2hhcnAgZWRnZSBiZXR3ZWVuIHR3byBzdG9wcy5cbiAgICAvLyBcXGBudW1iZXJzQXJlRXF1YWxcXGAgd2lsbCBiZSAxLjAgaWYgdGhlIG51bWJlcnMgYXJlIGVxdWFsLCAwLjAgaWYgdGhleSBhcmUgbm90LlxuICAgIC8vIFdlIHRoZW4gc3VidHJhY3QgRVBTSUxPTiBmcm9tIHRoZSBsYXN0IHN0b3AgbWFraW5nIHRoZSBzdG9wIHZhbHVlIF9hbG1vc3RfIGVxdWFsXG4gICAgLy8gdG8gdGhlIG5leHQgc3RvcCBidXQgbm90IGVub3VnaCB0byBjYXVzZSBibGVuZGluZyBpc3N1ZXMuXG4gICAgLy8gSXQncyBtb3JlIGVmZmljaWVudCB0byBkbyB0aGlzIHRoYW4gYW4gaWYgLyBlbHNlIHN0YXRlbWVudC5cbiAgICBmbG9hdCBudW1iZXJzQXJlRXF1YWwgPSAxLjAgLSBzdGVwKEVQU0lMT04sIGFicyhsYXN0U3RvcFZhbHVlIC0gdGhpc1N0b3BWYWx1ZSkpO1xuICAgIGxhc3RTdG9wVmFsdWUgPSBsYXN0U3RvcFZhbHVlIC0gbnVtYmVyc0FyZUVxdWFsICogRVBTSUxPTjtcblxuICAgIGZsb2F0IGxhc3RTY2FsZWRTdG9wUG9zaXRpb24gPSBsYXN0U3RvcFZhbHVlICogcG93KHZfc2NhbGUsIDEuNik7XG5cbiAgICBpZiAoZGlzdGFuY2VGcm9tR2xvYmVFZGdlIDw9IHNjYWxlZFN0b3BQb3NpdGlvbikge1xuICAgICAgZmxvYXQgc3RvcEJsZW5kRmFjdG9yID0gKGRpc3RhbmNlRnJvbUdsb2JlRWRnZSAtIGxhc3RTY2FsZWRTdG9wUG9zaXRpb24pIC8gKHNjYWxlZFN0b3BQb3NpdGlvbiAtIGxhc3RTY2FsZWRTdG9wUG9zaXRpb24pO1xuICAgICAgY29sb3IgPSBtaXgodV9jb2xvcnNbaSAtIDFdLCB1X2NvbG9yc1tpXSwgc3RvcEJsZW5kRmFjdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiICogY29sb3IuYSwgY29sb3IuYSk7XG59XG5gLCBwdCA9IDIsIGp1ID0gW1wicG9zaXRpb25cIl0sIFV1ID0gW1wibWF0cml4XCIsIFwicm90YXRpb25NYXRyaXhcIiwgXCJzdG9wc051bWJlclwiLCBcInN0b3BzXCIsIFwiY29sb3JzXCIsIFwibWF4RGlzdGFuY2VcIiwgXCJzY2FsZVwiXSwgRHUgPSBbXG4gIC0yLFxuICAtMixcbiAgMCxcbiAgcHQsXG4gIC0yLFxuICAwLFxuICAtMixcbiAgcHQsXG4gIDAsXG4gIHB0LFxuICBwdCxcbiAgMFxuXSwgamUgPSB7XG4gIHNjYWxlOiAwLjksXG4gIHN0b3BzOiBbXG4gICAgWzAsIFwicmdiYSgxNzYsIDIwOCwgMjQwLCAxKVwiXSxcbiAgICBbMC4xLCBcInJnYmEoOTgsIDE2OCwgMjI5LCAwLjMpXCJdLFxuICAgIFswLjIsIFwicmdiYSg5OCwgMTY4LCAyMjksIDAuMClcIl1cbiAgXVxufSwgeGEgPSAwLjA2O1xuY2xhc3MgUnIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSYWRpYWxHcmFkaWVudExheWVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JhZGlhbEdyYWRpZW50TGF5ZXJDb25zdHJ1Y3Rvck9wdGlvbnMgfCBib29sZWFufSBncmFkaWVudCAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJhZGlhbCBncmFkaWVudCBvciBhIGJvb2xlYW4gdmFsdWUuXG4gICAqIElmIGEgYm9vbGVhbiBpcyBwcm92aWRlZCwgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMgd2lsbCBiZSB1c2VkLlxuICAgKiBJZiBhbiBgUmFkaWFsR3JhZGllbnRMYXllckNvbnN0cnVjdG9yT3B0aW9uc2AgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHYodGhpcywgXCJpZFwiLCBcIkhhbG8gTGF5ZXJcIik7XG4gICAgdih0aGlzLCBcInR5cGVcIiwgXCJjdXN0b21cIik7XG4gICAgdih0aGlzLCBcInJlbmRlcmluZ01vZGVcIiwgXCIzZFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZ3JhZGllbnQgZGVmaW5pdGlvbiB1c2VkIGJ5IHRoaXMgbGF5ZXIuXG4gICAgICogSXQgY29udGFpbnMgdGhlIHN0b3BzIGFuZCBzY2FsZSBmb3IgdGhlIHJhZGlhbCBncmFkaWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtHcmFkaWVudERlZmluaXRpb259XG4gICAgICovXG4gICAgdih0aGlzLCBcImdyYWRpZW50XCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgcmFkaWFsIGdyYWRpZW50LCB3aGljaCBkZXRlcm1pbmVzIGl0cyBzaXplLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgYW5pbWF0ZWQgZnJvbSAwIHRvIHRoZSB0YXJnZXQgc2NhbGUgZHVyaW5nIHRoZSBsYXllcidzIGFwcGVhcmFuY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHYodGhpcywgXCJzY2FsZVwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYW5pbWF0aW9uIGRlbHRhIHZhbHVlIHVzZWQgdG8gY29udHJvbCB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGdyYWRpZW50J3MgYXBwZWFyYW5jZSBhbmltYXRpb24uXG4gICAgICogSXQgaXMgaW5jcmVtZW50ZWQgZHVyaW5nIGVhY2ggZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiB1bnRpbCBpdCByZWFjaGVzIDEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHYodGhpcywgXCJhbmltYXRpb25EZWx0YVwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgTWFwU0RLIGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgbGF5ZXIgaXMgYWRkZWQuXG4gICAgICogVGhpcyBpcyBzZXQgd2hlbiB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNYXBTREt9XG4gICAgICovXG4gICAgdih0aGlzLCBcIm1hcFwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgM0Qgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFkaWFsIGdyYWRpZW50IHBsYW5lLlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCBhbmQgY29udGFpbnMgdGhlIHNoYWRlciBwcm9ncmFtIGFuZCBidWZmZXJzLlxuICAgICAqIEl0IGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgcmFkaWFsIGdyYWRpZW50IGVmZmVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3QzRDwodHlwZW9mIEFUVFJJQlVURVNfS0VZUylbbnVtYmVyXSwgKHR5cGVvZiBVTklGT1JNU19LRVlTKVtudW1iZXJdPn1cbiAgICAgKi9cbiAgICB2KHRoaXMsIFwicGxhbmVcIik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgaGFsbyBzaG91bGQgYmUgYW5pbWF0ZWQgaW4gYW5kIG91dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHYodGhpcywgXCJhbmltYXRpb25BY3RpdmVcIiwgITApO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhpcy5ncmFkaWVudCA9IGplO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyYWRpZW50ID0ge1xuICAgICAgLi4uamUsXG4gICAgICAuLi5lXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWRkcyB0aGUgcmFkaWFsIGdyYWRpZW50IGxheWVyIHRvIHRoZSBzcGVjaWZpZWQgbWFwLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1hcCB3aGVuIHRoZSBsYXllciBpcyBhZGRlZCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtNYXBTREt9IG1hcCAtIFRoZSBNYXBTREsgaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBsYXllciBpcyBiZWluZyBhZGRlZFxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgbGF5ZXJcbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgb25BZGQoZSwgdCkge1xuICAgIHRoaXMubWFwID0gZSwgdGhpcy5wbGFuZSA9IHhvKHtcbiAgICAgIGdsOiB0LFxuICAgICAgdmVydGV4U2hhZGVyU291cmNlOiBPdSxcbiAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlOiBOdSxcbiAgICAgIGF0dHJpYnV0ZXNLZXlzOiBqdSxcbiAgICAgIHVuaWZvcm1zS2V5czogVXUsXG4gICAgICB2ZXJ0aWNlczogRHVcbiAgICB9KSwgdGhpcy5hbmltYXRlSW4oKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBncmFkaWVudCBjb25maWd1cmF0aW9uIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQgbGF5ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtHcmFkaWVudERlZmluaXRpb259IFRoZSBjdXJyZW50IGdyYWRpZW50IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBnZXRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JhZGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSByYWRpYWwgZ3JhZGllbnQgaW50byB2aWV3IGJ5IGdyYWR1YWxseSBzY2FsaW5nIGZyb20gMCB0byB0aGUgdGFyZ2V0IHNjYWxlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB1c2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0byBjcmVhdGUgYSBzbW9vdGggc2NhbGluZyBhbmltYXRpb24gZWZmZWN0LlxuICAgKiBEdXJpbmcgZWFjaCBmcmFtZSwgaXQ6XG4gICAqICAgMS4gSW50ZXJwb2xhdGVzIHRoZSBzY2FsZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIHRoZSB0YXJnZXQgc2NhbGVcbiAgICogICAyLiBJbmNyZW1lbnRzIHRoZSBhbmltYXRpb24gcHJvZ3Jlc3MgKGFuaW1hdGlvbkRlbHRhKVxuICAgKiAgIDMuIFRyaWdnZXJzIGEgbWFwIHJlcGFpbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICovXG4gIGFzeW5jIGFuaW1hdGVJbigpIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0aW9uQWN0aXZlKSB7XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5ncmFkaWVudC5zY2FsZSwgdGhpcy5hbmltYXRpb25EZWx0YSA9IDEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgICAgdGhpcy5hbmltYXRpb25EZWx0YSA9IDA7XG4gICAgICBjb25zdCB0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25EZWx0YSA8IDEpIHtcbiAgICAgICAgICB0aGlzLnNjYWxlID0gUmUoMCwgdGhpcy5ncmFkaWVudC5zY2FsZSwgdGhpcy5hbmltYXRpb25EZWx0YSksIHRoaXMuYW5pbWF0aW9uRGVsdGEgKz0geGEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgdGhlIHJhZGlhbCBncmFkaWVudCBsYXllciBvdXQgYnkgZ3JhZHVhbGx5IHJlZHVjaW5nIGl0cyBzY2FsZSB0byB6ZXJvLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgc21vb3RoIHRyYW5zaXRpb24gZWZmZWN0IGJ5IGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHNjYWxlXG4gICAqIGZyb20gaXRzIGN1cnJlbnQgdmFsdWUgdG8gemVybyBvdmVyIG11bHRpcGxlIGFuaW1hdGlvbiBmcmFtZXMuIER1cmluZyBlYWNoIGZyYW1lLFxuICAgKiB0aGUgYW5pbWF0aW9uIHByb2dyZXNzZXMgYnkgaW5jcmVtZW50aW5nIHRoZSBpbnRlcm5hbCBhbmltYXRpb24gZGVsdGEgdmFsdWUuXG4gICAqXG4gICAqIFRoZSBtYXAgaXMgcmVwYWludGVkIGFmdGVyIGVhY2ggYW5pbWF0aW9uIHN0ZXAgdG8gcmVmbGVjdCB0aGUgdXBkYXRlZCBzY2FsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgYXN5bmMgYW5pbWF0ZU91dCgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25BY3RpdmUpXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25EZWx0YSA9IDAsIG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsdGEgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gUmUodGhpcy5ncmFkaWVudC5zY2FsZSwgMCwgdGhpcy5hbmltYXRpb25EZWx0YSksIHRoaXMuYW5pbWF0aW9uRGVsdGEgKz0geGEsIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0KCk7XG4gICAgICB9KTtcbiAgfVxuICBvblJlbW92ZShlLCB0KSB7XG4gICAgdGhpcy5wbGFuZSAhPT0gdm9pZCAwICYmICh0LmRlbGV0ZVByb2dyYW0odGhpcy5wbGFuZS5zaGFkZXJQcm9ncmFtKSwgdC5kZWxldGVCdWZmZXIodGhpcy5wbGFuZS5wb3NpdGlvbkJ1ZmZlcikpO1xuICB9XG4gIHByZXJlbmRlcihlLCB0KSB7XG4gIH1cbiAgcmVuZGVyKGUsIHQpIHtcbiAgICBpZiAodGhpcy5tYXAgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSYWRpYWxHcmFkaWVudExheWVyXTogTWFwIGlzIHVuZGVmaW5lZFwiKTtcbiAgICBpZiAoIXRoaXMubWFwLmlzR2xvYmVQcm9qZWN0aW9uKCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucGxhbmUgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSYWRpYWxHcmFkaWVudExheWVyXTogUGxhbmUgaXMgdW5kZWZpbmVkXCIpO1xuICAgIGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLCBlLmVuYWJsZShlLkJMRU5EKSwgZS51c2VQcm9ncmFtKHRoaXMucGxhbmUuc2hhZGVyUHJvZ3JhbSksIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUiwgdGhpcy5wbGFuZS5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgY29uc3QgbiA9IHRoaXMucGxhbmUucHJvZ3JhbUluZm8uYXR0cmlidXRlc0xvY2F0aW9ucy5wb3NpdGlvbjtcbiAgICBlLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG4pLCBlLnZlcnRleEF0dHJpYlBvaW50ZXIobiwgMywgZS5GTE9BVCwgITEsIDAsIDApO1xuICAgIGNvbnN0IGEgPSBtdCgpLCBvID0gdGhpcy5zY2FsZTtcbiAgICBpdShhLCBhLCBbbywgbywgb10pO1xuICAgIGNvbnN0IGkgPSBtdCgpO1xuICAgIG91KGksIHQuZGVmYXVsdFByb2plY3Rpb25EYXRhLm1haW5NYXRyaXgsIGEpO1xuICAgIGNvbnN0IHMgPSB0aGlzLnBsYW5lLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLm1hdHJpeDtcbiAgICBlLnVuaWZvcm1NYXRyaXg0ZnYocywgITEsIGkpO1xuICAgIGNvbnN0IGwgPSBtdCgpLCB1ID0gdGhpcy5tYXAudHJhbnNmb3JtLmNhbWVyYVBvc2l0aW9uLCBjID0gQXIoTnQoKSwgdSksIHAgPSBjdSgwLCAxLCAwKSwgZCA9IE50KCk7XG4gICAgY2EoZCwgcCwgYyksIEFyKGQsIGQpO1xuICAgIGNvbnN0IGYgPSBOdCgpO1xuICAgIGNhKGYsIGMsIGQpLCBBcihmLCBmKSwgYXUobCwgZFswXSwgZFsxXSwgZFsyXSwgMCwgZlswXSwgZlsxXSwgZlsyXSwgMCwgY1swXSwgY1sxXSwgY1syXSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgY29uc3QgaCA9IHRoaXMucGxhbmUucHJvZ3JhbUluZm8udW5pZm9ybXNMb2NhdGlvbnMucm90YXRpb25NYXRyaXg7XG4gICAgZS51bmlmb3JtTWF0cml4NGZ2KGgsICExLCBsKTtcbiAgICBjb25zdCBtID0gdGhpcy5ncmFkaWVudC5zdG9wcy5sZW5ndGgsIHkgPSBbXSwgdyA9IFtdO1xuICAgIGZvciAobGV0IGcgPSAwOyBnIDw9IG07IGcrKylcbiAgICAgIGlmIChnIDwgbSkge1xuICAgICAgICB5W2ddID0gdGhpcy5ncmFkaWVudC5zdG9wc1tnXVswXTtcbiAgICAgICAgY29uc3QgeCA9IGp0KHRoaXMuZ3JhZGllbnQuc3RvcHNbZ11bMV0pO1xuICAgICAgICB3LnB1c2goLi4ueCk7XG4gICAgICB9XG4gICAgZS51bmlmb3JtMWkodGhpcy5wbGFuZS5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5zdG9wc051bWJlciwgbSksIGUudW5pZm9ybTFmdih0aGlzLnBsYW5lLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLnN0b3BzLCBuZXcgRmxvYXQzMkFycmF5KHkpKSwgZS51bmlmb3JtNGZ2KHRoaXMucGxhbmUucHJvZ3JhbUluZm8udW5pZm9ybXNMb2NhdGlvbnMuY29sb3JzLCBuZXcgRmxvYXQzMkFycmF5KHcpKSwgZS51bmlmb3JtMWYodGhpcy5wbGFuZS5wcm9ncmFtSW5mby51bmlmb3Jtc0xvY2F0aW9ucy5tYXhEaXN0YW5jZSwgcHQpLCBlLnVuaWZvcm0xZih0aGlzLnBsYW5lLnByb2dyYW1JbmZvLnVuaWZvcm1zTG9jYXRpb25zLnNjYWxlLCBvKSwgZS5kcmF3QXJyYXlzKGUuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IGdyYWRpZW50IGZvciB0aGUgcmFkaWFsIGdyYWRpZW50IGxheWVyIGFuZCBhbmltYXRlcyB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgYW5pbWF0ZXMgdGhlIGN1cnJlbnQgZ3JhZGllbnQgb3V0LCB0aGVuIHVwZGF0ZXMgdGhlIGdyYWRpZW50XG4gICAqIHByb3BlcnR5IHdpdGggdGhlIG5ldyBncmFkaWVudCBkZWZpbml0aW9uLCBhbmQgZmluYWxseSBhbmltYXRlcyB0aGUgbmV3IGdyYWRpZW50IGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0dyYWRpZW50RGVmaW5pdGlvbn0gZ3JhZGllbnQgLSBUaGUgbmV3IGdyYWRpZW50IGRlZmluaXRpb24gdG8gc2V0IGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbmV3IGdyYWRpZW50IGlzIHNldCBhbmQgYW5pbWF0ZWQgaW4uXG4gICAqL1xuICBhc3luYyBzZXRHcmFkaWVudChlKSB7XG4gICAgaWYgKGUgPT09ICExKSB7XG4gICAgICBhd2FpdCB0aGlzLmFuaW1hdGVPdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGF3YWl0IHRoaXMuYW5pbWF0ZU91dCgpLCAhQnUoZSkpIHtcbiAgICAgIHRoaXMuZ3JhZGllbnQuc2NhbGUgPSBqZS5zY2FsZSwgdGhpcy5ncmFkaWVudC5zdG9wcyA9IFtcbiAgICAgICAgWzAsIFwidHJhbnNwYXJlbnRcIl0sXG4gICAgICAgIFsxLCBcInRyYW5zcGFyZW50XCJdXG4gICAgICBdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID09PSAhMCA/ICh0aGlzLmdyYWRpZW50LnNjYWxlID0gamUuc2NhbGUsIHRoaXMuZ3JhZGllbnQuc3RvcHMgPSBqZS5zdG9wcykgOiAodGhpcy5ncmFkaWVudC5zY2FsZSA9IGUuc2NhbGUgPz8gamUuc2NhbGUsIHRoaXMuZ3JhZGllbnQuc3RvcHMgPSBlLnN0b3BzID8/IGplLnN0b3BzKSwgYXdhaXQgdGhpcy5hbmltYXRlSW4oKTtcbiAgfVxuICBzZXRBbmltYXRpb25BY3RpdmUoZSkge1xuICAgIHRoaXMuYW5pbWF0aW9uQWN0aXZlID0gZTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMubWFwLnNldExheW91dFByb3BlcnR5KHRoaXMuaWQsIFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eSh0aGlzLmlkLCBcInZpc2liaWxpdHlcIiwgXCJub25lXCIpO1xuICB9XG59XG5mdW5jdGlvbiBCdShyKSB7XG4gIHJldHVybiB0eXBlb2YgciA9PSBcImJvb2xlYW5cIiA/ICEwIDogISh0eXBlb2Ygci5zY2FsZSAhPSBcIm51bWJlclwiIHx8ICFyLnN0b3BzIHx8IHIuc3RvcHMubGVuZ3RoID09PSAwIHx8IHIuc3RvcHMuc29tZSgoZSkgPT4gdHlwZW9mIGVbMF0gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZVsxXSAhPSBcInN0cmluZ1wiKSk7XG59XG5jb25zdCBxdSA9IHtcbiAgUE9JTlQ6IFwiUE9JTlRcIixcbiAgQ09VTlRSWTogXCJDT1VOVFJZXCJcbn07XG5sZXQgTG8gPSBjbGFzcyBDbyBleHRlbmRzIEwuTWFwIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIExpKHQuY29udGFpbmVyKSwgdC5hcGlLZXkgJiYgKGouYXBpS2V5ID0gdC5hcGlLZXkpO1xuICAgIGNvbnN0IHsgc3R5bGU6IG4sIHJlcXVpcmVzVXJsTW9uaXRvcmluZzogYSwgaXNGYWxsYmFjazogbyB9ID0gb2EodC5zdHlsZSk7XG4gICAgbyAmJiBjb25zb2xlLndhcm4oXG4gICAgICBcIkludmFsaWQgc3R5bGUuIEEgc3R5bGUgbXVzdCBiZSBhIHZhbGlkIFVSTCB0byBhIHN0eWxlLmpzb24sIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdmFsaWQgU3R5bGVTcGVjaWZpY2F0aW9uIG9yIGEgdmFsaWQgU3R5bGVTcGVjaWZpY2F0aW9uIG9iamVjdC4gRmFsbGJhY2sgdG8gZGVmYXVsdCBNYXBUaWxlciBzdHlsZS5cIlxuICAgICksIGouYXBpS2V5IHx8IGNvbnNvbGUud2FybihcIk1hcFRpbGVyIENsb3VkIEFQSSBrZXkgaXMgbm90IHNldC4gVmlzaXQgaHR0cHM6Ly9tYXB0aWxlci5jb20gYW5kIHRyeSBDbG91ZCBmb3IgZnJlZSFcIik7XG4gICAgY29uc3QgaSA9IGxvY2F0aW9uLmhhc2g7XG4gICAgbGV0IHMgPSB7XG4gICAgICBjb21wYWN0OiAhMVxuICAgIH07XG4gICAgdC5jdXN0b21BdHRyaWJ1dGlvbiA/IHMuY3VzdG9tQXR0cmlidXRpb24gPSB0LmN1c3RvbUF0dHJpYnV0aW9uIDogdC5hdHRyaWJ1dGlvbkNvbnRyb2wgJiYgdHlwZW9mIHQuYXR0cmlidXRpb25Db250cm9sID09IFwib2JqZWN0XCIgJiYgKHMgPSB7XG4gICAgICAuLi5zLFxuICAgICAgLi4udC5hdHRyaWJ1dGlvbkNvbnRyb2xcbiAgICB9KTtcbiAgICBjb25zdCBsID0ge1xuICAgICAgLi4udCxcbiAgICAgIHN0eWxlOiBuLFxuICAgICAgbWFwbGlicmVMb2dvOiAhMSxcbiAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6ICRuKHQudHJhbnNmb3JtUmVxdWVzdCksXG4gICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHQuZm9yY2VOb0F0dHJpYnV0aW9uQ29udHJvbCA9PT0gITAgPyAhMSA6IHNcbiAgICB9O1xuICAgIGRlbGV0ZSBsLnN0eWxlO1xuICAgIHN1cGVyKGwpO1xuICAgIHYodGhpcywgXCJ0ZWxlbWV0cnlcIik7XG4gICAgdih0aGlzLCBcInNwYWNlXCIpO1xuICAgIHYodGhpcywgXCJoYWxvXCIpO1xuICAgIHYodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIHYodGhpcywgXCJpc1RlcnJhaW5FbmFibGVkXCIsICExKTtcbiAgICB2KHRoaXMsIFwidGVycmFpbkV4YWdnZXJhdGlvblwiLCAxKTtcbiAgICB2KHRoaXMsIFwicHJpbWFyeUxhbmd1YWdlXCIpO1xuICAgIHYodGhpcywgXCJ0ZXJyYWluR3Jvd2luZ1wiLCAhMSk7XG4gICAgdih0aGlzLCBcInRlcnJhaW5GbGF0dGVuaW5nXCIsICExKTtcbiAgICB2KHRoaXMsIFwibWluaW1hcFwiKTtcbiAgICB2KHRoaXMsIFwiZm9yY2VMYW5ndWFnZVVwZGF0ZVwiKTtcbiAgICB2KHRoaXMsIFwibGFuZ3VhZ2VBbHdheXNCZWVuU3R5bGVcIik7XG4gICAgdih0aGlzLCBcImlzUmVhZHlcIiwgITEpO1xuICAgIHYodGhpcywgXCJ0ZXJyYWluQW5pbWF0aW9uRHVyYXRpb25cIiwgMWUzKTtcbiAgICB2KHRoaXMsIFwibW9uaXRvcmVkU3R5bGVVcmxzXCIpO1xuICAgIHYodGhpcywgXCJzdHlsZUluUHJvY2Vzc1wiLCAhMSk7XG4gICAgdih0aGlzLCBcImN1cmVudFByb2plY3Rpb25cIik7XG4gICAgdih0aGlzLCBcIm9yaWdpbmFsTGFiZWxTdHlsZVwiLCBuZXcgd2luZG93Lk1hcCgpKTtcbiAgICB2KHRoaXMsIFwiaXNTdHlsZUxvY2FsaXplZFwiLCAhMSk7XG4gICAgdih0aGlzLCBcImxhbmd1YWdlSXNVcGRhdGVkXCIsICExKTtcbiAgICB2KHRoaXMsIFwic3BhY2Vib3hMb2FkaW5nU3RhdGVcIiwge1xuICAgICAgc3R5bGVMb2FkQ2FsbGJhY2tTZXQ6ICExXG4gICAgfSk7XG4gICAgdGhpcy5vcHRpb25zID0gdCwgdGhpcy5zZXRTdHlsZShuKSwgYSAmJiB0aGlzLm1vbml0b3JTdHlsZVVybChuKTtcbiAgICBjb25zdCB1ID0gKCkgPT4ge1xuICAgICAgbGV0IGggPSBcIlRoZSBkaXN0YW50IHN0eWxlIGNvdWxkIG5vdCBiZSBsb2FkZWQuXCI7XG4gICAgICB0aGlzLmdldFN0eWxlKCkgPyBoICs9IFwiTGVhdmluZyB0aGUgc3R5bGUgYXMgaXMuXCIgOiAodGhpcy5zZXRTdHlsZShmdC5TVFJFRVRTKSwgaCArPSBgTG9hZGluZyBkZWZhdWx0IE1hcFRpbGVyIENsb3VkIHN0eWxlIFwiJHtmdC5TVFJFRVRTLmdldERlZmF1bHRWYXJpYW50KCkuZ2V0SWQoKX1cIiBhcyBhIGZhbGxiYWNrLmApLCBjb25zb2xlLndhcm4oaCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5vbihcInN0eWxlLmxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdHlsZUluUHJvY2VzcyA9ICExO1xuICAgIH0pLCB0aGlzLm9uKFwiZXJyb3JcIiwgKGgpID0+IHtcbiAgICAgIGlmIChoLmVycm9yIGluc3RhbmNlb2YgTC5BSkFYRXJyb3IpIHtcbiAgICAgICAgY29uc3QgeSA9IGguZXJyb3IudXJsLCB3ID0gbmV3IFVSTCh5KTtcbiAgICAgICAgdy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICBjb25zdCBnID0gdy5ocmVmO1xuICAgICAgICB0aGlzLm1vbml0b3JlZFN0eWxlVXJscyAmJiB0aGlzLm1vbml0b3JlZFN0eWxlVXJscy5oYXMoZykgJiYgKHRoaXMubW9uaXRvcmVkU3R5bGVVcmxzLmRlbGV0ZShnKSwgdSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3R5bGVJblByb2Nlc3MpIHtcbiAgICAgICAgdSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSksIGouY2FjaGluZyAmJiAhJHIgJiYgY29uc29sZS53YXJuKFwiVGhlIGNhY2hlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBzZWN1cmUgY29udGV4dHMuIE1vcmUgaW5mbyBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGVcIiksIGouY2FjaGluZyAmJiAkciAmJiBiaSgpLCB0eXBlb2YgdC5sYW5ndWFnZSA+IFwidVwiKVxuICAgICAgdGhpcy5wcmltYXJ5TGFuZ3VhZ2UgPSBqLnByaW1hcnlMYW5ndWFnZTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSBJbih0Lmxhbmd1YWdlLCB6KTtcbiAgICAgIHRoaXMucHJpbWFyeUxhbmd1YWdlID0gaCA/PyBqLnByaW1hcnlMYW5ndWFnZTtcbiAgICB9XG4gICAgdGhpcy5mb3JjZUxhbmd1YWdlVXBkYXRlID0gISh0aGlzLnByaW1hcnlMYW5ndWFnZSA9PT0gei5TVFlMRSB8fCB0aGlzLnByaW1hcnlMYW5ndWFnZSA9PT0gei5TVFlMRV9MT0NLKSwgdGhpcy5sYW5ndWFnZUFsd2F5c0JlZW5TdHlsZSA9IHRoaXMucHJpbWFyeUxhbmd1YWdlID09PSB6LlNUWUxFLCB0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24gPSB0LnRlcnJhaW5FeGFnZ2VyYXRpb24gPz8gdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uLCB0aGlzLmN1cmVudFByb2plY3Rpb24gPSB0LnByb2plY3Rpb24sIHRoaXMub24oXCJzdHlsZWRhdGFcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jdXJlbnRQcm9qZWN0aW9uID09PSBcIm1lcmNhdG9yXCIgPyB0aGlzLnNldFByb2plY3Rpb24oeyB0eXBlOiBcIm1lcmNhdG9yXCIgfSkgOiB0aGlzLmN1cmVudFByb2plY3Rpb24gPT09IFwiZ2xvYmVcIiAmJiB0aGlzLnNldFByb2plY3Rpb24oeyB0eXBlOiBcImdsb2JlXCIgfSk7XG4gICAgfSksIHRoaXMub25jZShcInN0eWxlZGF0YVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXQuZ2VvbG9jYXRlIHx8IHQuY2VudGVyIHx8IHQuaGFzaCAmJiBpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodC5nZW9sb2NhdGUgPT09IHF1LkNPVU5UUlkpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmZpdFRvSXBCb3VuZHMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHkubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBsZXQgaDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2VudGVyT25JcFBvaW50KHQuem9vbSksIGggPSB0aGlzLmdldENhbWVyYUhhc2goKTtcbiAgICAgIH0gY2F0Y2ggKHkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHkubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICAoYXdhaXQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgbmFtZTogXCJnZW9sb2NhdGlvblwiXG4gICAgICB9KSkuc3RhdGUgPT09IFwiZ3JhbnRlZFwiICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgIC8vIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgKHkpID0+IHtcbiAgICAgICAgICBoID09PSB0aGlzLmdldENhbWVyYUhhc2goKSAmJiAodGhpcy50ZXJyYWluID8gdGhpcy5lYXNlVG8oe1xuICAgICAgICAgICAgY2VudGVyOiBbeS5jb29yZHMubG9uZ2l0dWRlLCB5LmNvb3Jkcy5sYXRpdHVkZV0sXG4gICAgICAgICAgICB6b29tOiB0Lnpvb20gfHwgMTIsXG4gICAgICAgICAgICBkdXJhdGlvbjogMmUzXG4gICAgICAgICAgfSkgOiB0aGlzLm9uY2UoXCJ0ZXJyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWFzZVRvKHtcbiAgICAgICAgICAgICAgY2VudGVyOiBbeS5jb29yZHMubG9uZ2l0dWRlLCB5LmNvb3Jkcy5sYXRpdHVkZV0sXG4gICAgICAgICAgICAgIHpvb206IHQuem9vbSB8fCAxMixcbiAgICAgICAgICAgICAgZHVyYXRpb246IDJlM1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBlcnJvciBjYWxsYmFja1xuICAgICAgICBudWxsLFxuICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgIHtcbiAgICAgICAgICBtYXhpbXVtQWdlOiAyNCAqIDM2MDAgKiAxZTMsXG4gICAgICAgICAgLy8gYSBkYXkgaW4gbWlsbGlzZWNcbiAgICAgICAgICB0aW1lb3V0OiA1ZTMsXG4gICAgICAgICAgLy8gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiAhMVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCB0aGlzLm9uKFwic3R5bGVkYXRhXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc2V0UHJpbWFyeUxhbmd1YWdlKHRoaXMucHJpbWFyeUxhbmd1YWdlKTtcbiAgICB9KSwgdGhpcy5vbihcInN0eWxlZGF0YVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmdldFRlcnJhaW4oKSA9PT0gbnVsbCAmJiB0aGlzLmlzVGVycmFpbkVuYWJsZWQgJiYgdGhpcy5lbmFibGVUZXJyYWluKHRoaXMudGVycmFpbkV4YWdnZXJhdGlvbik7XG4gICAgfSksIHRoaXMub25jZShcImxvYWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGggPSB7IGxvZ286IG51bGwgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG0gPSBPYmplY3Qua2V5cyh0aGlzLnN0eWxlLnNvdXJjZUNhY2hlcykubWFwKChnKSA9PiB0aGlzLmdldFNvdXJjZShnKSkuZmlsdGVyKChnKSA9PiBnICYmIFwidXJsXCIgaW4gZyAmJiB0eXBlb2YgZy51cmwgPT0gXCJzdHJpbmdcIiAmJiBnLnVybC5pbmNsdWRlcyhcInRpbGVzLmpzb25cIikpLCB5ID0gbmV3IFVSTChtWzBdLnVybCk7XG4gICAgICAgIHkuc2VhcmNoUGFyYW1zLmhhcyhcImtleVwiKSB8fCB5LnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJrZXlcIiwgai5hcGlLZXkpLCBoID0gYXdhaXQgKGF3YWl0IGZldGNoKHkuaHJlZikpLmpzb24oKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgaWYgKHQuY3VzdG9tQ29udHJvbHMpIHtcbiAgICAgICAgY29uc3QgbSA9IFwiW2RhdGEtbWFwdGlsZXItY29udHJvbC1ncm91cF1cIiwgeSA9IFwiW2RhdGEtbWFwdGlsZXItY29udHJvbF1cIiwgdyA9IChUKSA9PiB7XG4gICAgICAgICAgbGV0IE4gPSBULmRhdGFzZXQubWFwdGlsZXJDb250cm9sO1xuICAgICAgICAgIHJldHVybiAoTiA9PT0gXCJ0cnVlXCIgfHwgTiA9PT0gXCJcIikgJiYgKE4gPSB2b2lkIDApLCBOO1xuICAgICAgICB9LCBnID0gKFQpID0+IFQuZGF0YXNldC5tYXB0aWxlclBvc2l0aW9uO1xuICAgICAgICBsZXQgeCA9IFsuLi50aGlzLl9jb250YWluZXIub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG0pXSwgRSA9IFsuLi50aGlzLl9jb250YWluZXIub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHkpXS5maWx0ZXIoXG4gICAgICAgICAgKFQpID0+IFQuY2xvc2VzdChtKSA9PT0gbnVsbFxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZW9mIHQuY3VzdG9tQ29udHJvbHMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IFQgPSB0LmN1c3RvbUNvbnRyb2xzO1xuICAgICAgICAgIHggPSB4LmZpbHRlcigoTikgPT4gTi5tYXRjaGVzKFQpIHx8IE4uY2xvc2VzdChUKSAhPT0gbnVsbCksIEUgPSBFLmZpbHRlcigoTikgPT4gTi5tYXRjaGVzKFQpIHx8IE4uY2xvc2VzdChUKSAhPT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBUIG9mIHgpIHtcbiAgICAgICAgICBjb25zdCBOID0gbmV3IEdyKFQpO1xuICAgICAgICAgIHRoaXMuYWRkQ29udHJvbChOLCBnKFQpKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHZlIG9mIFQucXVlcnlTZWxlY3RvckFsbCh5KSlcbiAgICAgICAgICAgIE4uY29uZmlndXJlR3JvdXBJdGVtKHZlLCB3KHZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBUIG9mIEUpXG4gICAgICAgICAgdGhpcy5hZGRDb250cm9sKG5ldyBHcihULCB3KFQpKSwgZyhUKSk7XG4gICAgICAgIGNvbnN0IEMgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBsbmc6IFQsIGxhdDogTiB9ID0gdGhpcy5nZXRDZW50ZXIoKTtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLW1hcHRpbGVyLWNlbnRlci1sbmdcIiwgU3RyaW5nKFQpKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1jZW50ZXItbGF0XCIsIFN0cmluZyhOKSksIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbWFwdGlsZXItem9vbVwiLCBTdHJpbmcodGhpcy5nZXRab29tKCkpKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1iZWFyaW5nXCIsIFN0cmluZyh0aGlzLmdldEJlYXJpbmcoKSkpLCB0aGlzLl9jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLW1hcHRpbGVyLXBpdGNoXCIsIFN0cmluZyh0aGlzLmdldFBpdGNoKCkpKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1tYXB0aWxlci1yb2xsXCIsIFN0cmluZyh0aGlzLmdldFJvbGwoKSkpLCB0aGlzLl9jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLW1hcHRpbGVyLWlzLWdsb2JlLXByb2plY3Rpb25cIiwgU3RyaW5nKHRoaXMuaXNHbG9iZVByb2plY3Rpb24oKSkpLCB0aGlzLl9jb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLW1hcHRpbGVyLWhhcy10ZXJyYWluXCIsIFN0cmluZyh0aGlzLmhhc1RlcnJhaW4oKSkpO1xuICAgICAgICB9O1xuICAgICAgICBDKCksIHRoaXMub24oXCJyZW5kZXJcIiwgQyk7XG4gICAgICB9XG4gICAgICBpZiAodC5mb3JjZU5vQXR0cmlidXRpb25Db250cm9sICE9PSAhMClcbiAgICAgICAgaWYgKFwibG9nb1wiIGluIGggJiYgaC5sb2dvKSB7XG4gICAgICAgICAgY29uc3QgbSA9IGgubG9nbztcbiAgICAgICAgICB0aGlzLmFkZENvbnRyb2wobmV3IE5uKHsgbG9nb1VSTDogbSB9KSwgdC5sb2dvUG9zaXRpb24pO1xuICAgICAgICB9IGVsc2UgdC5tYXB0aWxlckxvZ28gJiYgdGhpcy5hZGRDb250cm9sKG5ldyBObigpLCB0LmxvZ29Qb3NpdGlvbik7XG4gICAgICBpZiAodC5zY2FsZUNvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgbSA9IHQuc2NhbGVDb250cm9sID09PSAhMCB8fCB0LnNjYWxlQ29udHJvbCA9PT0gdm9pZCAwID8gXCJib3R0b20tcmlnaHRcIiA6IHQuc2NhbGVDb250cm9sLCB5ID0gbmV3IHppKHsgdW5pdDogai51bml0IH0pO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2woeSwgbSksIGoub24oXCJ1bml0XCIsICh3KSA9PiB7XG4gICAgICAgICAgeS5zZXRVbml0KHcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0Lm5hdmlnYXRpb25Db250cm9sICE9PSAhMSkge1xuICAgICAgICBjb25zdCBtID0gdC5uYXZpZ2F0aW9uQ29udHJvbCA9PT0gITAgfHwgdC5uYXZpZ2F0aW9uQ29udHJvbCA9PT0gdm9pZCAwID8gXCJ0b3AtcmlnaHRcIiA6IHQubmF2aWdhdGlvbkNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChuZXcgSmwoKSwgbSk7XG4gICAgICB9XG4gICAgICBpZiAodC5nZW9sb2NhdGVDb250cm9sICE9PSAhMSkge1xuICAgICAgICBjb25zdCBtID0gdC5nZW9sb2NhdGVDb250cm9sID09PSAhMCB8fCB0Lmdlb2xvY2F0ZUNvbnRyb2wgPT09IHZvaWQgMCA/IFwidG9wLXJpZ2h0XCIgOiB0Lmdlb2xvY2F0ZUNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChcbiAgICAgICAgICAvLyBuZXcgbWFwbGlicmVnbC5HZW9sb2NhdGVDb250cm9sKHtcbiAgICAgICAgICBuZXcgZXUoe1xuICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogITAsXG4gICAgICAgICAgICAgIG1heGltdW1BZ2U6IDAsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDZlM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEJvdW5kc09wdGlvbnM6IHtcbiAgICAgICAgICAgICAgbWF4Wm9vbTogMTVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFja1VzZXJMb2NhdGlvbjogITAsXG4gICAgICAgICAgICBzaG93QWNjdXJhY3lDaXJjbGU6ICEwLFxuICAgICAgICAgICAgc2hvd1VzZXJMb2NhdGlvbjogITBcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodC50ZXJyYWluQ29udHJvbCkge1xuICAgICAgICBjb25zdCBtID0gdC50ZXJyYWluQ29udHJvbCA9PT0gITAgfHwgdC50ZXJyYWluQ29udHJvbCA9PT0gdm9pZCAwID8gXCJ0b3AtcmlnaHRcIiA6IHQudGVycmFpbkNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChuZXcgV2woKSwgbSk7XG4gICAgICB9XG4gICAgICBpZiAodC5wcm9qZWN0aW9uQ29udHJvbCkge1xuICAgICAgICBjb25zdCBtID0gdC5wcm9qZWN0aW9uQ29udHJvbCA9PT0gITAgfHwgdC5wcm9qZWN0aW9uQ29udHJvbCA9PT0gdm9pZCAwID8gXCJ0b3AtcmlnaHRcIiA6IHQucHJvamVjdGlvbkNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChuZXcgcnUoKSwgbSk7XG4gICAgICB9XG4gICAgICBpZiAodC5mdWxsc2NyZWVuQ29udHJvbCkge1xuICAgICAgICBjb25zdCBtID0gdC5mdWxsc2NyZWVuQ29udHJvbCA9PT0gITAgfHwgdC5mdWxsc2NyZWVuQ29udHJvbCA9PT0gdm9pZCAwID8gXCJ0b3AtcmlnaHRcIiA6IHQuZnVsbHNjcmVlbkNvbnRyb2w7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbChuZXcgRmkoe30pLCBtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNSZWFkeSA9ICEwLCB0aGlzLmZpcmUoXCJyZWFkeVwiLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9KTtcbiAgICBsZXQgYyA9ICExLCBwID0gITEsIGQ7XG4gICAgdGhpcy5vbmNlKFwicmVhZHlcIiwgKCkgPT4ge1xuICAgICAgYyA9ICEwLCBwICYmIHRoaXMuZmlyZShcImxvYWRXaXRoVGVycmFpblwiLCBkKTtcbiAgICB9KSwgdGhpcy5vbmNlKFwic3R5bGUubG9hZFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IG1pbmltYXA6IGggfSA9IHQ7XG4gICAgICBpZiAodHlwZW9mIGggPT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgem9vbTogbSxcbiAgICAgICAgICBjZW50ZXI6IHksXG4gICAgICAgICAgc3R5bGU6IHcsXG4gICAgICAgICAgbGFuZ3VhZ2U6IGcsXG4gICAgICAgICAgYXBpS2V5OiB4LFxuICAgICAgICAgIG1hcHRpbGVyTG9nbzogRSxcbiAgICAgICAgICBjYW52YXNDb250ZXh0QXR0cmlidXRlczogQyxcbiAgICAgICAgICByZWZyZXNoRXhwaXJlZFRpbGVzOiBULFxuICAgICAgICAgIG1heEJvdW5kczogTixcbiAgICAgICAgICBzY3JvbGxab29tOiB2ZSxcbiAgICAgICAgICBtaW5ab29tOiBZZSxcbiAgICAgICAgICBtYXhab29tOiBXZSxcbiAgICAgICAgICBib3hab29tOiBILFxuICAgICAgICAgIGxvY2FsZTogT2UsXG4gICAgICAgICAgZmFkZUR1cmF0aW9uOiBZbyxcbiAgICAgICAgICBjcm9zc1NvdXJjZUNvbGxpc2lvbnM6IFdvLFxuICAgICAgICAgIGNsaWNrVG9sZXJhbmNlOiBKbyxcbiAgICAgICAgICBib3VuZHM6IFFvLFxuICAgICAgICAgIGZpdEJvdW5kc09wdGlvbnM6IGVpLFxuICAgICAgICAgIHBpeGVsUmF0aW86IHRpLFxuICAgICAgICAgIHZhbGlkYXRlU3R5bGU6IHJpXG4gICAgICAgIH0gPSB0O1xuICAgICAgICB0aGlzLm1pbmltYXAgPSBuZXcgRXIoaCwge1xuICAgICAgICAgIHpvb206IG0sXG4gICAgICAgICAgY2VudGVyOiB5LFxuICAgICAgICAgIHN0eWxlOiB3LFxuICAgICAgICAgIGxhbmd1YWdlOiBnLFxuICAgICAgICAgIGFwaUtleTogeCxcbiAgICAgICAgICBjb250YWluZXI6IFwibnVsbFwiLFxuICAgICAgICAgIG1hcHRpbGVyTG9nbzogRSxcbiAgICAgICAgICBjYW52YXNDb250ZXh0QXR0cmlidXRlczogQyxcbiAgICAgICAgICByZWZyZXNoRXhwaXJlZFRpbGVzOiBULFxuICAgICAgICAgIG1heEJvdW5kczogTixcbiAgICAgICAgICBzY3JvbGxab29tOiB2ZSxcbiAgICAgICAgICBtaW5ab29tOiBZZSxcbiAgICAgICAgICBtYXhab29tOiBXZSxcbiAgICAgICAgICBib3hab29tOiBILFxuICAgICAgICAgIGxvY2FsZTogT2UsXG4gICAgICAgICAgZmFkZUR1cmF0aW9uOiBZbyxcbiAgICAgICAgICBjcm9zc1NvdXJjZUNvbGxpc2lvbnM6IFdvLFxuICAgICAgICAgIGNsaWNrVG9sZXJhbmNlOiBKbyxcbiAgICAgICAgICBib3VuZHM6IFFvLFxuICAgICAgICAgIGZpdEJvdW5kc09wdGlvbnM6IGVpLFxuICAgICAgICAgIHBpeGVsUmF0aW86IHRpLFxuICAgICAgICAgIHZhbGlkYXRlU3R5bGU6IHJpXG4gICAgICAgIH0pLCB0aGlzLmFkZENvbnRyb2wodGhpcy5taW5pbWFwLCBoLnBvc2l0aW9uID8/IFwiYm90dG9tLWxlZnRcIik7XG4gICAgICB9IGVsc2UgaCA9PT0gITAgPyAodGhpcy5taW5pbWFwID0gbmV3IEVyKHt9LCB0KSwgdGhpcy5hZGRDb250cm9sKHRoaXMubWluaW1hcCwgXCJib3R0b20tbGVmdFwiKSkgOiBoICE9PSB2b2lkIDAgJiYgaCAhPT0gITEgJiYgKHRoaXMubWluaW1hcCA9IG5ldyBFcih7fSwgdCksIHRoaXMuYWRkQ29udHJvbCh0aGlzLm1pbmltYXAsIGgpKTtcbiAgICB9KTtcbiAgICBjb25zdCBmID0gKGgpID0+IHtcbiAgICAgIGgudGVycmFpbiAmJiAocCA9ICEwLCBkID0ge1xuICAgICAgICB0eXBlOiBcImxvYWRXaXRoVGVycmFpblwiLFxuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHRlcnJhaW46IGgudGVycmFpblxuICAgICAgfSwgdGhpcy5vZmYoXCJ0ZXJyYWluXCIsIGYpLCBjICYmIHRoaXMuZmlyZShcImxvYWRXaXRoVGVycmFpblwiLCBkKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKFwidGVycmFpblwiLCBmKSwgdC50ZXJyYWluICYmIHRoaXMuZW5hYmxlVGVycmFpbih0LnRlcnJhaW5FeGFnZ2VyYXRpb24gPz8gdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uKSwgdGhpcy5vbmNlKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmdldENhbnZhcygpLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIChtKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVkID09PSAhMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlt3ZWJnbGNvbnRleHRsb3N0XVwiLCBcIldlYkdMIGNvbnRleHQgbG9zdCBhZnRlciBtYXAgcmVtb3ZhbC4gVGhpcyBpcyBoYXJtbGVzcy5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIlt3ZWJnbGNvbnRleHRsb3N0XVwiLCBcIlVuZXhwZWN0ZWQgbG9zcyBvZiBXZWJHTCBjb250ZXh0IVwiKSwgdGhpcy5maXJlKFwid2ViZ2xDb250ZXh0TG9zdFwiLCBtKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaCA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVswXTtcbiAgICAgIHQuc3BhY2UgJiYgdGhpcy5pbml0U3BhY2UoeyBvcHRpb25zOiB0LCBiZWZvcmU6IGggfSksIHQuaGFsbyAmJiB0aGlzLmluaXRIYWxvKHsgb3B0aW9uczogdCwgYmVmb3JlOiBoIH0pO1xuICAgIH0pLCB0aGlzLnRlbGVtZXRyeSA9IG5ldyBudSh0aGlzKTtcbiAgfVxuICBnZXRTcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGFjZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc3BhY2UgZm9yIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7Q3ViZW1hcERlZmluaXRpb259IHNwYWNlIHRoZSBgQ3ViZW1hcERlZmluaXRpb25gIG9wdGlvbnMgdG8gc2V0LlxuICAgKiBAcmVtYXJrcyBUaGlzIG1ldGhvZCwgYXQgcHJlc2VudCwgKiogb3ZlcndyaXRlcyAqKiB0aGUgY3VycmVudCBjb25maWcuXG4gICAqIElmIGFuIG9wdGlvbiBpcyBub3Qgc2V0IGl0IHdpbGwgaW50ZXJuYWxseSByZXZlcnQgdG8gdGhlIGRlZmF1bHQgb3B0aW9uXG4gICAqIHVubGVzcyBleHBsaWNpdGx5IHNldCB3aGVuIGNhbGxpbmcuXG4gICAqL1xuICBzZXRTcGFjZSh0KSB7XG4gICAgaWYgKHQgPT09ICExKSB7XG4gICAgICB0aGlzLnNwYWNlID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0dsb2JlUHJvamVjdGlvbigpKSB7XG4gICAgICBpZiAodGhpcy5zcGFjZSkge1xuICAgICAgICB0aGlzLnNwYWNlLnNldEN1YmVtYXAodCksIHRoaXMuZ2V0TGF5ZXIodGhpcy5zcGFjZS5pZCkgfHwgdGhpcy5hZGRMYXllcih0aGlzLnNwYWNlLCB0aGlzLmdldExheWVyc09yZGVyKClbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNwYWNlID0gbmV3IFByKHQpLCB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVswXTtcbiAgICAgICAgdGhpcy5zcGFjZSAmJiB0aGlzLmFkZExheWVyKHRoaXMuc3BhY2UsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgc3BhY2UgbGF5ZXIuXG4gICAqL1xuICBlbmFibGVTcGFjZUFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRTcGFjZUFuaW1hdGlvbkFjdGl2ZSghMCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgc3BhY2UgbGF5ZXIuXG4gICAqL1xuICBkaXNhYmxlU3BhY2VBbmltYXRpb25zKCkge1xuICAgIHRoaXMuc2V0U3BhY2VBbmltYXRpb25BY3RpdmUoITEpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgaGFsbyBsYXllci5cbiAgICovXG4gIGVuYWJsZUhhbG9BbmltYXRpb25zKCkge1xuICAgIHRoaXMuc2V0SGFsb0FuaW1hdGlvbkFjdGl2ZSghMCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBhbmltYXRpb25zIGZvciB0aGUgaGFsbyBsYXllci5cbiAgICovXG4gIGRpc2FibGVIYWxvQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLnNldEhhbG9BbmltYXRpb25BY3RpdmUoITEpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIGhhbG8gbGF5ZXIgc2hvdWxkIGJlIGFuaW1hdGVkIGluIGFuZCBvdXQuXG4gICAqIEBwYXJhbSBhY3RpdmUgLSBXaGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICovXG4gIHNldEhhbG9BbmltYXRpb25BY3RpdmUodCkge1xuICAgIHRoaXMuaGFsbyA/IHRoaXMuaGFsby5zZXRBbmltYXRpb25BY3RpdmUodCkgOiB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgKG4gPSB0aGlzLmhhbG8pID09IG51bGwgfHwgbi5zZXRBbmltYXRpb25BY3RpdmUodCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgc3BhY2UgbGF5ZXIgc2hvdWxkIGJlIGFuaW1hdGVkIGluIGFuZCBvdXQuXG4gICAqIEBwYXJhbSBhY3RpdmUgLSBXaGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICovXG4gIHNldFNwYWNlQW5pbWF0aW9uQWN0aXZlKHQpIHtcbiAgICB0aGlzLnNwYWNlID8gdGhpcy5zcGFjZS5zZXRBbmltYXRpb25BY3RpdmUodCkgOiB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgKG4gPSB0aGlzLnNwYWNlKSA9PSBudWxsIHx8IG4uc2V0QW5pbWF0aW9uQWN0aXZlKHQpO1xuICAgIH0pO1xuICB9XG4gIHNldFNwYWNlRnJvbVN0eWxlKHsgc3R5bGU6IHQgfSkge1xuICAgIHZhciBpLCBzLCBsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0U3BhY2UodGhpcy5vcHRpb25zLnNwYWNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbiA9IChzID0gKGkgPSB0Lm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogaS5tYXB0aWxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc3BhY2U7XG4gICAgaWYgKCFuKSB7XG4gICAgICB0aGlzLnNldFNwYWNlKHtcbiAgICAgICAgY29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgha28obikpIHtcbiAgICAgIHRoaXMuc2V0U3BhY2Uoe1xuICAgICAgICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KChsID0gdGhpcy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuZ2V0Q29uZmlnKCkpID09PSBKU09OLnN0cmluZ2lmeShuKSkge1xuICAgICAgaWYgKHRoaXMuc3BhY2UgJiYgIXRoaXMuZ2V0TGF5ZXIodGhpcy5zcGFjZS5pZCkpIHtcbiAgICAgICAgY29uc3QgdSA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVswXTtcbiAgICAgICAgdGhpcy5hZGRMYXllcih0aGlzLnNwYWNlLCB1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNwYWNlICYmIHRoaXMuaXNHbG9iZVByb2plY3Rpb24oKSkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0TGF5ZXIodGhpcy5zcGFjZS5pZCkpIHtcbiAgICAgICAgICBjb25zdCB1ID0gdGhpcy5nZXRMYXllcnNPcmRlcigpWzBdO1xuICAgICAgICAgIHRoaXMuYWRkTGF5ZXIodGhpcy5zcGFjZSwgdSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGFjZS5zZXRDdWJlbWFwKG4pO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbiAgc2V0SGFsb0Zyb21TdHlsZSh7IHN0eWxlOiB0IH0pIHtcbiAgICB2YXIgbywgaSwgcztcbiAgICBjb25zdCBuID0gKG8gPSB0Lm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogby5tYXB0aWxlcjtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoKGkgPSB0aGlzLmhhbG8pID09IG51bGwgPyB2b2lkIDAgOiBpLmdldENvbmZpZygpKSA9PT0gSlNPTi5zdHJpbmdpZnkobiA9PSBudWxsID8gdm9pZCAwIDogbi5oYWxvKSkge1xuICAgICAgaWYgKHRoaXMuaGFsbyAmJiAhdGhpcy5nZXRMYXllcih0aGlzLmhhbG8uaWQpKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmdldExheWVyc09yZGVyKCkuaW5kZXhPZigoKHMgPSB0aGlzLnNwYWNlKSA9PSBudWxsID8gdm9pZCAwIDogcy5pZCkgPz8gXCJcIikgKyAxLCB1ID0gdGhpcy5nZXRMYXllcnNPcmRlcigpW2xdO1xuICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgdSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKG4gIT0gbnVsbCAmJiBuLmhhbG8pICYmICF0aGlzLm9wdGlvbnMuaGFsbykge1xuICAgICAgdGhpcy5zZXRIYWxvKHtcbiAgICAgICAgc3RvcHM6IFtcbiAgICAgICAgICBbMCwgXCJ0cmFuc3BhcmVudFwiXSxcbiAgICAgICAgICBbMSwgXCJ0cmFuc3BhcmVudFwiXVxuICAgICAgICBdLFxuICAgICAgICBzY2FsZTogMVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgoKSA9PiB7XG4gICAgICB2YXIgbDtcbiAgICAgIGlmICh0aGlzLmhhbG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldExheWVyKHRoaXMuaGFsby5pZCkpIHtcbiAgICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRMYXllcnNPcmRlcigpLmluZGV4T2YoKChsID0gdGhpcy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuaWQpID8/IFwiXCIpICsgMSwgcCA9IHRoaXMuZ2V0TGF5ZXJzT3JkZXIoKVtjXTtcbiAgICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgcCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdSA9IChuID09IG51bGwgPyB2b2lkIDAgOiBuLmhhbG8pID8/IHRoaXMub3B0aW9ucy5oYWxvO1xuICAgICAgICB1ICYmIHRoaXMuaGFsby5zZXRHcmFkaWVudCh1KTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIGluaXRTcGFjZSh7IG9wdGlvbnM6IHQgPSB0aGlzLm9wdGlvbnMsIGJlZm9yZTogbiwgc3BlYzogYSB9KSB7XG4gICAgaWYgKHRoaXMuc3BhY2UpIHtcbiAgICAgIHRoaXMuZ2V0TGF5ZXIodGhpcy5zcGFjZS5pZCkgfHwgdGhpcy5hZGRMYXllcih0aGlzLnNwYWNlLCBuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHQuc3BhY2UgPT09ICExKSByZXR1cm47XG4gICAgY29uc3QgbyA9IGE7XG4gICAgaWYgKHQuc3BhY2UpIHtcbiAgICAgIHRoaXMuc3BhY2UgPSBuZXcgUHIodC5zcGFjZSksIHRoaXMuYWRkTGF5ZXIodGhpcy5zcGFjZSwgbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG8gJiYgKHRoaXMuc3BhY2UgPSBuZXcgUHIobyksIHRoaXMuYWRkTGF5ZXIodGhpcy5zcGFjZSwgbikpO1xuICB9XG4gIGluaXRIYWxvKHsgb3B0aW9uczogdCA9IHRoaXMub3B0aW9ucywgYmVmb3JlOiBuLCBzcGVjOiBhIH0pIHtcbiAgICBpZiAodGhpcy5oYWxvICYmIHRoaXMuZ2V0TGF5ZXIodGhpcy5oYWxvLmlkKSB8fCB0LmhhbG8gPT09ICExKSByZXR1cm47XG4gICAgY29uc3QgbyA9IGE7XG4gICAgaWYgKHQuaGFsbykge1xuICAgICAgdGhpcy5oYWxvID0gbmV3IFJyKHQuaGFsbyksIHRoaXMuYWRkTGF5ZXIodGhpcy5oYWxvLCBuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbyAmJiAodGhpcy5oYWxvID0gbmV3IFJyKG8pLCB0aGlzLmFkZExheWVyKHRoaXMuaGFsbywgbikpO1xuICB9XG4gIGdldEhhbG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFsbztcbiAgfVxuICBzZXRIYWxvKHQpIHtcbiAgICBpZiAodGhpcy5pc0dsb2JlUHJvamVjdGlvbigpKSB7XG4gICAgICBpZiAodGhpcy5oYWxvKSB7XG4gICAgICAgIHRoaXMuaGFsby5zZXRHcmFkaWVudCh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5oYWxvID0gbmV3IFJyKHQpLCB0aGlzLm9uY2UoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmdldExheWVyc09yZGVyKCksIGEgPSBuWzBdLCBvID0gbi5pbmRleE9mKCgocyA9IHRoaXMuc3BhY2UpID09IG51bGwgPyB2b2lkIDAgOiBzLmlkKSA/PyBcIlwiKSArIDIsIGkgPSBuW29dO1xuICAgICAgICB0aGlzLmhhbG8gJiYgdGhpcy5hZGRMYXllcih0aGlzLmhhbG8sIHRoaXMuc3BhY2UgPyBpIDogYSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlY3JlYXRlcyB0aGUgbWFwIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgb3B0aW9ucy5cbiAgICogVXNlZnVsIGZvciBXZWJHTCBjb250ZXh0IGxvc3MuXG4gICAqL1xuICByZWNyZWF0ZSgpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgY2VudGVyOiB0aGlzLmdldENlbnRlcigpLFxuICAgICAgem9vbTogdGhpcy5nZXRab29tKCksXG4gICAgICBiZWFyaW5nOiB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgIHBpdGNoOiB0aGlzLmdldFBpdGNoKClcbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlKCksIE9iamVjdC5hc3NpZ24odGhpcywgbmV3IENvKHsgLi4udGhpcy5vcHRpb25zIH0pKSwgdGhpcy5vbmNlKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmp1bXBUbyh0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBkdXJhdGlvbiAobWlsbGlzZWMpIG9mIHRoZSB0ZXJyYWluIGFuaW1hdGlvbiBmb3IgZ3Jvd2luZyBvciBmbGF0dGVuaW5nLlxuICAgKiBNdXN0IGJlIHBvc2l0aXZlLiAoQnVpbHQtaW4gZGVmYXVsdDogYDEwMDBgIG1pbGxpc2Vjb25kcylcbiAgICovXG4gIHNldFRlcnJhaW5BbmltYXRpb25EdXJhdGlvbih0KSB7XG4gICAgdGhpcy50ZXJyYWluQW5pbWF0aW9uRHVyYXRpb24gPSBNYXRoLm1heCh0LCAwKTtcbiAgfVxuICAvKipcbiAgICogQXdhaXRzIGZvciBfdGhpc18gTWFwIGluc3RhbmNlIHRvIGJlIFwibG9hZGVkXCIgYW5kIHJldHVybnMgYSBQcm9taXNlIHRvIHRoZSBNYXAuXG4gICAqIElmIF90aGlzXyBNYXAgaW5zdGFuY2UgaXMgYWxyZWFkeSBsb2FkZWQsIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkIGRpcmVjdGx5LFxuICAgKiBvdGhlcndpc2UsIGl0IGlzIHJlc29sdmVkIGFzIGEgcmVzdWx0IG9mIHRoZSBcImxvYWRcIiBldmVudC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIG9uTG9hZEFzeW5jKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVkKCkpIHtcbiAgICAgICAgdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vbmNlKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIHQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXdhaXRzIGZvciBfdGhpc18gTWFwIGluc3RhbmNlIHRvIGJlIFwicmVhZHlcIiBhbmQgcmV0dXJucyBhIFByb21pc2UgdG8gdGhlIE1hcC5cbiAgICogSWYgX3RoaXNfIE1hcCBpbnN0YW5jZSBpcyBhbHJlYWR5IHJlYWR5LCB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZCBkaXJlY3RseSxcbiAgICogb3RoZXJ3aXNlLCBpdCBpcyByZXNvbHZlZCBhcyBhIHJlc3VsdCBvZiB0aGUgXCJyZWFkeVwiIGV2ZW50LlxuICAgKiBBIG1hcCBpbnN0YW5jZSBpcyBcInJlYWR5XCIgd2hlbiBhbGwgdGhlIGNvbnRyb2xzIHRoYXQgY2FuIGJlIG1hbmFnZWQgYnkgdGhlIGNvbnRydWN0b3IgYXJlXG4gICAqIGRlYWx0IHdpdGguIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgXCJsb2FkXCIgZXZlbnQsIGR1ZSB0byB0aGUgYXN5bmNocm9ub3VzIG5hdHVyZVxuICAgKiBvZiBzb21lIGJ1aWx0LWluIGNvbnRyb2xzLlxuICAgKi9cbiAgYXN5bmMgb25SZWFkeUFzeW5jKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNSZWFkeSkge1xuICAgICAgICB0KHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uY2UoXCJyZWFkeVwiLCAoKSA9PiB7XG4gICAgICAgIHQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXdhaXRzIGZvciBfdGhpc18gTWFwIGluc3RhbmNlIHRvIGJlIFwibG9hZGVkXCIgYXMgd2VsbCBhcyB3aXRoIHRlcnJhaW4gYmVpbmcgbm9uLW51bGwgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAqIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0byB0aGUgTWFwLlxuICAgKiBJZiBfdGhpc18gTWFwIGluc3RhbmNlIGlzIGFscmVhZHkgbG9hZGVkIHdpdGggdGVycmFpbiwgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQgZGlyZWN0bHksXG4gICAqIG90aGVyd2lzZSwgaXQgaXMgcmVzb2x2ZWQgYXMgYSByZXN1bHQgb2YgdGhlIFwibG9hZFdpdGhUZXJyYWluXCIgZXZlbnQuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBvbkxvYWRXaXRoVGVycmFpbkFzeW5jKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNSZWFkeSAmJiB0aGlzLnRlcnJhaW4pIHtcbiAgICAgICAgdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vbmNlKFwibG9hZFdpdGhUZXJyYWluXCIsICgpID0+IHtcbiAgICAgICAgdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG1vbml0b3JTdHlsZVVybCh0KSB7XG4gICAgdHlwZW9mIHRoaXMubW9uaXRvcmVkU3R5bGVVcmxzID4gXCJ1XCIgJiYgKHRoaXMubW9uaXRvcmVkU3R5bGVVcmxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgY29uc3QgbiA9IG5ldyBVUkwodCk7XG4gICAgbi5zZWFyY2ggPSBcIlwiLCB0aGlzLm1vbml0b3JlZFN0eWxlVXJscy5hZGQobi5ocmVmKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdHlsZSBvZiB0aGUgbWFwLlxuICAgKiBDYW4gYmU6XG4gICAqIC0gYSBmdWxsIHN0eWxlIFVSTCAocG9zc2libHkgd2l0aCBBUEkga2V5KVxuICAgKiAtIGEgc2hvcnRoYW5kIHdpdGggb25seSB0aGUgTWFwVElsZXIgc3R5bGUgbmFtZSAoZWcuIGBcInN0cmVldHMtdjJcImApXG4gICAqIC0gYSBsb25nZXIgZm9ybSB3aXRoIHRoZSBwcmVmaXggYFwibWFwdGlsZXI6Ly9cImAgKGVnLiBgXCJtYXB0aWxlcjovL3N0cmVldHMtdjJcImApXG4gICAqL1xuICBzZXRTdHlsZSh0LCBuKSB7XG4gICAgdmFyIGMsIHAsIGQsIGYsIGg7XG4gICAgdGhpcy5vcmlnaW5hbExhYmVsU3R5bGUuY2xlYXIoKSwgKGMgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgYy5zZXRTdHlsZSh0KSwgdGhpcy5mb3JjZUxhbmd1YWdlVXBkYXRlID0gITAsIHRoaXMub25jZShcImlkbGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5mb3JjZUxhbmd1YWdlVXBkYXRlID0gITE7XG4gICAgfSk7XG4gICAgY29uc3QgYSA9IG9hKHQpO1xuICAgIGlmIChhLnJlcXVpcmVzVXJsTW9uaXRvcmluZyAmJiB0aGlzLm1vbml0b3JTdHlsZVVybChhLnN0eWxlKSwgYS5pc0ZhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRTdHlsZSgpKVxuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiW01hcC5zZXRTdHlsZV06IEludmFsaWQgc3R5bGUuIEEgc3R5bGUgbXVzdCBiZSBhIHZhbGlkIFVSTCB0byBhIHN0eWxlLmpzb24sIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdmFsaWQgU3R5bGVTcGVjaWZpY2F0aW9uIG9yIGEgdmFsaWQgU3R5bGVTcGVjaWZpY2F0aW9uIG9iamVjdC4gS2VlcGluZyB0aGUgY3VyZW50IHN0eWxlIGluc3RlYWQuXCJcbiAgICAgICAgKSwgdGhpcztcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbTWFwLnNldFN0eWxlXTogSW52YWxpZCBzdHlsZS4gQSBzdHlsZSBtdXN0IGJlIGEgdmFsaWQgVVJMIHRvIGEgc3R5bGUuanNvbiwgYSBKU09OIHN0cmluZyByZXByZXNlbnRpbmcgYSB2YWxpZCBTdHlsZVNwZWNpZmljYXRpb24gb3IgYSB2YWxpZCBTdHlsZVNwZWNpZmljYXRpb24gb2JqZWN0LiBGYWxsYmFjayB0byBkZWZhdWx0IE1hcFRpbGVyIHN0eWxlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5nZXRTdHlsZSgpLCBpID0gYS5zdHlsZTtcbiAgICB0cnkge1xuICAgICAgc3VwZXIuc2V0U3R5bGUoYS5zdHlsZSwgbiksIHRoaXMuc3R5bGVJblByb2Nlc3MgPSAhMDtcbiAgICB9IGNhdGNoIChtKSB7XG4gICAgICB0aGlzLnN0eWxlSW5Qcm9jZXNzID0gITEsIGNvbnNvbGUuZXJyb3IoXCJbTWFwLnNldFN0eWxlXTogRXJyb3Igd2hpbGUgc2V0dGluZyBzdHlsZTpcIiwgbSk7XG4gICAgfVxuICAgIGNvbnN0IHMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtID0gYS5zdHlsZTtcbiAgICAgIGlmICghbS5wcm9qZWN0aW9uIHx8IG0ucHJvamVjdGlvbi50eXBlID09PSBcIm1lcmNhdG9yXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW01hcC5zZXRTdHlsZV06IE5laXRoZXIgc3BhY2Ugbm9yIGhhbG8gaXMgc3VwcG9ydGVkIGZvciBtZXJjYXRvciBwcm9qZWN0aW9uLiBJZ25vcmluZy4uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTcGFjZUZyb21TdHlsZSh7IHN0eWxlOiBhLnN0eWxlIH0pLCB0aGlzLnNldEhhbG9Gcm9tU3R5bGUoeyBzdHlsZTogYS5zdHlsZSB9KTtcbiAgICB9LCBsID0gKG0pID0+IHtcbiAgICAgIHZhciBnLCB4LCBFLCBDO1xuICAgICAgY29uc3QgeSA9IChtID09IG51bGwgPyB2b2lkIDAgOiBtLnRhcmdldC5nZXRTdHlsZSgpKSA/PyBhLnN0eWxlLCB3ID0gdGhpcy5nZXRMYXllcnNPcmRlcigpWzBdO1xuICAgICAgdGhpcy5zcGFjZSA/IHRoaXMuc2V0U3BhY2VGcm9tU3R5bGUoeyBzdHlsZTogeSB9KSA6IHRoaXMuaW5pdFNwYWNlKHsgYmVmb3JlOiB3LCBzcGVjOiAoeCA9IChnID0geS5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGcubWFwdGlsZXIpID09IG51bGwgPyB2b2lkIDAgOiB4LnNwYWNlIH0pLCB0aGlzLmhhbG8gPyB0aGlzLnNldEhhbG9Gcm9tU3R5bGUoeyBzdHlsZTogeSB9KSA6IHRoaXMuaW5pdEhhbG8oeyBiZWZvcmU6IHcsIHNwZWM6IChDID0gKEUgPSB5Lm1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogRS5tYXB0aWxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IEMuaGFsbyB9KTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgYS5zdHlsZSA9PSBcInN0cmluZ1wiIHx8IGEucmVxdWlyZXNVcmxNb25pdG9yaW5nKVxuICAgICAgcmV0dXJuIHRoaXMub24oXCJzdHlsZWRhdGFcIiwgbCksIHRoaXM7XG4gICAgaWYgKHRoaXMuc3R5bGVJblByb2Nlc3MgJiYgIXRoaXMuc3BhY2Vib3hMb2FkaW5nU3RhdGUuc3R5bGVMb2FkQ2FsbGJhY2tTZXQpXG4gICAgICByZXR1cm4gdGhpcy5vbmNlKFwic3R5bGUubG9hZFwiLCBsKSwgdGhpcy5vbmNlKFwic3R5bGVkYXRhXCIsIGwpLCB0aGlzLnNwYWNlYm94TG9hZGluZ1N0YXRlLnN0eWxlTG9hZENhbGxiYWNrU2V0ID0gITAsIHRoaXM7XG4gICAgaWYgKCgocCA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8udGVycmFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IHAuc291cmNlKSAhPT0gKChkID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS50ZXJyYWluKSA9PSBudWxsID8gdm9pZCAwIDogZC5zb3VyY2UpIHx8ICgoZiA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8udGVycmFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZXhhZ2dlcmF0aW9uKSAhPT0gKChoID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS50ZXJyYWluKSA9PSBudWxsID8gdm9pZCAwIDogaC5leGFnZ2VyYXRpb24pKVxuICAgICAgcmV0dXJuIHRoaXMub25jZShcInRlcnJhaW5cIiwgcyksIHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIGwoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBbTWFwTGlicmUgc3R5bGUgbGF5ZXJdKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvbGF5ZXJzKVxuICAgKiB0byB0aGUgbWFwJ3Mgc3R5bGUuXG4gICAqXG4gICAqIEEgbGF5ZXIgZGVmaW5lcyBob3cgZGF0YSBmcm9tIGEgc3BlY2lmaWVkIHNvdXJjZSB3aWxsIGJlIHN0eWxlZC4gUmVhZCBtb3JlIGFib3V0IGxheWVyIHR5cGVzXG4gICAqIGFuZCBhdmFpbGFibGUgcGFpbnQgYW5kIGxheW91dCBwcm9wZXJ0aWVzIGluIHRoZSBbTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy9sYXllcnMpLlxuICAgKlxuICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYWRkLFxuICAgKiBjb25mb3JtaW5nIHRvIGVpdGhlciB0aGUgTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbidzIFtsYXllciBkZWZpbml0aW9uXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjL2xheWVycykgb3IsXG4gICAqIGxlc3MgY29tbW9ubHksIHRoZSB7QGxpbmsgQ3VzdG9tTGF5ZXJJbnRlcmZhY2V9IHNwZWNpZmljYXRpb24uXG4gICAqIFRoZSBNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uJ3MgbGF5ZXIgZGVmaW5pdGlvbiBpcyBhcHByb3ByaWF0ZSBmb3IgbW9zdCBsYXllcnMuXG4gICAqXG4gICAqIEBwYXJhbSBiZWZvcmVJZCAtIFRoZSBJRCBvZiBhbiBleGlzdGluZyBsYXllciB0byBpbnNlcnQgdGhlIG5ldyBsYXllciBiZWZvcmUsXG4gICAqIHJlc3VsdGluZyBpbiB0aGUgbmV3IGxheWVyIGFwcGVhcmluZyB2aXN1YWxseSBiZW5lYXRoIHRoZSBleGlzdGluZyBsYXllci5cbiAgICogSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbGF5ZXIgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsYXllcnMgYXJyYXlcbiAgICogYW5kIGFwcGVhciB2aXN1YWxseSBhYm92ZSBhbGwgb3RoZXIgbGF5ZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdGhpc2BcbiAgICovXG4gIGFkZExheWVyKHQsIG4pIHtcbiAgICB2YXIgYTtcbiAgICByZXR1cm4gKGEgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgYS5hZGRMYXllcih0LCBuKSwgc3VwZXIuYWRkTGF5ZXIodCwgbik7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmVzIGEgbGF5ZXIgdG8gYSBkaWZmZXJlbnQgei1wb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBsYXllciB0byBtb3ZlLlxuICAgKiBAcGFyYW0gYmVmb3JlSWQgLSBUaGUgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IHRoZSBuZXcgbGF5ZXIgYmVmb3JlLiBXaGVuIHZpZXdpbmcgdGhlIG1hcCwgdGhlIGBpZGAgbGF5ZXIgd2lsbCBhcHBlYXIgYmVuZWF0aCB0aGUgYGJlZm9yZUlkYCBsYXllci4gSWYgYGJlZm9yZUlkYCBpcyBvbWl0dGVkLCB0aGUgbGF5ZXIgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsYXllcnMgYXJyYXkgYW5kIGFwcGVhciBhYm92ZSBhbGwgb3RoZXIgbGF5ZXJzIG9uIHRoZSBtYXAuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBNb3ZlIGEgbGF5ZXIgd2l0aCBJRCAncG9seWdvbicgYmVmb3JlIHRoZSBsYXllciB3aXRoIElEICdjb3VudHJ5LWxhYmVsJy4gVGhlIGBwb2x5Z29uYCBsYXllciB3aWxsIGFwcGVhciBiZW5lYXRoIHRoZSBgY291bnRyeS1sYWJlbGAgbGF5ZXIgb24gdGhlIG1hcC5cbiAgICogYGBgdHNcbiAgICogbWFwLm1vdmVMYXllcigncG9seWdvbicsICdjb3VudHJ5LWxhYmVsJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgbW92ZUxheWVyKHQsIG4pIHtcbiAgICB2YXIgYTtcbiAgICByZXR1cm4gKGEgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgYS5tb3ZlTGF5ZXIodCwgbiksIHN1cGVyLm1vdmVMYXllcih0LCBuKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gSUQgZnJvbSB0aGUgbWFwJ3Mgc3R5bGUuXG4gICAqXG4gICAqIEFuIHtAbGluayBFcnJvckV2ZW50fSB3aWxsIGJlIGZpcmVkIGlmIHRoZSBpbWFnZSBwYXJhbWV0ZXIgaXMgaW52YWxkLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyBgdGhpc2BcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogSWYgYSBsYXllciB3aXRoIElEICdzdGF0ZS1kYXRhJyBleGlzdHMsIHJlbW92ZSBpdC5cbiAgICogYGBgdHNcbiAgICogaWYgKG1hcC5nZXRMYXllcignc3RhdGUtZGF0YScpKSBtYXAucmVtb3ZlTGF5ZXIoJ3N0YXRlLWRhdGEnKTtcbiAgICogYGBgXG4gICAqL1xuICByZW1vdmVMYXllcih0KSB7XG4gICAgdmFyIG47XG4gICAgcmV0dXJuIChuID0gdGhpcy5taW5pbWFwKSA9PSBudWxsIHx8IG4ucmVtb3ZlTGF5ZXIodCksIHN1cGVyLnJlbW92ZUxheWVyKHQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB6b29tIGV4dGVudCBmb3IgdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci4gVGhlIHpvb20gZXh0ZW50IGluY2x1ZGVzIHRoZVxuICAgKiBbbWluaW11bSB6b29tIGxldmVsXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjL2xheWVycy8jbWluem9vbSlcbiAgICogYW5kIFttYXhpbXVtIHpvb20gbGV2ZWxdKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvbGF5ZXJzLyNtYXh6b29tKSlcbiAgICogYXQgd2hpY2ggdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqXG4gICAqIE5vdGU6IEZvciBzdHlsZSBsYXllcnMgdXNpbmcgdmVjdG9yIHNvdXJjZXMsIHN0eWxlIGxheWVycyBjYW5ub3QgYmUgcmVuZGVyZWQgYXQgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiB0aGVcbiAgICogbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBfc291cmNlIGxheWVyXyBiZWNhdXNlIHRoZSBkYXRhIGRvZXMgbm90IGV4aXN0IGF0IHRob3NlIHpvb20gbGV2ZWxzLiBJZiB0aGUgbWluaW11bVxuICAgKiB6b29tIGxldmVsIG9mIHRoZSBzb3VyY2UgbGF5ZXIgaXMgaGlnaGVyIHRoYW4gdGhlIG1pbmltdW0gem9vbSBsZXZlbCBkZWZpbmVkIGluIHRoZSBzdHlsZSBsYXllciwgdGhlIHN0eWxlXG4gICAqIGxheWVyIHdpbGwgbm90IGJlIHJlbmRlcmVkIGF0IGFsbCB6b29tIGxldmVscyBpbiB0aGUgem9vbSByYW5nZS5cbiAgICovXG4gIHNldExheWVyWm9vbVJhbmdlKHQsIG4sIGEpIHtcbiAgICB2YXIgbztcbiAgICByZXR1cm4gKG8gPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgby5zZXRMYXllclpvb21SYW5nZSh0LCBuLCBhKSwgc3VwZXIuc2V0TGF5ZXJab29tUmFuZ2UodCwgbiwgYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbHRlciBmb3IgdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICpcbiAgICogRmlsdGVycyBjb250cm9sIHdoaWNoIGZlYXR1cmVzIGEgc3R5bGUgbGF5ZXIgcmVuZGVycyBmcm9tIGl0cyBzb3VyY2UuXG4gICAqIEFueSBmZWF0dXJlIGZvciB3aGljaCB0aGUgZmlsdGVyIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGB0cnVlYCB3aWxsIGJlXG4gICAqIHJlbmRlcmVkIG9uIHRoZSBtYXAuIFRob3NlIHRoYXQgYXJlIGZhbHNlIHdpbGwgYmUgaGlkZGVuLlxuICAgKlxuICAgKiBVc2UgYHNldEZpbHRlcmAgdG8gc2hvdyBhIHN1YnNldCBvZiB5b3VyIHNvdXJjZSBkYXRhLlxuICAgKlxuICAgKiBUbyBjbGVhciB0aGUgZmlsdGVyLCBwYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cbiAgICovXG4gIHNldEZpbHRlcih0LCBuLCBhKSB7XG4gICAgdmFyIG87XG4gICAgcmV0dXJuIChvID0gdGhpcy5taW5pbWFwKSA9PSBudWxsIHx8IG8uc2V0RmlsdGVyKHQsIG4sIGEpLCBzdXBlci5zZXRGaWx0ZXIodCwgbiwgYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcGFpbnQgcHJvcGVydHkgaW4gdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIGxheWVySWQgLSBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHNldCB0aGUgcGFpbnQgcHJvcGVydHkgaW4uXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhaW50IHByb3BlcnR5IHRvIHNldC5cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYWludCBwcm9wZXJ0eSB0byBzZXQuXG4gICAqIE11c3QgYmUgb2YgYSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHksIGFzIGRlZmluZWQgaW4gdGhlIFtNYXBMaWJyZSBTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1zdHlsZS1zcGVjLykuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBtYXAuc2V0UGFpbnRQcm9wZXJ0eSgnbXktbGF5ZXInLCAnZmlsbC1jb2xvcicsICcjZmFhZmVlJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2V0UGFpbnRQcm9wZXJ0eSh0LCBuLCBhLCBvKSB7XG4gICAgdmFyIGk7XG4gICAgcmV0dXJuIChpID0gdGhpcy5taW5pbWFwKSA9PSBudWxsIHx8IGkuc2V0UGFpbnRQcm9wZXJ0eSh0LCBuLCBhLCBvKSwgc3VwZXIuc2V0UGFpbnRQcm9wZXJ0eSh0LCBuLCBhLCBvKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBsYXlvdXQgcHJvcGVydHkgaW4gdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICogTGF5b3V0IHByb3BlcnRpZXMgZGVmaW5lIGhvdyB0aGUgbGF5ZXIgaXMgc3R5bGVkLlxuICAgKiBMYXlvdXQgcHJvcGVydGllcyBmb3IgbGF5ZXJzIG9mIHRoZSBzYW1lIHR5cGUgYXJlIGRvY3VtZW50ZWQgdG9nZXRoZXIuXG4gICAqIExheWVycyBvZiBkaWZmZXJlbnQgdHlwZXMgaGF2ZSBkaWZmZXJlbnQgbGF5b3V0IHByb3BlcnRpZXMuXG4gICAqIFNlZSB0aGUgW01hcExpYnJlIFN0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvKSBmb3IgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgbGF5b3V0IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBsYXllcklkIC0gVGhlIElEIG9mIHRoZSBsYXllciB0byBzZXQgdGhlIGxheW91dCBwcm9wZXJ0eSBpbi5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbGF5b3V0IHByb3BlcnR5IHRvIHNldC5cbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBsYXlvdXQgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBNdXN0IGJlIG9mIGEgdHlwZSBhcHByb3ByaWF0ZSBmb3IgdGhlIHByb3BlcnR5LCBhcyBkZWZpbmVkIGluIHRoZSBbTWFwTGlicmUgU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBsaWJyZS5vcmcvbWFwbGlicmUtc3R5bGUtc3BlYy8pLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBgdGhpc2BcbiAgICovXG4gIHNldExheW91dFByb3BlcnR5KHQsIG4sIGEsIG8pIHtcbiAgICB2YXIgaTtcbiAgICByZXR1cm4gKGkgPSB0aGlzLm1pbmltYXApID09IG51bGwgfHwgaS5zZXRMYXlvdXRQcm9wZXJ0eSh0LCBuLCBhLCBvKSwgc3VwZXIuc2V0TGF5b3V0UHJvcGVydHkodCwgbiwgYSwgbyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzdHlsZSdzIGdseXBocyBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIGdseXBoc1VybCAtIEdseXBoIFVSTCB0byBzZXQuIE11c3QgY29uZm9ybSB0byB0aGUgW01hcExpYnJlIFN0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vbWFwbGlicmUub3JnL21hcGxpYnJlLXN0eWxlLXNwZWMvZ2x5cGhzLykuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zIGB0aGlzYFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBtYXAuc2V0R2x5cGhzKCdodHRwczovL2RlbW90aWxlcy5tYXBsaWJyZS5vcmcvZm9udC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZicpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldEdseXBocyh0LCBuKSB7XG4gICAgdmFyIGE7XG4gICAgcmV0dXJuIChhID0gdGhpcy5taW5pbWFwKSA9PSBudWxsIHx8IGEuc2V0R2x5cGhzKHQsIG4pLCBzdXBlci5zZXRHbHlwaHModCwgbik7XG4gIH1cbiAgZ2V0U3R5bGVMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc3R5bGUgfHwgIXRoaXMuc3R5bGUuc3R5bGVzaGVldCB8fCAhdGhpcy5zdHlsZS5zdHlsZXNoZWV0Lm1ldGFkYXRhIHx8IHR5cGVvZiB0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGEgIT0gXCJvYmplY3RcIiA/IG51bGwgOiBcIm1hcHRpbGVyOmxhbmd1YWdlXCIgaW4gdGhpcy5zdHlsZS5zdHlsZXNoZWV0Lm1ldGFkYXRhICYmIHR5cGVvZiB0aGlzLnN0eWxlLnN0eWxlc2hlZXQubWV0YWRhdGFbXCJtYXB0aWxlcjpsYW5ndWFnZVwiXSA9PSBcInN0cmluZ1wiID8gdWkodGhpcy5zdHlsZS5zdHlsZXNoZWV0Lm1ldGFkYXRhW1wibWFwdGlsZXI6bGFuZ3VhZ2VcIl0pIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIHRoZSBwcmltYXJ5IGxhbmd1YWdlIG9mIHRoZSBtYXAuIE5vdGUgdGhhdCBub3QgYWxsIHRoZSBsYW5ndWFnZXMgc2hvcnRoYW5kcyBwcm92aWRlZCBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgc2V0TGFuZ3VhZ2UodCkge1xuICAgIHZhciBuO1xuICAgIChuID0gdGhpcy5taW5pbWFwKSA9PSBudWxsIHx8IG4ubWFwLnNldExhbmd1YWdlKHQpLCB0aGlzLm9uU3R5bGVSZWFkeSgoKSA9PiB7XG4gICAgICB0aGlzLnNldFByaW1hcnlMYW5ndWFnZSh0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVmaW5lIHRoZSBwcmltYXJ5IGxhbmd1YWdlIG9mIHRoZSBtYXAuIE5vdGUgdGhhdCBub3QgYWxsIHRoZSBsYW5ndWFnZXMgc2hvcnRoYW5kcyBwcm92aWRlZCBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgc2V0UHJpbWFyeUxhbmd1YWdlKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRTdHlsZUxhbmd1YWdlKCksIGEgPSBJbih0LCB6KTtcbiAgICBpZiAoIWEpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIGxhbmd1YWdlIFwiJHthfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKGEuZmxhZyA9PT0gei5TVFlMRS5mbGFnICYmIG4gJiYgKG4uZmxhZyA9PT0gei5BVVRPLmZsYWcgfHwgbi5mbGFnID09PSB6LlZJU0lUT1IuZmxhZykpICYmIChhLmZsYWcgIT09IHouU1RZTEUuZmxhZyAmJiAodGhpcy5sYW5ndWFnZUFsd2F5c0JlZW5TdHlsZSA9ICExKSwgdGhpcy5sYW5ndWFnZUFsd2F5c0JlZW5TdHlsZSB8fCB0aGlzLnByaW1hcnlMYW5ndWFnZSA9PT0gYSAmJiAhdGhpcy5mb3JjZUxhbmd1YWdlVXBkYXRlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5wcmltYXJ5TGFuZ3VhZ2UuZmxhZyA9PT0gei5TVFlMRV9MT0NLLmZsYWcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRoZSBsYW5ndWFnZSBjYW5ub3QgYmUgY2hhbmdlZCBiZWNhdXNlIHRoaXMgbWFwIGhhcyBiZWVuIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBTVFlMRV9MT0NLIGxhbmd1YWdlIGZsYWcuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByaW1hcnlMYW5ndWFnZSA9IGE7XG4gICAgbGV0IG8gPSBhO1xuICAgIGlmIChhLmZsYWcgPT09IHouU1RZTEUuZmxhZykge1xuICAgICAgaWYgKCFuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBzdHlsZSBoYXMgbm8gZGVmYXVsdCBsYW5ndWFnZXMgb3IgaGFzIGFuIGludmFsaWQgb25lLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbyA9IG47XG4gICAgfVxuICAgIGxldCBpID0gei5MT0NBTC5mbGFnLCBzID0gW1wiZ2V0XCIsIGldO1xuICAgIG8uZmxhZyA9PT0gei5WSVNJVE9SLmZsYWcgPyAoaSA9IFBuKCkuZmxhZywgcyA9IFtcbiAgICAgIFwiY2FzZVwiLFxuICAgICAgW1wiYWxsXCIsIFtcImhhc1wiLCBpXSwgW1wiaGFzXCIsIHouTE9DQUwuZmxhZ11dLFxuICAgICAgW1xuICAgICAgICBcImNhc2VcIixcbiAgICAgICAgW1wiPT1cIiwgW1wiZ2V0XCIsIGldLCBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXV0sXG4gICAgICAgIFtcImdldFwiLCB6LkxPQ0FMLmZsYWddLFxuICAgICAgICBbXCJmb3JtYXRcIiwgW1wiZ2V0XCIsIGldLCB7IFwiZm9udC1zY2FsZVwiOiAwLjggfSwgYFxuYCwgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ10sIHsgXCJmb250LXNjYWxlXCI6IDEuMSB9XVxuICAgICAgXSxcbiAgICAgIFtcImdldFwiLCB6LkxPQ0FMLmZsYWddXG4gICAgXSkgOiBvLmZsYWcgPT09IHouVklTSVRPUl9FTkdMSVNILmZsYWcgPyAoaSA9IHouRU5HTElTSC5mbGFnLCBzID0gW1xuICAgICAgXCJjYXNlXCIsXG4gICAgICBbXCJhbGxcIiwgW1wiaGFzXCIsIGldLCBbXCJoYXNcIiwgei5MT0NBTC5mbGFnXV0sXG4gICAgICBbXG4gICAgICAgIFwiY2FzZVwiLFxuICAgICAgICBbXCI9PVwiLCBbXCJnZXRcIiwgaV0sIFtcImdldFwiLCB6LkxPQ0FMLmZsYWddXSxcbiAgICAgICAgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ10sXG4gICAgICAgIFtcImZvcm1hdFwiLCBbXCJnZXRcIiwgaV0sIHsgXCJmb250LXNjYWxlXCI6IDAuOCB9LCBgXG5gLCBbXCJnZXRcIiwgei5MT0NBTC5mbGFnXSwgeyBcImZvbnQtc2NhbGVcIjogMS4xIH1dXG4gICAgICBdLFxuICAgICAgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ11cbiAgICBdKSA6IG8uZmxhZyA9PT0gei5BVVRPLmZsYWcgPyAoaSA9IFBuKCkuZmxhZywgcyA9IFtcImNvYWxlc2NlXCIsIFtcImdldFwiLCBpXSwgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ11dKSA6IG8gPT09IHouTE9DQUwgPyAoaSA9IHouTE9DQUwuZmxhZywgcyA9IFtcImdldFwiLCBpXSkgOiAoaSA9IG8uZmxhZywgcyA9IFtcImNvYWxlc2NlXCIsIFtcImdldFwiLCBpXSwgW1wiZ2V0XCIsIHouTE9DQUwuZmxhZ11dKTtcbiAgICBjb25zdCB7IGxheWVyczogbCB9ID0gdGhpcy5nZXRTdHlsZSgpLCB1ID0gdGhpcy5vcmlnaW5hbExhYmVsU3R5bGUuc2l6ZSA9PT0gMDtcbiAgICBpZiAodSkge1xuICAgICAgY29uc3QgYyA9IE1pKGwsIHRoaXMpO1xuICAgICAgdGhpcy5pc1N0eWxlTG9jYWxpemVkID0gT2JqZWN0LmtleXMoYy5sb2NhbGl6ZWQpLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYyBvZiBsKSB7XG4gICAgICBpZiAoYy50eXBlICE9PSBcInN5bWJvbFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHAgPSBjLCBkID0gdGhpcy5nZXRTb3VyY2UocC5zb3VyY2UpO1xuICAgICAgaWYgKCFkIHx8ICEoXCJ1cmxcIiBpbiBkICYmIHR5cGVvZiBkLnVybCA9PSBcInN0cmluZ1wiKSB8fCBuZXcgVVJMKGQudXJsKS5ob3N0ICE9PSBYLm1hcHRpbGVyQXBpSG9zdClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB7IGlkOiBoLCBsYXlvdXQ6IG0gfSA9IHA7XG4gICAgICBpZiAoIW0gfHwgIShcInRleHQtZmllbGRcIiBpbiBtKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZXQgeTtcbiAgICAgIGlmICh1ID8gKHkgPSB0aGlzLmdldExheW91dFByb3BlcnR5KGgsIFwidGV4dC1maWVsZFwiKSwgdGhpcy5vcmlnaW5hbExhYmVsU3R5bGUuc2V0KGgsIHkpKSA6IHkgPSB0aGlzLm9yaWdpbmFsTGFiZWxTdHlsZS5nZXQoaCksIHR5cGVvZiB5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluczogdywgZXhhY3RNYXRjaDogZyB9ID0gRWkoeSwgdGhpcy5pc1N0eWxlTG9jYWxpemVkKTtcbiAgICAgICAgaWYgKCF3KSBjb250aW51ZTtcbiAgICAgICAgaWYgKGcpXG4gICAgICAgICAgdGhpcy5zZXRMYXlvdXRQcm9wZXJ0eShoLCBcInRleHQtZmllbGRcIiwgcyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHggPSBBaSh5LCBzLCB0aGlzLmlzU3R5bGVMb2NhbGl6ZWQpO1xuICAgICAgICAgIHRoaXMuc2V0TGF5b3V0UHJvcGVydHkoaCwgXCJ0ZXh0LWZpZWxkXCIsIHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3ID0gQ2koeSwgcywgdGhpcy5pc1N0eWxlTG9jYWxpemVkKTtcbiAgICAgICAgdGhpcy5zZXRMYXlvdXRQcm9wZXJ0eShoLCBcInRleHQtZmllbGRcIiwgdyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFuZ3VhZ2VJc1VwZGF0ZWQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcmltYXJ5IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRQcmltYXJ5TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJpbWFyeUxhbmd1YWdlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4YWdnZXJhdGlvbiBmYWN0b3IgYXBwbGllZCB0byB0aGUgdGVycmFpblxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VGVycmFpbkV4YWdnZXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBLbm93IGlmIHRlcnJpYW4gaXMgZW5hYmxlZCBvciBub3RcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1RlcnJhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUZXJyYWluRW5hYmxlZDtcbiAgfVxuICBncm93VGVycmFpbih0KSB7XG4gICAgaWYgKCF0aGlzLnRlcnJhaW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHBlcmZvcm1hbmNlLm5vdygpLCBhID0gdGhpcy50ZXJyYWluLmV4YWdnZXJhdGlvbiwgbyA9IHQgLSBhLCBpID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnRlcnJhaW4gfHwgdGhpcy50ZXJyYWluRmxhdHRlbmluZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcyA9IChwZXJmb3JtYW5jZS5ub3coKSAtIG4pIC8gdGhpcy50ZXJyYWluQW5pbWF0aW9uRHVyYXRpb247XG4gICAgICBpZiAocyA8IDAuOTkpIHtcbiAgICAgICAgY29uc3QgbCA9IDEgLSAoMSAtIHMpICoqIDQsIHUgPSBhICsgbCAqIG87XG4gICAgICAgIHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb24gPSB1LCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy50ZXJyYWluR3Jvd2luZyA9ICExLCB0aGlzLnRlcnJhaW5GbGF0dGVuaW5nID0gITEsIHRoaXMudGVycmFpbi5leGFnZ2VyYXRpb24gPSB0LCB0aGlzLmZpcmUoXCJ0ZXJyYWluQW5pbWF0aW9uU3RvcFwiLCB7IHRlcnJhaW46IHRoaXMudGVycmFpbiB9KTtcbiAgICAgIHRoaXMuX2VsZXZhdGlvbkZyZWV6ZSA9ICExLCB0aGlzLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgfTtcbiAgICAhdGhpcy50ZXJyYWluR3Jvd2luZyAmJiAhdGhpcy50ZXJyYWluRmxhdHRlbmluZyAmJiB0aGlzLmZpcmUoXCJ0ZXJyYWluQW5pbWF0aW9uU3RhcnRcIiwgeyB0ZXJyYWluOiB0aGlzLnRlcnJhaW4gfSksIHRoaXMudGVycmFpbkdyb3dpbmcgPSAhMCwgdGhpcy50ZXJyYWluRmxhdHRlbmluZyA9ICExLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIDNEIHRlcnJhaW4gdmlzdWFsaXphdGlvblxuICAgKi9cbiAgZW5hYmxlVGVycmFpbih0ID0gdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uKSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUZXJyYWluIGV4YWdnZXJhdGlvbiBjYW5ub3QgYmUgbmVnYXRpdmUuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gKG8pID0+IHtcbiAgICAgICF0aGlzLnRlcnJhaW4gfHwgby50eXBlICE9PSBcImRhdGFcIiB8fCBvLmRhdGFUeXBlICE9PSBcInNvdXJjZVwiIHx8ICEoXCJzb3VyY2VcIiBpbiBvKSB8fCBvLnNvdXJjZUlkICE9PSBcIm1hcHRpbGVyLXRlcnJhaW5cIiB8fCBvLnNvdXJjZS50eXBlICE9PSBcInJhc3Rlci1kZW1cIiB8fCBvLmlzU291cmNlTG9hZGVkICYmICh0aGlzLm9mZihcImRhdGFcIiwgbiksIHRoaXMuZ3Jvd1RlcnJhaW4odCkpO1xuICAgIH0sIGEgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzVGVycmFpbkVuYWJsZWQgPSAhMCwgdGhpcy50ZXJyYWluRXhhZ2dlcmF0aW9uID0gdCwgdGhpcy5vbihcImRhdGFcIiwgbiksIHRoaXMuYWRkU291cmNlKFgudGVycmFpblNvdXJjZUlkLCB7XG4gICAgICAgIHR5cGU6IFwicmFzdGVyLWRlbVwiLFxuICAgICAgICB1cmw6IFgudGVycmFpblNvdXJjZVVSTFxuICAgICAgfSksIHRoaXMuc2V0VGVycmFpbih7XG4gICAgICAgIHNvdXJjZTogWC50ZXJyYWluU291cmNlSWQsXG4gICAgICAgIGV4YWdnZXJhdGlvbjogMFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5nZXRUZXJyYWluKCkpIHtcbiAgICAgIHRoaXMuaXNUZXJyYWluRW5hYmxlZCA9ICEwLCB0aGlzLmdyb3dUZXJyYWluKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2FkZWQoKSB8fCB0aGlzLmlzVGVycmFpbkVuYWJsZWQpXG4gICAgICBhKCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmdldFRlcnJhaW4oKSAmJiB0aGlzLmdldFNvdXJjZShYLnRlcnJhaW5Tb3VyY2VJZCkgfHwgYSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub25jZShcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICBvKCk7XG4gICAgICB9KSwgdGhpcy5vbmNlKFwibW92ZWVuZFwiLCAoKSA9PiB7XG4gICAgICAgIG8oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgM0QgdGVycmFpbiB2aXN1YWxpemF0aW9uXG4gICAqL1xuICBkaXNhYmxlVGVycmFpbigpIHtcbiAgICBpZiAoIXRoaXMudGVycmFpbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzVGVycmFpbkVuYWJsZWQgPSAhMTtcbiAgICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCksIG4gPSB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uLCBhID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnRlcnJhaW4gfHwgdGhpcy50ZXJyYWluR3Jvd2luZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHQpIC8gdGhpcy50ZXJyYWluQW5pbWF0aW9uRHVyYXRpb247XG4gICAgICBpZiAodGhpcy5fZWxldmF0aW9uRnJlZXplID0gITEsIG8gPCAwLjk5KSB7XG4gICAgICAgIGNvbnN0IGkgPSAoMSAtIG8pICoqIDQsIHMgPSBuICogaTtcbiAgICAgICAgdGhpcy50ZXJyYWluLmV4YWdnZXJhdGlvbiA9IHMsIHJlcXVlc3RBbmltYXRpb25GcmFtZShhKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uID0gMCwgdGhpcy50ZXJyYWluR3Jvd2luZyA9ICExLCB0aGlzLnRlcnJhaW5GbGF0dGVuaW5nID0gITEsIHRoaXMuc2V0VGVycmFpbigpLCB0aGlzLmdldFNvdXJjZShYLnRlcnJhaW5Tb3VyY2VJZCkgJiYgdGhpcy5yZW1vdmVTb3VyY2UoWC50ZXJyYWluU291cmNlSWQpLCB0aGlzLmZpcmUoXCJ0ZXJyYWluQW5pbWF0aW9uU3RvcFwiLCB7IHRlcnJhaW46IG51bGwgfSk7XG4gICAgICB0aGlzLnRyaWdnZXJSZXBhaW50KCk7XG4gICAgfTtcbiAgICAhdGhpcy50ZXJyYWluR3Jvd2luZyAmJiAhdGhpcy50ZXJyYWluRmxhdHRlbmluZyAmJiB0aGlzLmZpcmUoXCJ0ZXJyYWluQW5pbWF0aW9uU3RhcnRcIiwgeyB0ZXJyYWluOiB0aGlzLnRlcnJhaW4gfSksIHRoaXMudGVycmFpbkdyb3dpbmcgPSAhMSwgdGhpcy50ZXJyYWluRmxhdHRlbmluZyA9ICEwLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIDNEIHRlcnJhaW4gZXhhZ2VyYXRpb24gZmFjdG9yLlxuICAgKiBJZiB0aGUgdGVycmFpbiB3YXMgbm90IGVuYWJsZWQgcHJpb3IgdG8gdGhlIGNhbGwgb2YgdGhpcyBtZXRob2QsXG4gICAqIHRoZSBtZXRob2QgYC5lbmFibGVUZXJyYWluKClgIHdpbGwgYmUgY2FsbGVkLlxuICAgKiBJZiBgYW5pbWF0ZWAgaXMgYHRydWVgLCB0aGUgdGVycmFpbiB0cmFuc2Zvcm1hdGlvbiB3aWxsIGJlIGFuaW1hdGVkIGluIHRoZSBzcGFuIG9mIDEgc2Vjb25kLlxuICAgKiBJZiBgYW5pbWF0ZWAgaXMgYGZhbHNlYCwgbm8gYW5pbWF0ZWQgdHJhbnNpdGlvbiB0byB0aGUgbmV3bHkgZGVmaW5lZCBleGFnZ2VyYXRpb24uXG4gICAqL1xuICBzZXRUZXJyYWluRXhhZ2dlcmF0aW9uKHQsIG4gPSAhMCkge1xuICAgICFuICYmIHRoaXMudGVycmFpbiA/ICh0aGlzLnRlcnJhaW5FeGFnZ2VyYXRpb24gPSB0LCB0aGlzLnRlcnJhaW4uZXhhZ2dlcmF0aW9uID0gdCwgdGhpcy50cmlnZ2VyUmVwYWludCgpKSA6IHRoaXMuZW5hYmxlVGVycmFpbih0KTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhbiBhY3Rpb24gd2hlbiB0aGUgc3R5bGUgaXMgcmVhZHkuIEl0IGNvdWxkIGJlIGF0IHRoZSBtb21lbnQgb2YgY2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiBvciBsYXRlci5cbiAgICovXG4gIG9uU3R5bGVSZWFkeSh0KSB7XG4gICAgdGhpcy5pc1N0eWxlTG9hZGVkKCkgPyB0KCkgOiB0aGlzLm9uY2UoXCJzdHlsZWRhdGFcIiwgKCkgPT4ge1xuICAgICAgdCgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZpdFRvSXBCb3VuZHMoKSB7XG4gICAgY29uc3QgdCA9IGF3YWl0IE1uLmluZm8oKTtcbiAgICB0aGlzLmZpdEJvdW5kcyh0LmNvdW50cnlfYm91bmRzLCB7XG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIHBhZGRpbmc6IDEwMFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNlbnRlck9uSXBQb2ludCh0KSB7XG4gICAgY29uc3QgbiA9IGF3YWl0IE1uLmluZm8oKTtcbiAgICB0aGlzLmp1bXBUbyh7XG4gICAgICBjZW50ZXI6IFtuLmxvbmdpdHVkZSA/PyAwLCBuLmxhdGl0dWRlID8/IDBdLFxuICAgICAgem9vbTogdCB8fCAxMVxuICAgIH0pO1xuICB9XG4gIGdldENhbWVyYUhhc2goKSB7XG4gICAgY29uc3QgdCA9IG5ldyBGbG9hdDMyQXJyYXkoNSksIG4gPSB0aGlzLmdldENlbnRlcigpO1xuICAgIHJldHVybiB0WzBdID0gbi5sbmcsIHRbMV0gPSBuLmxhdCwgdFsyXSA9IHRoaXMuZ2V0Wm9vbSgpLCB0WzNdID0gdGhpcy5nZXRQaXRjaCgpLCB0WzRdID0gdGhpcy5nZXRCZWFyaW5nKCksIGZpLmZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgU0RLIGNvbmZpZyBvYmplY3QuXG4gICAqIFRoaXMgaXMgY29udmVuaWVudCB0byBkaXNwYXRjaCB0aGUgU0RLIGNvbmZpZ3VyYXRpb24gdG8gZXh0ZXJuYWxseSBidWlsdCBsYXllcnNcbiAgICogdGhhdCBkbyBub3QgZGlyZWN0bHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIFNESyBjb25maWd1cmF0aW9uIGJ1dCBkbyBoYXZlIGFjY2VzcyB0byBhIE1hcCBpbnN0YW5jZS5cbiAgICovXG4gIGdldFNka0NvbmZpZygpIHtcbiAgICByZXR1cm4gajtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBNYXBUaWxlciBzZXNzaW9uIElELiBDb252ZW5pZW50IHRvIGRpc3BhdGNoIHRvIGV4dGVybmFseSBidWlsdCBjb21wb25lbnRcbiAgICogdGhhdCBkbyBub3QgZGlyZWN0bHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIFNESyBjb25maWd1cmF0aW9uIGJ1dCBkbyBoYXZlIGFjY2VzcyB0byBhIE1hcCBpbnN0YW5jZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldE1hcHRpbGVyU2Vzc2lvbklkKCkge1xuICAgIHJldHVybiB0bjtcbiAgfVxuICAvKipcbiAgICogIFVwZGF0ZXMgdGhlIHJlcXVlc3RNYW5hZ2VyJ3MgdHJhbnNmb3JtIHJlcXVlc3Qgd2l0aCBhIG5ldyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zZm9ybVJlcXVlc3QgQSBjYWxsYmFjayBydW4gYmVmb3JlIHRoZSBNYXAgbWFrZXMgYSByZXF1ZXN0IGZvciBhbiBleHRlcm5hbCBVUkwuIFRoZSBjYWxsYmFjayBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHVybCwgc2V0IGhlYWRlcnMsIG9yIHNldCB0aGUgY3JlZGVudGlhbHMgcHJvcGVydHkgZm9yIGNyb3NzLW9yaWdpbiByZXF1ZXN0cy5cbiAgICogICAgRXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgYHVybGAgcHJvcGVydHkgYW5kIG9wdGlvbmFsbHkgYGhlYWRlcnNgIGFuZCBgY3JlZGVudGlhbHNgIHByb3BlcnRpZXNcbiAgICpcbiAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAqXG4gICAqICBAZXhhbXBsZVxuICAgKiAgbWFwLnNldFRyYW5zZm9ybVJlcXVlc3QoKHVybDogc3RyaW5nLCByZXNvdXJjZVR5cGU6IHN0cmluZykgPT4ge30pO1xuICAgKi9cbiAgc2V0VHJhbnNmb3JtUmVxdWVzdCh0KSB7XG4gICAgcmV0dXJuIHN1cGVyLnNldFRyYW5zZm9ybVJlcXVlc3QoJG4odCkpLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBnbG9iZSBwcm9qZWN0aW9uIGlzIGN1cnJlbnRseSBiZWluZyB1c2VkXG4gICAqL1xuICBpc0dsb2JlUHJvamVjdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgcmV0dXJuIHQgPyB0LnR5cGUgPT09IFwiZ2xvYmVcIiA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgZ2xvYmUgcHJvamVjdGlvbi5cbiAgICovXG4gIGVuYWJsZUdsb2JlUHJvamVjdGlvbigpIHtcbiAgICB0aGlzLmlzR2xvYmVQcm9qZWN0aW9uKCkgIT09ICEwICYmICh0aGlzLnNldFByb2plY3Rpb24oeyB0eXBlOiBcImdsb2JlXCIgfSksIHRoaXMuY3VyZW50UHJvamVjdGlvbiA9IFwiZ2xvYmVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKi9cbiAgZW5hYmxlTWVyY2F0b3JQcm9qZWN0aW9uKCkge1xuICAgIHRoaXMuaXNHbG9iZVByb2plY3Rpb24oKSAhPT0gITEgJiYgKHRoaXMuc2V0UHJvamVjdGlvbih7IHR5cGU6IFwibWVyY2F0b3JcIiB9KSwgdGhpcy5jdXJlbnRQcm9qZWN0aW9uID0gXCJtZXJjYXRvclwiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGxhbmd1YWdlIHdhcyBldmVyIHVwZGF0ZWQsIG1lYW5pbmcgY2hhbmdlZFxuICAgKiBmcm9tIHdoYXQgaXMgZGVsaXZlcmVkIGluIHRoZSBzdHlsZS5cbiAgICogUmV0dXJucyBgZmFsc2VgIGlmIGxhbmd1YWdlIGluIHVzZSBpcyB0aGUgbGFuZ3VhZ2UgZnJvbSB0aGUgc3R5bGVcbiAgICogYW5kIGhhcyBuZXZlciBiZWVuIGNoYW5nZWQuXG4gICAqL1xuICBpc0xhbmd1YWdlVXBkYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYW5ndWFnZUlzVXBkYXRlZDtcbiAgfVxufTtcbmNsYXNzIGFlIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbiwgYSA9IHt9KSB7XG4gICAgdih0aGlzLCBcInR5cGVcIik7XG4gICAgdih0aGlzLCBcInRhcmdldFwiKTtcbiAgICB2KHRoaXMsIFwib3JpZ2luYWxFdmVudFwiKTtcbiAgICB0aGlzLnR5cGUgPSBlLCB0aGlzLnRhcmdldCA9IHQsIHRoaXMub3JpZ2luYWxFdmVudCA9IG4gPz8gbnVsbCwgT2JqZWN0LmFzc2lnbih0aGlzLCBhKTtcbiAgfVxufVxuY29uc3QgRW8gPSBbXG4gIC8vIHBhc3Mgbm90aGluZyBvdGhlciB0aGFuIHRhcmdldCAobWFwIC8gdmlld2VyKSBhbmQgdHlwZVxuICBcImlkbGVcIixcbiAgXCJyZW5kZXJcIixcbiAgXCJsb2FkXCIsXG4gIFwicmVtb3ZlXCIsXG4gIFwiaWRsZVwiXG4gIC8vIHRoZXNlIGFyZSBmaXJlZCBvbiBsYXllcnMsIG5vdCB0aGUgbWFwLFxuICAvLyBrZWVwaW5nIHRoZW0gZm9yIHJlZmVyZW5jZVxuICAvLyBcImNvbnRlbnRcIixcbiAgLy8gXCJ2aXNpYmlsaXR5XCIsXG5dLCBBbyA9IFtcbiAgXCJlcnJvclwiXG4gIC8vIEVycm9yRXZlbnRcbl0sIFRvID0gW1wicmVzaXplXCJdLCBfbyA9IFtcIndlYmdsY29udGV4dGxvc3RcIiwgXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiXSwgSW8gPSBbXG4gIFwibW92ZWVuZFwiLFxuICBcIm1vdmVzdGFydFwiLFxuICBcIm1vdmVcIixcbiAgXCJ6b29tZW5kXCIsXG4gIFwiem9vbXN0YXJ0XCIsXG4gIFwiem9vbVwiLFxuICBcInJvdGF0ZXN0YXJ0XCIsXG4gIFwicm90YXRlZW5kXCIsXG4gIFwicm90YXRlXCIsXG4gIFwiZHJhZ3N0YXJ0XCIsXG4gIFwiZHJhZ2VuZFwiLFxuICBcImRyYWdcIixcbiAgXCJib3h6b29tY2FuY2VsXCIsXG4gIFwiYm94em9vbWVuZFwiLFxuICBcImJveHpvb21zdGFydFwiXG5dLCBNbyA9IFtcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZWRvd25cIiwgXCJtb3VzZXVwXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIiwgXCJjb250ZXh0bWVudVwiLCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoY2FuY2VsXCJdLCBQbyA9IFtcImNvb3BlcmF0aXZlZ2VzdHVyZXByZXZlbnRlZFwiXSwgUm8gPSBbXG4gIFwiZGF0YVwiLFxuICBcImRhdGFsb2FkaW5nXCIsXG4gIFwic291cmNlZGF0YVwiLFxuICBcInNvdXJjZWRhdGFsb2FkaW5nXCIsXG4gIFwiZGF0YWFib3J0XCIsXG4gIFwic291cmNlZGF0YWFib3J0XCJcbiAgLy8gdGhpcyBpcyBmaXJlZCBvbiBsYXllcnMsIG5vdCB0aGUgbWFwXG4gIC8vIGtlZXBpbmcgaXQgZm9yIHJlZmVyZW5jZVxuICAvLyBcIm1ldGFkYXRhXCIsXG5dLCBWdSA9IFtcbiAgLi4uRW8sXG4gIC4uLkFvLFxuICAuLi5UbyxcbiAgLi4uX28sXG4gIC4uLklvLFxuICAuLi5NbyxcbiAgLi4uUm8sXG4gIC4uLlBvXG5dLCBHdSA9IFtcImxuZ0xhdFwiLCBcIl9kZWZhdWx0UHJldmVudGVkXCJdO1xuZnVuY3Rpb24gSHUoeyBtYXA6IHIsIHZpZXdlcjogZSwgbG5nTGF0VG9QeDogdCB9KSB7XG4gIFZ1LmZvckVhY2goKG4pID0+IHtcbiAgICB0cnkge1xuICAgICAgci5vbihuLCAoYSkgPT4ge1xuICAgICAgICBjb25zdCBvID0gbjtcbiAgICAgICAgaWYgKE1vLmluY2x1ZGVzKG8pKSB7XG4gICAgICAgICAgY29uc3QgZiA9IGEsIGggPSBmLmxuZ0xhdCAmJiB0KGYubG5nTGF0KSwgbSA9IHtcbiAgICAgICAgICAgIGltYWdlWDogaFswXSxcbiAgICAgICAgICAgIGltYWdlWTogaFsxXSxcbiAgICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhhKS5maWx0ZXIoKFt5XSkgPT4gIUd1LmluY2x1ZGVzKHkpKSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGUuZmlyZShuZXcgYWUobiwgZSwgZi5vcmlnaW5hbEV2ZW50LCBtKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSBuO1xuICAgICAgICBpZiAoSW8uaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICBjb25zdCBmID0gYTtcbiAgICAgICAgICBlLmZpcmUobmV3IGFlKG4sIGUsIGYub3JpZ2luYWxFdmVudCwgZikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzID0gbjtcbiAgICAgICAgaWYgKEFvLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgICAgY29uc3QgZiA9IGE7XG4gICAgICAgICAgZS5maXJlKG5ldyBhZShuLCBlLCBudWxsLCBmKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGwgPSBuO1xuICAgICAgICBpZiAoVG8uaW5jbHVkZXMobCkpIHtcbiAgICAgICAgICBjb25zdCBmID0gYTtcbiAgICAgICAgICBlLmZpcmUobmV3IGFlKG4sIGUsIG51bGwsIGYpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdSA9IG47XG4gICAgICAgIGlmIChfby5pbmNsdWRlcyh1KSkge1xuICAgICAgICAgIGNvbnN0IGYgPSBhO1xuICAgICAgICAgIGUuZmlyZShuZXcgYWUobiwgZSwgZi5vcmlnaW5hbEV2ZW50LCBmKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBuO1xuICAgICAgICBpZiAoUm8uaW5jbHVkZXMoYykpIHtcbiAgICAgICAgICBjb25zdCBmID0gYTtcbiAgICAgICAgICBlLmZpcmUobmV3IGFlKG4sIGUsIG51bGwsIGYpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IG47XG4gICAgICAgIGlmIChQby5pbmNsdWRlcyhwKSkge1xuICAgICAgICAgIGNvbnN0IGYgPSBhO1xuICAgICAgICAgIGUuZmlyZShuZXcgYWUobiwgZSwgbnVsbCwgZikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gbjtcbiAgICAgICAgaWYgKEVvLmluY2x1ZGVzKGQpKSB7XG4gICAgICAgICAgZS5maXJlKG5ldyBhZShuLCBlKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmb3J3YXJkaW5nIGV2ZW50IHRvIEltYWdlVmlld2VyLCBldmVudCBvZiB0eXBlIFwiJHtufVwiIGlzIG5vdCBzdXBwb3J0ZWRgLCBhKTtcbiAgICB9XG4gIH0pO1xufVxuY2xhc3MgWnUgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQsIG4sIGEpIHtcbiAgICBjb25zdCBvID0gYFske2F9XTogRmFpbGVkIHRvIGZldGNoICR7bn0gYXQgJHt0LnVybH06ICR7dC5zdGF0dXMudG9TdHJpbmcoKX06ICR7dC5zdGF0dXNUZXh0fWA7XG4gICAgc3VwZXIobyk7XG4gICAgdih0aGlzLCBcInN0YXR1c1wiKTtcbiAgICB2KHRoaXMsIFwic3RhdHVzVGV4dFwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIiwgdGhpcy5tZXNzYWdlID0gbywgdGhpcy5zdGF0dXMgPSB0LnN0YXR1cywgdGhpcy5zdGF0dXNUZXh0ID0gdC5zdGF0dXNUZXh0O1xuICB9XG59XG5jb25zdCBYdSA9IDg1LjA1MTEyOTtcbmZ1bmN0aW9uIEt1KHIsIGUpIHtcbiAgcmV0dXJuIG5ldyBlbihlLnggLyByLCBlLnkgLyByKS50b0xuZ0xhdCgpO1xufVxuZnVuY3Rpb24gWXUocikge1xuICByZXR1cm4gTWF0aC5wb3coMiwgcik7XG59XG5mdW5jdGlvbiBXdShyKSB7XG4gIHJldHVybiBNYXRoLmxvZyhyKSAvIE1hdGguTE4yO1xufVxuZnVuY3Rpb24gem8ociwgZSwgdCkge1xuICByZXR1cm4gTWF0aC5taW4odCwgTWF0aC5tYXgoZSwgcikpO1xufVxuZnVuY3Rpb24gSHIocikge1xuICByZXR1cm4gKDE4MCAtIDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIHIgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xufVxuZnVuY3Rpb24gWnIocikge1xuICByZXR1cm4gKDE4MCArIHIpIC8gMzYwO1xufVxuZnVuY3Rpb24ga2EociwgZSwgdCkge1xuICBjb25zdCBuID0gdCAtIGUsIGEgPSAoKHIgLSBlKSAlIG4gKyBuKSAlIG4gKyBlO1xuICByZXR1cm4gYSA9PT0gZSA/IHQgOiBhO1xufVxuZnVuY3Rpb24gSnUociwgZSkge1xuICBjb25zdCB0ID0gem8oZS5sYXQsIC04NS4wNTExMjksIFh1KTtcbiAgcmV0dXJuIG5ldyBLbyhacihlLmxuZykgKiByLCBIcih0KSAqIHIpO1xufVxuZnVuY3Rpb24gUXUocikge1xuICByLnRyYW5zZm9ybS5nZXRDb25zdHJhaW5lZCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB0ID0gem8oK3QsIHRoaXMubWluWm9vbSwgdGhpcy5tYXhab29tKTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgY2VudGVyOiBuZXcga2MoZS5sbmcsIGUubGF0KSxcbiAgICAgIHpvb206IHRcbiAgICB9O1xuICAgIGxldCBhID0gdGhpcy5faGVscGVyLl9sbmdSYW5nZTtcbiAgICBhID09PSBudWxsICYmIChhID0gWy0xNzkuOTk5OTk5OTk5OSwgMTc5Ljk5OTk5OTk5OTldKTtcbiAgICBjb25zdCBvID0gdGhpcy50aWxlU2l6ZSAqIFl1KG4uem9vbSk7XG4gICAgbGV0IGkgPSAwLCBzID0gbywgbCA9IDAsIHUgPSBvLCBjID0gMCwgcCA9IDA7XG4gICAgY29uc3QgeyB4OiBkLCB5OiBmIH0gPSB0aGlzLnNpemUsIGggPSAwLjU7XG4gICAgaWYgKHRoaXMuX2hlbHBlci5fbGF0UmFuZ2UpIHtcbiAgICAgIGNvbnN0IEggPSB0aGlzLl9oZWxwZXIuX2xhdFJhbmdlO1xuICAgICAgaSA9IEhyKEhbMV0pICogbywgcyA9IEhyKEhbMF0pICogbywgcyAtIGkgPCBoICogZiAmJiAoYyA9IGggKiBmIC8gKHMgLSBpKSk7XG4gICAgfVxuICAgIGEgJiYgKGwgPSBrYShacihhWzBdKSAqIG8sIDAsIG8pLCB1ID0ga2EoWnIoYVsxXSkgKiBvLCAwLCBvKSwgdSA8IGwgJiYgKHUgKz0gbyksIHUgLSBsIDwgaCAqIGQgJiYgKHAgPSBoICogZCAvICh1IC0gbCkpKTtcbiAgICBjb25zdCB7IHg6IG0sIHkgfSA9IEp1KG8sIGUpO1xuICAgIGxldCB3LCBnO1xuICAgIGNvbnN0IHggPSBNYXRoLm1pbihwIHx8IDAsIGMgfHwgMCk7XG4gICAgaWYgKHgpXG4gICAgICByZXR1cm4gbi56b29tICs9IFd1KHgpLCBuO1xuICAgIGxldCBFID0gMCwgQyA9IDA7XG4gICAgY29uc3QgVCA9IDEsIE4gPSAxIC0gKHMgLSBpKSAvIGYsIHZlID0gMSAtICh1IC0gbCkgLyBkO1xuICAgIEUgPSBNYXRoLm1heCh2ZSwgVCksIEMgPSBNYXRoLm1heChOLCBUKTtcbiAgICBjb25zdCBZZSA9IDEgLSBFLCBXZSA9IDEgLSBDO1xuICAgIGlmICh0aGlzLl9oZWxwZXIuX2xhdFJhbmdlKSB7XG4gICAgICBjb25zdCBIID0gV2UgKiBmIC8gMjtcbiAgICAgIHkgLSBIIDwgaSAmJiAoZyA9IGkgKyBIKSwgeSArIEggPiBzICYmIChnID0gcyAtIEgpO1xuICAgIH1cbiAgICBpZiAoYSkge1xuICAgICAgY29uc3QgSCA9IG0sIE9lID0gWWUgKiBkIC8gMjtcbiAgICAgIEggLSBPZSA8IGwgJiYgKHcgPSBsICsgT2UpLCBIICsgT2UgPiB1ICYmICh3ID0gdSAtIE9lKTtcbiAgICB9XG4gICAgaWYgKHcgIT09IHZvaWQgMCB8fCBnICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IEggPSBuZXcgS28odyA/PyBtLCBnID8/IHkpO1xuICAgICAgbi5jZW50ZXIgPSBLdShvLCBIKS53cmFwKCk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9O1xufVxuY2xhc3MgZWMge1xuICBjb25zdHJ1Y3Rvcih7IGltYWdlVmlld2VyOiBlIH0pIHtcbiAgICB2KHRoaXMsIFwidmlld2VyXCIpO1xuICAgIHYodGhpcywgXCJjb250YWluZXJcIik7XG4gICAgdih0aGlzLCBcImhhbmRsZUNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlld2VyLmZpdEltYWdlVG9WaWV3cG9ydCh7IGVhc2U6ICEwIH0pO1xuICAgIH0pO1xuICAgIGlmICghZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlVmlld2VyRml0SW1hZ2VUb0JvdW5kc0NvbnRyb2w6IGFuIGluc3RhbmNlIG9mICdJbWFnZVZpZXdlcicgaXMgcmVxdWlyZWRcIik7XG4gICAgdGhpcy52aWV3ZXIgPSBlO1xuICB9XG4gIG9uQWRkKGUpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmxcIiwgXCJtYXBsaWJyZWdsLWN0cmwtZ3JvdXBcIiksIHQuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1maXQtaW1hZ2UtdG8tYm91bmRzXCIpO1xuICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICByZXR1cm4gbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWljb25cIiksIHQudGl0bGUgPSBcIlpvb20gaW1hZ2UgdG8gdmlld3BvcnQgYm91bmRzXCIsIHQuYXBwZW5kQ2hpbGQobiksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlQ2xpY2spLCB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0KSwgdGhpcy5jb250YWluZXI7XG4gIH1cbiAgb25SZW1vdmUoKSB7XG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gIH1cbn1cbmNvbnN0IHRjID0gTC5FdmVudGVkLCByYyA9IHtcbiAgc3R5bGU6IHtcbiAgICB2ZXJzaW9uOiA4LFxuICAgIHNvdXJjZXM6IHt9LFxuICAgIGxheWVyczogW11cbiAgfSxcbiAgbWluUGl0Y2g6IDAsXG4gIG1heFBpdGNoOiAwLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgcHJvamVjdGlvbjogXCJtZXJjYXRvclwiLFxuICBnZW9sb2NhdGVDb250cm9sOiAhMSxcbiAgbmF2aWdhdGlvbkNvbnRyb2w6ICExLFxuICBwcm9qZWN0aW9uQ29udHJvbDogITEsXG4gIGhhc2g6ICExLFxuICByZW5kZXJXb3JsZENvcGllczogITEsXG4gIHRlcnJhaW46ICExLFxuICBzcGFjZTogITEsXG4gIGhhbG86ICExXG59LCBuYyA9IHtcbiAgZGVidWc6ICExLFxuICBmaXRUb0JvdW5kc0NvbnRyb2w6ICEwLFxuICBuYXZpZ2F0aW9uQ29udHJvbDogITBcbn07XG5jbGFzcyBKYyBleHRlbmRzIHRjIHtcbiAgLy8jcmVnaW9uIGNvbnN0cnVjdG9yXG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBJbWFnZVZpZXdlci5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPEltYWdlVmlld2VyQ29uc3RydWN0b3JPcHRpb25zPn0gaW1hZ2VWaWV3ZXJDb25zdHJ1Y3Rvck9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIEltYWdlVmlld2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgXCJAbWFwdGlsZXIvc2RrL2Rpc3QvbWFwdGlsZXItc2RrLmNzc1wiOyAvLyBpbXBvcnQgY3NzXG4gICAqIGltcG9ydCB7IEltYWdlVmlld2VyIH0gZnJvbSBcIkBtYXB0aWxlci9zZGtcIjsgLy8gaW1wb3J0IHRoZSBzZGtcbiAgICpcbiAgICogY29uc3QgaW1hZ2VWaWV3ZXIgPSBuZXcgSW1hZ2VWaWV3ZXIoe1xuICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYXBcIiksXG4gICAqICAgaW1hZ2VVVUlEOiBcIjAxOTg2MDI1LWNlYjktNzQ4Ny05ZWE2LTdhODYzN2RjYzFhMVwiLFxuICAgKiAgIGRlYnVnOiB0cnVlLCAvLyBzaG93IHRpbGUgYm91bmRhcmllcywgcGFkZGluZywgY29sbGlzaW9uIGJveGVzIGV0Y1xuICAgKiAgIGZpdFRvQm91bmRzQ29udHJvbDogdHJ1ZSwgLy8gc2hvdyBhIGNvbnRyb2wgdG8gZml0IHRoZSBpbWFnZSB0byB0aGUgdmlld3BvcnRcbiAgICogICBuYXZpZ2F0aW9uQ29udHJvbDogdHJ1ZSwgLy8gc2hvdyBhIG5hdmlnYXRpb24gY29udHJvbFxuICAgKiAgIGNlbnRlcjogWzAsIDBdLCAvLyBjZW50ZXIgaW4gcGl4ZWxzXG4gICAqICAgem9vbTogMSwgLy8gem9vbSBsZXZlbFxuICAgKiAgIGJlYXJpbmc6IDAsIC8vIGJlYXJpbmdcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogVGhlIFVVSUQgb2YgdGhlIGltYWdlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdih0aGlzLCBcImltYWdlVVVJRFwiKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZWJ1ZyBtb2RlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdih0aGlzLCBcImRlYnVnXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhZGF0YSBvZiB0aGUgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB2KHRoaXMsIFwiaW1hZ2VNZXRhZGF0YVwiKTtcbiAgICAvKipcbiAgICAgKiBXaHkgbm90IGV4dGVuZCB0aGUgTWFwIGNsYXNzP1xuICAgICAqIEJlY2F1c2UgSW1hZ2VWaWV3ZXIgdGVjaG5pY2FsbHkgb3BlcmF0ZXMgaW4gc2NyZWVuIHNwYWNlIGFuZCBub3QgaW4gbWFwIHNwYWNlLlxuICAgICAqIFdlIHdyYXAgbWFwIGFuZCBwZXJmb3JtIGNhbGN1bGF0aW9ucyBpbiBzY3JlZW4gc3BhY2UuXG4gICAgICogV2UgZG8gbm90IHdhbnQgdG8gaGF2ZSB0byBleHRlbmQgdGhlIE1hcCBjbGFzcyBhbmQgZ2l2ZSBhY2Nlc3MgdG9cbiAgICAgKiBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgb3BlcmF0ZSBpbiBMbmdMYXQgc3BhY2UuICAgKlxuICAgICAqL1xuICAgIHYodGhpcywgXCJzZGtcIik7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbnMgZm9yIHRoZSBJbWFnZVZpZXdlci5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHYodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHYodGhpcywgXCJpbWFnZVNpemVcIik7XG4gICAgLyoqXG4gICAgICogVGhlIHBhZGRlZCBzaXplIG1heC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHYodGhpcywgXCJwYWRkZWRTaXplTWF4XCIpO1xuICAgIC8vIHRoaXMgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgaW1hZ2Ugc2hvdWxkIGJlIGZpdCB0byB0aGUgdmlld3BvcnRcbiAgICAvLyB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZFxuICAgIHYodGhpcywgXCJzaG91bGRGaXRJbWFnZVRvVmlld3BvcnRcIiwgITApO1xuICAgIGlmICghdC5pbWFnZVVVSUQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJdOiBgaW1hZ2VVVUlEYCBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAodHlwZW9mIHQuY29udGFpbmVyICE9IFwic3RyaW5nXCIgJiYgISh0LmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltJbWFnZVZpZXdlcl06IGBjb250YWluZXJgIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nIG9yIEhUTUxFbGVtZW50XCIpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLm5jLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLnJjXG4gICAgfTtcbiAgICBkZWxldGUgbi5jZW50ZXIsIHRoaXMuc2RrID0gbmV3IExvKG4pLCB0aGlzLnNkay50ZWxlbWV0cnkucmVnaXN0ZXJWaWV3ZXJUeXBlKFwiSW1hZ2VWaWV3ZXJcIik7XG4gICAgY29uc3QgeyBpbWFnZVVVSUQ6IGEsIGRlYnVnOiBvIH0gPSB0O1xuICAgIHRoaXMuaW1hZ2VVVUlEID0gYSwgdGhpcy5kZWJ1ZyA9IG8gPz8gITEsIHRoaXMuZGVidWcgJiYgKHRoaXMuc2RrLnNob3dUaWxlQm91bmRhcmllcyA9IHRoaXMuZGVidWcsIHRoaXMuc2RrLnNob3dQYWRkaW5nID0gdGhpcy5kZWJ1ZywgdGhpcy5zZGsuc2hvd0NvbGxpc2lvbkJveGVzID0gdGhpcy5kZWJ1ZywgdGhpcy5zZGsucmVwYWludCA9IHRoaXMuZGVidWcpLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIEltYWdlVmlld2VyIC8gU0RLLlxuICAgKi9cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnZlcnNpb247XG4gIH1cbiAgLy8jcmVnaW9uIG9uUmVhZHlBc3luY1xuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBJbWFnZVZpZXdlciB0byBiZSByZWFkeS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBvblJlYWR5QXN5bmMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2RrLm9uUmVhZHlBc3luYygpLCBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZSgodCwgbikgPT4ge1xuICAgICAgICAgIHRoaXMub25jZShcImltYWdldmlld2VycmVhZHlcIiwgKGEpID0+IHtcbiAgICAgICAgICAgIHQoYSk7XG4gICAgICAgICAgfSksIHRoaXMub25jZShcImltYWdldmlld2VyaW5pdGVycm9yXCIsIChhKSA9PiB7XG4gICAgICAgICAgICBuKGEuZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb21pc2UoKHQsIG4pID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG4obmV3IEVycm9yKFwiVGltZW91dCB3YWl0aW5nIGZvciBpbWFnZSB2aWV3ZXIgdG8gYmUgcmVhZHlcIikpO1xuICAgICAgICAgIH0sIDVlMyk7XG4gICAgICAgIH0pXG4gICAgICBdKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICB0aHJvdyB0O1xuICAgIH1cbiAgfVxuICAvLyNyZWdpb24gaW5pdFxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIEltYWdlVmlld2VyXG4gICAqICAtIGZldGNoZXMgdGhlIGltYWdlIG1ldGFkYXRhXG4gICAqICAtIGFkZHMgdGhlIGltYWdlIHNvdXJjZSB0byB0aGUgc2RrIGluc3RhbmNlXG4gICAqICAtIHNldHMgdGhlIGNlbnRlciB0byB0aGUgbWlkZGxlIG9mIHRoZSBpbWFnZSAoaWYgY2VudGVyIGlzIG5vdCBwcm92aWRlZClcbiAgICogIC0gbW9ua2V5cGF0Y2hlcyB0aGUgbWFwbGlicmUtZ2wgc2RrIHRyYW5zZm9ybSBtZXRob2QgdG8gYWxsb3cgZm9yIG92ZXJwYW5uaW5nIGFuZCB1bmRlcnpvb21pbmcuXG4gICAqICAtIHNldHMgdXAgZ2xvYmFsIGV2ZW50IGZvcndhcmRpbmcgLyBpbnRlcmNlcHRpbmcgZnJvbSB0aGUgbWFwIGluc3RhbmNlXG4gICAqICAtIHNldHMgdGhlIGNlbnRlciB0byB0aGUgbWlkZGxlIG9mIHRoZSBpbWFnZSAoaWYgY2VudGVyIGlzIG5vdCBwcm92aWRlZClcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB2YXIgdCwgbiwgYTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5mZXRjaEltYWdlTWV0YWRhdGEoKSwgdGhpcy5hZGRJbWFnZVNvdXJjZSgpLCB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbkNvbnRyb2wgJiYgdGhpcy5zZGsuYWRkQ29udHJvbChcbiAgICAgICAgbmV3IE1hKHtcbiAgICAgICAgICB2aXN1YWxpemVQaXRjaDogITEsXG4gICAgICAgICAgdmlzdWFsaXplUm9sbDogITFcbiAgICAgICAgfSlcbiAgICAgICksIHRoaXMub3B0aW9ucy5maXRUb0JvdW5kc0NvbnRyb2wgJiYgdGhpcy5zZGsuYWRkQ29udHJvbChuZXcgZWMoeyBpbWFnZVZpZXdlcjogdGhpcyB9KSksIEh1KHtcbiAgICAgICAgbWFwOiB0aGlzLnNkayxcbiAgICAgICAgdmlld2VyOiB0aGlzLFxuICAgICAgICBsbmdMYXRUb1B4OiAodSkgPT4gdGhpcy5sbmdMYXRUb1B4KHUpXG4gICAgICB9KSwgUXUodGhpcy5zZGspO1xuICAgICAgY29uc3QgeyBjZW50ZXI6IG8sIHpvb206IGksIGJlYXJpbmc6IHMgfSA9IHRoaXMub3B0aW9ucywgbCA9IG8gPz8gWygoKHQgPSB0aGlzLmltYWdlTWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiB0LndpZHRoKSA/PyAwKSAvIDIsICgoKG4gPSB0aGlzLmltYWdlTWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBuLmhlaWdodCkgPz8gMCkgLyAyXTtcbiAgICAgIHRoaXMuc2V0Q2VudGVyKGwpLCB0aGlzLnNldEJlYXJpbmcocyA/PyAwKSwgdGhpcy5vcHRpb25zLnpvb20gPyB0aGlzLnNldFpvb20oaSA/PyAoKGEgPSB0aGlzLmltYWdlTWV0YWRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBhLm1heHpvb20pID8/IDUpIDogdGhpcy5maXRJbWFnZVRvVmlld3BvcnQoKSwgdGhpcy5zZGsub24oXCJ3aGVlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvdWxkRml0SW1hZ2VUb1ZpZXdwb3J0ID0gITE7XG4gICAgICB9KSwgdGhpcy5zZGsub24oXCJ0b3VjaHN0YXJ0XCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zaG91bGRGaXRJbWFnZVRvVmlld3BvcnQgPSAhMTtcbiAgICAgIH0pLCB0aGlzLnNkay5vbihcImRyYWdcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNob3VsZEZpdEltYWdlVG9WaWV3cG9ydCA9ICExO1xuICAgICAgfSksIHRoaXMuc2RrLm9uKFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgICAgdmFyIGQsIGY7XG4gICAgICAgIGNvbnN0IHUgPSB0aGlzLmdldENlbnRlcigpLCBjID0gKChkID0gdGhpcy5pbWFnZU1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogZC53aWR0aCkgPz8gMCwgcCA9ICgoZiA9IHRoaXMuaW1hZ2VNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuaGVpZ2h0KSA/PyAwO1xuICAgICAgICB0aGlzLnNob3VsZEZpdEltYWdlVG9WaWV3cG9ydCAmJiB0aGlzLmZpdEltYWdlVG9WaWV3cG9ydCgpLCAodVswXSAhPT0gYyAvIDIgfHwgdVsxXSAhPT0gcCAvIDIpICYmIHRoaXMuc2V0Q2VudGVyKHUpO1xuICAgICAgfSksIHRoaXMuZmlyZShcImltYWdldmlld2VycmVhZHlcIiwgbmV3IGFlKFwiaW1hZ2V2aWV3ZXJyZWFkeVwiLCB0aGlzKSk7XG4gICAgfSBjYXRjaCAobykge1xuICAgICAgdGhpcy5maXJlKFwiaW1hZ2V2aWV3ZXJpbml0ZXJyb3JcIiwgeyBlcnJvcjogbyB9KTtcbiAgICB9XG4gIH1cbiAgLy8jcmVnaW9uIGZpdEltYWdlVG9WaWV3cG9ydFxuICAvKipcbiAgICogRml0cyB0aGUgaW1hZ2UgdG8gdGhlIHZpZXdwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgZml0IGltYWdlIHRvIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZWFzZSAtIFdoZXRoZXIgdG8gZWFzZSB0byB0aGUgdmlld3BvcnQgYm91bmRzLlxuICAgKi9cbiAgZml0SW1hZ2VUb1ZpZXdwb3J0KHsgZWFzZTogdCA9ICExIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pbWFnZU1ldGFkYXRhKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0ltYWdlVmlld2VyXTogSW1hZ2UgbWV0YWRhdGEgbm90IGZvdW5kXCIpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnB4VG9MbmdMYXQoWzAsIDBdKSwgYSA9IHRoaXMucHhUb0xuZ0xhdChbdGhpcy5pbWFnZU1ldGFkYXRhLndpZHRoID8/IDAsIHRoaXMuaW1hZ2VNZXRhZGF0YS5oZWlnaHQgPz8gMF0pLCBvID0gdGhpcy5zZGsuY2FtZXJhRm9yQm91bmRzKFtuLCBhXSwgeyBwYWRkaW5nOiA1MCB9KTtcbiAgICBvICYmICh0ID8gdGhpcy5zZGsuZWFzZVRvKHsgLi4ubywgcGl0Y2g6IDAgfSwgbnVsbCkgOiB0aGlzLnNkay5qdW1wVG8oeyAuLi5vLCBwaXRjaDogMCB9LCBudWxsKSksIHRoaXMuc2hvdWxkRml0SW1hZ2VUb1ZpZXdwb3J0ID0gITA7XG4gIH1cbiAgLy8jcmVnaW9uIGZldGNoSW1hZ2VNZXRhZGF0YVxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgaW1hZ2UgbWV0YWRhdGEgZnJvbSB0aGUgQVBJLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBmZXRjaEltYWdlTWV0YWRhdGEoKSB7XG4gICAgY29uc3QgdCA9IGFjKHRoaXMuaW1hZ2VVVUlEKSwgbiA9IGF3YWl0IGZldGNoKHQpO1xuICAgIGlmICghbi5vaylcbiAgICAgIHRocm93IG5ldyBadShuLCBcImltYWdlIG1ldGFkYXRhXCIsIFwiSW1hZ2VWaWV3ZXJcIik7XG4gICAgY29uc3QgYSA9IGF3YWl0IG4uanNvbigpO1xuICAgIHRoaXMuaW1hZ2VNZXRhZGF0YSA9IGE7XG4gIH1cbiAgLy8jcmVnaW9uIGFkZEltYWdlU291cmNlXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBpbWFnZSBzb3VyY2UgdG8gdGhlIHNkayBpbnN0YW5jZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkSW1hZ2VTb3VyY2UoKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlTWV0YWRhdGEpXG4gICAgICB0aHJvdyB0aGlzLmZpcmUoXCJlcnJvclwiLCBuZXcgYWUoXCJlcnJvclwiLCB0aGlzLCBudWxsLCB7IGVycm9yOiBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJdOiBJbWFnZSBtZXRhZGF0YSBub3QgZm91bmRcIikgfSkpLCBuZXcgRXJyb3IoXCJbSW1hZ2VWaWV3ZXJdOiBJbWFnZSBtZXRhZGF0YSBub3QgZm91bmRcIik7XG4gICAgY29uc3QgdCA9IG9jKHRoaXMuaW1hZ2VVVUlEKSwgbiA9IChzKSA9PiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cocykgLyBNYXRoLkxOMikpO1xuICAgIHRoaXMuaW1hZ2VTaXplID0gW3RoaXMuaW1hZ2VNZXRhZGF0YS53aWR0aCwgdGhpcy5pbWFnZU1ldGFkYXRhLmhlaWdodF0sIHRoaXMucGFkZGVkU2l6ZU1heCA9IE1hdGgubWF4KG4odGhpcy5pbWFnZVNpemVbMF0pLCBuKHRoaXMuaW1hZ2VTaXplWzFdKSk7XG4gICAgY29uc3QgYSA9IHRoaXMucHhUb0xuZ0xhdChbMCwgMF0pLCBvID0gdGhpcy5weFRvTG5nTGF0KHRoaXMuaW1hZ2VTaXplKSwgaSA9IFthLmxuZywgby5sYXQsIG8ubG5nLCBhLmxhdF07XG4gICAgdGhpcy5zZGsuYWRkU291cmNlKFwiaW1hZ2VcIiwge1xuICAgICAgLi4udGhpcy5pbWFnZU1ldGFkYXRhLFxuICAgICAgdHlwZTogXCJyYXN0ZXJcIixcbiAgICAgIGJvdW5kczogaSxcbiAgICAgIHRpbGVzOiBbdF1cbiAgICB9KSwgdGhpcy5zZGsuYWRkTGF5ZXIoe1xuICAgICAgaWQ6IFwiaW1hZ2VcIixcbiAgICAgIHR5cGU6IFwicmFzdGVyXCIsXG4gICAgICBzb3VyY2U6IFwiaW1hZ2VcIlxuICAgIH0pO1xuICB9XG4gIC8vI3JlZ2lvbiBTREsgbWFwcGluZ3NcbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgcmVwYWludCBvZiB0aGUgSW1hZ2VWaWV3ZXIuIFNhbWUgYXMgbWFwLnRyaWdnZXJSZXBhaW50KCkuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHRyaWdnZXJSZXBhaW50KCkge1xuICAgIHRoaXMuc2RrLnRyaWdnZXJSZXBhaW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JvbGwgem9vbSBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1Njcm9sbFpvb21IYW5kbGVyfVxuICAgKi9cbiAgZ2V0IHNjcm9sbFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnNjcm9sbFpvb207XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY3JvbGwgem9vbSBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtTY3JvbGxab29tSGFuZGxlcn0gdmFsdWUgLSBUaGUgc2Nyb2xsIHpvb20gaGFuZGxlci5cbiAgICovXG4gIHNldCBzY3JvbGxab29tKHQpIHtcbiAgICB0aGlzLnNkay5zY3JvbGxab29tID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJveCB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7Qm94Wm9vbUhhbmRsZXJ9XG4gICAqL1xuICBnZXQgYm94Wm9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsuYm94Wm9vbTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJveCB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge0JveFpvb21IYW5kbGVyfSB2YWx1ZSAtIFRoZSBib3ggem9vbSBoYW5kbGVyLlxuICAgKi9cbiAgc2V0IGJveFpvb20odCkge1xuICAgIHRoaXMuc2RrLmJveFpvb20gPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZHJhZyBwYW4gaGFuZGxlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtEcmFnUGFuSGFuZGxlcn1cbiAgICovXG4gIGdldCBkcmFnUGFuKCkge1xuICAgIHJldHVybiB0aGlzLnNkay5kcmFnUGFuO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZHJhZyBwYW4gaGFuZGxlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7RHJhZ1BhbkhhbmRsZXJ9IHZhbHVlIC0gVGhlIGRyYWcgcGFuIGhhbmRsZXIuXG4gICAqL1xuICBzZXQgZHJhZ1Bhbih0KSB7XG4gICAgdGhpcy5zZGsuZHJhZ1BhbiA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXlib2FyZCBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge0tleWJvYXJkSGFuZGxlcn1cbiAgICovXG4gIGdldCBrZXlib2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsua2V5Ym9hcmQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBrZXlib2FyZCBoYW5kbGVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtLZXlib2FyZEhhbmRsZXJ9IHZhbHVlIC0gVGhlIGtleWJvYXJkIGhhbmRsZXIuXG4gICAqL1xuICBzZXQga2V5Ym9hcmQodCkge1xuICAgIHRoaXMuc2RrLmtleWJvYXJkID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGRvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7RG91YmxlQ2xpY2tab29tSGFuZGxlcn1cbiAgICovXG4gIGdldCBkb3VibGVDbGlja1pvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmRvdWJsZUNsaWNrWm9vbTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge0RvdWJsZUNsaWNrWm9vbUhhbmRsZXJ9IHZhbHVlIC0gVGhlIGRvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gICAqL1xuICBzZXQgZG91YmxlQ2xpY2tab29tKHQpIHtcbiAgICB0aGlzLnNkay5kb3VibGVDbGlja1pvb20gPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG91Y2ggem9vbSByb3RhdGUgaGFuZGxlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEByZXR1cm5zIHtUd29GaW5nZXJzVG91Y2hab29tUm90YXRlSGFuZGxlcn1cbiAgICovXG4gIGdldCB0b3VjaFpvb21Sb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLnRvdWNoWm9vbVJvdGF0ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRvdWNoIHpvb20gcm90YXRlIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1R3b0ZpbmdlcnNUb3VjaFpvb21Sb3RhdGVIYW5kbGVyfSB2YWx1ZSAtIFRoZSB0b3VjaCB6b29tIHJvdGF0ZSBoYW5kbGVyLlxuICAgKi9cbiAgc2V0IHRvdWNoWm9vbVJvdGF0ZSh0KSB7XG4gICAgdGhpcy5zZGsudG91Y2hab29tUm90YXRlID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvb3BlcmF0aXZlIGdlc3R1cmVzIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcmV0dXJucyB7Q29vcGVyYXRpdmVHZXN0dXJlc0hhbmRsZXJ9XG4gICAqL1xuICBnZXQgY29vcGVyYXRpdmVHZXN0dXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZGsuY29vcGVyYXRpdmVHZXN0dXJlcztcbiAgfVxuICAvKipcbiAgICogVGhlIGNvb3BlcmF0aXZlIGdlc3R1cmVzIGhhbmRsZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge0Nvb3BlcmF0aXZlR2VzdHVyZXNIYW5kbGVyfSB2YWx1ZSAtIFRoZSBjb29wZXJhdGl2ZSBnZXN0dXJlcyBoYW5kbGVyLlxuICAgKi9cbiAgc2V0IGNvb3BlcmF0aXZlR2VzdHVyZXModCkge1xuICAgIHRoaXMuc2RrLmNvb3BlcmF0aXZlR2VzdHVyZXMgPSB0O1xuICB9XG4gIC8vI2VuZHJlZ2lvbiBTREsgTWFwcGluZ3NcbiAgLy8jcmVnaW9uIGxuZ0xhdFRvUHhcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgTG5nTGF0IHRvIGEgcHggY29vcmRpbmF0ZSwgYmFzZWQgb24gdGhlIGltYWdlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtMbmdMYXR9IGxuZ0xhdCAtIFRoZSBMbmdMYXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFRoZSBweCBjb29yZGluYXRlLlxuICAgKi9cbiAgbG5nTGF0VG9QeCh0KSB7XG4gICAgaWYgKCF0aGlzLnBhZGRlZFNpemVNYXgpIHtcbiAgICAgIGNvbnN0IGEgPSBcIltJbWFnZVZpZXdlcl06IFVuYWJsZSB0byBjb252ZXJ0IExuZ0xhdCB0byBweCwgcGFkZGVkIHNpemUgbWF4IG5vdCBzZXRcIjtcbiAgICAgIHRocm93IHRoaXMuZmlyZShcImVycm9yXCIsIG5ldyBhZShcImVycm9yXCIsIHRoaXMsIG51bGwsIHsgZXJyb3I6IG5ldyBFcnJvcihhKSB9KSksIG5ldyBFcnJvcihhKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IGVuLmZyb21MbmdMYXQodC53cmFwKCkpO1xuICAgIHJldHVybiBbbi54ICogdGhpcy5wYWRkZWRTaXplTWF4LCBuLnkgKiB0aGlzLnBhZGRlZFNpemVNYXhdO1xuICB9XG4gIC8vI3JlZ2lvbiBweFRvTG5nTGF0XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHB4IGNvb3JkaW5hdGUgdG8gYSBMbmdMYXQsIGJhc2VkIG9uIHRoZSBpbWFnZSBtZXRhZGF0YS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdMYXQgLSBUaGUgTG5nTGF0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXJdfSBUaGUgcHggY29vcmRpbmF0ZS5cbiAgICovXG4gIHB4VG9MbmdMYXQodCkge1xuICAgIGlmICghdGhpcy5wYWRkZWRTaXplTWF4KSB7XG4gICAgICBjb25zdCBhID0gXCJbSW1hZ2VWaWV3ZXJdOiBVbmFibGUgdG8gY29udmVydCBweCB0byBMbmdMYXQsIHBhZGRlZCBzaXplIG1heCBub3Qgc2V0XCI7XG4gICAgICB0aHJvdyB0aGlzLmZpcmUoXCJlcnJvclwiLCBuZXcgYWUoXCJlcnJvclwiLCB0aGlzLCBudWxsLCB7IGVycm9yOiBuZXcgRXJyb3IoYSkgfSkpLCBuZXcgRXJyb3IoYSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZW4odFswXSAvIHRoaXMucGFkZGVkU2l6ZU1heCwgdFsxXSAvIHRoaXMucGFkZGVkU2l6ZU1heCkudG9MbmdMYXQoKTtcbiAgfVxuICAvLyNyZWdpb24gZmx5VG9cbiAgLyoqXG4gICAqIEZseSB0byBhIGdpdmVuIGNlbnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtJbWFnZVZpZXdlckZseVRvT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgZmx5IHRvLlxuICAgKiBAcGFyYW0ge01hcERhdGFFdmVudH0gZXZlbnREYXRhIC0gVGhlIGV2ZW50IGRhdGEuXG4gICAqL1xuICBmbHlUbyh0LCBuKSB7XG4gICAgY29uc3QgYSA9IHRoaXMucHhUb0xuZ0xhdCh0LmNlbnRlcik7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmZseVRvKHsgLi4udCwgcGl0Y2g6IDAsIGNlbnRlcjogYSB9LCBuKTtcbiAgfVxuICAvLyNyZWdpb24ganVtcFRvXG4gIC8qKlxuICAgKiBKdW1wIHRvIGEgZ2l2ZW4gY2VudGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0ltYWdlVmlld2VySnVtcFRvT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUganVtcCB0by5cbiAgICogQHBhcmFtIHtNYXBEYXRhRXZlbnR9IGV2ZW50RGF0YSAtIFRoZSBldmVudCBkYXRhLlxuICAgKi9cbiAganVtcFRvKHQsIG4pIHtcbiAgICBjb25zdCBhID0gdGhpcy5weFRvTG5nTGF0KHQuY2VudGVyKTtcbiAgICByZXR1cm4gdGhpcy5zZGsuanVtcFRvKHsgLi4udCwgcGl0Y2g6IDAsIGNlbnRlcjogYSB9LCBuKTtcbiAgfVxuICAvLyNyZWdpb24gc2V0Wm9vbVxuICAvKipcbiAgICogU2V0IHRoZSB6b29tIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIGxldmVsLlxuICAgKi9cbiAgc2V0Wm9vbSh0KSB7XG4gICAgdGhpcy5zZGsuc2V0Wm9vbSh0KTtcbiAgfVxuICAvLyNyZWdpb24gZ2V0Wm9vbVxuICAvKipcbiAgICogR2V0IHRoZSB6b29tIGxldmVsLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgem9vbSBsZXZlbC5cbiAgICovXG4gIGdldFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmdldFpvb20oKTtcbiAgfVxuICAvLyNyZWdpb24gZ2V0Q2VudGVyXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VWaWV3ZXIgaW4gcGl4ZWxzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHJldHVybnMge1tudW1iZXIsIG51bWJlcl19IFRoZSBjZW50ZXIgb2YgdGhlIEltYWdlVmlld2VyLlxuICAgKi9cbiAgZ2V0Q2VudGVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnNkay5nZXRDZW50ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5sbmdMYXRUb1B4KHQpO1xuICB9XG4gIC8vI3JlZ2lvbiBzZXRDZW50ZXJcbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZVZpZXdlciBpbiBwaXhlbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjZW50ZXIgLSBUaGUgY2VudGVyIG9mIHRoZSBJbWFnZVZpZXdlci5cbiAgICovXG4gIHNldENlbnRlcih0KSB7XG4gICAgdGhpcy5zZGsuc2V0Q2VudGVyKHRoaXMucHhUb0xuZ0xhdCh0KSk7XG4gIH1cbiAgLy8jcmVnaW9uIHNldEJlYXJpbmdcbiAgLyoqXG4gICAqIFNldCB0aGUgYmVhcmluZyBvZiB0aGUgSW1hZ2VWaWV3ZXIgaW4gZGVncmVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgLSBUaGUgYmVhcmluZyBvZiB0aGUgSW1hZ2VWaWV3ZXIuXG4gICAqL1xuICBzZXRCZWFyaW5nKHQpIHtcbiAgICB0aGlzLnNkay5zZXRCZWFyaW5nKHQpO1xuICB9XG4gIC8vI3JlZ2lvbiBnZXRCZWFyaW5nXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJlYXJpbmcgb2YgdGhlIEltYWdlVmlld2VyIGluIGRlZ3JlZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBiZWFyaW5nIG9mIHRoZSBJbWFnZVZpZXdlci5cbiAgICovXG4gIGdldEJlYXJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmdldEJlYXJpbmcoKTtcbiAgfVxuICAvLyNyZWdpb24gcGFuQnlcbiAgLyoqXG4gICAqIFBhbiBieSBhIGdpdmVuIGRlbHRhIGluIHBpeGVscy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludExpa2V9IGRlbHRhIC0gVGhlIGRlbHRhIHRvIHBhbiBieS5cbiAgICogQHBhcmFtIHtJbWFnZVZpZXdlckVhc2VUb09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBhbi5cbiAgICogQHBhcmFtIHthbnl9IGV2ZW50RGF0YSAtIFRoZSBldmVudCBkYXRhLlxuICAgKi9cbiAgcGFuQnkodCwgbiwgYSkge1xuICAgIHRoaXMuc2RrLnBhbkJ5KHQsIHsgLi4ubiwgcGl0Y2g6IDAgfSwgYSk7XG4gIH1cbiAgLy8jcmVnaW9uIHBhblRvXG4gIC8qKlxuICAgKiBQYW4gdG8gYSBnaXZlbiBjZW50ZXIgaW4gcGl4ZWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyIC0gVGhlIGNlbnRlciB0byBwYW4gdG8uXG4gICAqIEBwYXJhbSB7SW1hZ2VWaWV3ZXJFYXNlVG9PcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBwYW4uXG4gICAqIEBwYXJhbSB7YW55fSBldmVudERhdGEgLSBUaGUgZXZlbnQgZGF0YS5cbiAgICovXG4gIHBhblRvKHQsIG4sIGEpIHtcbiAgICB0aGlzLnNkay5wYW5Ubyh0aGlzLnB4VG9MbmdMYXQodCksIHsgLi4ubiwgcGl0Y2g6IDAgfSwgYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFjKHIpIHtcbiAgcmV0dXJuIGAke0ZvKCl9LyR7cn0vaW1hZ2UuanNvbj9rZXk9JHtqLmFwaUtleX1gO1xufVxuZnVuY3Rpb24gb2Mocikge1xuICByZXR1cm4gYCR7Rm8oKX0vJHtyfS97en0ve3h9L3t5fT9rZXk9JHtqLmFwaUtleX1gO1xufVxuZnVuY3Rpb24gRm8oKSB7XG4gIHJldHVybiBcImh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9pbWFnZXNcIjtcbn1cbmZ1bmN0aW9uIENuKHIpIHtcbiAgaWYgKHR5cGVvZiBET01QYXJzZXIgPCBcInVcIikge1xuICAgIGNvbnN0IGUgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHIsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgIGlmIChlLnF1ZXJ5U2VsZWN0b3IoXCJwYXJzZXJlcnJvclwiKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwcm92aWRlZCBzdHJpbmcgaXMgbm90IHZhbGlkIFhNTFwiKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBYTUwgcGFyc2VyIGZvdW5kXCIpO1xufVxuZnVuY3Rpb24gJG8ociwgZSkge1xuICBpZiAoIXIuaGFzQ2hpbGROb2RlcygpKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChjb25zdCB0IG9mIEFycmF5LmZyb20oci5jaGlsZE5vZGVzKSkge1xuICAgIGNvbnN0IG4gPSB0Lm5vZGVOYW1lO1xuICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIG4udHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09IGUudG9Mb3dlckNhc2UoKSlcbiAgICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBMYShyKSB7XG4gIGlmICh0eXBlb2YgWE1MU2VyaWFsaXplciA8IFwidVwiKVxuICAgIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHIpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBYTUwgc2VyaWFsaXplciBmb3VuZFwiKTtcbn1cbmZ1bmN0aW9uIE9vKHIpIHtcbiAgY29uc3QgZSA9IHR5cGVvZiByID09IFwic3RyaW5nXCIgPyBDbihyKSA6IHI7XG4gIGlmICghJG8oZSwgXCJncHhcIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIFhNTCBkb2N1bWVudCBpcyBub3QgdmFsaWQgR1BYXCIpO1xuICBjb25zdCB0ID0gRyhlLCBcInRya1wiKSwgbiA9IEcoZSwgXCJydGVcIiksIGEgPSBHKGUsIFwid3B0XCIpLCBvID0ge1xuICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICBmZWF0dXJlczogW11cbiAgfTtcbiAgZm9yIChjb25zdCBpIG9mIEFycmF5LmZyb20odCkpIHtcbiAgICBjb25zdCBzID0gdWMoaSk7XG4gICAgcyAmJiBvLmZlYXR1cmVzLnB1c2gocyk7XG4gIH1cbiAgZm9yIChjb25zdCBpIG9mIEFycmF5LmZyb20obikpIHtcbiAgICBjb25zdCBzID0gY2MoaSk7XG4gICAgcyAmJiBvLmZlYXR1cmVzLnB1c2gocyk7XG4gIH1cbiAgZm9yIChjb25zdCBpIG9mIEFycmF5LmZyb20oYSkpXG4gICAgby5mZWF0dXJlcy5wdXNoKHBjKGkpKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBObyhyLCBlKSB7XG4gIGxldCB0ID0gcjtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBDbih0KSksICEkbyh0LCBcImttbFwiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgWE1MIGRvY3VtZW50IGlzIG5vdCB2YWxpZCBLTUxcIik7XG4gIGNvbnN0IG4gPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgIGZlYXR1cmVzOiBbXVxuICB9LCBhID0ge30sIG8gPSB7fSwgaSA9IHt9LCBzID0gRyh0LCBcIlBsYWNlbWFya1wiKSwgbCA9IEcodCwgXCJTdHlsZVwiKSwgdSA9IEcodCwgXCJTdHlsZU1hcFwiKTtcbiAgZm9yIChjb25zdCBjIG9mIEFycmF5LmZyb20obCkpIHtcbiAgICBjb25zdCBwID0gRWEoZSAhPT0gdm9pZCAwID8gZShjKSA6IExhKGMpKS50b1N0cmluZygxNik7XG4gICAgYVtgIyR7WmUoYywgXCJpZFwiKX1gXSA9IHAsIG9bcF0gPSBjO1xuICB9XG4gIGZvciAoY29uc3QgYyBvZiBBcnJheS5mcm9tKHUpKSB7XG4gICAgYVtgIyR7WmUoYywgXCJpZFwiKX1gXSA9IEVhKGUgIT09IHZvaWQgMCA/IGUoYykgOiBMYShjKSkudG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IHAgPSBHKGMsIFwiUGFpclwiKSwgZCA9IHt9O1xuICAgIGZvciAoY29uc3QgZiBvZiBBcnJheS5mcm9tKHApKVxuICAgICAgZFtPKF8oZiwgXCJrZXlcIikpID8/IFwiXCJdID0gTyhfKGYsIFwic3R5bGVVcmxcIikpO1xuICAgIGlbYCMke1plKGMsIFwiaWRcIil9YF0gPSBkO1xuICB9XG4gIGZvciAoY29uc3QgYyBvZiBBcnJheS5mcm9tKHMpKVxuICAgIG4uZmVhdHVyZXMgPSBuLmZlYXR1cmVzLmNvbmNhdChsYyhjLCBhLCBvLCBpKSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gQ2Eocikge1xuICBpZiAociA9PT0gbnVsbCkgcmV0dXJuIFtcIiMwMDAwMDBcIiwgMV07XG4gIGxldCBlID0gXCJcIiwgdCA9IDEsIG4gPSByO1xuICByZXR1cm4gbi5zdGFydHNXaXRoKFwiI1wiKSAmJiAobiA9IG4uc3Vic3RyaW5nKDEpKSwgKG4ubGVuZ3RoID09PSA2IHx8IG4ubGVuZ3RoID09PSAzKSAmJiAoZSA9IG4pLCBuLmxlbmd0aCA9PT0gOCAmJiAodCA9IE51bWJlci5wYXJzZUludChuLnN1YnN0cmluZygwLCAyKSwgMTYpIC8gMjU1LCBlID0gYCMke24uc3Vic3RyaW5nKDYsIDgpfSR7bi5zdWJzdHJpbmcoNCwgNil9JHtuLnN1YnN0cmluZygyLCA0KX1gKSwgW2UgPz8gXCIjMDAwMDAwXCIsIHQgPz8gMV07XG59XG5mdW5jdGlvbiBpYyhyKSB7XG4gIHJldHVybiBEbyhyLnNwbGl0KFwiIFwiKSk7XG59XG5mdW5jdGlvbiBzYyhyKSB7XG4gIGxldCBlID0gRyhyLCBcImNvb3JkXCIpO1xuICBjb25zdCB0ID0gW10sIG4gPSBbXTtcbiAgZS5sZW5ndGggPT09IDAgJiYgKGUgPSBHKHIsIFwiZ3g6Y29vcmRcIikpO1xuICBmb3IgKGNvbnN0IG8gb2YgQXJyYXkuZnJvbShlKSlcbiAgICB0LnB1c2goaWMoTyhvKSA/PyBcIlwiKSk7XG4gIGNvbnN0IGEgPSBHKHIsIFwid2hlblwiKTtcbiAgZm9yIChjb25zdCBvIG9mIEFycmF5LmZyb20oYSkpIG4ucHVzaChPKG8pKTtcbiAgcmV0dXJuIHtcbiAgICBjb29yZHM6IHQsXG4gICAgdGltZXM6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFV0KHIpIHtcbiAgY29uc3QgZSA9IFtcIlBvbHlnb25cIiwgXCJMaW5lU3RyaW5nXCIsIFwiUG9pbnRcIiwgXCJUcmFja1wiLCBcImd4OlRyYWNrXCJdO1xuICBsZXQgdCwgbiwgYSwgbywgaTtcbiAgY29uc3QgcyA9IFtdLCBsID0gW107XG4gIGlmIChfKHIsIFwiTXVsdGlHZW9tZXRyeVwiKSAhPT0gbnVsbClcbiAgICByZXR1cm4gVXQoXyhyLCBcIk11bHRpR2VvbWV0cnlcIikpO1xuICBpZiAoXyhyLCBcIk11bHRpVHJhY2tcIikgIT09IG51bGwpXG4gICAgcmV0dXJuIFV0KF8ociwgXCJNdWx0aVRyYWNrXCIpKTtcbiAgaWYgKF8ociwgXCJneDpNdWx0aVRyYWNrXCIpICE9PSBudWxsKVxuICAgIHJldHVybiBVdChfKHIsIFwiZ3g6TXVsdGlUcmFja1wiKSk7XG4gIGZvciAoYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKVxuICAgIGlmIChuID0gRyhyLCBlW2FdKSwgbikge1xuICAgICAgZm9yIChvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICAgIGlmICh0ID0gbltvXSwgZVthXSA9PT0gXCJQb2ludFwiKVxuICAgICAgICAgIHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogQm8oTyhfKHQsIFwiY29vcmRpbmF0ZXNcIikpID8/IFwiXCIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKGVbYV0gPT09IFwiTGluZVN0cmluZ1wiKVxuICAgICAgICAgIHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBUYShPKF8odCwgXCJjb29yZGluYXRlc1wiKSkgPz8gXCJcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBpZiAoZVthXSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICBjb25zdCB1ID0gRyh0LCBcIkxpbmVhclJpbmdcIiksIGMgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGMucHVzaChUYShPKF8odVtpXSwgXCJjb29yZGluYXRlc1wiKSkgPz8gXCJcIikpO1xuICAgICAgICAgIHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZVthXSA9PT0gXCJUcmFja1wiIHx8IGVbYV0gPT09IFwiZ3g6VHJhY2tcIikge1xuICAgICAgICAgIGNvbnN0IHUgPSBzYyh0KTtcbiAgICAgICAgICBzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogdS5jb29yZHNcbiAgICAgICAgICB9KSwgdS50aW1lcy5sZW5ndGggJiYgbC5wdXNoKHUudGltZXMpO1xuICAgICAgICB9XG4gICAgfVxuICByZXR1cm4geyBnZW9tczogcywgY29vcmRUaW1lczogbCB9O1xufVxuZnVuY3Rpb24gbGMociwgZSwgdCwgbikge1xuICBjb25zdCBhID0gVXQociksIG8gPSB7fSwgaSA9IE8oXyhyLCBcIm5hbWVcIikpLCBzID0gTyhfKHIsIFwiYWRkcmVzc1wiKSksIGwgPSBPKF8ociwgXCJkZXNjcmlwdGlvblwiKSksIHUgPSBfKHIsIFwiVGltZVNwYW5cIiksIGMgPSBfKHIsIFwiVGltZVN0YW1wXCIpLCBwID0gXyhyLCBcIkV4dGVuZGVkRGF0YVwiKSwgZCA9IF8ociwgXCJ2aXNpYmlsaXR5XCIpO1xuICBsZXQgZiwgaCA9IE8oXyhyLCBcInN0eWxlVXJsXCIpKSwgbSA9IF8ociwgXCJMaW5lU3R5bGVcIiksIHkgPSBfKHIsIFwiUG9seVN0eWxlXCIpO1xuICBpZiAoIWEuZ2VvbXMubGVuZ3RoKSByZXR1cm4gW107XG4gIGlmIChpICYmIChvLm5hbWUgPSBpKSwgcyAmJiAoby5hZGRyZXNzID0gcyksIGgpIHtcbiAgICBoLnN0YXJ0c1dpdGgoXCIjXCIpIHx8IChoID0gYCMke2h9YCksIG8uc3R5bGVVcmwgPSBoLCBlW2hdICYmIChvLnN0eWxlSGFzaCA9IGVbaF0pLCBuW2hdICYmIChvLnN0eWxlTWFwSGFzaCA9IG5baF0sIG8uc3R5bGVIYXNoID0gZVtuW2hdLm5vcm1hbCA/PyBcIlwiXSk7XG4gICAgY29uc3QgZyA9IHRbby5zdHlsZUhhc2ggPz8gXCJcIl07XG4gICAgaWYgKGcpIHtcbiAgICAgIG0gfHwgKG0gPSBfKGcsIFwiTGluZVN0eWxlXCIpKSwgeSB8fCAoeSA9IF8oZywgXCJQb2x5U3R5bGVcIikpO1xuICAgICAgY29uc3QgeCA9IF8oZywgXCJJY29uU3R5bGVcIik7XG4gICAgICBpZiAoeCkge1xuICAgICAgICBjb25zdCBFID0gXyh4LCBcIkljb25cIik7XG4gICAgICAgIGlmIChFKSB7XG4gICAgICAgICAgY29uc3QgQyA9IE8oXyhFLCBcImhyZWZcIikpO1xuICAgICAgICAgIEMgJiYgKG8uaWNvbiA9IEMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsICYmIChvLmRlc2NyaXB0aW9uID0gbCksIHUpIHtcbiAgICBjb25zdCBnID0gTyhfKHUsIFwiYmVnaW5cIikpLCB4ID0gTyhfKHUsIFwiZW5kXCIpKTtcbiAgICBnICYmIHggJiYgKG8udGltZXNwYW4gPSB7IGJlZ2luOiBnLCBlbmQ6IHggfSk7XG4gIH1cbiAgaWYgKGMgIT09IG51bGwgJiYgKG8udGltZXN0YW1wID0gTyhfKGMsIFwid2hlblwiKSkgPz8gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpKSwgbSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGcgPSBDYShPKF8obSwgXCJjb2xvclwiKSkpLCB4ID0gZ1swXSwgRSA9IGdbMV0sIEMgPSBOdW1iZXIucGFyc2VGbG9hdChPKF8obSwgXCJ3aWR0aFwiKSkgPz8gXCJcIik7XG4gICAgeCAmJiAoby5zdHJva2UgPSB4KSwgTnVtYmVyLmlzTmFOKEUpIHx8IChvW1wic3Ryb2tlLW9wYWNpdHlcIl0gPSBFKSwgTnVtYmVyLmlzTmFOKEMpIHx8IChvW1wic3Ryb2tlLXdpZHRoXCJdID0gQyk7XG4gIH1cbiAgaWYgKHkpIHtcbiAgICBjb25zdCBnID0gQ2EoTyhfKHksIFwiY29sb3JcIikpKSwgeCA9IGdbMF0sIEUgPSBnWzFdLCBDID0gTyhfKHksIFwiZmlsbFwiKSksIFQgPSBPKF8oeSwgXCJvdXRsaW5lXCIpKTtcbiAgICB4ICYmIChvLmZpbGwgPSB4KSwgTnVtYmVyLmlzTmFOKEUpIHx8IChvW1wiZmlsbC1vcGFjaXR5XCJdID0gRSksIEMgJiYgKG9bXCJmaWxsLW9wYWNpdHlcIl0gPSBDID09PSBcIjFcIiA/IG9bXCJmaWxsLW9wYWNpdHlcIl0gfHwgMSA6IDApLCBUICYmIChvW1wic3Ryb2tlLW9wYWNpdHlcIl0gPSBUID09PSBcIjFcIiA/IG9bXCJzdHJva2Utb3BhY2l0eVwiXSB8fCAxIDogMCk7XG4gIH1cbiAgaWYgKHApIHtcbiAgICBjb25zdCBnID0gRyhwLCBcIkRhdGFcIiksIHggPSBHKHAsIFwiU2ltcGxlRGF0YVwiKTtcbiAgICBmb3IgKGYgPSAwOyBmIDwgZy5sZW5ndGg7IGYrKylcbiAgICAgIG9bZ1tmXS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID8/IFwiXCJdID0gTyhfKGdbZl0sIFwidmFsdWVcIikpID8/IFwiXCI7XG4gICAgZm9yIChmID0gMDsgZiA8IHgubGVuZ3RoOyBmKyspXG4gICAgICBvW3hbZl0uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA/PyBcIlwiXSA9IE8oeFtmXSkgPz8gXCJcIjtcbiAgfVxuICBkICE9PSBudWxsICYmIChvLnZpc2liaWxpdHkgPSBPKGQpID8/IFwiXCIpLCBhLmNvb3JkVGltZXMubGVuZ3RoICE9PSAwICYmIChvLmNvb3JkVGltZXMgPSBhLmNvb3JkVGltZXMubGVuZ3RoID09PSAxID8gYS5jb29yZFRpbWVzWzBdIDogYS5jb29yZFRpbWVzKTtcbiAgY29uc3QgdyA9IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBnZW9tZXRyeTogYS5nZW9tcy5sZW5ndGggPT09IDEgPyBhLmdlb21zWzBdIDoge1xuICAgICAgdHlwZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIixcbiAgICAgIGdlb21ldHJpZXM6IGEuZ2VvbXNcbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IG9cbiAgfTtcbiAgcmV0dXJuIFplKHIsIFwiaWRcIikgJiYgKHcuaWQgPSBaZShyLCBcImlkXCIpID8/IHZvaWQgMCksIFt3XTtcbn1cbmZ1bmN0aW9uIGpvKHIsIGUpIHtcbiAgY29uc3QgdCA9IEcociwgZSksIG4gPSBbXSwgYSA9IFtdO1xuICBsZXQgbyA9IFtdO1xuICBjb25zdCBpID0gdC5sZW5ndGg7XG4gIGlmICghKGkgPCAyKSkge1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgaTsgcysrKSB7XG4gICAgICBjb25zdCBsID0gcW8odFtzXSk7XG4gICAgICBuLnB1c2gobC5jb29yZGluYXRlcyksIGwudGltZSAmJiBhLnB1c2gobC50aW1lKSwgKGwuaGVhcnRSYXRlIHx8IG8ubGVuZ3RoKSAmJiAoby5sZW5ndGggPT09IDAgJiYgKG8gPSBuZXcgQXJyYXkocykuZmlsbChudWxsKSksIG8ucHVzaChsLmhlYXJ0UmF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbixcbiAgICAgIHRpbWVzOiBhLFxuICAgICAgaGVhcnRSYXRlczogb1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHVjKHIpIHtcbiAgY29uc3QgZSA9IEcociwgXCJ0cmtzZWdcIiksIHQgPSBbXSwgbiA9IFtdLCBhID0gW107XG4gIGxldCBvO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IGUubGVuZ3RoOyBzKyspXG4gICAgaWYgKG8gPSBqbyhlW3NdLCBcInRya3B0XCIpLCBvICE9PSB2b2lkIDAgJiYgKG8ubGluZSAmJiB0LnB1c2goby5saW5lKSwgby50aW1lcyAmJiBvLnRpbWVzLmxlbmd0aCAmJiBuLnB1c2goby50aW1lcyksIGEubGVuZ3RoIHx8IG8uaGVhcnRSYXRlcyAmJiBvLmhlYXJ0UmF0ZXMubGVuZ3RoKSkge1xuICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBzOyBsKyspXG4gICAgICAgICAgYS5wdXNoKG5ldyBBcnJheSh0W2xdLmxlbmd0aCkuZmlsbChudWxsKSk7XG4gICAgICBvLmhlYXJ0UmF0ZXMgJiYgby5oZWFydFJhdGVzLmxlbmd0aCA/IGEucHVzaChvLmhlYXJ0UmF0ZXMpIDogYS5wdXNoKG5ldyBBcnJheShvLmxpbmUubGVuZ3RoKS5maWxsKG51bGwpKTtcbiAgICB9XG4gIGlmICh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBjb25zdCBpID0ge1xuICAgIC4uLkVuKHIpLFxuICAgIC4uLlVvKF8ociwgXCJleHRlbnNpb25zXCIpKVxuICB9O1xuICByZXR1cm4gbi5sZW5ndGggIT09IDAgJiYgKGkuY29vcmRUaW1lcyA9IHQubGVuZ3RoID09PSAxID8gblswXSA6IG4pLCBhLmxlbmd0aCAhPT0gMCAmJiAoaS5oZWFydFJhdGVzID0gdC5sZW5ndGggPT09IDEgPyBhWzBdIDogYSksIHQubGVuZ3RoID09PSAxID8ge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgIHByb3BlcnRpZXM6IGksXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgY29vcmRpbmF0ZXM6IHRbMF1cbiAgICB9XG4gIH0gOiB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgcHJvcGVydGllczogaSxcbiAgICBnZW9tZXRyeToge1xuICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgIGNvb3JkaW5hdGVzOiB0XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2Mocikge1xuICBjb25zdCBlID0gam8ociwgXCJydGVwdFwiKTtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5FbihyKSxcbiAgICAgIC4uLlVvKF8ociwgXCJleHRlbnNpb25zXCIpKVxuICAgIH0sXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgY29vcmRpbmF0ZXM6IGUubGluZVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBjKHIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBwcm9wZXJ0aWVzOiB7IC4uLkVuKHIpLCAuLi5YcihyLCBbXCJzeW1cIl0pIH0sXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgIGNvb3JkaW5hdGVzOiBxbyhyKS5jb29yZGluYXRlc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFVvKHIpIHtcbiAgY29uc3QgZSA9IHt9O1xuICBpZiAocikge1xuICAgIGNvbnN0IHQgPSBfKHIsIFwibGluZVwiKTtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgbiA9IE8oXyh0LCBcImNvbG9yXCIpKSwgYSA9IE51bWJlci5wYXJzZUZsb2F0KE8oXyh0LCBcIm9wYWNpdHlcIikpID8/IFwiMFwiKSwgbyA9IE51bWJlci5wYXJzZUZsb2F0KE8oXyh0LCBcIndpZHRoXCIpKSA/PyBcIjBcIik7XG4gICAgICBuICYmIChlLnN0cm9rZSA9IG4pLCBOdW1iZXIuaXNOYU4oYSkgfHwgKGVbXCJzdHJva2Utb3BhY2l0eVwiXSA9IGEpLCBOdW1iZXIuaXNOYU4obykgfHwgKGVbXCJzdHJva2Utd2lkdGhcIl0gPSBvICogOTYgLyAyNS40KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBFbihyKSB7XG4gIGNvbnN0IGUgPSBYcihyLCBbXCJuYW1lXCIsIFwiY210XCIsIFwiZGVzY1wiLCBcInR5cGVcIiwgXCJ0aW1lXCIsIFwia2V5d29yZHNcIl0pLCB0ID0gRyhyLCBcImxpbmtcIik7XG4gIGlmICh0Lmxlbmd0aCAhPT0gMCkge1xuICAgIGUubGlua3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgQXJyYXkuZnJvbSh0KSkge1xuICAgICAgY29uc3QgYSA9IHtcbiAgICAgICAgaHJlZjogWmUobiwgXCJocmVmXCIpLFxuICAgICAgICAuLi5YcihuLCBbXCJ0ZXh0XCIsIFwidHlwZVwiXSlcbiAgICAgIH07XG4gICAgICBlLmxpbmtzLnB1c2goYSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gRWEocikge1xuICBsZXQgZSA9IDA7XG4gIGlmICghciB8fCAhci5sZW5ndGgpIHJldHVybiBlO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspXG4gICAgZSA9IChlIDw8IDUpIC0gZSArIHIuY2hhckNvZGVBdCh0KSB8IDA7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gRyhyLCBlKSB7XG4gIHJldHVybiByLmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpO1xufVxuZnVuY3Rpb24gWmUociwgZSkge1xuICByZXR1cm4gci5nZXRBdHRyaWJ1dGUoZSk7XG59XG5mdW5jdGlvbiBBYShyLCBlKSB7XG4gIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChaZShyLCBlKSA/PyBcIjBcIik7XG59XG5mdW5jdGlvbiBfKHIsIGUpIHtcbiAgY29uc3QgdCA9IEcociwgZSk7XG4gIHJldHVybiB0Lmxlbmd0aCA/IHRbMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gZmMocikge1xuICByZXR1cm4gci5ub3JtYWxpemUgJiYgci5ub3JtYWxpemUoKSwgcjtcbn1cbmZ1bmN0aW9uIERvKHIpIHtcbiAgcmV0dXJuIHIubWFwKE51bWJlci5wYXJzZUZsb2F0KS5tYXAoKGUpID0+IE51bWJlci5pc05hTihlKSA/IG51bGwgOiBlKTtcbn1cbmZ1bmN0aW9uIE8ocikge1xuICByZXR1cm4gciAmJiBmYyhyKSwgciAmJiByLnRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gWHIociwgZSkge1xuICBjb25zdCB0ID0ge307XG4gIGxldCBuLCBhO1xuICBmb3IgKGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKylcbiAgICBuID0gXyhyLCBlW2FdKSwgbiAmJiAodFtlW2FdXSA9IE8obikgPz8gXCJcIik7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gQm8ocikge1xuICByZXR1cm4gRG8oci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpLnNwbGl0KFwiLFwiKSk7XG59XG5mdW5jdGlvbiBUYShyKSB7XG4gIGNvbnN0IGUgPSByLnJlcGxhY2UoL15cXHMqfFxccyokL2csIFwiXCIpLnNwbGl0KC9cXHMrLyksIHQgPSBbXTtcbiAgZm9yIChjb25zdCBuIG9mIGUpIHQucHVzaChCbyhuKSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gcW8ocikge1xuICBjb25zdCBlID0gW0FhKHIsIFwibG9uXCIpLCBBYShyLCBcImxhdFwiKV0sIHQgPSBfKHIsIFwiZWxlXCIpLCBuID0gXyhyLCBcImdweHRweDpoclwiKSB8fCBfKHIsIFwiaHJcIiksIGEgPSBfKHIsIFwidGltZVwiKTtcbiAgbGV0IG87XG4gIHJldHVybiB0ICYmIChvID0gTnVtYmVyLnBhcnNlRmxvYXQoTyh0KSA/PyBcIjBcIiksIE51bWJlci5pc05hTihvKSB8fCBlLnB1c2gobykpLCB7XG4gICAgY29vcmRpbmF0ZXM6IGUsXG4gICAgdGltZTogYSA/IE8oYSkgOiBudWxsLFxuICAgIGhlYXJ0UmF0ZTogbiAhPT0gbnVsbCA/IE51bWJlci5wYXJzZUZsb2F0KE8obikgPz8gXCIwXCIpIDogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gZGMocikge1xuICBsZXQgZSA9IHI7XG4gIHRyeSB7XG4gICAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IENuKGUpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gT28oZSk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIE5vKGUpO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhjKHIsIGUgPSB7fSkge1xuICBjb25zdCB0ID0gZS5kb3dubG9hZCA/PyAhMSwgbiA9IGF3YWl0IG1jKHIpO1xuICBpZiAodCkge1xuICAgIGNvbnN0IGEgPSBlLmZpbGVuYW1lID8/IFwibWFwdGlsZXJfc2NyZWVuc2hvdC5wbmdcIiwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIG8uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG8pLCBvLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG4pLCBvLmRvd25sb2FkID0gYSwgby5jbGljaygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobyksIFVSTC5yZXZva2VPYmplY3RVUkwoby5ocmVmKTtcbiAgICB9LCAwKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIG1jKHIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChlLCB0KSA9PiB7XG4gICAgci5yZWRyYXcoKSwgci5vbmNlKFwiaWRsZVwiLCAoKSA9PiB7XG4gICAgICByLmdldENhbnZhcygpLnRvQmxvYigobikgPT4ge1xuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICB0KEVycm9yKFwiU2NyZWVuc2hvdCBjb3VsZCBub3QgYmUgY3JlYXRlZC5cIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlKG4pO1xuICAgICAgfSwgXCJpbWFnZS9wbmdcIik7XG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgS3IgPSBbXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMWQ1Yjc5NDY4Yjk3ZWY2MjYyZjNhYTYwXG4gIFtcIiMxRDVCNzlcIiwgXCIjNDY4Qjk3XCIsIFwiI0VGNjI2MlwiLCBcIiNGM0FBNjBcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvNjE0YmMzMzNiYmM1ODVlNmM1YzhmZmUwXG4gIFtcIiM2MTRCQzNcIiwgXCIjMzNCQkM1XCIsIFwiIzg1RTZDNVwiLCBcIiNDOEZGRTBcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvNDYxOTU5N2EzMTZmY2Q2Njg4YWVkOGNjXG4gIFtcIiM0NjE5NTlcIiwgXCIjN0EzMTZGXCIsIFwiI0NENjY4OFwiLCBcIiNBRUQ4Q0NcIl0sXG4gIC8vIGh0dHBzOi8vY29sb3JodW50LmNvL3BhbGV0dGUvMDA3OWZmMDBkZmEyZjZmYTcwZmYwMDYwXG4gIFtcIiMwMDc5RkZcIiwgXCIjMDBERkEyXCIsIFwiI0Y2RkE3MFwiLCBcIiNGRjAwNjBcIl0sXG4gIC8vaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8zOWI1ZTBhMzFhY2JmZjc4ZjBmNWVhNWFcbiAgW1wiIzM5QjVFMFwiLCBcIiNBMzFBQ0JcIiwgXCIjRkY3OEYwXCIsIFwiI0Y1RUE1QVwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8zN2UyZDU1OTA2OTZjNzBhODBmYmNiMGFcbiAgW1wiIzM3RTJENVwiLCBcIiM1OTA2OTZcIiwgXCIjQzcwQTgwXCIsIFwiI0ZCQ0IwQVwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS9mZmQzNmVmZmY1NmQ5OWZmY2Q5ZmI0ZmZcbiAgW1wiI0ZGRDM2RVwiLCBcIiNGRkY1NkRcIiwgXCIjOTlGRkNEXCIsIFwiIzlGQjRGRlwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8wMGVhZDNmZmY1YjdmZjQ0OWYwMDVmOTlcbiAgW1wiIzAwRUFEM1wiLCBcIiNGRkY1QjdcIiwgXCIjRkY0NDlGXCIsIFwiIzAwNUY5OVwiXSxcbiAgLy8gaHR0cHM6Ly9jb2xvcmh1bnQuY28vcGFsZXR0ZS8xMGExOWQ1NDAzNzVmZjcwMDBmZmJmMDBcbiAgW1wiIzEwQTE5RFwiLCBcIiM1NDAzNzVcIiwgXCIjRkY3MDAwXCIsIFwiI0ZGQkYwMFwiXVxuXTtcbmZ1bmN0aW9uIGRyKCkge1xuICByZXR1cm4gS3Jbfn4oTWF0aC5yYW5kb20oKSAqIEtyLmxlbmd0aCldW35+KE1hdGgucmFuZG9tKCkgKiA0KV07XG59XG5mdW5jdGlvbiBJdCgpIHtcbiAgcmV0dXJuIGBtYXB0aWxlcl9zb3VyY2VfJHtJYSgpfWA7XG59XG5mdW5jdGlvbiBNdCgpIHtcbiAgcmV0dXJuIGBtYXB0aWxlcl9sYXllcl8ke0lhKCl9YDtcbn1cbmZ1bmN0aW9uIFlyKHIsIGUpIHtcbiAgaWYgKGUgPD0gclswXS56b29tKVxuICAgIHJldHVybiByWzBdLnZhbHVlO1xuICBpZiAoZSA+PSByW3IubGVuZ3RoIC0gMV0uem9vbSlcbiAgICByZXR1cm4gcltyLmxlbmd0aCAtIDFdLnZhbHVlO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IHIubGVuZ3RoIC0gMTsgdCArPSAxKVxuICAgIGlmIChlID49IHJbdF0uem9vbSAmJiBlIDwgclt0ICsgMV0uem9vbSkge1xuICAgICAgY29uc3QgbiA9IHJbdCArIDFdLnpvb20gLSByW3RdLnpvb20sIGEgPSAoZSAtIHJbdF0uem9vbSkgLyBuO1xuICAgICAgcmV0dXJuIGEgKiByW3QgKyAxXS52YWx1ZSArICgxIC0gYSkgKiByW3RdLnZhbHVlO1xuICAgIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBGZShyKSB7XG4gIHJldHVybiBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcInpvb21cIl0sIC4uLnIuZmxhdE1hcCgoZSkgPT4gW2Uuem9vbSwgZS52YWx1ZV0pXTtcbn1cbmZ1bmN0aW9uIEYocikge1xuICByZXR1cm4gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAuLi5yLmZsYXRNYXAoKGUpID0+IFtlLnpvb20sIGUudmFsdWVdKV07XG59XG5mdW5jdGlvbiBWbyhyLCBlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiICYmIHR5cGVvZiByID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIDIgKiBlICsgcjtcbiAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIgJiYgQXJyYXkuaXNBcnJheShyKSlcbiAgICByZXR1cm4gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAuLi5yLmZsYXRNYXAoKHQpID0+IFt0Lnpvb20sIDIgKiBlICsgdC52YWx1ZV0pXTtcbiAgaWYgKHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJ6b29tXCJdLCAuLi5lLmZsYXRNYXAoKHQpID0+IFt0Lnpvb20sIDIgKiB0LnZhbHVlICsgcl0pXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikgJiYgQXJyYXkuaXNBcnJheShlKSkge1xuICAgIGNvbnN0IHQgPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5yLm1hcCgobikgPT4gbi56b29tKSwgLi4uZS5tYXAoKG4pID0+IG4uem9vbSldKSkuc29ydCgobiwgYSkgPT4gbiA8IGEgPyAtMSA6IDEpO1xuICAgIHJldHVybiBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcInpvb21cIl0sIC4uLnQuZmxhdE1hcCgobikgPT4gW24sIDIgKiBZcihlLCBuKSArIFlyKHIsIG4pXSldO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gR28ociwgZSkge1xuICByZXR1cm4gW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgodCkgPT4gW3QucHJvcGVydHlWYWx1ZSwgdC52YWx1ZV0pXTtcbn1cbmZ1bmN0aW9uIEFuKHIpIHtcbiAgY29uc3QgZSA9IHIudHJpbVN0YXJ0KCksIHQgPSBgJHtlfSR7XCIgXCIucmVwZWF0KHIubGVuZ3RoIC0gZS5sZW5ndGgpfWAsIG4gPSBBcnJheS5mcm9tKHQpO1xuICBpZiAoIW4uZXZlcnkoKHMpID0+IHMgPT09IFwiIFwiIHx8IHMgPT09IFwiX1wiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGRhc2ggcGF0dGVybiBtdXN0IGJlIGNvbXBvc2VkIG9ubHkgb2Ygd2hpdGVzcGFjZSBhbmQgdW5kZXJzY29yZSBjaGFyYWN0ZXJzLlwiKTtcbiAgaWYgKCEobi5zb21lKChzKSA9PiBzID09PSBcIl9cIikgJiYgbi5zb21lKChzKSA9PiBzID09PSBcIiBcIikpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgZGFzaCBwYXR0ZXJuIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdW5kZXJzY29yZSBhbmQgb25lIHdoaXRlc3BhY2UgY2hhcmFjdGVyXCIpO1xuICBjb25zdCBpID0gWzFdO1xuICBmb3IgKGxldCBzID0gMTsgcyA8IG4ubGVuZ3RoOyBzICs9IDEpIHtcbiAgICBjb25zdCBsID0gbltzIC0gMV0sIHUgPSBuW3NdO1xuICAgIGwgPT09IHUgPyBpW2kubGVuZ3RoIC0gMV0gKz0gMSA6IGkucHVzaCgxKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFdyKHIsIGUpIHtcbiAgcmV0dXJuIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKHQpID0+IFt0LnZhbHVlLCB0LmNvbG9yXSldO1xufVxuZnVuY3Rpb24gSnIociwgZSwgdCA9ICEwKSB7XG4gIHJldHVybiB0ID8gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiem9vbVwiXSxcbiAgICAwLFxuICAgIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnZhbHVlLCBuLnBvaW50UmFkaXVzICogMC4wMjVdKV0sXG4gICAgMixcbiAgICBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKChuKSA9PiBbbi52YWx1ZSwgbi5wb2ludFJhZGl1cyAqIDAuMDVdKV0sXG4gICAgNCxcbiAgICBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKChuKSA9PiBbbi52YWx1ZSwgbi5wb2ludFJhZGl1cyAqIDAuMV0pXSxcbiAgICA4LFxuICAgIFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiZ2V0XCIsIGVdLCAuLi5yLmZsYXRNYXAoKG4pID0+IFtuLnZhbHVlLCBuLnBvaW50UmFkaXVzICogMC4yNV0pXSxcbiAgICAxNixcbiAgICBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKChuKSA9PiBbbi52YWx1ZSwgbi5wb2ludFJhZGl1c10pXVxuICBdIDogW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24udmFsdWUsIG4ucG9pbnRSYWRpdXNdKV07XG59XG5mdW5jdGlvbiBIbyhyLCBlLCB0ID0gITApIHtcbiAgcmV0dXJuIHQgPyBbXG4gICAgXCJpbnRlcnBvbGF0ZVwiLFxuICAgIFtcImxpbmVhclwiXSxcbiAgICBbXCJ6b29tXCJdLFxuICAgIDAsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24ucHJvcGVydHlWYWx1ZSwgbi52YWx1ZSAqIDAuMDI1XSldLFxuICAgIDIsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24ucHJvcGVydHlWYWx1ZSwgbi52YWx1ZSAqIDAuMDVdKV0sXG4gICAgNCxcbiAgICBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcImdldFwiLCBlXSwgLi4uci5mbGF0TWFwKChuKSA9PiBbbi5wcm9wZXJ0eVZhbHVlLCBuLnZhbHVlICogMC4xXSldLFxuICAgIDgsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24ucHJvcGVydHlWYWx1ZSwgbi52YWx1ZSAqIDAuMjVdKV0sXG4gICAgMTYsXG4gICAgW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24ucHJvcGVydHlWYWx1ZSwgbi52YWx1ZV0pXVxuICBdIDogW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJnZXRcIiwgZV0sIC4uLnIuZmxhdE1hcCgobikgPT4gW24ucHJvcGVydHlWYWx1ZSwgbi52YWx1ZV0pXTtcbn1cbmZ1bmN0aW9uIFFyKHIsIGUpIHtcbiAgcmV0dXJuIHIuZXZlcnkoKHQpID0+IHQuY29sb3JbM10gPT09IHJbMF0uY29sb3JbM10pID8gclswXS5jb2xvclszXSA/IHJbMF0uY29sb3JbM10gLyAyNTUgOiAxIDogW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiZ2V0XCIsIGVdLFxuICAgIC4uLnIuZ2V0UmF3Q29sb3JTdG9wcygpLmZsYXRNYXAoKHQpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0LnZhbHVlLCBhID0gdC5jb2xvcjtcbiAgICAgIHJldHVybiBbbiwgYS5sZW5ndGggPT09IDQgPyBhWzNdIC8gMjU1IDogMV07XG4gICAgfSlcbiAgXTtcbn1cbmZ1bmN0aW9uIFpvKHIsIGUgPSAxMCkge1xuICByZXR1cm4gW1xuICAgIFwiaW50ZXJwb2xhdGVcIixcbiAgICBbXCJsaW5lYXJcIl0sXG4gICAgW1wiaGVhdG1hcC1kZW5zaXR5XCJdLFxuICAgIC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IGUgKyAxIH0sICh0LCBuKSA9PiB7XG4gICAgICBjb25zdCBhID0gbiAvIGU7XG4gICAgICByZXR1cm4gW2EsIHIuZ2V0Q29sb3JIZXgoYSldO1xuICAgIH0pLmZsYXQoKVxuICBdO1xufVxuZnVuY3Rpb24gJHQocikge1xuICBjb25zdCBlID0gci50b1N0cmluZygxNik7XG4gIHJldHVybiBlLmxlbmd0aCA9PT0gMSA/IGAwJHtlfWAgOiBlO1xufVxuZnVuY3Rpb24geWMocikge1xuICByZXR1cm4gYCMkeyR0KHJbMF0pfSR7JHQoclsxXSl9JHskdChyWzJdKX0ke3IubGVuZ3RoID09PSA0ID8gJHQoclszXSkgOiBcIlwifWA7XG59XG5jbGFzcyBBIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih0ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHYodGhpcywgXCJtaW5cIiwgMCk7XG4gICAgdih0aGlzLCBcIm1heFwiLCAxKTtcbiAgICBcIm1pblwiIGluIHQgJiYgKHRoaXMubWluID0gdC5taW4pLCBcIm1heFwiIGluIHQgJiYgKHRoaXMubWF4ID0gdC5tYXgpLCBcInN0b3BzXCIgaW4gdCAmJiB0aGlzLnNldFN0b3BzKHQuc3RvcHMsIHsgY2xvbmU6ICExIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGFycmF5LWRlZmluaXRpb24gY29sb3IgcmFtcCBkZWZpbml0aW9uIGludG8gYSB1c2FibGUgQ29sb3JSYW1wIGluc3RhbmNlLlxuICAgKiBOb3RlOiB1bml0cyBhcmUgbm90IGNvbnZlcnRlZCBhbmQgbWF5IG5lZWQgdG8gdG8gYmUgY29udmVydGVkIGJlZm9yZWhhbmQgKGVnLiBrZWx2aW4gdG8gY2VudGlncmFkZSlcbiAgICogQHBhcmFtIGNyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZnJvbUFycmF5RGVmaW5pdGlvbih0KSB7XG4gICAgcmV0dXJuIG5ldyBBKHtcbiAgICAgIHN0b3BzOiB0Lm1hcCgobikgPT4gKHtcbiAgICAgICAgdmFsdWU6IG5bMF0sXG4gICAgICAgIGNvbG9yOiBuWzFdXG4gICAgICB9KSlcbiAgICB9KTtcbiAgfVxuICBzZXRTdG9wcyh0LCBuID0geyBjbG9uZTogITAgfSkge1xuICAgIGNvbnN0IGEgPSBuLmNsb25lID8gdGhpcy5jbG9uZSgpIDogdGhpcztcbiAgICBhLmxlbmd0aCA9IDA7XG4gICAgbGV0IG8gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcyArPSAxKVxuICAgICAgbyA9IE1hdGgubWluKG8sIHRbc10udmFsdWUpLCBpID0gTWF0aC5tYXgoaSwgdFtzXS52YWx1ZSksIGEucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0W3NdLnZhbHVlLFxuICAgICAgICBjb2xvcjogdFtzXS5jb2xvci5zbGljZSgpXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGRvIGEgZGVlcCBjb3B5IGFuZCBub3QgYSByZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgIHJldHVybiBhLnNvcnQoKHMsIGwpID0+IHMudmFsdWUgPCBsLnZhbHVlID8gLTEgOiAxKSwgdGhpcy5taW4gPSBvLCB0aGlzLm1heCA9IGksIGE7XG4gIH1cbiAgc2NhbGUodCwgbiwgYSA9IHsgY2xvbmU6ICEwIH0pIHtcbiAgICBjb25zdCBvID0gYS5jbG9uZSwgaSA9IHRoaXNbMF0udmFsdWUsIGwgPSB0aGlzLmF0KC0xKS52YWx1ZSAtIGksIHUgPSBuIC0gdCwgYyA9IFtdO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgdGhpcy5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgY29uc3QgaCA9ICh0aGlzW3BdLnZhbHVlIC0gaSkgLyBsICogdSArIHQ7XG4gICAgICBvID8gYy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGgsXG4gICAgICAgIGNvbG9yOiB0aGlzW3BdLmNvbG9yLnNsaWNlKClcbiAgICAgIH0pIDogdGhpc1twXS52YWx1ZSA9IGg7XG4gICAgfVxuICAgIHJldHVybiBvID8gbmV3IEEoeyBzdG9wczogYyB9KSA6IHRoaXM7XG4gIH1cbiAgLy8gZm9yIHNvbWUgcmVhc29uLCBJIGhhZCB0byByZWltcGxlbWVudCB0aGlzXG4gIGF0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAgPyB0aGlzW3RoaXMubGVuZ3RoICsgdF0gOiB0aGlzW3RdO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQSh7IHN0b3BzOiB0aGlzLmdldFJhd0NvbG9yU3RvcHMoKSB9KTtcbiAgfVxuICBnZXRSYXdDb2xvclN0b3BzKCkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHRoaXMubGVuZ3RoOyBuICs9IDEpXG4gICAgICB0LnB1c2goeyB2YWx1ZTogdGhpc1tuXS52YWx1ZSwgY29sb3I6IHRoaXNbbl0uY29sb3IgfSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV2ZXJzZSh0ID0geyBjbG9uZTogITAgfSkge1xuICAgIGNvbnN0IG4gPSB0LmNsb25lID8gdGhpcy5jbG9uZSgpIDogdGhpcztcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IH5+KG4ubGVuZ3RoIC8gMik7IGEgKz0gMSkge1xuICAgICAgY29uc3QgbyA9IG5bYV0uY29sb3I7XG4gICAgICBuW2FdLmNvbG9yID0gbi5hdCgtKGEgKyAxKSkuY29sb3IsIG4uYXQoLShhICsgMSkpLmNvbG9yID0gbztcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiB7IG1pbjogdGhpcy5taW4sIG1heDogdGhpcy5tYXggfTtcbiAgfVxuICBnZXRDb2xvcih0LCBuID0geyBzbW9vdGg6ICEwIH0pIHtcbiAgICBpZiAodCA8PSB0aGlzWzBdLnZhbHVlKVxuICAgICAgcmV0dXJuIHRoaXNbMF0uY29sb3I7XG4gICAgaWYgKHQgPj0gdGhpcy5hdCgtMSkudmFsdWUpXG4gICAgICByZXR1cm4gdGhpcy5hdCgtMSkuY29sb3I7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmxlbmd0aCAtIDE7IGEgKz0gMSkge1xuICAgICAgaWYgKHQgPiB0aGlzW2EgKyAxXS52YWx1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBvID0gdGhpc1thXS5jb2xvcjtcbiAgICAgIGlmICghbi5zbW9vdGgpXG4gICAgICAgIHJldHVybiBvLnNsaWNlKCk7XG4gICAgICBjb25zdCBpID0gdGhpc1thXS52YWx1ZSwgcyA9IHRoaXNbYSArIDFdLnZhbHVlLCBsID0gdGhpc1thICsgMV0uY29sb3IsIHUgPSAocyAtIHQpIC8gKHMgLSBpKTtcbiAgICAgIHJldHVybiBvLm1hcCgoYywgcCkgPT4gTWF0aC5yb3VuZChjICogdSArIGxbcF0gKiAoMSAtIHUpKSk7XG4gICAgfVxuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3IgYXMgYW4gaGV4YWRlY2ltYWwgc3RyaW5nXG4gICAqL1xuICBnZXRDb2xvckhleCh0LCBuID0ge1xuICAgIHNtb290aDogITAsXG4gICAgd2l0aEFscGhhOiAhMVxuICB9KSB7XG4gICAgcmV0dXJuIHljKHRoaXMuZ2V0Q29sb3IodCwgbikpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIG9mIHRoZSBjb2xvciByYW1wIGF0IGEgcmVsYXRpdmUgcG9zaXRpb24gaW4gWzAsIDFdXG4gICAqL1xuICBnZXRDb2xvclJlbGF0aXZlKHQsIG4gPSB7IHNtb290aDogITAgfSkge1xuICAgIGNvbnN0IGEgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmdldENvbG9yKGEubWluICsgdCAqIChhLm1heCAtIGEubWluKSwgbik7XG4gIH1cbiAgZ2V0Q2FudmFzU3RyaXAodCA9IHtcbiAgICBob3Jpem9udGFsOiAhMCxcbiAgICBzaXplOiA1MTIsXG4gICAgc21vb3RoOiAhMFxuICB9KSB7XG4gICAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgbi53aWR0aCA9IHQuaG9yaXpvbnRhbCA/IHQuc2l6ZSA6IDEsIG4uaGVpZ2h0ID0gdC5ob3Jpem9udGFsID8gMSA6IHQuc2l6ZTtcbiAgICBjb25zdCBhID0gbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFhKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW52cyBjb250ZXh0IGlzIG1pc3NpbmdcIik7XG4gICAgY29uc3QgbyA9IGEuZ2V0SW1hZ2VEYXRhKDAsIDAsIG4ud2lkdGgsIG4uaGVpZ2h0KSwgaSA9IG8uZGF0YSwgcyA9IHQuc2l6ZSwgbCA9IHRoaXNbMF0udmFsdWUsIHAgPSAodGhpcy5hdCgtMSkudmFsdWUgLSBsKSAvIHM7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCBzOyBkICs9IDEpIHtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLmdldENvbG9yKGwgKyBkICogcCwge1xuICAgICAgICBzbW9vdGg6IHQuc21vb3RoXG4gICAgICB9KTtcbiAgICAgIGlbZCAqIDRdID0gZlswXSwgaVtkICogNCArIDFdID0gZlsxXSwgaVtkICogNCArIDJdID0gZlsyXSwgaVtkICogNCArIDNdID0gZi5sZW5ndGggPiAzID8gZlszXSA6IDI1NTtcbiAgICB9XG4gICAgcmV0dXJuIGEucHV0SW1hZ2VEYXRhKG8sIDAsIDApLCBuO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSBhIG5vbi1saW5lYXIgcmVzc2FtcGxpbmcuIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3JSYW1wIHdpdGggdGhlIHNhbWUgYm91bmRzLlxuICAgKi9cbiAgcmVzYW1wbGUodCwgbiA9IDE1KSB7XG4gICAgY29uc3QgYSA9IHRoaXMuZ2V0Qm91bmRzKCksIG8gPSB0aGlzLnNjYWxlKDAsIDEpLCBpID0gMSAvIChuIC0gMSk7XG4gICAgbGV0IHM7XG4gICAgaWYgKHQgPT09IFwiZWFzZS1pbi1zcXVhcmVcIilcbiAgICAgIHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChjLCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBwICogaSwgZiA9IGQgKiogMiwgaCA9IG8uZ2V0Q29sb3IoZik7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBkLCBjb2xvcjogaCB9O1xuICAgICAgfSk7XG4gICAgZWxzZSBpZiAodCA9PT0gXCJlYXNlLW91dC1zcXVhcmVcIilcbiAgICAgIHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChjLCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBwICogaSwgZiA9IDEgLSAoMSAtIGQpICoqIDIsIGggPSBvLmdldENvbG9yKGYpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgY29sb3I6IGggfTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKHQgPT09IFwiZWFzZS1vdXQtc3FydFwiKVxuICAgICAgcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgKGMsIHApID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHAgKiBpLCBmID0gZCAqKiAwLjUsIGggPSBvLmdldENvbG9yKGYpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgY29sb3I6IGggfTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKHQgPT09IFwiZWFzZS1pbi1zcXJ0XCIpXG4gICAgICBzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoYywgcCkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcCAqIGksIGYgPSAxIC0gKDEgLSBkKSAqKiAwLjUsIGggPSBvLmdldENvbG9yKGYpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgY29sb3I6IGggfTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKHQgPT09IFwiZWFzZS1vdXQtZXhwXCIpXG4gICAgICBzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoYywgcCkgPT4ge1xuICAgICAgICBjb25zdCBkID0gcCAqIGksIGYgPSAxIC0gMiAqKiAoLTEwICogZCksIGggPSBvLmdldENvbG9yKGYpO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgY29sb3I6IGggfTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKHQgPT09IFwiZWFzZS1pbi1leHBcIilcbiAgICAgIHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBuIH0sIChjLCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBwICogaSwgZiA9IDIgKiogKDEwICogZCAtIDEwKSwgaCA9IG8uZ2V0Q29sb3IoZik7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBkLCBjb2xvcjogaCB9O1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNzYW1wbGluZyBtZXRob2QuXCIpO1xuICAgIHJldHVybiBuZXcgQSh7IHN0b3BzOiBzIH0pLnNjYWxlKGEubWluLCBhLm1heCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgY2xvbmUgb2YgdGhpcyBjb2xvciByYW1wIHRoYXQgaXMgZnVsbHkgdHJhbnNwYXJhbnQgYXQgdGhlIGJlZ2luaW5nIG9mIHRoZWlyIHJhbmdlXG4gICAqL1xuICB0cmFuc3BhcmVudFN0YXJ0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFJhd0NvbG9yU3RvcHMoKTtcbiAgICB0LnVuc2hpZnQoe1xuICAgICAgdmFsdWU6IHRbMF0udmFsdWUsXG4gICAgICBjb2xvcjogdFswXS5jb2xvci5zbGljZSgpXG4gICAgfSksIHRbMV0udmFsdWUgKz0gMWUtMztcbiAgICBmb3IgKGNvbnN0IG4gb2YgdClcbiAgICAgIG4uY29sb3IubGVuZ3RoID09PSAzICYmIG4uY29sb3IucHVzaCgyNTUpO1xuICAgIHJldHVybiB0WzBdLmNvbG9yWzNdID0gMCwgbmV3IEEoeyBzdG9wczogdCB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyBjb2xvciByYW1wIGhhcyBhIHRyYW5zcGFyZW50IHN0YXJ0XG4gICAqL1xuICBoYXNUcmFuc3BhcmVudFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzWzBdLmNvbG9yLmxlbmd0aCA9PT0gNCAmJiB0aGlzWzBdLmNvbG9yWzNdID09PSAwO1xuICB9XG59XG5jb25zdCBYbyA9IHtcbiAgLyoqXG4gICAqIEEgZnVsbHkgdHJhbnNwYXJlbnQgWzAsIDAsIDAsIDBdIGNvbG9ycmFtcCB0byBoaWRlIGRhdGEuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBOVUxMOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMCwgMCwgMCwgMF0gfVxuICAgIF1cbiAgfSksXG4gIEdSQVk6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgamV0IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBKRVQ6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAxMzFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFswLCA2MCwgMTcwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbNSwgMjU1LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYyNSwgY29sb3I6IFsyNTUsIDI1NSwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzI1MCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTI4LCAwLCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgSFNWIGNvbG9yIHJhbXAgKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUpLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgSFNWOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMjU1LCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xNjksIGNvbG9yOiBbMjUzLCAyNTUsIDJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjE3MywgY29sb3I6IFsyNDcsIDI1NSwgMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzM3LCBjb2xvcjogWzAsIDI1MiwgNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzQxLCBjb2xvcjogWzAsIDI1MiwgMTBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUwNiwgY29sb3I6IFsxLCAyNDksIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjcxLCBjb2xvcjogWzIsIDAsIDI1M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjc1LCBjb2xvcjogWzgsIDAsIDI1M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuODM5LCBjb2xvcjogWzI1NSwgMCwgMjUxXSB9LFxuICAgICAgeyB2YWx1ZTogMC44NDMsIGNvbG9yOiBbMjU1LCAwLCAyNDVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMCwgNl0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGhvdCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgSE9UOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMywgY29sb3I6IFsyMzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMjU1LCAyMTAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBzcHJpbmcgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFNQUklORzogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzI1NSwgMCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1NSwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHN1bW1lciBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgU1VNTUVSOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMTI4LCAxMDJdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAxMDJdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBhdXRvbW1uIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBBVVRPTU46IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsyNTUsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgd2ludGVyIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBXSU5URVI6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzAsIDI1NSwgMTI4XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYm9uZSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQk9ORTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NiwgY29sb3I6IFs4NCwgODQsIDExNl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUzLCBjb2xvcjogWzE2OSwgMjAwLCAyMDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBjb3BwZXIgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENPUFBFUjogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjgwNCwgY29sb3I6IFsyNTUsIDE2MCwgMTAyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDE5OSwgMTI3XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZ3JleXMgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEdSRVlTOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHlpZ25idSBjb2xvciByYW1wIChibHVlIHRvIGxpZ2h0IHllbGxvdykuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBZSUdOQlU6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs4LCAyOSwgODhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFszNywgNTIsIDE0OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMzQsIDk0LCAxNjhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFsyOSwgMTQ1LCAxOTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNjUsIDE4MiwgMTk2XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MjUsIGNvbG9yOiBbMTI3LCAyMDUsIDE4N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTk5LCAyMzMsIDE4MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzIzNywgMjQ4LCAyMTddIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjU1LCAyMTddIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBncmVlbnMgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEdSRUVOUzogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDY4LCAyN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzAsIDEwOSwgNDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzM1LCAxMzksIDY5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbNjUsIDE3MSwgOTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTE2LCAxOTYsIDExOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzE2MSwgMjE3LCAxNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE5OSwgMjMzLCAxOTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg3NSwgY29sb3I6IFsyMjksIDI0NSwgMjI0XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNDcsIDI1MiwgMjQ1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgeWlvcnJkIGNvbG9yIHJhbXAgKHJlZCB0byBsaWdodCB5ZWxsb3cpLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgWUlPUlJEOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTI4LCAwLCAzOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzE4OSwgMCwgMzhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzIyNywgMjYsIDI4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbMjUyLCA3OCwgNDJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMjUzLCAxNDEsIDYwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MjUsIGNvbG9yOiBbMjU0LCAxNzgsIDc2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNTQsIDIxNywgMTE4XSB9LFxuICAgICAgeyB2YWx1ZTogMC44NzUsIGNvbG9yOiBbMjU1LCAyMzcsIDE2MF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTUsIDIwNF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGJsdWUtcmVkIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBCTFVFUkVEOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDAsIDBdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyByZGJ1IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBSREJVOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNSwgMTAsIDE3Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzUsIGNvbG9yOiBbMTA2LCAxMzcsIDI0N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxOTAsIDE5MCwgMTkwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzIyMCwgMTcwLCAxMzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjcsIGNvbG9yOiBbMjMwLCAxNDUsIDkwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNzgsIDEwLCAyOF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHBpY25pYyBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUElDTklDOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xLCBjb2xvcjogWzUxLCAxNTMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMiwgY29sb3I6IFsxMDIsIDIwNCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zLCBjb2xvcjogWzE1MywgMjA0LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMjA0LCAyMDQsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC42LCBjb2xvcjogWzI1NSwgMjA0LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjcsIGNvbG9yOiBbMjU1LCAxNTMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOCwgY29sb3I6IFsyNTUsIDEwMiwgMjA0XSB9LFxuICAgICAgeyB2YWx1ZTogMC45LCBjb2xvcjogWzI1NSwgMTAyLCAxMDJdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMCwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHJhaW5ib3cgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFJBSU5CT1c6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxNTAsIDAsIDkwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbMCwgMCwgMjAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFswLCAyNSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbMCwgMTUyLCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbNDQsIDI1NSwgMTUwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MjUsIGNvbG9yOiBbMTUxLCAyNTUsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzI1NSwgMjM0LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC44NzUsIGNvbG9yOiBbMjU1LCAxMTEsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMCwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIFBvcnRsYW5kIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBQT1JUTEFORDogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzEyLCA1MSwgMTMxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMCwgMTM2LCAxODZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMjQyLCAyMTEsIDU2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDIsIDE0MywgNTZdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIxNywgMzAsIDMwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgYmxhY2tib2R5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBCTEFDS0JPRFk6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAwLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yLCBjb2xvcjogWzIzMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNCwgY29sb3I6IFsyMzAsIDIxMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNywgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNjAsIDIwMCwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZWFydGggY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEVBUlRIOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMTMwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xLCBjb2xvcjogWzAsIDE4MCwgMTgwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yLCBjb2xvcjogWzQwLCAyMTAsIDQwXSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzIzMCwgMjMwLCA1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNiwgY29sb3I6IFsxMjAsIDcwLCAyMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTUsIDI1NV0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGVsZWN0cmljIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBFTEVDVFJJQzogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzAsIDAsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjE1LCBjb2xvcjogWzMwLCAwLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMTIwLCAwLCAxMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMTYwLCA5MCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOCwgY29sb3I6IFsyMzAsIDIwMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjU1LCAyNTAsIDIyMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHZpcmlkaXMgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFZJUklESVM6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs2OCwgMSwgODRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzcxLCA0NCwgMTIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs1OSwgODEsIDEzOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbNDQsIDExMywgMTQyXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzMzLCAxNDQsIDE0MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMzksIDE3MywgMTI5XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFs5MiwgMjAwLCA5OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMTcwLCAyMjAsIDUwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTMsIDIzMSwgMzddIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBpbmZlcm5vIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBJTkZFUk5POiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMzEsIDEyLCA3Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbODUsIDE1LCAxMDldIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEzNiwgMzQsIDEwNl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxODYsIDU0LCA4NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjI3LCA4OSwgNTFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzI0OSwgMTQwLCAxMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjQ5LCAyMDEsIDUwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTIsIDI1NSwgMTY0XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgbWFnbWEgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIE1BR01BOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjgsIDE2LCA2OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNzksIDE4LCAxMjNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzEyOSwgMzcsIDEyOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxODEsIDU0LCAxMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIyOSwgODAsIDEwMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjUxLCAxMzUsIDk3XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyNTQsIDE5NCwgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTIsIDI1MywgMTkxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcGxhc21hIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBQTEFTTUE6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMywgOCwgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs3NSwgMywgMTYxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsxMjUsIDMsIDE2OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTY4LCAzNCwgMTUwXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzIwMywgNzAsIDEyMV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjI5LCAxMDcsIDkzXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDgsIDE0OCwgNjVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzI1MywgMTk1LCA0MF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjQwLCAyNDksIDMzXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgd2FybSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgV0FSTTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzEyNSwgMCwgMTc5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFsxNzIsIDAsIDE4N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMjE5LCAwLCAxNzBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzI1NSwgMCwgMTMwXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzI1NSwgNjMsIDc0XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyNTUsIDEyMywgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjM0LCAxNzYsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzE5MCwgMjI4LCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNDcsIDI1NSwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGNvb2wgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENPT0w6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMjUsIDAsIDE3OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMTE2LCAwLCAyMThdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzk4LCA3NCwgMjM3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFs2OCwgMTQ2LCAyMzFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMCwgMjA0LCAxOTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzAsIDI0NywgMTQ2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFswLCAyNTUsIDg4XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFs0MCwgMjU1LCA4XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxNDcsIDI1NSwgMF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHJhaW5ib3ogc29mdCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgUkFJTkJPV19TT0ZUOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTI1LCAwLCAxNzldIH0sXG4gICAgICB7IHZhbHVlOiAwLjEsIGNvbG9yOiBbMTk5LCAwLCAxODBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjIsIGNvbG9yOiBbMjU1LCAwLCAxMjFdIH0sXG4gICAgICB7IHZhbHVlOiAwLjMsIGNvbG9yOiBbMjU1LCAxMDgsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMjIyLCAxOTQsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTUwLCAyNTUsIDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMCwgMjU1LCA1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNywgY29sb3I6IFswLCAyNDYsIDE1MF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOCwgY29sb3I6IFs1MCwgMTY3LCAyMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjksIGNvbG9yOiBbMTAzLCA1MSwgMjM1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsxMjQsIDAsIDE4Nl0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIGJhdGh5bWV0cnkgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEJBVEhZTUVUUlk6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0MCwgMjYsIDQ0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs1OSwgNDksIDkwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs2NCwgNzYsIDEzOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbNjMsIDExMCwgMTUxXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzcyLCAxNDIsIDE1OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbODUsIDE3NCwgMTYzXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxMjAsIDIwNiwgMTYzXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxODcsIDIzMCwgMTcyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTMsIDI1NCwgMjA0XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY2RvbSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQ0RPTTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzQ3LCAxNSwgNjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzg3LCAyMywgODZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzEzMCwgMjgsIDk5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNzEsIDQxLCA5Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsyMDYsIDY3LCA4Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjMwLCAxMDYsIDg0XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDIsIDE0OSwgMTAzXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyNDksIDE5MywgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTQsIDIzNywgMTc2XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY2hsb3JvcGh5bGwgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENITE9ST1BIWUxMOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTgsIDM2LCAyMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjUsIDYzLCA0MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMjQsIDkxLCA1OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTMsIDExOSwgNzJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTgsIDE0OCwgODBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzgwLCAxNzMsIDg5XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxMzIsIDE5NiwgMTIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsxNzUsIDIyMSwgMTYyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyMTUsIDI0OSwgMjA4XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgZGVuc2l0eSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgREVOU0lUWTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzU0LCAxNCwgMzZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzg5LCAyMywgODBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzExMCwgNDUsIDEzMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMTIwLCA3NywgMTc4XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzEyMCwgMTEzLCAyMTNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzExNSwgMTUxLCAyMjhdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzEzNCwgMTg1LCAyMjddIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzE3NywgMjE0LCAyMjddIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzIzMCwgMjQxLCAyNDFdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBmcmVlc3VyZmFjZSBibHVlIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBGUkVFU1VSRkFDRV9CTFVFOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMzAsIDQsIDExMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbNDcsIDE0LCAxNzZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzQxLCA0NSwgMjM2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsyNSwgOTksIDIxMl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs2OCwgMTMxLCAyMDBdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzExNCwgMTU2LCAxOTddIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzE1NywgMTgxLCAyMDNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzIwMCwgMjA4LCAyMTZdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI0MSwgMjM3LCAyMzZdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBmcmVlc3VyZmFjZSByZWQgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIEZSRUVTVVJGQUNFX1JFRDogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzYwLCA5LCAxOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMTAwLCAxNywgMjddIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzE0MiwgMjAsIDI5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNzcsIDQzLCAyN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxOTIsIDg3LCA2M10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMjA1LCAxMjUsIDEwNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjE2LCAxNjIsIDE0OF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMjI3LCAxOTksIDE5M10gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjQxLCAyMzcsIDIzNl0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIG94eWdlbiBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgT1hZR0VOOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbNjQsIDUsIDVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzEwNiwgNiwgMTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzE0NCwgMjYsIDddIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzE2OCwgNjQsIDNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTg4LCAxMDAsIDRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzIwNiwgMTM2LCAxMV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjIwLCAxNzQsIDI1XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMzEsIDIxNSwgNDRdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI0OCwgMjU0LCAxMDVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogQ2xhc3NpYyBwYXIgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFBBUjogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzUxLCAyMCwgMjRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzkwLCAzMiwgMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzEyOSwgNDQsIDM0XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNTksIDY4LCAyNV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxODIsIDk5LCAxOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbMTk5LCAxMzQsIDIyXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyMTIsIDE3MSwgMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzIyMSwgMjEwLCA1NF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjI1LCAyNTMsIDc1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgcGhhc2UgY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFBIQVNFOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMTQ1LCAxMDUsIDE4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFsxODQsIDcxLCAzOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTg2LCA1OCwgMTE1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxNjAsIDcxLCAxODVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTEwLCA5NywgMjE4XSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFs1MCwgMTIzLCAxNjRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjc1LCBjb2xvcjogWzMxLCAxMzEsIDExMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbNzcsIDEyOSwgMzRdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzE0NSwgMTA1LCAxOF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHNhbGluaXR5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBTQUxJTklUWTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzQyLCAyNCwgMTA4XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFszMywgNTAsIDE2Ml0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTUsIDkwLCAxNDVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM4LCBjb2xvcjogWzQwLCAxMTgsIDEzN10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs1OSwgMTQ2LCAxMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzc5LCAxNzUsIDEyNl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTIwLCAyMDMsIDEwNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODgsIGNvbG9yOiBbMTkzLCAyMjEsIDEwMF0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjUzLCAyMzksIDE1NF0gfVxuICAgIF1cbiAgfSksXG4gIC8qKlxuICAgKiBDbGFzc2ljIHRlbXBlcmF0dXJlIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBURU1QRVJBVFVSRTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzQsIDM1LCA1MV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjMsIDUxLCAxMjJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjI1LCBjb2xvcjogWzg1LCA1OSwgMTU3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMjksIDc5LCAxNDNdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbMTc1LCA5NSwgMTMwXSB9LFxuICAgICAgeyB2YWx1ZTogMC42MywgY29sb3I6IFsyMjIsIDExMiwgMTAxXSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNDksIDE0NiwgNjZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjg4LCBjb2xvcjogWzI0OSwgMTk2LCA2NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjMyLCAyNTAsIDkxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgdHVyYmlkaXR5IGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBUVVJCSURJVFk6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFszNCwgMzEsIDI3XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs2NSwgNTAsIDQxXSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs5OCwgNjksIDUyXSB9LFxuICAgICAgeyB2YWx1ZTogMC4zOCwgY29sb3I6IFsxMzEsIDg5LCA1N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxNjEsIDExMiwgNTldIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzE4NSwgMTQwLCA2Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjAyLCAxNzQsIDg4XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMTYsIDIwOSwgMTI2XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyMzMsIDI0NiwgMTcxXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgdmVsb2NpdHkgYmx1ZSBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgVkVMT0NJVFlfQkxVRTogbmV3IEEoe1xuICAgIHN0b3BzOiBbXG4gICAgICB7IHZhbHVlOiAwLCBjb2xvcjogWzE3LCAzMiwgNjRdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEzLCBjb2xvcjogWzM1LCA1MiwgMTE2XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFsyOSwgODEsIDE1Nl0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMzEsIDExMywgMTYyXSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzUwLCAxNDQsIDE2OV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjMsIGNvbG9yOiBbODcsIDE3MywgMTc2XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsxNDksIDE5NiwgMTg5XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMDMsIDIyMSwgMjExXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTQsIDI1MSwgMjMwXSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgdmVsb2NpdHkgZ3JlZW4gY29sb3IgcmFtcC5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIFZFTE9DSVRZX0dSRUVOOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMjMsIDM1LCAxOV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTMsIGNvbG9yOiBbMjQsIDY0LCAzOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbMTEsIDk1LCA0NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzgsIGNvbG9yOiBbMzksIDEyMywgMzVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUsIGNvbG9yOiBbOTUsIDE0NiwgMTJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjYzLCBjb2xvcjogWzE1MiwgMTY1LCAxOF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMjAxLCAxODYsIDY5XSB9LFxuICAgICAgeyB2YWx1ZTogMC44OCwgY29sb3I6IFsyMzMsIDIxNiwgMTM3XSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyNTUsIDI1MywgMjA1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgY3ViZSBoZWxpeCBjb2xvciByYW1wLlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgQ1VCRUhFTElYOiBuZXcgQSh7XG4gICAgc3RvcHM6IFtcbiAgICAgIHsgdmFsdWU6IDAsIGNvbG9yOiBbMCwgMCwgMF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMDcsIGNvbG9yOiBbMjIsIDUsIDU5XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMywgY29sb3I6IFs2MCwgNCwgMTA1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yLCBjb2xvcjogWzEwOSwgMSwgMTM1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNywgY29sb3I6IFsxNjEsIDAsIDE0N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzMsIGNvbG9yOiBbMjEwLCAyLCAxNDJdIH0sXG4gICAgICB7IHZhbHVlOiAwLjQsIGNvbG9yOiBbMjUxLCAxMSwgMTIzXSB9LFxuICAgICAgeyB2YWx1ZTogMC40NywgY29sb3I6IFsyNTUsIDI5LCA5N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuNTMsIGNvbG9yOiBbMjU1LCA1NCwgNjldIH0sXG4gICAgICB7IHZhbHVlOiAwLjYsIGNvbG9yOiBbMjU1LCA4NSwgNDZdIH0sXG4gICAgICB7IHZhbHVlOiAwLjY3LCBjb2xvcjogWzI1NSwgMTIwLCAzNF0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzMsIGNvbG9yOiBbMjU1LCAxNTcsIDM3XSB9LFxuICAgICAgeyB2YWx1ZTogMC44LCBjb2xvcjogWzI0MSwgMTkxLCA1N10gfSxcbiAgICAgIHsgdmFsdWU6IDAuODcsIGNvbG9yOiBbMjI0LCAyMjAsIDkzXSB9LFxuICAgICAgeyB2YWx1ZTogMC45MywgY29sb3I6IFsyMTgsIDI0MSwgMTQyXSB9LFxuICAgICAgeyB2YWx1ZTogMSwgY29sb3I6IFsyMjcsIDI1MywgMTk4XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBjaXZpZGlzIGNvbG9yIHJhbXAgaXMgY29sb3IgYmxpbmQgZnJpZW5kbHkuXG4gICAqIFJlYWQgbW9yZSBoZXJlIGh0dHBzOi8vam91cm5hbHMucGxvcy5vcmcvcGxvc29uZS9hcnRpY2xlP2lkPTEwLjEzNzEvam91cm5hbC5wb25lLjAxOTkyMzlcbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIENJVklESVM6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFswLCAzMiwgNzcsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMTI1LCBjb2xvcjogWzUsIDU0LCAxMTAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNjUsIDc3LCAxMDgsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMzc1LCBjb2xvcjogWzk3LCAxMDAsIDExMSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC41LCBjb2xvcjogWzEyNSwgMTI0LCAxMjEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzE1NiwgMTQ5LCAxMjAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNzUsIGNvbG9yOiBbMTkwLCAxNzUsIDExMSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC44NzUsIGNvbG9yOiBbMjI1LCAyMDQsIDk0LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzI1NSwgMjM1LCA3MCwgMjU1XSB9XG4gICAgXVxuICB9KSxcbiAgLyoqXG4gICAqIENsYXNzaWMgdHVyYm8gY29sb3IgcmFtcC5cbiAgICogVGhpcyBpcyBhIGx1bWluYW5jZS1jb25zdGFudCBhbHRlcm5hdGl2ZSB0byB0aGUgamV0LCBtYWtpbmcgaXQgbW9yZVxuICAgKiBjbG9yLWJsaW5kIGZyaWVuZGx5LlxuICAgKiBEZWZpbmVkIGluIGludGVydmFsIFswLCAxXSwgd2l0aG91dCB1bml0LlxuICAgKi9cbiAgVFVSQk86IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFs0OCwgMTgsIDU5LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjEyNSwgY29sb3I6IFs3MCwgMTA3LCAyMjcsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuMjUsIGNvbG9yOiBbNDAsIDE4NywgMjM2LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjM3NSwgY29sb3I6IFs0OSwgMjQyLCAxNTMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFsxNjIsIDI1MiwgNjAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzIzNywgMjA4LCA1OCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFsyNTEsIDEyOCwgMzQsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzIxMCwgNDksIDUsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMTIyLCA0LCAzLCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogVGhlIHJvY2tldCBjb2xvciByYW1wIGlzIHBlcmNlcHR1YWxseSB1bmlmb3JtLCB3aGljaCBtYWtlcyBpdCBtb3JlXG4gICAqIGNvbG9yIGJsaWVuZCBmcmllbmRseSB0aGFuIHRoZSBjbGFzc2ljIG1hZ21hIGNvbG9yIHJhbXAuXG4gICAqIERlZmluZWQgaW4gaW50ZXJ2YWwgWzAsIDFdLCB3aXRob3V0IHVuaXQuXG4gICAqL1xuICBST0NLRVQ6IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsyNTAsIDIzNSwgMjIxLCAwXSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMzMsIGNvbG9yOiBbMjUwLCAyMzUsIDIyMSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNjYsIGNvbG9yOiBbMjQ2LCAxNzAsIDEzMCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC40LCBjb2xvcjogWzI0MCwgOTYsIDY3LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAwLjUzMywgY29sb3I6IFsyMDMsIDI3LCA3OSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC42NjYsIGNvbG9yOiBbMTMyLCAzMCwgOTAsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuOCwgY29sb3I6IFs2MywgMjcsIDY4LCAyNTVdIH0sXG4gICAgICB7IHZhbHVlOiAxLCBjb2xvcjogWzMsIDUsIDI2LCAyNTVdIH1cbiAgICBdXG4gIH0pLFxuICAvKipcbiAgICogVGhlIG1ha28gY29sb3IgcmFtcCBpcyBwZXJjZXB0dWFsbHkgdW5pZm9ybSBhbmQgY2FuIGJlIHNlZW4gYXNcbiAgICogYSBjb2xvciBibGluZCBmcmllbmRseSBhbHRlcm5hdGl2ZSB0byBiYXRoeW1ldHJ5IG9yIHlpZ25idS5cbiAgICogRGVmaW5lZCBpbiBpbnRlcnZhbCBbMCwgMV0sIHdpdGhvdXQgdW5pdC5cbiAgICovXG4gIE1BS086IG5ldyBBKHtcbiAgICBzdG9wczogW1xuICAgICAgeyB2YWx1ZTogMCwgY29sb3I6IFsxMSwgNCwgNSwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4xMjUsIGNvbG9yOiBbNDMsIDI4LCA1MywgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4yNSwgY29sb3I6IFs2MiwgNTMsIDEwNywgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC4zNzUsIGNvbG9yOiBbNTksIDg2LCAxNTIsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNSwgY29sb3I6IFs1MywgMTIzLCAxNjIsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuNjI1LCBjb2xvcjogWzUzLCAxNTgsIDE3MCwgMjU1XSB9LFxuICAgICAgeyB2YWx1ZTogMC43NSwgY29sb3I6IFs3MywgMTkzLCAxNzMsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDAuODc1LCBjb2xvcjogWzE1MCwgMjIxLCAxODEsIDI1NV0gfSxcbiAgICAgIHsgdmFsdWU6IDEsIGNvbG9yOiBbMjIyLCAyNDUsIDIyOSwgMjU1XSB9XG4gICAgXVxuICB9KVxufTtcbmFzeW5jIGZ1bmN0aW9uIGdjKHIsIGUsIHQgPSB7fSkge1xuICB2YXIgYSwgbztcbiAgaWYgKCFlLnNvdXJjZUlkICYmICFlLmRhdGEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRpbmcgYSBwb2x5bGluZSBsYXllciByZXF1aXJlcyBhbiBleGlzdGluZyAuc291cmNlSWQgb3IgYSB2YWxpZCAuZGF0YSBwcm9wZXJ0eVwiKTtcbiAgbGV0IG4gPSBlLmRhdGE7XG4gIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKFl0KG4pKVxuICAgICAgbiA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vZGF0YS8ke2UuZGF0YX0vZmVhdHVyZXMuanNvbj9rZXk9JHtqLmFwaUtleX1gO1xuICAgIGVsc2UgaWYgKCgoYSA9IG4uc3BsaXQoXCIuXCIpLnBvcCgpKSA9PSBudWxsID8gdm9pZCAwIDogYS50b0xvd2VyQ2FzZSgpLnRyaW0oKSkgPT09IFwiZ3B4XCIpIHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCAoYXdhaXQgZmV0Y2gobiwgdCkpLnRleHQoKTtcbiAgICAgIG4gPSBPbyhzKTtcbiAgICB9IGVsc2UgaWYgKCgobyA9IG4uc3BsaXQoXCIuXCIpLnBvcCgpKSA9PSBudWxsID8gdm9pZCAwIDogby50b0xvd2VyQ2FzZSgpLnRyaW0oKSkgPT09IFwia21sXCIpIHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCAoYXdhaXQgZmV0Y2gobiwgdCkpLnRleHQoKTtcbiAgICAgIG4gPSBObyhzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaSA9IHhpKG4pID8/IGRjKG4pO1xuICAgICAgaSAmJiAobiA9IGkpO1xuICAgIH1cbiAgICBpZiAoIW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bGluZSBkYXRhIHdhcyBwcm92aWRlZCBhcyBzdHJpbmcgYnV0IGlzIGluY29tcGF0aWJsZSB3aXRoIHZhbGlkIGZvcm1hdHMuXCIpO1xuICB9XG4gIHJldHVybiB2YyhyLCB7XG4gICAgLi4uZSxcbiAgICBkYXRhOiBuXG4gIH0pO1xufVxuZnVuY3Rpb24gdmMociwgZSkge1xuICBpZiAoZS5sYXllcklkICYmIHIuZ2V0TGF5ZXIoZS5sYXllcklkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbGF5ZXIgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgbGF5ZXIgaWQ6ICR7ZS5sYXllcklkfWApO1xuICBjb25zdCB0ID0gZS5zb3VyY2VJZCA/PyBJdCgpLCBuID0gZS5sYXllcklkID8/IE10KCksIGEgPSB7XG4gICAgcG9seWxpbmVMYXllcklkOiBuLFxuICAgIHBvbHlsaW5lT3V0bGluZUxheWVySWQ6IFwiXCIsXG4gICAgcG9seWxpbmVTb3VyY2VJZDogdFxuICB9O1xuICBlLmRhdGEgJiYgIXIuZ2V0U291cmNlKHQpICYmIHIuYWRkU291cmNlKHQsIHtcbiAgICB0eXBlOiBcImdlb2pzb25cIixcbiAgICBkYXRhOiBlLmRhdGFcbiAgfSk7XG4gIGNvbnN0IG8gPSBlLmxpbmVXaWR0aCA/PyAzLCBpID0gZS5saW5lQ29sb3IgPz8gZHIoKSwgcyA9IGUubGluZU9wYWNpdHkgPz8gMSwgbCA9IGUubGluZUJsdXIgPz8gMCwgdSA9IGUubGluZUdhcFdpZHRoID8/IDA7XG4gIGxldCBjID0gZS5saW5lRGFzaEFycmF5ID8/IG51bGw7XG4gIGNvbnN0IHAgPSBlLm91dGxpbmVXaWR0aCA/PyAxLCBkID0gZS5vdXRsaW5lQ29sb3IgPz8gXCIjRkZGRkZGXCIsIGYgPSBlLm91dGxpbmVPcGFjaXR5ID8/IDEsIGggPSBlLm91dGxpbmVCbHVyID8/IDA7XG4gIGlmICh0eXBlb2YgYyA9PSBcInN0cmluZ1wiICYmIChjID0gQW4oYykpLCBlLm91dGxpbmUgPT09ICEwKSB7XG4gICAgY29uc3QgbSA9IGAke259X291dGxpbmVgO1xuICAgIGEucG9seWxpbmVPdXRsaW5lTGF5ZXJJZCA9IG0sIHIuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBtLFxuICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgc291cmNlOiB0LFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiBlLmxpbmVKb2luID8/IFwicm91bmRcIixcbiAgICAgICAgICBcImxpbmUtY2FwXCI6IGUubGluZUNhcCA/PyBcInJvdW5kXCJcbiAgICAgICAgfSxcbiAgICAgICAgbWluem9vbTogZS5taW56b29tID8/IDAsXG4gICAgICAgIG1heHpvb206IGUubWF4em9vbSA/PyAyMyxcbiAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICBcImxpbmUtb3BhY2l0eVwiOiB0eXBlb2YgZiA9PSBcIm51bWJlclwiID8gZiA6IEYoZiksXG4gICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IHR5cGVvZiBkID09IFwic3RyaW5nXCIgPyBkIDogRmUoZCksXG4gICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IFZvKG8sIHApLFxuICAgICAgICAgIFwibGluZS1ibHVyXCI6IHR5cGVvZiBoID09IFwibnVtYmVyXCIgPyBoIDogRihoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZS5iZWZvcmVJZFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHIuYWRkTGF5ZXIoXG4gICAge1xuICAgICAgaWQ6IG4sXG4gICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgIHNvdXJjZTogdCxcbiAgICAgIGxheW91dDoge1xuICAgICAgICBcImxpbmUtam9pblwiOiBlLmxpbmVKb2luID8/IFwicm91bmRcIixcbiAgICAgICAgXCJsaW5lLWNhcFwiOiBlLmxpbmVDYXAgPz8gXCJyb3VuZFwiXG4gICAgICB9LFxuICAgICAgbWluem9vbTogZS5taW56b29tID8/IDAsXG4gICAgICBtYXh6b29tOiBlLm1heHpvb20gPz8gMjMsXG4gICAgICBwYWludDoge1xuICAgICAgICBcImxpbmUtb3BhY2l0eVwiOiB0eXBlb2YgcyA9PSBcIm51bWJlclwiID8gcyA6IEYocyksXG4gICAgICAgIFwibGluZS1jb2xvclwiOiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gaSA6IEZlKGkpLFxuICAgICAgICBcImxpbmUtd2lkdGhcIjogdHlwZW9mIG8gPT0gXCJudW1iZXJcIiA/IG8gOiBGKG8pLFxuICAgICAgICBcImxpbmUtYmx1clwiOiB0eXBlb2YgbCA9PSBcIm51bWJlclwiID8gbCA6IEYobCksXG4gICAgICAgIFwibGluZS1nYXAtd2lkdGhcIjogdHlwZW9mIHUgPT0gXCJudW1iZXJcIiA/IHUgOiBGKHUpLFxuICAgICAgICAvLyBGb3Igc29tZSByZWFzb25zIHBhc3NpbmcgXCJsaW5lLWRhc2hhcnJheVwiIHdpdGggdGhlIHZhbHVlIFwidW5kZWZpbmVkXCJcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBubyBzaG93aW5nIHRoZSBsaW5lIHdoaWxlIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIGJlaGF2aW9yXG4gICAgICAgIC8vIG9mIG5vdCBhZGRpbmcgdGhlIHByb3BlcnR5IFwibGluZS1kYXNoYXJyYXlcIiBhcyBhbGwuXG4gICAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCwgd2UgYXJlIGlubGluaW5nIHRoZSBhZGRpdGlvbiBvZiB0aGUgcHJvcCB3aXRoIGEgY29uZGl0aW9uYWxcbiAgICAgICAgLy8gd2hpY2ggaXMgbGVzcyByZWFkYWJsZS5cbiAgICAgICAgLi4uYyAmJiB7IFwibGluZS1kYXNoYXJyYXlcIjogYyB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlLmJlZm9yZUlkXG4gICksIGE7XG59XG5mdW5jdGlvbiBiYyhyLCBlKSB7XG4gIGlmIChlLmxheWVySWQgJiYgci5nZXRMYXllcihlLmxheWVySWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihgQSBsYXllciBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBsYXllciBpZDogJHtlLmxheWVySWR9YCk7XG4gIGNvbnN0IHQgPSBlLnNvdXJjZUlkID8/IEl0KCksIG4gPSBlLmxheWVySWQgPz8gTXQoKSwgYSA9IHtcbiAgICBwb2x5Z29uTGF5ZXJJZDogbixcbiAgICBwb2x5Z29uT3V0bGluZUxheWVySWQ6IGUub3V0bGluZSA/IGAke259X291dGxpbmVgIDogXCJcIixcbiAgICBwb2x5Z29uU291cmNlSWQ6IHRcbiAgfTtcbiAgaWYgKGUuZGF0YSAmJiAhci5nZXRTb3VyY2UodCkpIHtcbiAgICBsZXQgbSA9IGUuZGF0YTtcbiAgICB0eXBlb2YgbSA9PSBcInN0cmluZ1wiICYmIFl0KG0pICYmIChtID0gYGh0dHBzOi8vYXBpLm1hcHRpbGVyLmNvbS9kYXRhLyR7bX0vZmVhdHVyZXMuanNvbj9rZXk9JHtqLmFwaUtleX1gKSwgci5hZGRTb3VyY2UodCwge1xuICAgICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgICBkYXRhOiBtXG4gICAgfSk7XG4gIH1cbiAgbGV0IG8gPSBlLm91dGxpbmVEYXNoQXJyYXkgPz8gbnVsbDtcbiAgY29uc3QgaSA9IGUub3V0bGluZVdpZHRoID8/IDEsIHMgPSBlLm91dGxpbmVDb2xvciA/PyBcIiNGRkZGRkZcIiwgbCA9IGUub3V0bGluZU9wYWNpdHkgPz8gMSwgdSA9IGUub3V0bGluZUJsdXIgPz8gMCwgYyA9IGUuZmlsbENvbG9yID8/IGRyKCksIHAgPSBlLmZpbGxPcGFjaXR5ID8/IDEsIGQgPSBlLm91dGxpbmVQb3NpdGlvbiA/PyBcImNlbnRlclwiLCBmID0gZS5wYXR0ZXJuID8/IG51bGw7XG4gIHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgKG8gPSBBbihvKSk7XG4gIGNvbnN0IGggPSAobSA9IG51bGwpID0+IHtcbiAgICBpZiAoci5hZGRMYXllcihcbiAgICAgIHtcbiAgICAgICAgaWQ6IG4sXG4gICAgICAgIHR5cGU6IFwiZmlsbFwiLFxuICAgICAgICBzb3VyY2U6IHQsXG4gICAgICAgIG1pbnpvb206IGUubWluem9vbSA/PyAwLFxuICAgICAgICBtYXh6b29tOiBlLm1heHpvb20gPz8gMjMsXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgXCJmaWxsLWNvbG9yXCI6IHR5cGVvZiBjID09IFwic3RyaW5nXCIgPyBjIDogRmUoYyksXG4gICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdHlwZW9mIHAgPT0gXCJudW1iZXJcIiA/IHAgOiBGKHApLFxuICAgICAgICAgIC8vIEFkZGluZyBhIHBhdHRlcm4gaWYgcHJvdmlkZWRcbiAgICAgICAgICAuLi5tICYmIHsgXCJmaWxsLXBhdHRlcm5cIjogbSB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlLmJlZm9yZUlkXG4gICAgKSwgZS5vdXRsaW5lID09PSAhMCkge1xuICAgICAgbGV0IHk7XG4gICAgICBkID09PSBcImluc2lkZVwiID8gdHlwZW9mIGkgPT0gXCJudW1iZXJcIiA/IHkgPSAwLjUgKiBpIDogeSA9IEYoXG4gICAgICAgIGkubWFwKCh7IHpvb206IHcsIHZhbHVlOiBnIH0pID0+ICh7XG4gICAgICAgICAgem9vbTogdyxcbiAgICAgICAgICB2YWx1ZTogMC41ICogZ1xuICAgICAgICB9KSlcbiAgICAgICkgOiBkID09PSBcIm91dHNpZGVcIiA/IHR5cGVvZiBpID09IFwibnVtYmVyXCIgPyB5ID0gLTAuNSAqIGkgOiB5ID0gRihcbiAgICAgICAgaS5tYXAoKHcpID0+ICh7XG4gICAgICAgICAgem9vbTogdy56b29tLFxuICAgICAgICAgIHZhbHVlOiAtMC41ICogdy52YWx1ZVxuICAgICAgICB9KSlcbiAgICAgICkgOiB5ID0gMCwgci5hZGRMYXllcihcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBhLnBvbHlnb25PdXRsaW5lTGF5ZXJJZCxcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICBzb3VyY2U6IHQsXG4gICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBcImxpbmUtam9pblwiOiBlLm91dGxpbmVKb2luID8/IFwicm91bmRcIixcbiAgICAgICAgICAgIFwibGluZS1jYXBcIjogZS5vdXRsaW5lQ2FwID8/IFwiYnV0dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtaW56b29tOiBlLm1pbnpvb20gPz8gMCxcbiAgICAgICAgICBtYXh6b29tOiBlLm1heHpvb20gPz8gMjMsXG4gICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgIFwibGluZS1vcGFjaXR5XCI6IHR5cGVvZiBsID09IFwibnVtYmVyXCIgPyBsIDogRihsKSxcbiAgICAgICAgICAgIFwibGluZS1jb2xvclwiOiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcyA6IEZlKHMpLFxuICAgICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IHR5cGVvZiBpID09IFwibnVtYmVyXCIgPyBpIDogRihpKSxcbiAgICAgICAgICAgIFwibGluZS1ibHVyXCI6IHR5cGVvZiB1ID09IFwibnVtYmVyXCIgPyB1IDogRih1KSxcbiAgICAgICAgICAgIFwibGluZS1vZmZzZXRcIjogeSxcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbnMgcGFzc2luZyBcImxpbmUtZGFzaGFycmF5XCIgd2l0aCB0aGUgdmFsdWUgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgLy8gcmVzdWx0cyBpbiBubyBzaG93aW5nIHRoZSBsaW5lIHdoaWxlIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBvZiBub3QgYWRkaW5nIHRoZSBwcm9wZXJ0eSBcImxpbmUtZGFzaGFycmF5XCIgYXMgYWxsLlxuICAgICAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kLCB3ZSBhcmUgaW5saW5pbmcgdGhlIGFkZGl0aW9uIG9mIHRoZSBwcm9wIHdpdGggYSBjb25kaXRpb25hbFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgbGVzcyByZWFkYWJsZS5cbiAgICAgICAgICAgIC4uLm8gJiYge1xuICAgICAgICAgICAgICBcImxpbmUtZGFzaGFycmF5XCI6IG9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGUuYmVmb3JlSWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZiA/IHIuaGFzSW1hZ2UoZikgPyBoKGYpIDogci5sb2FkSW1hZ2UoZikudGhlbigobSkgPT4ge1xuICAgIHIuYWRkSW1hZ2UoZiwgbS5kYXRhKSwgaChmKTtcbiAgfSkuY2F0Y2goKG0pID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGxvYWQgdGhlIHBhdHRlcm4gaW1hZ2UuXCIsIG0ubWVzc2FnZSksIGgoKTtcbiAgfSkgOiBoKCksIGE7XG59XG5mdW5jdGlvbiB3YyhyLCBlKSB7XG4gIGlmIChlLmxheWVySWQgJiYgci5nZXRMYXllcihlLmxheWVySWQpKVxuICAgIHRocm93IG5ldyBFcnJvcihgQSBsYXllciBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBsYXllciBpZDogJHtlLmxheWVySWR9YCk7XG4gIGNvbnN0IHQgPSBlLm1pblBvaW50UmFkaXVzID8/IDEwLCBuID0gZS5tYXhQb2ludFJhZGl1cyA/PyA1MCwgYSA9IGUuY2x1c3RlciA/PyAhMSwgbyA9IDIwLCBpID0gQXJyYXkuaXNBcnJheShlLnBvaW50Q29sb3IpID8gZS5wb2ludENvbG9yIDogWG8uVFVSQk8uc2NhbGUoMTAsIGUuY2x1c3RlciA/IDFlNCA6IDFlMykucmVzYW1wbGUoXCJlYXNlLW91dC1zcXVhcmVcIiksIHMgPSBpLmdldEJvdW5kcygpLCBsID0gZS5zb3VyY2VJZCA/PyBJdCgpLCB1ID0gZS5sYXllcklkID8/IE10KCksIGMgPSBlLnNob3dMYWJlbCA/PyBhLCBwID0gZS5hbGlnbk9uVmlld3BvcnQgPz8gITAsIGQgPSBlLm91dGxpbmUgPz8gITEsIGYgPSBlLm91dGxpbmVPcGFjaXR5ID8/IDEsIGggPSBlLm91dGxpbmVXaWR0aCA/PyAxLCBtID0gZS5vdXRsaW5lQ29sb3IgPz8gXCIjRkZGRkZGXCI7XG4gIGxldCB5O1xuICBjb25zdCB3ID0gZS56b29tQ29tcGVuc2F0aW9uID8/ICEwLCBnID0gZS5taW56b29tID8/IDAsIHggPSBlLm1heHpvb20gPz8gMjM7XG4gIHR5cGVvZiBlLnBvaW50T3BhY2l0eSA9PSBcIm51bWJlclwiID8geSA9IGUucG9pbnRPcGFjaXR5IDogQXJyYXkuaXNBcnJheShlLnBvaW50T3BhY2l0eSkgPyB5ID0gRihlLnBvaW50T3BhY2l0eSkgOiBlLmNsdXN0ZXIgPyB5ID0gUXIoaSwgXCJwb2ludF9jb3VudFwiKSA6IGUucHJvcGVydHkgPyB5ID0gUXIoaSwgZS5wcm9wZXJ0eSkgOiB5ID0gRihbXG4gICAgeyB6b29tOiBnLCB2YWx1ZTogMCB9LFxuICAgIHsgem9vbTogZyArIDAuMjUsIHZhbHVlOiAxIH0sXG4gICAgeyB6b29tOiB4IC0gMC4yNSwgdmFsdWU6IDEgfSxcbiAgICB7IHpvb206IHgsIHZhbHVlOiAwIH1cbiAgXSk7XG4gIGNvbnN0IEUgPSB7XG4gICAgcG9pbnRMYXllcklkOiB1LFxuICAgIGNsdXN0ZXJMYXllcklkOiBcIlwiLFxuICAgIGxhYmVsTGF5ZXJJZDogXCJcIixcbiAgICBwb2ludFNvdXJjZUlkOiBsXG4gIH07XG4gIGlmIChlLmRhdGEgJiYgIXIuZ2V0U291cmNlKGwpKSB7XG4gICAgbGV0IEMgPSBlLmRhdGE7XG4gICAgdHlwZW9mIEMgPT0gXCJzdHJpbmdcIiAmJiBZdChDKSAmJiAoQyA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vZGF0YS8ke0N9L2ZlYXR1cmVzLmpzb24/a2V5PSR7ai5hcGlLZXl9YCksIHIuYWRkU291cmNlKGwsIHtcbiAgICAgIHR5cGU6IFwiZ2VvanNvblwiLFxuICAgICAgZGF0YTogQyxcbiAgICAgIGNsdXN0ZXI6IGFcbiAgICB9KTtcbiAgfVxuICBpZiAoYSkge1xuICAgIEUuY2x1c3RlckxheWVySWQgPSBgJHt1fV9jbHVzdGVyYDtcbiAgICBjb25zdCBDID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbyB9LCAoVCwgTikgPT4ge1xuICAgICAgY29uc3QgdmUgPSBzLm1pbiArIE4gKiAocy5tYXggLSBzLm1pbikgLyAobyAtIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZlLFxuICAgICAgICBwb2ludFJhZGl1czogdCArIChuIC0gdCkgKiAoTiAvIChvIC0gMSkpICoqIDAuNSxcbiAgICAgICAgY29sb3I6IGkuZ2V0Q29sb3JIZXgodmUpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHIuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBFLmNsdXN0ZXJMYXllcklkLFxuICAgICAgICB0eXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzb3VyY2U6IGwsXG4gICAgICAgIGZpbHRlcjogW1wiaGFzXCIsIFwicG9pbnRfY291bnRcIl0sXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgLy8gJ2NpcmNsZS1jb2xvcic6IG9wdGlvbnMucG9pbnRDb2xvciA/PyBjb2xvckRyaXZlbkJ5UHJvcGVydHkoY2x1c3RlclN0eWxlLCBcInBvaW50X2NvdW50XCIpLFxuICAgICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IHR5cGVvZiBlLnBvaW50Q29sb3IgPT0gXCJzdHJpbmdcIiA/IGUucG9pbnRDb2xvciA6IFdyKEMsIFwicG9pbnRfY291bnRcIiksXG4gICAgICAgICAgXCJjaXJjbGUtcmFkaXVzXCI6IHR5cGVvZiBlLnBvaW50UmFkaXVzID09IFwibnVtYmVyXCIgPyBlLnBvaW50UmFkaXVzIDogQXJyYXkuaXNBcnJheShlLnBvaW50UmFkaXVzKSA/IEYoZS5wb2ludFJhZGl1cykgOiBKcihDLCBcInBvaW50X2NvdW50XCIsICExKSxcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIjogcCA/IFwidmlld3BvcnRcIiA6IFwibWFwXCIsXG4gICAgICAgICAgXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIjogXCJtYXBcIixcbiAgICAgICAgICAvLyBzY2FsZSB3aXRoIGNhbWVyYSBkaXN0YW5jZSByZWdhcmRsZXNzIG9mIHZpZXdwb3J0L2JpZXdwb3J0IGFsaWduZW1lbnRcbiAgICAgICAgICBcImNpcmNsZS1vcGFjaXR5XCI6IHksXG4gICAgICAgICAgLi4uZCAmJiB7XG4gICAgICAgICAgICBcImNpcmNsZS1zdHJva2Utb3BhY2l0eVwiOiB0eXBlb2YgZiA9PSBcIm51bWJlclwiID8gZiA6IEYoZiksXG4gICAgICAgICAgICBcImNpcmNsZS1zdHJva2Utd2lkdGhcIjogdHlwZW9mIGggPT0gXCJudW1iZXJcIiA/IGggOiBGKGgpLFxuICAgICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLWNvbG9yXCI6IHR5cGVvZiBtID09IFwic3RyaW5nXCIgPyBtIDogRmUobSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1pbnpvb206IGcsXG4gICAgICAgIG1heHpvb206IHhcbiAgICAgIH0sXG4gICAgICBlLmJlZm9yZUlkXG4gICAgKSwgci5hZGRMYXllcihcbiAgICAgIHtcbiAgICAgICAgaWQ6IEUucG9pbnRMYXllcklkLFxuICAgICAgICB0eXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzb3VyY2U6IGwsXG4gICAgICAgIGZpbHRlcjogW1wiIVwiLCBbXCJoYXNcIiwgXCJwb2ludF9jb3VudFwiXV0sXG4gICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IHAgPyBcInZpZXdwb3J0XCIgOiBcIm1hcFwiLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IFwibWFwXCIsXG4gICAgICAgICAgLy8gc2NhbGUgd2l0aCBjYW1lcmEgZGlzdGFuY2UgcmVnYXJkbGVzcyBvZiB2aWV3cG9ydC9iaWV3cG9ydCBhbGlnbmVtZW50XG4gICAgICAgICAgLy8gJ2NpcmNsZS1jb2xvcic6ICBvcHRpb25zLnBvaW50Q29sb3IgPz8gY2x1c3RlclN0eWxlWzBdLmNvbG9yLFxuICAgICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IHR5cGVvZiBlLnBvaW50Q29sb3IgPT0gXCJzdHJpbmdcIiA/IGUucG9pbnRDb2xvciA6IGkuZ2V0Q29sb3JIZXgoaS5nZXRCb3VuZHMoKS5taW4pLFxuICAgICAgICAgIFwiY2lyY2xlLXJhZGl1c1wiOiB0eXBlb2YgZS5wb2ludFJhZGl1cyA9PSBcIm51bWJlclwiID8gZS5wb2ludFJhZGl1cyA6IEFycmF5LmlzQXJyYXkoZS5wb2ludFJhZGl1cykgPyBGKGUucG9pbnRSYWRpdXMpIDogQ1swXS5wb2ludFJhZGl1cyAqIDAuNzUsXG4gICAgICAgICAgXCJjaXJjbGUtb3BhY2l0eVwiOiB5LFxuICAgICAgICAgIC4uLmQgJiYge1xuICAgICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjogdHlwZW9mIGYgPT0gXCJudW1iZXJcIiA/IGYgOiBGKGYpLFxuICAgICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IHR5cGVvZiBoID09IFwibnVtYmVyXCIgPyBoIDogRihoKSxcbiAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB0eXBlb2YgbSA9PSBcInN0cmluZ1wiID8gbSA6IEZlKG0pXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtaW56b29tOiBnLFxuICAgICAgICBtYXh6b29tOiB4XG4gICAgICB9LFxuICAgICAgZS5iZWZvcmVJZFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IEMgPSB0eXBlb2YgZS5wb2ludENvbG9yID09IFwic3RyaW5nXCIgPyBlLnBvaW50Q29sb3IgOiBBcnJheS5pc0FycmF5KGUucG9pbnRDb2xvcikgPyBlLnBvaW50Q29sb3IuZ2V0Q29sb3JIZXgoZS5wb2ludENvbG9yLmdldEJvdW5kcygpLm1pbikgOiBkcigpLCBUID0gdHlwZW9mIGUucG9pbnRSYWRpdXMgPT0gXCJudW1iZXJcIiA/IHcgPyBGKFtcbiAgICAgIHsgem9vbTogMCwgdmFsdWU6IGUucG9pbnRSYWRpdXMgKiAwLjAyNSB9LFxuICAgICAgeyB6b29tOiAyLCB2YWx1ZTogZS5wb2ludFJhZGl1cyAqIDAuMDUgfSxcbiAgICAgIHsgem9vbTogNCwgdmFsdWU6IGUucG9pbnRSYWRpdXMgKiAwLjEgfSxcbiAgICAgIHsgem9vbTogOCwgdmFsdWU6IGUucG9pbnRSYWRpdXMgKiAwLjI1IH0sXG4gICAgICB7IHpvb206IDE2LCB2YWx1ZTogZS5wb2ludFJhZGl1cyAqIDEgfVxuICAgIF0pIDogZS5wb2ludFJhZGl1cyA6IEFycmF5LmlzQXJyYXkoZS5wb2ludFJhZGl1cykgPyBGKGUucG9pbnRSYWRpdXMpIDogdyA/IEYoW1xuICAgICAgeyB6b29tOiAwLCB2YWx1ZTogdCAqIDAuMDUgfSxcbiAgICAgIHsgem9vbTogMiwgdmFsdWU6IHQgKiAwLjEgfSxcbiAgICAgIHsgem9vbTogNCwgdmFsdWU6IHQgKiAwLjIgfSxcbiAgICAgIHsgem9vbTogOCwgdmFsdWU6IHQgKiAwLjUgfSxcbiAgICAgIHsgem9vbTogMTYsIHZhbHVlOiB0ICogMSB9XG4gICAgXSkgOiB0O1xuICAgIGlmIChlLnByb3BlcnR5ICYmIEFycmF5LmlzQXJyYXkoZS5wb2ludENvbG9yKSkge1xuICAgICAgY29uc3QgTiA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG8gfSwgKHZlLCBZZSkgPT4ge1xuICAgICAgICBjb25zdCBXZSA9IHMubWluICsgWWUgKiAocy5tYXggLSBzLm1pbikgLyAobyAtIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBXZSxcbiAgICAgICAgICBwb2ludFJhZGl1czogdHlwZW9mIGUucG9pbnRSYWRpdXMgPT0gXCJudW1iZXJcIiA/IGUucG9pbnRSYWRpdXMgOiB0ICsgKG4gLSB0KSAqIChZZSAvIChvIC0gMSkpICoqIDAuNSxcbiAgICAgICAgICBjb2xvcjogdHlwZW9mIGUucG9pbnRDb2xvciA9PSBcInN0cmluZ1wiID8gZS5wb2ludENvbG9yIDogaS5nZXRDb2xvckhleChXZSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgQyA9IFdyKE4sIGUucHJvcGVydHkpLCBUID0gSnIoTiwgZS5wcm9wZXJ0eSwgdyk7XG4gICAgfVxuICAgIHIuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBFLnBvaW50TGF5ZXJJZCxcbiAgICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc291cmNlOiBsLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAvLyBDb250cmFyeSB0byBsYWJlbHMsIHdlIHdhbnQgdG8gc2VlIHRoZSBzbWFsbCBvbmUgaW4gZnJvbnQuIFdlaXJkbHkgXCJjaXJjbGUtc29ydC1rZXlcIiB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGFzIFwic3ltYm9sLXNvcnQta2V5XCIuXG4gICAgICAgICAgXCJjaXJjbGUtc29ydC1rZXlcIjogZS5wcm9wZXJ0eSA/IFtcIi9cIiwgMSwgW1wiZ2V0XCIsIGUucHJvcGVydHldXSA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICBcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIjogcCA/IFwidmlld3BvcnRcIiA6IFwibWFwXCIsXG4gICAgICAgICAgXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIjogXCJtYXBcIixcbiAgICAgICAgICAvLyBzY2FsZSB3aXRoIGNhbWVyYSBkaXN0YW5jZSByZWdhcmRsZXNzIG9mIHZpZXdwb3J0L2JpZXdwb3J0IGFsaWduZW1lbnRcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiBDLFxuICAgICAgICAgIFwiY2lyY2xlLW9wYWNpdHlcIjogeSxcbiAgICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogVCxcbiAgICAgICAgICAuLi5kICYmIHtcbiAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHR5cGVvZiBmID09IFwibnVtYmVyXCIgPyBmIDogRihmKSxcbiAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB0eXBlb2YgaCA9PSBcIm51bWJlclwiID8gaCA6IEYoaCksXG4gICAgICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjogdHlwZW9mIG0gPT0gXCJzdHJpbmdcIiA/IG0gOiBGZShtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWluem9vbTogZyxcbiAgICAgICAgbWF4em9vbTogeFxuICAgICAgfSxcbiAgICAgIGUuYmVmb3JlSWRcbiAgICApO1xuICB9XG4gIGlmIChjICE9PSAhMSAmJiAoZS5jbHVzdGVyIHx8IGUucHJvcGVydHkpKSB7XG4gICAgRS5sYWJlbExheWVySWQgPSBgJHt1fV9sYWJlbGA7XG4gICAgY29uc3QgQyA9IGUubGFiZWxDb2xvciA/PyBcIiNmZmZcIiwgVCA9IGUubGFiZWxTaXplID8/IDEyO1xuICAgIHIuYWRkTGF5ZXIoXG4gICAgICB7XG4gICAgICAgIGlkOiBFLmxhYmVsTGF5ZXJJZCxcbiAgICAgICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICAgICAgc291cmNlOiBsLFxuICAgICAgICBmaWx0ZXI6IFtcImhhc1wiLCBlLmNsdXN0ZXIgPyBcInBvaW50X2NvdW50XCIgOiBlLnByb3BlcnR5XSxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgXCJ0ZXh0LWZpZWxkXCI6IGUuY2x1c3RlciA/IFwie3BvaW50X2NvdW50X2FiYnJldmlhdGVkfVwiIDogYHske2UucHJvcGVydHl9fWAsXG4gICAgICAgICAgXCJ0ZXh0LWZvbnRcIjogW1wiTm90byBTYW5zIFJlZ3VsYXJcIl0sXG4gICAgICAgICAgXCJ0ZXh0LXNpemVcIjogVCxcbiAgICAgICAgICBcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHAgPyBcInZpZXdwb3J0XCIgOiBcIm1hcFwiLFxuICAgICAgICAgIFwic3ltYm9sLXNvcnQta2V5XCI6IFtcIi9cIiwgMSwgW1wiZ2V0XCIsIGUuY2x1c3RlciA/IFwicG9pbnRfY291bnRcIiA6IGUucHJvcGVydHldXVxuICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGxhcmdlc3QgdmFsdWUgZ29lcyBvbiB0b3BcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICBcInRleHQtY29sb3JcIjogQyxcbiAgICAgICAgICBcInRleHQtb3BhY2l0eVwiOiB5XG4gICAgICAgIH0sXG4gICAgICAgIG1pbnpvb206IGcsXG4gICAgICAgIG1heHpvb206IHhcbiAgICAgIH0sXG4gICAgICBlLmJlZm9yZUlkXG4gICAgKTtcbiAgfVxuICByZXR1cm4gRTtcbn1cbmZ1bmN0aW9uIFNjKHIsIGUpIHtcbiAgaWYgKGUubGF5ZXJJZCAmJiByLmdldExheWVyKGUubGF5ZXJJZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIGxheWVyIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIGxheWVyIGlkOiAke2UubGF5ZXJJZH1gKTtcbiAgY29uc3QgdCA9IGUuc291cmNlSWQgPz8gSXQoKSwgbiA9IGUubGF5ZXJJZCA/PyBNdCgpLCBhID0gZS5taW56b29tID8/IDAsIG8gPSBlLm1heHpvb20gPz8gMjMsIGkgPSBlLnpvb21Db21wZW5zYXRpb24gPz8gITAsIHMgPSBlLm9wYWNpdHkgPz8gW1xuICAgIHsgem9vbTogYSwgdmFsdWU6IDAgfSxcbiAgICB7IHpvb206IGEgKyAwLjI1LCB2YWx1ZTogMSB9LFxuICAgIHsgem9vbTogbyAtIDAuMjUsIHZhbHVlOiAxIH0sXG4gICAgeyB6b29tOiBvLCB2YWx1ZTogMCB9XG4gIF07XG4gIGxldCBsID0gQXJyYXkuaXNBcnJheShlLmNvbG9yUmFtcCkgPyBlLmNvbG9yUmFtcCA6IFhvLlRVUkJPLnRyYW5zcGFyZW50U3RhcnQoKTtcbiAgY29uc3QgdSA9IGwuZ2V0Qm91bmRzKCk7XG4gICh1Lm1pbiAhPT0gMCB8fCB1Lm1heCAhPT0gMSkgJiYgKGwgPSBsLnNjYWxlKDAsIDEpKSwgbC5oYXNUcmFuc3BhcmVudFN0YXJ0KCkgfHwgKGwgPSBsLnRyYW5zcGFyZW50U3RhcnQoKSk7XG4gIGNvbnN0IGMgPSBlLmludGVuc2l0eSA/PyBbXG4gICAgeyB6b29tOiAwLCB2YWx1ZTogMC4wMSB9LFxuICAgIHsgem9vbTogNCwgdmFsdWU6IDAuMiB9LFxuICAgIHsgem9vbTogMTYsIHZhbHVlOiAxIH1cbiAgXSwgcCA9IGUucHJvcGVydHkgPz8gbnVsbCwgZCA9IGUud2VpZ2h0ID8/IDE7XG4gIGxldCBmID0gMTtcbiAgcCA/IHR5cGVvZiBkID09IFwibnVtYmVyXCIgPyAoZiA9IGQsIHR5cGVvZiBlLndlaWdodCA9PSBcIm51bWJlclwiICYmIGNvbnNvbGUud2FybihcIlRoZSBvcHRpb24gYC5wcm9wZXJ0eWAgaXMgaWdub3JlZCB3aGVuIGAucHJvcGVydHlWYWx1ZVdlaWdodHNgIGlzIG5vdCBvZiB0eXBlIGBQcm9wZXJ0eVZhbHVlV2VpZ2h0c2BcIikpIDogQXJyYXkuaXNBcnJheShkKSA/IGYgPSBHbyhkLCBwKSA6IGNvbnNvbGUud2FybihcIlRoZSBvcHRpb24gYC5wcm9wZXJ0eWAgaXMgaWdub3JlZCB3aGVuIGAucHJvcGVydHlWYWx1ZVdlaWdodHNgIGlzIG5vdCBvZiB0eXBlIGBQcm9wZXJ0eVZhbHVlV2VpZ2h0c2BcIikgOiB0eXBlb2YgZCA9PSBcIm51bWJlclwiID8gZiA9IGQgOiBBcnJheS5pc0FycmF5KGQpICYmIGNvbnNvbGUud2FybihcIlRoZSBvcHRpb25zIGAucHJvcGVydHlWYWx1ZVdlaWdodHNgIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBgLnByb3BlcnR5YCBpcyBwcm92aWRlZC5cIik7XG4gIGNvbnN0IGggPSBbXG4gICAgeyB6b29tOiAwLCB2YWx1ZTogNTAgKiAwLjAyNSB9LFxuICAgIHsgem9vbTogMiwgdmFsdWU6IDUwICogMC4wNSB9LFxuICAgIHsgem9vbTogNCwgdmFsdWU6IDUwICogMC4xIH0sXG4gICAgeyB6b29tOiA4LCB2YWx1ZTogNTAgKiAwLjI1IH0sXG4gICAgeyB6b29tOiAxNiwgdmFsdWU6IDUwIH1cbiAgXSwgbSA9IGUucmFkaXVzID8/IChpID8gaCA6IDEwKTtcbiAgbGV0IHkgPSAxO1xuICB0eXBlb2YgbSA9PSBcIm51bWJlclwiID8geSA9IG0gOiBBcnJheS5pc0FycmF5KG0pICYmIFwiem9vbVwiIGluIG1bMF0gPyB5ID0gRihtKSA6IHAgJiYgQXJyYXkuaXNBcnJheShtKSAmJiBcInByb3BlcnR5VmFsdWVcIiBpbiBtWzBdID8geSA9IEhvKG0sIHAsIGkpIDogIXAgJiYgQXJyYXkuaXNBcnJheShtKSAmJiBcInByb3BlcnR5VmFsdWVcIiBpbiBtWzBdID8gKHkgPSBGKGgpLCBjb25zb2xlLndhcm4oXCJUaGUgb3B0aW9uIGAucmFkaXVzYCBjYW4gb25seSBiZSBwcm9wZXJ0eS1kcml2ZW4gaWYgdGhlIG9wdGlvbiBgLnByb3BlcnR5YCBpcyBwcm92aWRlZC5cIikpIDogeSA9IEYoaCk7XG4gIGNvbnN0IHcgPSB7XG4gICAgaGVhdG1hcExheWVySWQ6IG4sXG4gICAgaGVhdG1hcFNvdXJjZUlkOiB0XG4gIH07XG4gIGlmIChlLmRhdGEgJiYgIXIuZ2V0U291cmNlKHQpKSB7XG4gICAgbGV0IGcgPSBlLmRhdGE7XG4gICAgdHlwZW9mIGcgPT0gXCJzdHJpbmdcIiAmJiBZdChnKSAmJiAoZyA9IGBodHRwczovL2FwaS5tYXB0aWxlci5jb20vZGF0YS8ke2d9L2ZlYXR1cmVzLmpzb24/a2V5PSR7ai5hcGlLZXl9YCksIHIuYWRkU291cmNlKHQsIHtcbiAgICAgIHR5cGU6IFwiZ2VvanNvblwiLFxuICAgICAgZGF0YTogZ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByLmFkZExheWVyKFxuICAgIHtcbiAgICAgIGlkOiBuLFxuICAgICAgdHlwZTogXCJoZWF0bWFwXCIsXG4gICAgICBzb3VyY2U6IHQsXG4gICAgICBtaW56b29tOiBhLFxuICAgICAgbWF4em9vbTogbyxcbiAgICAgIHBhaW50OiB7XG4gICAgICAgIFwiaGVhdG1hcC13ZWlnaHRcIjogZixcbiAgICAgICAgXCJoZWF0bWFwLWludGVuc2l0eVwiOiB0eXBlb2YgYyA9PSBcIm51bWJlclwiID8gYyA6IEYoYyksXG4gICAgICAgIFwiaGVhdG1hcC1jb2xvclwiOiBabyhsKSxcbiAgICAgICAgXCJoZWF0bWFwLXJhZGl1c1wiOiB5LFxuICAgICAgICBcImhlYXRtYXAtb3BhY2l0eVwiOiB0eXBlb2YgcyA9PSBcIm51bWJlclwiID8gcyA6IEYocylcbiAgICAgIH1cbiAgICB9LFxuICAgIGUuYmVmb3JlSWRcbiAgKSwgdztcbn1cbmNvbnN0IFFjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWRkSGVhdG1hcDogU2MsXG4gIGFkZFBvaW50OiB3YyxcbiAgYWRkUG9seWdvbjogYmMsXG4gIGFkZFBvbHlsaW5lOiBnYyxcbiAgY29sb3JEcml2ZW5CeVByb3BlcnR5OiBXcixcbiAgY29sb3JQYWxldHRlczogS3IsXG4gIGNvbXB1dGVSYW1wZWRPdXRsaW5lV2lkdGg6IFZvLFxuICBkYXNoQXJyYXlNYWtlcjogQW4sXG4gIGdlbmVyYXRlUmFuZG9tTGF5ZXJOYW1lOiBNdCxcbiAgZ2VuZXJhdGVSYW5kb21Tb3VyY2VOYW1lOiBJdCxcbiAgZ2V0UmFuZG9tQ29sb3I6IGRyLFxuICBoZWF0bWFwSW50ZW5zaXR5RnJvbUNvbG9yUmFtcDogWm8sXG4gIGxlcnBab29tTnVtYmVyVmFsdWVzOiBZcixcbiAgb3BhY2l0eURyaXZlbkJ5UHJvcGVydHk6IFFyLFxuICBwYWludENvbG9yT3B0aW9uc1RvUGFpbnRTcGVjOiBGZSxcbiAgcmFkaXVzRHJpdmVuQnlQcm9wZXJ0eTogSnIsXG4gIHJhZGl1c0RyaXZlbkJ5UHJvcGVydHlIZWF0bWFwOiBIbyxcbiAgcmFtcGVkT3B0aW9uc1RvTGF5ZXJQYWludFNwZWM6IEYsXG4gIHJhbXBlZFByb3BlcnR5VmFsdWVXZWlnaHQ6IEdvLFxuICB0YWtlU2NyZWVuc2hvdDogaGNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG53aSgpO1xuZnVuY3Rpb24geGMoKSB7XG4gIHJldHVybiBcIjMuOC4wXCI7XG59XG5jb25zdCBlcCA9IEwuTWFwLCB0cCA9IEwuTWFya2VyLCBycCA9IEwuUG9wdXAsIG5wID0gTC5TdHlsZSwgYXAgPSBMLkNhbnZhc1NvdXJjZSwgb3AgPSBMLkdlb0pTT05Tb3VyY2UsIGlwID0gTC5JbWFnZVNvdXJjZSwgc3AgPSBMLlJhc3RlclRpbGVTb3VyY2UsIGxwID0gTC5SYXN0ZXJERU1UaWxlU291cmNlLCB1cCA9IEwuVmVjdG9yVGlsZVNvdXJjZSwgY3AgPSBMLlZpZGVvU291cmNlLCBwcCA9IEwuTmF2aWdhdGlvbkNvbnRyb2wsIGZwID0gTC5HZW9sb2NhdGVDb250cm9sLCBkcCA9IEwuQXR0cmlidXRpb25Db250cm9sLCBocCA9IEwuTG9nb0NvbnRyb2wsIG1wID0gTC5TY2FsZUNvbnRyb2wsIHlwID0gTC5GdWxsc2NyZWVuQ29udHJvbCwgZ3AgPSBMLlRlcnJhaW5Db250cm9sLCB2cCA9IEwuQm94Wm9vbUhhbmRsZXIsIGJwID0gTC5TY3JvbGxab29tSGFuZGxlciwgd3AgPSBMLkNvb3BlcmF0aXZlR2VzdHVyZXNIYW5kbGVyLCBTcCA9IEwuS2V5Ym9hcmRIYW5kbGVyLCB4cCA9IEwuVHdvRmluZ2Vyc1RvdWNoUGl0Y2hIYW5kbGVyLCBrcCA9IEwuTWFwV2hlZWxFdmVudCwgTHAgPSBMLk1hcFRvdWNoRXZlbnQsIENwID0gTC5NYXBNb3VzZUV2ZW50LCBFcCA9IEwuY29uZmlnLCBBcCA9IEwuZ2V0VmVyc2lvbiwge1xuICBzZXRSVExUZXh0UGx1Z2luOiBUcCxcbiAgZ2V0UlRMVGV4dFBsdWdpblN0YXR1czogX3AsXG4gIExuZ0xhdDoga2MsXG4gIExuZ0xhdEJvdW5kczogSXAsXG4gIE1lcmNhdG9yQ29vcmRpbmF0ZTogZW4sXG4gIEV2ZW50ZWQ6IE1wLFxuICBBSkFYRXJyb3I6IFBwLFxuICBwcmV3YXJtOiBScCxcbiAgY2xlYXJQcmV3YXJtZWRSZXNvdXJjZXM6IHpwLFxuICBIYXNoOiBGcCxcbiAgUG9pbnQ6IEtvLFxuICBFZGdlSW5zZXRzOiAkcCxcbiAgRHJhZ1JvdGF0ZUhhbmRsZXI6IE9wLFxuICBEcmFnUGFuSGFuZGxlcjogTnAsXG4gIFR3b0ZpbmdlcnNUb3VjaFpvb21Sb3RhdGVIYW5kbGVyOiBqcCxcbiAgRG91YmxlQ2xpY2tab29tSGFuZGxlcjogVXAsXG4gIFR3b0ZpbmdlcnNUb3VjaFpvb21IYW5kbGVyOiBEcCxcbiAgVHdvRmluZ2Vyc1RvdWNoUm90YXRlSGFuZGxlcjogQnAsXG4gIGdldFdvcmtlckNvdW50OiBxcCxcbiAgc2V0V29ya2VyQ291bnQ6IFZwLFxuICBnZXRNYXhQYXJhbGxlbEltYWdlUmVxdWVzdHM6IEdwLFxuICBzZXRNYXhQYXJhbGxlbEltYWdlUmVxdWVzdHM6IEhwLFxuICBnZXRXb3JrZXJVcmw6IFpwLFxuICBzZXRXb3JrZXJVcmw6IFhwLFxuICBhZGRTb3VyY2VUeXBlOiBLcCxcbiAgaW1wb3J0U2NyaXB0SW5Xb3JrZXJzOiBZcCxcbiAgYWRkUHJvdG9jb2w6IFdwLFxuICByZW1vdmVQcm90b2NvbDogSnBcbn0gPSBMO1xuZXhwb3J0IHtcbiAgUHAgYXMgQUpBWEVycm9yLFxuICBCYyBhcyBBdHRyaWJ1dGlvbkNvbnRyb2wsXG4gIGRwIGFzIEF0dHJpYnV0aW9uQ29udHJvbE1MR0wsXG4gIFZjIGFzIEJveFpvb21IYW5kbGVyLFxuICB2cCBhcyBCb3hab29tSGFuZGxlck1MR0wsXG4gIEZjIGFzIENhbnZhc1NvdXJjZSxcbiAgYXAgYXMgQ2FudmFzU291cmNlTUxHTCxcbiAgQSBhcyBDb2xvclJhbXAsXG4gIFhvIGFzIENvbG9yUmFtcENvbGxlY3Rpb24sXG4gIEhjIGFzIENvb3BlcmF0aXZlR2VzdHVyZXNIYW5kbGVyLFxuICB3cCBhcyBDb29wZXJhdGl2ZUdlc3R1cmVzSGFuZGxlck1MR0wsXG4gIFVlIGFzIEN1YmVtYXBGYWNlTmFtZXMsXG4gIF91IGFzIEN1YmVtYXBJbWFnZXNQcmVzZXRzLFxuICBQciBhcyBDdWJlbWFwTGF5ZXIsXG4gIExlIGFzIERPTWNyZWF0ZSxcbiAga3QgYXMgRE9NcmVtb3ZlLFxuICBVcCBhcyBEb3VibGVDbGlja1pvb21IYW5kbGVyLFxuICBOcCBhcyBEcmFnUGFuSGFuZGxlcixcbiAgT3AgYXMgRHJhZ1JvdGF0ZUhhbmRsZXIsXG4gICRwIGFzIEVkZ2VJbnNldHMsXG4gIE1wIGFzIEV2ZW50ZWQsXG4gIEZpIGFzIEZ1bGxzY3JlZW5Db250cm9sLFxuICB5cCBhcyBGdWxsc2NyZWVuQ29udHJvbE1MR0wsXG4gICRjIGFzIEdlb0pTT05Tb3VyY2UsXG4gIG9wIGFzIEdlb0pTT05Tb3VyY2VNTEdMLFxuICBQaSBhcyBHZW9sb2NhdGVDb250cm9sLFxuICBmcCBhcyBHZW9sb2NhdGVDb250cm9sTUxHTCxcbiAgcXUgYXMgR2VvbG9jYXRpb25UeXBlLFxuICBGcCBhcyBIYXNoLFxuICBPYyBhcyBJbWFnZVNvdXJjZSxcbiAgaXAgYXMgSW1hZ2VTb3VyY2VNTEdMLFxuICBKYyBhcyBJbWFnZVZpZXdlcixcbiAgYWUgYXMgSW1hZ2VWaWV3ZXJFdmVudCxcbiAgWmMgYXMgS2V5Ym9hcmRIYW5kbGVyLFxuICBTcCBhcyBLZXlib2FyZEhhbmRsZXJNTEdMLFxuICB6IGFzIExhbmd1YWdlLFxuICBrYyBhcyBMbmdMYXQsXG4gIElwIGFzIExuZ0xhdEJvdW5kcyxcbiAgUmkgYXMgTG9nb0NvbnRyb2wsXG4gIGhwIGFzIExvZ29Db250cm9sTUxHTCxcbiAgTG8gYXMgTWFwLFxuICBlcCBhcyBNYXBNTEdMLFxuICBXYyBhcyBNYXBNb3VzZUV2ZW50LFxuICBDcCBhcyBNYXBNb3VzZUV2ZW50TUxHTCxcbiAgdGYgYXMgTWFwU3R5bGUsXG4gIHJmIGFzIE1hcFN0eWxlVmFyaWFudCxcbiAgWWMgYXMgTWFwVG91Y2hFdmVudCxcbiAgTHAgYXMgTWFwVG91Y2hFdmVudE1MR0wsXG4gIEtjIGFzIE1hcFdoZWVsRXZlbnQsXG4gIGtwIGFzIE1hcFdoZWVsRXZlbnRNTEdMLFxuICB0dSBhcyBNYXB0aWxlckN1c3RvbUNvbnRyb2wsXG4gIEdyIGFzIE1hcHRpbGVyRXh0ZXJuYWxDb250cm9sLFxuICBldSBhcyBNYXB0aWxlckdlb2xvY2F0ZUNvbnRyb2wsXG4gIE5uIGFzIE1hcHRpbGVyTG9nb0NvbnRyb2wsXG4gIEpsIGFzIE1hcHRpbGVyTmF2aWdhdGlvbkNvbnRyb2wsXG4gIHJ1IGFzIE1hcHRpbGVyUHJvamVjdGlvbkNvbnRyb2wsXG4gIFdsIGFzIE1hcHRpbGVyVGVycmFpbkNvbnRyb2wsXG4gIE1jIGFzIE1hcmtlcixcbiAgdHAgYXMgTWFya2VyTUxHTCxcbiAgZW4gYXMgTWVyY2F0b3JDb29yZGluYXRlLFxuICBwcCBhcyBOYXZpZ2F0aW9uQ29udHJvTUxHTCxcbiAgTWEgYXMgTmF2aWdhdGlvbkNvbnRyb2wsXG4gIEtvIGFzIFBvaW50LFxuICBSYyBhcyBQb3B1cCxcbiAgcnAgYXMgUG9wdXBNTEdMLFxuICBSciBhcyBSYWRpYWxHcmFkaWVudExheWVyLFxuICBqYyBhcyBSYXN0ZXJERU1UaWxlU291cmNlLFxuICBscCBhcyBSYXN0ZXJERU1UaWxlU291cmNlTUxHTCxcbiAgTmMgYXMgUmFzdGVyVGlsZVNvdXJjZSxcbiAgc3AgYXMgUmFzdGVyVGlsZVNvdXJjZU1MR0wsXG4gIG5mIGFzIFJlZmVyZW5jZU1hcFN0eWxlLFxuICB6aSBhcyBTY2FsZUNvbnRyb2wsXG4gIG1wIGFzIFNjYWxlQ29udHJvbE1MR0wsXG4gIEdjIGFzIFNjcm9sbFpvb21IYW5kbGVyLFxuICBicCBhcyBTY3JvbGxab29tSGFuZGxlck1MR0wsXG4gIGRpIGFzIFNka0NvbmZpZyxcbiAgYWYgYXMgU2VydmljZUVycm9yLFxuICB6YyBhcyBTdHlsZSxcbiAgbnAgYXMgU3R5bGVNTEdMLFxuICBncCBhcyBUZXJyYWluQ29udHJvTUxHTCxcbiAgcWMgYXMgVGVycmFpbkNvbnRyb2wsXG4gIFhjIGFzIFR3b0ZpbmdlcnNUb3VjaFBpdGNoSGFuZGxlcixcbiAgeHAgYXMgVHdvRmluZ2Vyc1RvdWNoUGl0Y2hIYW5kbGVyTUxHTCxcbiAgQnAgYXMgVHdvRmluZ2Vyc1RvdWNoUm90YXRlSGFuZGxlcixcbiAgRHAgYXMgVHdvRmluZ2Vyc1RvdWNoWm9vbUhhbmRsZXIsXG4gIGpwIGFzIFR3b0ZpbmdlcnNUb3VjaFpvb21Sb3RhdGVIYW5kbGVyLFxuICBVYyBhcyBWZWN0b3JUaWxlU291cmNlLFxuICB1cCBhcyBWZWN0b3JUaWxlU291cmNlTUxHTCxcbiAgRGMgYXMgVmlkZW9Tb3VyY2UsXG4gIGNwIGFzIFZpZGVvU291cmNlTUxHTCxcbiAgV3AgYXMgYWRkUHJvdG9jb2wsXG4gIEtwIGFzIGFkZFNvdXJjZVR5cGUsXG4gIG9mIGFzIGFyZVNhbWVMYW5ndWFnZXMsXG4gIHNmIGFzIGJ1ZmZlclRvUGl4ZWxEYXRhQnJvd3NlcixcbiAgbGYgYXMgY2FuUGFyc2VQaXhlbERhdGEsXG4gIHVmIGFzIGNpcmN1bWZlcmVuY2VBdExhdGl0dWRlLFxuICB6cCBhcyBjbGVhclByZXdhcm1lZFJlc291cmNlcyxcbiAgaiBhcyBjb25maWcsXG4gIEVwIGFzIGNvbmZpZ01MR0wsXG4gIGNmIGFzIGNvb3JkaW5hdGVzLFxuICBIZSBhcyBjdWJlbWFwUHJlc2V0cyxcbiAgcGYgYXMgZGF0YSxcbiAgSWMgYXMgZGlzcGxheVdlYkdMQ29udGV4dExvc3RXYXJuaW5nLFxuICBmZiBhcyBlbGV2YXRpb24sXG4gIGRmIGFzIGV4cGFuZE1hcFN0eWxlLFxuICBoZiBhcyBnZW9jb2RpbmcsXG4gIG1mIGFzIGdlb2xvY2F0aW9uLFxuICB5ZiBhcyBnZXRBdXRvTGFuZ3VhZ2UsXG4gIFBuIGFzIGdldEJyb3dzZXJMYW5ndWFnZSxcbiAgZ2YgYXMgZ2V0QnVmZmVyVG9QaXhlbERhdGFQYXJzZXIsXG4gIHZmIGFzIGdldExhbmd1YWdlSW5mb0Zyb21Db2RlLFxuICBiZiBhcyBnZXRMYW5ndWFnZUluZm9Gcm9tRmxhZyxcbiAgd2YgYXMgZ2V0TGFuZ3VhZ2VJbmZvRnJvbUtleSxcbiAgQXAgYXMgZ2V0TWFwTGlicmVWZXJzaW9uLFxuICBHcCBhcyBnZXRNYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMsXG4gIF9wIGFzIGdldFJUTFRleHRQbHVnaW5TdGF0dXMsXG4gIFNmIGFzIGdldFRpbGVDYWNoZSxcbiAgeGMgYXMgZ2V0VmVyc2lvbixcbiAga2kgYXMgZ2V0V2ViR0xTdXBwb3J0RXJyb3IsXG4gIHFwIGFzIGdldFdvcmtlckNvdW50LFxuICBacCBhcyBnZXRXb3JrZXJVcmwsXG4gIE9vIGFzIGdweCxcbiAgZGMgYXMgZ3B4T3JLbWwsXG4gICRvIGFzIGhhc0NoaWxkTm9kZVdpdGhOYW1lLFxuICBRYyBhcyBoZWxwZXJzLFxuICBZcCBhcyBpbXBvcnRTY3JpcHRJbldvcmtlcnMsXG4gIHhmIGFzIGlzTGFuZ3VhZ2VJbmZvLFxuICBObyBhcyBrbWwsXG4gIGtmIGFzIG1hcFN0eWxlUHJlc2V0TGlzdCxcbiAgTGYgYXMgbWF0aCxcbiAgQ2YgYXMgbWlzYyxcbiAgUnAgYXMgcHJld2FybSxcbiAgSnAgYXMgcmVtb3ZlUHJvdG9jb2wsXG4gIEhwIGFzIHNldE1heFBhcmFsbGVsSW1hZ2VSZXF1ZXN0cyxcbiAgVHAgYXMgc2V0UlRMVGV4dFBsdWdpbixcbiAgVnAgYXMgc2V0V29ya2VyQ291bnQsXG4gIFhwIGFzIHNldFdvcmtlclVybCxcbiAgRWYgYXMgc3RhdGljTWFwcyxcbiAgQ24gYXMgc3RyMnhtbCxcbiAgQWYgYXMgc3R5bGVUb1N0eWxlLFxuICBUZiBhcyB0b0xhbmd1YWdlSW5mbyxcbiAgdm8gYXMgdG9nZ2xlUHJvamVjdGlvbixcbiAgZ28gYXMgdG9nZ2xlVGVycmFpbixcbiAgTGEgYXMgeG1sMnN0clxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcHRpbGVyLXNkay5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs\n");

/***/ })

};
;