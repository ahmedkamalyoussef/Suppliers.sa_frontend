"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/manage-businesses/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },\n/* harmony export */   apiService: function() { return /* binding */ apiService; }\n/* harmony export */ });\n// services/api.ts\nconst API_BASE_URL = \"http://localhost:8000\";\nclass ValidationError extends Error {\n    constructor(message, errors){\n        super(message);\n        this.name = \"ValidationError\";\n        this.errors = errors;\n    }\n}\nclass ApiService {\n    // ====== REQUEST WRAPPER ======\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, requiresAuth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        // Convert HeadersInit to Record<string, string>\n        const optionsHeaders = {};\n        if (options.headers) {\n            if (options.headers instanceof Headers) {\n                options.headers.forEach((value, key)=>{\n                    optionsHeaders[key] = value;\n                });\n            } else if (Array.isArray(options.headers)) {\n                options.headers.forEach((param)=>{\n                    let [key, value] = param;\n                    optionsHeaders[key] = value;\n                });\n            } else {\n                Object.assign(optionsHeaders, options.headers);\n            }\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n            ...optionsHeaders\n        };\n        if (requiresAuth) {\n            const token = localStorage.getItem(\"supplier_token\");\n            const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n            if (!token) throw new Error(\"No auth token found\");\n            headers[\"Authorization\"] = \"\".concat(tokenType, \" \").concat(token);\n        }\n        const response = await fetch(url, {\n            ...options,\n            credentials: \"include\",\n            headers\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            // Enhanced logging for debugging\n            console.error(\"API Error \".concat(response.status, \":\"), {\n                url,\n                method: options.method || \"GET\",\n                errorData,\n                headers\n            });\n            if (response.status === 422) {\n                const validationError = new ValidationError(\"Validation failed\", errorData.errors || errorData);\n                // Log detailed validation errors\n                console.error(\"Validation Errors:\", validationError.errors);\n                console.error(\"Error data:\", errorData);\n                // Log password validation specifically\n                if (errorData.password) {\n                    console.error(\"Password validation errors:\", errorData.password);\n                }\n                throw validationError;\n            }\n            throw new Error(errorData.message || \"HTTP error \".concat(response.status));\n        }\n        return await response.json();\n    }\n    // ====== API METHODS ======\n    async registerSupplier(data) {\n        return this.request(\"/api/supplier/register\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async login(data) {\n        const response = await this.request(\"/api/auth/login\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async logout() {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/logout\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({\n                    message: \"Logout failed\"\n                }));\n            throw new Error(error.message || \"Logout failed\");\n        }\n        // Clear localStorage after successful logout\n        localStorage.removeItem(\"supplier_token\");\n        localStorage.removeItem(\"token_type\");\n        localStorage.removeItem(\"supplier_user\");\n    }\n    async forgotPassword(data) {\n        return this.request(\"/api/auth/forgot-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async resetPassword(data) {\n        return this.request(\"/api/auth/reset-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async sendOtp(data) {\n        return this.request(\"/api/auth/send-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async verifyOtp(data) {\n        const response = await this.request(\"/api/auth/verify-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async updateProfile(data) {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"PATCH\",\n            body: JSON.stringify(data)\n        }, true); // requiresAuth = true\n    }\n    async updateProfileWithFormData(formData) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile\"), {\n            method: \"PATCH\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            // Enhanced logging for debugging\n            console.error(\"API Error \".concat(response.status, \":\"), {\n                url: \"\".concat(this.baseURL, \"/api/supplier/profile\"),\n                method: \"PATCH\",\n                errorData\n            });\n            if (response.status === 422) {\n                console.error(\"Validation Errors:\", errorData.errors || errorData);\n                throw new ValidationError(errorData.message || \"Validation failed\", errorData.errors || errorData);\n            }\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async getProfile() {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"GET\"\n        }, true);\n    }\n    async uploadDocument(file) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const formData = new FormData();\n        formData.append(\"document\", file);\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/documents\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData,\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            console.error(\"Document upload error:\", errorData);\n            throw new Error(errorData.message || \"Failed to upload document\");\n        }\n        return await response.json();\n    }\n    async uploadProfileImage(file) {\n        const formData = new FormData();\n        formData.append(\"profile_image\", file);\n        // Create headers object\n        const headers = new Headers();\n        // Don't set Content-Type header, let the browser set it with the correct boundary\n        // Get the auth token\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile/image\"), {\n                method: \"POST\",\n                headers,\n                body: formData,\n                credentials: \"include\"\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                throw new Error(data.message || \"Failed to upload profile image\");\n            }\n            // Update user data in localStorage\n            if (data.supplier) {\n                localStorage.setItem(\"supplier_user\", JSON.stringify(data.supplier));\n            }\n            return {\n                success: true,\n                message: data.message || \"تم تحديث صورة الملف الشخصي بنجاح\",\n                supplier: data.supplier\n            };\n        } catch (error) {\n            console.error(\"Error uploading profile image:\", error);\n            throw error;\n        }\n    }\n    // ====== HELPERS ======\n    isAuthenticated() {\n        return !!localStorage.getItem(\"supplier_token\");\n    }\n    constructor(){\n        this.baseURL = API_BASE_URL;\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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STlCLE1BQU15QyxLQUFLdkMsT0FBTyxJQUFJO1lBQ2xDO1lBRUEsbUNBQW1DO1lBQ25DLElBQUl1QyxLQUFLd0IsUUFBUSxFQUFFO2dCQUNqQnpDLGFBQWF1QixPQUFPLENBQUMsaUJBQWlCSixLQUFLQyxTQUFTLENBQUNILEtBQUt3QixRQUFRO1lBQ3BFO1lBRUEsT0FBTztnQkFDTEMsU0FBUztnQkFDVGhFLFNBQVN1QyxLQUFLdkMsT0FBTyxJQUFJO2dCQUN6QitELFVBQVV4QixLQUFLd0IsUUFBUTtZQUN6QjtRQUNGLEVBQUUsT0FBTzlCLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsd0JBQXdCO0lBQ3hCZ0Msa0JBQTJCO1FBQ3pCLE9BQU8sQ0FBQyxDQUFDM0MsYUFBYUMsT0FBTyxDQUFDO0lBQ2hDO0lBdFRBeEIsYUFBYztRQUNaLElBQUksQ0FBQ1UsT0FBTyxHQUFHYjtJQUNqQjtBQXFURjtBQUVPLE1BQU1zRSxhQUFhLElBQUkvRCxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2aWNlcy9hcGkudHNcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cmF0aW9uRGF0YSB7XG4gIGJ1c2luZXNzTmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBwYXNzd29yZF9jb25maXJtYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RyYXRpb25SZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgc3VwcGxpZXI6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kT3RwUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5T3RwUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG90cDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcmdvdFBhc3N3b3JkUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzZXRQYXNzd29yZFJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xuICBvdHA6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcGFzc3dvcmRfY29uZmlybWF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5SZXF1ZXN0IHtcbiAgZW1haWw6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpblJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB1c2VyVHlwZTogc3RyaW5nO1xuICBzdXBwbGllcjoge1xuICAgIGlkOiBudW1iZXI7XG4gICAgc2x1Zzogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBob25lOiBzdHJpbmc7XG4gICAgcHJvZmlsZUltYWdlOiBzdHJpbmc7XG4gICAgZW1haWxWZXJpZmllZEF0OiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgcGxhbjogc3RyaW5nO1xuICAgIHByb2ZpbGVDb21wbGV0aW9uOiBudW1iZXI7XG4gICAgcHJvZmlsZTogYW55O1xuICAgIGJyYW5jaGVzOiBhbnlbXTtcbiAgfTtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgdG9rZW5UeXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3RwUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIHN1cHBsaWVyPzogYW55O1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgdG9rZW5UeXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGVVcGRhdGVEYXRhIHtcbiAgYnVzaW5lc3NOYW1lPzogc3RyaW5nO1xuICBidXNpbmVzc1R5cGU/OiBzdHJpbmc7XG4gIGNhdGVnb3JpZXM/OiBzdHJpbmdbXTtcbiAgcHJvZHVjdEtleXdvcmRzPzogc3RyaW5nW107XG4gIHdob0RvWW91U2VydmU/OiBzdHJpbmc7XG4gIHNlcnZpY2VEaXN0YW5jZT86IG51bWJlcjtcbiAgc2VydmljZXM/OiBzdHJpbmdbXTtcbiAgd2Vic2l0ZT86IHN0cmluZztcbiAgbWFpblBob25lPzogc3RyaW5nO1xuICBhZGRpdGlvbmFsUGhvbmVzPzogQXJyYXk8e1xuICAgIG51bWJlcjogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG4gIH0+O1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBsb2NhdGlvbj86IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH07XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB3b3JraW5nSG91cnM/OiB7XG4gICAgW2tleTogc3RyaW5nXToge1xuICAgICAgY2xvc2VkPzogYm9vbGVhbjtcbiAgICAgIG9wZW4/OiBzdHJpbmc7XG4gICAgICBjbG9zZT86IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBoYXNCcmFuY2hlcz86IGJvb2xlYW47XG4gIGJyYW5jaGVzPzogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBwaG9uZT86IHN0cmluZztcbiAgICBlbWFpbD86IHN0cmluZztcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIG1hbmFnZXI/OiBzdHJpbmc7XG4gICAgbG9jYXRpb24/OiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9O1xuICAgIHdvcmtpbmdIb3Vycz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgICAgY2xvc2VkPzogYm9vbGVhbjtcbiAgICAgICAgb3Blbj86IHN0cmluZztcbiAgICAgICAgY2xvc2U/OiBzdHJpbmc7XG4gICAgICB9O1xuICAgIH07XG4gICAgc3BlY2lhbFNlcnZpY2VzPzogc3RyaW5nW107XG4gICAgaXNNYWluQnJhbmNoPzogYm9vbGVhbjtcbiAgfT47XG4gIGNvbnRhY3RFbWFpbD86IHN0cmluZzsgLy8gRnJvbSB2ZXJpZmljYXRpb24vbG9naW5cbiAgY29udGFjdFBob25lPzogc3RyaW5nOyAvLyBGcm9tIHZlcmlmaWNhdGlvbi9sb2dpblxuICBkb2N1bWVudD86IEZpbGU7IC8vIEluY2x1ZGUgZG9jdW1lbnQgaW4gbWFpbiByZXF1ZXN0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZmlsZVVwZGF0ZVJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBzdXBwbGllcjogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50VXBsb2FkUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcGlFcnJvciB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgZXJyb3JzOiBBcGlFcnJvcjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGVycm9yczogQXBpRXJyb3IpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlZhbGlkYXRpb25FcnJvclwiO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICB9XG59XG5cbmNsYXNzIEFwaVNlcnZpY2Uge1xuICBwcml2YXRlIGJhc2VVUkw6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhc2VVUkwgPSBBUElfQkFTRV9VUkw7XG4gIH1cblxuICAvLyA9PT09PT0gUkVRVUVTVCBXUkFQUEVSID09PT09PVxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9LFxuICAgIHJlcXVpcmVzQXV0aDogYm9vbGVhbiA9IGZhbHNlXG4gICk6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVSTH0ke2VuZHBvaW50fWA7XG5cbiAgICAvLyBDb252ZXJ0IEhlYWRlcnNJbml0IHRvIFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICBjb25zdCBvcHRpb25zSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgb3B0aW9uc0hlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBvcHRpb25zSGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zSGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4ub3B0aW9uc0hlYWRlcnMsXG4gICAgfTtcblxuICAgIGlmIChyZXF1aXJlc0F1dGgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuICAgICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYCR7dG9rZW5UeXBlfSAke3Rva2VufWA7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuXG4gICAgICAvLyBFbmhhbmNlZCBsb2dnaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFQSSBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306YCwge1xuICAgICAgICB1cmwsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgZXJyb3JEYXRhLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyMikge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgIFwiVmFsaWRhdGlvbiBmYWlsZWRcIixcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3JzIHx8IGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgICAvLyBMb2cgZGV0YWlsZWQgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlZhbGlkYXRpb24gRXJyb3JzOlwiLCB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRhdGE6XCIsIGVycm9yRGF0YSk7XG4gICAgICAgIC8vIExvZyBwYXNzd29yZCB2YWxpZGF0aW9uIHNwZWNpZmljYWxseVxuICAgICAgICBpZiAoZXJyb3JEYXRhLnBhc3N3b3JkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlBhc3N3b3JkIHZhbGlkYXRpb24gZXJyb3JzOlwiLCBlcnJvckRhdGEucGFzc3dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHZhbGlkYXRpb25FcnJvcjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQIGVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICAvLyA9PT09PT0gQVBJIE1FVEhPRFMgPT09PT09XG4gIGFzeW5jIHJlZ2lzdGVyU3VwcGxpZXIoXG4gICAgZGF0YTogUmVnaXN0cmF0aW9uRGF0YVxuICApOiBQcm9taXNlPFJlZ2lzdHJhdGlvblJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvc3VwcGxpZXIvcmVnaXN0ZXJcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgbG9naW4oZGF0YTogTG9naW5SZXF1ZXN0KTogUHJvbWlzZTxMb2dpblJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3Q8TG9naW5SZXNwb25zZT4oXCIvYXBpL2F1dGgvbG9naW5cIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLmFjY2Vzc1Rva2VuKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIsIHJlc3BvbnNlLmFjY2Vzc1Rva2VuKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidG9rZW5fdHlwZVwiLCByZXNwb25zZS50b2tlblR5cGUgfHwgXCJCZWFyZXJcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgYXN5bmMgbG9nb3V0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcblxuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2F1dGgvbG9nb3V0YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2VcbiAgICAgICAgLmpzb24oKVxuICAgICAgICAuY2F0Y2goKCkgPT4gKHsgbWVzc2FnZTogXCJMb2dvdXQgZmFpbGVkXCIgfSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgXCJMb2dvdXQgZmFpbGVkXCIpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZSBhZnRlciBzdWNjZXNzZnVsIGxvZ291dFxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ0b2tlbl90eXBlXCIpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwic3VwcGxpZXJfdXNlclwiKTtcbiAgfVxuXG4gIGFzeW5jIGZvcmdvdFBhc3N3b3JkKFxuICAgIGRhdGE6IEZvcmdvdFBhc3N3b3JkUmVxdWVzdFxuICApOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9hdXRoL2ZvcmdvdC1wYXNzd29yZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXNldFBhc3N3b3JkKFxuICAgIGRhdGE6IFJlc2V0UGFzc3dvcmRSZXF1ZXN0XG4gICk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvYXBpL2F1dGgvcmVzZXQtcGFzc3dvcmRcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZE90cChkYXRhOiBTZW5kT3RwUmVxdWVzdCk6IFByb21pc2U8T3RwUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9hdXRoL3NlbmQtb3RwXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeU90cChkYXRhOiBWZXJpZnlPdHBSZXF1ZXN0KTogUHJvbWlzZTxPdHBSZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0PE90cFJlc3BvbnNlPihcIi9hcGkvYXV0aC92ZXJpZnktb3RwXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmIChyZXNwb25zZS5hY2Nlc3NUb2tlbikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiLCByZXNwb25zZS5hY2Nlc3NUb2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRva2VuX3R5cGVcIiwgcmVzcG9uc2UudG9rZW5UeXBlIHx8IFwiQmVhcmVyXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2ZpbGUoZGF0YTogUHJvZmlsZVVwZGF0ZURhdGEpOiBQcm9taXNlPFByb2ZpbGVVcGRhdGVSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvcHJvZmlsZVwiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7IC8vIHJlcXVpcmVzQXV0aCA9IHRydWVcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2ZpbGVXaXRoRm9ybURhdGEoXG4gICAgZm9ybURhdGE6IEZvcm1EYXRhXG4gICk6IFByb21pc2U8UHJvZmlsZVVwZGF0ZVJlc3BvbnNlPiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuXG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcHJvZmlsZWAsIHtcbiAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YCxcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IENvbnRlbnQtVHlwZSBmb3IgRm9ybURhdGEgLSBicm93c2VyIHNldHMgaXQgd2l0aCBib3VuZGFyeVxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuXG4gICAgICAvLyBFbmhhbmNlZCBsb2dnaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFQSSBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306YCwge1xuICAgICAgICB1cmw6IGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3Byb2ZpbGVgLFxuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgZXJyb3JEYXRhLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyMikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVmFsaWRhdGlvbiBFcnJvcnM6XCIsIGVycm9yRGF0YS5lcnJvcnMgfHwgZXJyb3JEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCBcIlZhbGlkYXRpb24gZmFpbGVkXCIsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9ycyB8fCBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyBnZXRQcm9maWxlKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9wcm9maWxlXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHVwbG9hZERvY3VtZW50KGZpbGU6IEZpbGUpOiBQcm9taXNlPERvY3VtZW50VXBsb2FkUmVzcG9uc2U+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJkb2N1bWVudFwiLCBmaWxlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvZG9jdW1lbnRzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICB9LFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRG9jdW1lbnQgdXBsb2FkIGVycm9yOlwiLCBlcnJvckRhdGEpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHVwbG9hZCBkb2N1bWVudFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgXG4gIGFzeW5jIHVwbG9hZFByb2ZpbGVJbWFnZShcbiAgICBmaWxlOiBGaWxlXG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmc7IHN1cHBsaWVyOiBhbnkgfT4ge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwicHJvZmlsZV9pbWFnZVwiLCBmaWxlKTtcblxuICAgIC8vIENyZWF0ZSBoZWFkZXJzIG9iamVjdFxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgaGVhZGVyLCBsZXQgdGhlIGJyb3dzZXIgc2V0IGl0IHdpdGggdGhlIGNvcnJlY3QgYm91bmRhcnlcblxuICAgIC8vIEdldCB0aGUgYXV0aCB0b2tlblxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7dG9rZW59YCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcHJvZmlsZS9pbWFnZWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBsb2FkIHByb2ZpbGUgaW1hZ2VcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB1c2VyIGRhdGEgaW4gbG9jYWxTdG9yYWdlXG4gICAgICBpZiAoZGF0YS5zdXBwbGllcikge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInN1cHBsaWVyX3VzZXJcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YS5zdXBwbGllcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBtZXNzYWdlOiBkYXRhLm1lc3NhZ2UgfHwgXCLYqtmFINiq2K3Yr9mK2Ksg2LXZiNix2Kkg2KfZhNmF2YTZgSDYp9mE2LTYrti12Yog2KjZhtis2KfYrVwiLFxuICAgICAgICBzdXBwbGllcjogZGF0YS5zdXBwbGllclxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBwcm9maWxlIGltYWdlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT0gSEVMUEVSUyA9PT09PT1cbiAgaXNBdXRoZW50aWNhdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFwaVNlcnZpY2UgPSBuZXcgQXBpU2VydmljZSgpO1xuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsIlZhbGlkYXRpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZXJyb3JzIiwibmFtZSIsIkFwaVNlcnZpY2UiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwicmVxdWlyZXNBdXRoIiwidXJsIiwiYmFzZVVSTCIsIm9wdGlvbnNIZWFkZXJzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJhc3NpZ24iLCJBY2NlcHQiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ0b2tlblR5cGUiLCJyZXNwb25zZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsImNvbnNvbGUiLCJlcnJvciIsInN0YXR1cyIsIm1ldGhvZCIsInZhbGlkYXRpb25FcnJvciIsInBhc3N3b3JkIiwicmVnaXN0ZXJTdXBwbGllciIsImRhdGEiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZ2luIiwiYWNjZXNzVG9rZW4iLCJzZXRJdGVtIiwibG9nb3V0IiwiQXV0aG9yaXphdGlvbiIsInJlbW92ZUl0ZW0iLCJmb3Jnb3RQYXNzd29yZCIsInJlc2V0UGFzc3dvcmQiLCJzZW5kT3RwIiwidmVyaWZ5T3RwIiwidXBkYXRlUHJvZmlsZSIsInVwZGF0ZVByb2ZpbGVXaXRoRm9ybURhdGEiLCJmb3JtRGF0YSIsInN0YXR1c1RleHQiLCJnZXRQcm9maWxlIiwidXBsb2FkRG9jdW1lbnQiLCJmaWxlIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJ1cGxvYWRQcm9maWxlSW1hZ2UiLCJzdXBwbGllciIsInN1Y2Nlc3MiLCJpc0F1dGhlbnRpY2F0ZWQiLCJhcGlTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});