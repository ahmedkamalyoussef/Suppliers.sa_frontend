"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/about/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },\n/* harmony export */   apiService: function() { return /* binding */ apiService; }\n/* harmony export */ });\n// services/api.ts\nconst API_BASE_URL = \"http://localhost:8000\";\nclass ValidationError extends Error {\n    constructor(message, errors){\n        super(message);\n        this.name = \"ValidationError\";\n        this.errors = errors;\n    }\n}\nclass ApiService {\n    // ====== REQUEST WRAPPER ======\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, requiresAuth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        console.log(\"[API] Preparing request to: \".concat(url), {\n            method: options.method || \"GET\"\n        });\n        // Convert HeadersInit to Record<string, string>\n        const optionsHeaders = {};\n        if (options.headers) {\n            if (options.headers instanceof Headers) {\n                options.headers.forEach((value, key)=>{\n                    optionsHeaders[key] = value;\n                });\n            } else if (Array.isArray(options.headers)) {\n                options.headers.forEach((param)=>{\n                    let [key, value] = param;\n                    optionsHeaders[key] = value;\n                });\n            } else {\n                Object.assign(optionsHeaders, options.headers);\n            }\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n            ...optionsHeaders\n        };\n        if (requiresAuth) {\n            const token = localStorage.getItem(\"supplier_token\");\n            const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n            console.log(\"[API] Auth check - Token exists:\", !!token);\n            if (!token) {\n                console.error(\"[API] No auth token found in localStorage\");\n                throw new Error(\"No auth token found\");\n            }\n            headers[\"Authorization\"] = \"\".concat(tokenType, \" \").concat(token);\n        }\n        console.log(\"[API] Request headers:\", headers);\n        if (options.body) {\n            console.log(\"[API] Request body:\", options.body);\n        }\n        try {\n            console.log(\"[API] Sending request...\");\n            const response = await fetch(url, {\n                ...options,\n                credentials: \"include\",\n                headers\n            });\n            console.log(\"[API] Received response: \".concat(response.status, \" \").concat(response.statusText));\n            // Clone the response to read it as text first (for logging)\n            const responseClone = response.clone();\n            const responseText = await response.text();\n            let responseData;\n            try {\n                responseData = JSON.parse(responseText);\n                console.log(\"[API] Response data:\", responseData);\n            } catch (e) {\n                console.log(\"[API] Non-JSON response:\", responseText);\n                responseData = {};\n            }\n            if (!response.ok) {\n                console.error(\"[API] Request failed with status \".concat(response.status, \":\"), {\n                    url,\n                    status: response.status,\n                    statusText: response.statusText,\n                    response: responseData\n                });\n                if (response.status === 422) {\n                    const validationError = new ValidationError(\"Validation failed\", responseData.errors || responseData);\n                    console.error(\"[API] Validation Errors:\", validationError.errors);\n                    throw validationError;\n                }\n                throw new Error(responseData.message || \"HTTP error \".concat(response.status));\n            }\n            return responseData;\n        } catch (error) {\n            console.error(\"[API] Request failed:\", error);\n            throw error;\n        }\n    }\n    // ====== SUPPLIER INQUIRIES ======\n    async sendInquiry(data) {\n        return this.request(\"/api/supplier/supplier-inquiries\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        }, true);\n    }\n    async replyToInquiry(inquiryId, data) {\n        return this.request(\"/api/supplier/supplier-inquiries/\".concat(inquiryId, \"/reply\"), {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        }, true);\n    }\n    async markInquiryAsRead(inquiryId) {\n        return this.request(\"/api/supplier/supplier-inquiries/\".concat(inquiryId, \"/read\"), {\n            method: \"POST\"\n        }, true);\n    }\n    async getInquiry(inquiryId) {\n        return this.request(\"/api/supplier/supplier-inquiries/\".concat(inquiryId), {\n            method: \"GET\"\n        }, true);\n    }\n    async getAllInquiries() {\n        return this.request(\"/api/supplier/supplier-inquiries\", {\n            method: \"GET\"\n        }, true);\n    }\n    // ====== API METHODS ======\n    async registerSupplier(data) {\n        return this.request(\"/api/supplier/register\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async login(data) {\n        const response = await this.request(\"/api/auth/login\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async logout() {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/logout\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({\n                    message: \"Logout failed\"\n                }));\n            throw new Error(error.message || \"Logout failed\");\n        }\n        // Clear localStorage after successful logout\n        localStorage.removeItem(\"supplier_token\");\n        localStorage.removeItem(\"token_type\");\n        localStorage.removeItem(\"supplier_user\");\n    }\n    async forgotPassword(data) {\n        return this.request(\"/api/auth/forgot-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async resetPassword(data) {\n        return this.request(\"/api/auth/reset-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async sendOtp(data) {\n        return this.request(\"/api/auth/send-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async verifyOtp(data) {\n        const response = await this.request(\"/api/auth/verify-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async getBusinesses(params) {\n        const queryParams = new URLSearchParams();\n        const options = {\n            method: \"GET\"\n        };\n        // Check if user is authenticated\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n            options.headers = {\n                ...options.headers,\n                Authorization: \"\".concat(tokenType, \" \").concat(token),\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\"\n            };\n        }\n        if (params) {\n            // Handle category separately to prevent double encoding\n            const { category, ...restParams } = params;\n            if (category) {\n                queryParams.append(\"category\", category);\n            }\n            // Handle the rest of the parameters\n            Object.entries(restParams).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined && value !== null) {\n                    if (Array.isArray(value)) {\n                        queryParams.append(key, value.join(\",\"));\n                    } else if (typeof value === \"boolean\") {\n                        queryParams.append(key, value ? \"1\" : \"0\");\n                    } else {\n                        queryParams.append(key, value.toString());\n                    }\n                }\n            });\n        }\n        return this.request(\"/api/public/businesses?\".concat(queryParams.toString()), {\n            method: \"GET\"\n        }, false // doesn't require auth\n        );\n    }\n    async updateProfile(data) {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"PATCH\",\n            body: JSON.stringify(data)\n        }, true); // requiresAuth = true\n    }\n    async updateProfileWithFormData(formData) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile\"), {\n            method: \"PATCH\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            // Enhanced logging for debugging\n            console.error(\"API Error \".concat(response.status, \":\"), {\n                url: \"\".concat(this.baseURL, \"/api/supplier/profile\"),\n                method: \"PATCH\",\n                errorData\n            });\n            if (response.status === 422) {\n                console.error(\"Validation Errors:\", errorData.errors || errorData);\n                throw new ValidationError(errorData.message || \"Validation failed\", errorData.errors || errorData);\n            }\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async getProfile() {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"GET\"\n        }, true);\n    }\n    async uploadDocument(file) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const formData = new FormData();\n        formData.append(\"document\", file);\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/documents\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData,\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            console.error(\"Document upload error:\", errorData);\n            throw new Error(errorData.message || \"Failed to upload document\");\n        }\n        return await response.json();\n    }\n    async uploadProfileImage(file) {\n        const formData = new FormData();\n        formData.append(\"profile_image\", file);\n        // Create headers object\n        const headers = new Headers();\n        // Don't set Content-Type header, let the browser set it with the correct boundary\n        // Get the auth token\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n        }\n        try {\n            var _responseData_data;\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile/image\"), {\n                method: \"POST\",\n                headers,\n                body: formData,\n                credentials: \"include\"\n            });\n            // First, check if the response is OK\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to upload image\");\n            }\n            // Try to parse the response as JSON\n            let responseData;\n            try {\n                responseData = await response.json();\n            } catch (e) {\n                // If parsing fails but the status is 200, consider it a success\n                if (response.status === 200) {\n                    return {\n                        success: true,\n                        data: {\n                            url: \"\"\n                        }\n                    }; // Return default success response\n                }\n                throw new Error(\"Failed to parse server response\");\n            }\n            // If we got here, the request was successful\n            // The backend might be returning the URL directly or in a data object\n            const imageUrl = responseData.url || ((_responseData_data = responseData.data) === null || _responseData_data === void 0 ? void 0 : _responseData_data.url) || \"\";\n            return {\n                success: true,\n                data: {\n                    url: imageUrl\n                }\n            };\n        } catch (error) {\n            console.error(\"API Error:\", error);\n            // Handle different types of errors\n            if (typeof error === \"object\" && error !== null) {\n                // Handle Fetch API Response errors\n                if (\"response\" in error && error.response && typeof error.response === \"object\" && error.response !== null) {\n                    try {\n                        // @ts-ignore - We've already checked the type\n                        const errorData = await error.response.json().catch(()=>({}));\n                        throw new Error(errorData.message || \"فشل في رفع الصورة\");\n                    } catch (e) {\n                        // If we can't parse the error response\n                        throw new Error(\"فشل في معالجة استجابة الخادم\");\n                    }\n                }\n                // Handle Error objects\n                if (error instanceof Error) {\n                    throw new Error(error.message || \"حدث خطأ أثناء رفع الصورة. يرجى المحاولة مرة أخرى.\");\n                }\n            }\n            // Default error\n            throw new Error(\"حدث خطأ غير متوقع. يرجى المحاولة مرة أخرى.\");\n        }\n    }\n    // ====== HELPERS ======\n    isAuthenticated() {\n        return !!localStorage.getItem(\"supplier_token\");\n    }\n    /**\n   * Fetches business profile for a specific supplier\n   * @param id The supplier ID\n   * @returns Promise with the supplier's business profile including products\n   */ async getBusinessProfile(id) {\n        const headers = new Headers();\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n            headers.append(\"Accept\", \"application/json\");\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/suppliers/\").concat(id, \"/business\"), {\n                method: \"GET\",\n                headers,\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to fetch business profile\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Error fetching business profile:\", error);\n            throw error;\n        }\n    }\n    async getSupplierProfile(id) {\n        const headers = new Headers();\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n            headers.append(\"Accept\", \"application/json\");\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/suppliers/\").concat(id), {\n                method: \"GET\",\n                headers,\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to fetch supplier profile\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Error fetching supplier profile:\", error);\n            throw error;\n        }\n    }\n    async submitReview(supplierId, rating, comment) {\n        const token = localStorage.getItem(\"supplier_token\");\n        if (!token) {\n            throw new Error(\"Authentication required\");\n        }\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/ratings\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"Bearer \".concat(token),\n                Accept: \"application/json\"\n            },\n            body: JSON.stringify({\n                rated_supplier_id: supplierId,\n                score: rating,\n                comment: comment\n            })\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({}));\n            throw new Error(error.message || \"Failed to submit review\");\n        }\n        return response.json();\n    }\n    // Get business statistics\n    async getStats() {\n        return this.request(\"/api/public/stats\");\n    }\n    /**\n   * Fetches the profile picture URL for a user\n   * @param userId The ID of the user\n   * @returns Promise with the profile picture URL\n   */ async getProfilePicture(userId) {\n        return this.request(\"/api/auth/profile/picture/\".concat(userId), {\n            method: \"GET\"\n        });\n    }\n    /**\n   * Changes the user's password\n   * @param currentPassword The user's current password\n   * @param newPassword The new password\n   * @param confirmPassword The new password confirmation\n   * @returns Promise with success message\n   */ async changePassword(currentPassword, newPassword, confirmPassword) {\n        return this.request(\"/api/auth/change-password\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                current_password: currentPassword,\n                password: newPassword,\n                password_confirmation: confirmPassword\n            })\n        }, true // requires authentication\n        );\n    }\n    // ====== PREFERENCES ======\n    async getPreferences() {\n        return this.request(\"/api/supplier/preferences\", {\n            method: \"GET\"\n        }, true);\n    }\n    async updatePreferences(preferences) {\n        return this.request(\"/api/supplier/preferences\", {\n            method: \"PUT\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(preferences)\n        }, true);\n    }\n    // ====== PRODUCT IMAGES ======\n    async uploadProductImage(formData) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/product-images\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async deleteProductImage(imageId) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/product-images/\").concat(imageId), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Return success for DELETE operations\n        return {\n            success: true,\n            message: \"Image deleted successfully\"\n        };\n    }\n    async deleteAccount() {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/account\"), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Return success for DELETE operations\n        return {\n            success: true,\n            message: \"Account deleted successfully\"\n        };\n    }\n    // ====== DASHBOARD ======\n    async getDashboard() {\n        let range = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"30\";\n        return this.request(\"/api/supplier/dashboard?range=\".concat(range), {\n            method: \"GET\"\n        }, true);\n    }\n    constructor(){\n        this.baseURL = API_BASE_URL;\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrQkFBa0I7QUFDbEIsTUFBTUEsZUFBZTtBQTJQZCxNQUFNQyx3QkFBd0JDO0lBR25DQyxZQUFZQyxPQUFlLEVBQUVDLE1BQWdCLENBQUU7UUFDN0MsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxNQUFNLEdBQUdBO0lBQ2hCO0FBQ0Y7QUFFQSxNQUFNRTtJQU9KLGdDQUFnQztJQUNoQyxNQUFjQyxRQUNaQyxRQUFnQixFQUdKO1lBRlpDLFVBQUFBLGlFQUF1QixDQUFDLEdBQ3hCQyxlQUFBQSxpRUFBd0I7UUFFeEIsTUFBTUMsTUFBTSxHQUFrQkgsT0FBZixJQUFJLENBQUNJLE9BQU8sRUFBWSxPQUFUSjtRQUM5QkssUUFBUUMsR0FBRyxDQUFDLCtCQUFtQyxPQUFKSCxNQUFPO1lBQ2hESSxRQUFRTixRQUFRTSxNQUFNLElBQUk7UUFDNUI7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTUMsaUJBQXlDLENBQUM7UUFDaEQsSUFBSVAsUUFBUVEsT0FBTyxFQUFFO1lBQ25CLElBQUlSLFFBQVFRLE9BQU8sWUFBWUMsU0FBUztnQkFDdENULFFBQVFRLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDLENBQUNDLE9BQU9DO29CQUM5QkwsY0FBYyxDQUFDSyxJQUFJLEdBQUdEO2dCQUN4QjtZQUNGLE9BQU8sSUFBSUUsTUFBTUMsT0FBTyxDQUFDZCxRQUFRUSxPQUFPLEdBQUc7Z0JBQ3pDUixRQUFRUSxPQUFPLENBQUNFLE9BQU8sQ0FBQzt3QkFBQyxDQUFDRSxLQUFLRCxNQUFNO29CQUNuQ0osY0FBYyxDQUFDSyxJQUFJLEdBQUdEO2dCQUN4QjtZQUNGLE9BQU87Z0JBQ0xJLE9BQU9DLE1BQU0sQ0FBQ1QsZ0JBQWdCUCxRQUFRUSxPQUFPO1lBQy9DO1FBQ0Y7UUFFQSxNQUFNQSxVQUFrQztZQUN0QyxnQkFBZ0I7WUFDaEJTLFFBQVE7WUFDUixHQUFHVixjQUFjO1FBQ25CO1FBRUEsSUFBSU4sY0FBYztZQUNoQixNQUFNaUIsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1lBQ25DLE1BQU1DLFlBQVlGLGFBQWFDLE9BQU8sQ0FBQyxpQkFBaUI7WUFDeERoQixRQUFRQyxHQUFHLENBQUMsb0NBQW9DLENBQUMsQ0FBQ2E7WUFDbEQsSUFBSSxDQUFDQSxPQUFPO2dCQUNWZCxRQUFRa0IsS0FBSyxDQUFDO2dCQUNkLE1BQU0sSUFBSTlCLE1BQU07WUFDbEI7WUFDQWdCLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxHQUFnQlUsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1FBQzdDO1FBRUFkLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJHO1FBQ3RDLElBQUlSLFFBQVF1QixJQUFJLEVBQUU7WUFDaEJuQixRQUFRQyxHQUFHLENBQUMsdUJBQXVCTCxRQUFRdUIsSUFBSTtRQUNqRDtRQUVBLElBQUk7WUFDRm5CLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1tQixXQUFXLE1BQU1DLE1BQU12QixLQUFLO2dCQUNoQyxHQUFHRixPQUFPO2dCQUNWMEIsYUFBYTtnQkFDYmxCO1lBQ0Y7WUFFQUosUUFBUUMsR0FBRyxDQUNULDRCQUErQ21CLE9BQW5CQSxTQUFTRyxNQUFNLEVBQUMsS0FBdUIsT0FBcEJILFNBQVNJLFVBQVU7WUFHcEUsNERBQTREO1lBQzVELE1BQU1DLGdCQUFnQkwsU0FBU00sS0FBSztZQUNwQyxNQUFNQyxlQUFlLE1BQU1QLFNBQVNRLElBQUk7WUFDeEMsSUFBSUM7WUFFSixJQUFJO2dCQUNGQSxlQUFlQyxLQUFLQyxLQUFLLENBQUNKO2dCQUMxQjNCLFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0I0QjtZQUN0QyxFQUFFLE9BQU9HLEdBQUc7Z0JBQ1ZoQyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCMEI7Z0JBQ3hDRSxlQUFlLENBQUM7WUFDbEI7WUFFQSxJQUFJLENBQUNULFNBQVNhLEVBQUUsRUFBRTtnQkFDaEJqQyxRQUFRa0IsS0FBSyxDQUFDLG9DQUFvRCxPQUFoQkUsU0FBU0csTUFBTSxFQUFDLE1BQUk7b0JBQ3BFekI7b0JBQ0F5QixRQUFRSCxTQUFTRyxNQUFNO29CQUN2QkMsWUFBWUosU0FBU0ksVUFBVTtvQkFDL0JKLFVBQVVTO2dCQUNaO2dCQUVBLElBQUlULFNBQVNHLE1BQU0sS0FBSyxLQUFLO29CQUMzQixNQUFNVyxrQkFBa0IsSUFBSS9DLGdCQUMxQixxQkFDQTBDLGFBQWF0QyxNQUFNLElBQUlzQztvQkFFekI3QixRQUFRa0IsS0FBSyxDQUFDLDRCQUE0QmdCLGdCQUFnQjNDLE1BQU07b0JBQ2hFLE1BQU0yQztnQkFDUjtnQkFFQSxNQUFNLElBQUk5QyxNQUNSeUMsYUFBYXZDLE9BQU8sSUFBSSxjQUE4QixPQUFoQjhCLFNBQVNHLE1BQU07WUFFekQ7WUFFQSxPQUFPTTtRQUNULEVBQUUsT0FBT1gsT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNaUIsWUFBWUMsSUFRakIsRUFBNEI7UUFDM0IsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQ2pCLG9DQUNBO1lBQ0VRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkIsR0FDQTtJQUVKO0lBRUEsTUFBTUUsZUFDSkMsU0FBaUIsRUFDakJILElBQXlCLEVBQ0M7UUFDMUIsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQ2pCLG9DQUE4QyxPQUFWNkMsV0FBVSxXQUM5QztZQUNFckMsUUFBUTtZQUNSaUIsTUFBTVcsS0FBS08sU0FBUyxDQUFDRDtRQUN2QixHQUNBO0lBRUo7SUFFQSxNQUFNSSxrQkFBa0JELFNBQWlCLEVBQStCO1FBQ3RFLE9BQU8sSUFBSSxDQUFDN0MsT0FBTyxDQUNqQixvQ0FBOEMsT0FBVjZDLFdBQVUsVUFDOUM7WUFDRXJDLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNdUMsV0FBV0YsU0FBaUIsRUFBZ0M7UUFDaEUsT0FBTyxJQUFJLENBQUM3QyxPQUFPLENBQ2pCLG9DQUE4QyxPQUFWNkMsWUFDcEM7WUFDRXJDLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNd0Msa0JBQWdEO1FBQ3BELE9BQU8sSUFBSSxDQUFDaEQsT0FBTyxDQUNqQixvQ0FDQTtZQUNFUSxRQUFRO1FBQ1YsR0FDQTtJQUVKO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU15QyxpQkFDSlAsSUFBc0IsRUFDUztRQUMvQixPQUFPLElBQUksQ0FBQzFDLE9BQU8sQ0FBQywwQkFBMEI7WUFDNUNRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkI7SUFDRjtJQUVBLE1BQU1RLE1BQU1SLElBQWtCLEVBQTBCO1FBQ3RELE1BQU1oQixXQUFXLE1BQU0sSUFBSSxDQUFDMUIsT0FBTyxDQUFnQixtQkFBbUI7WUFDcEVRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkI7UUFFQSxJQUFJaEIsU0FBU3lCLFdBQVcsRUFBRTtZQUN4QjlCLGFBQWErQixPQUFPLENBQUMsa0JBQWtCMUIsU0FBU3lCLFdBQVc7WUFDM0Q5QixhQUFhK0IsT0FBTyxDQUFDLGNBQWMxQixTQUFTSCxTQUFTLElBQUk7UUFDM0Q7UUFFQSxPQUFPRztJQUNUO0lBRUEsTUFBTTJCLFNBQXdCO1FBQzVCLE1BQU1qQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFDbkMsTUFBTUMsWUFBWUYsYUFBYUMsT0FBTyxDQUFDLGlCQUFpQjtRQUV4RCxJQUFJLENBQUNGLE9BQU8sTUFBTSxJQUFJMUIsTUFBTTtRQUU1QixNQUFNZ0MsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJuQyxjQUFhLHFCQUFtQjtZQUM5RGdCLFFBQVE7WUFDUkUsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCNEMsZUFBZSxHQUFnQmxDLE9BQWJHLFdBQVUsS0FBUyxPQUFOSDtZQUNqQztRQUNGO1FBRUEsSUFBSSxDQUFDTSxTQUFTYSxFQUFFLEVBQUU7WUFDaEIsTUFBTWYsUUFBUSxNQUFNRSxTQUNqQjZCLElBQUksR0FDSkMsS0FBSyxDQUFDLElBQU87b0JBQUU1RCxTQUFTO2dCQUFnQjtZQUMzQyxNQUFNLElBQUlGLE1BQU04QixNQUFNNUIsT0FBTyxJQUFJO1FBQ25DO1FBRUEsNkNBQTZDO1FBQzdDeUIsYUFBYW9DLFVBQVUsQ0FBQztRQUN4QnBDLGFBQWFvQyxVQUFVLENBQUM7UUFDeEJwQyxhQUFhb0MsVUFBVSxDQUFDO0lBQzFCO0lBRUEsTUFBTUMsZUFDSmhCLElBQTJCLEVBQ0c7UUFDOUIsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQUMsNkJBQTZCO1lBQy9DUSxRQUFRO1lBQ1JpQixNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNaUIsY0FDSmpCLElBQTBCLEVBQ0k7UUFDOUIsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQUMsNEJBQTRCO1lBQzlDUSxRQUFRO1lBQ1JpQixNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNa0IsUUFBUWxCLElBQW9CLEVBQXdCO1FBQ3hELE9BQU8sSUFBSSxDQUFDMUMsT0FBTyxDQUFDLHNCQUFzQjtZQUN4Q1EsUUFBUTtZQUNSaUIsTUFBTVcsS0FBS08sU0FBUyxDQUFDRDtRQUN2QjtJQUNGO0lBRUEsTUFBTW1CLFVBQVVuQixJQUFzQixFQUF3QjtRQUM1RCxNQUFNaEIsV0FBVyxNQUFNLElBQUksQ0FBQzFCLE9BQU8sQ0FBYyx3QkFBd0I7WUFDdkVRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkI7UUFFQSxJQUFJaEIsU0FBU3lCLFdBQVcsRUFBRTtZQUN4QjlCLGFBQWErQixPQUFPLENBQUMsa0JBQWtCMUIsU0FBU3lCLFdBQVc7WUFDM0Q5QixhQUFhK0IsT0FBTyxDQUFDLGNBQWMxQixTQUFTSCxTQUFTLElBQUk7UUFDM0Q7UUFFQSxPQUFPRztJQUNUO0lBRUEsTUFBTW9DLGNBQWNDLE1BZW5CLEVBQWlDO1FBQ2hDLE1BQU1DLGNBQWMsSUFBSUM7UUFFeEIsTUFBTS9ELFVBQXVCO1lBQUVNLFFBQVE7UUFBTTtRQUU3QyxpQ0FBaUM7UUFDakMsTUFBTVksUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLElBQUlGLE9BQU87WUFDVCxNQUFNRyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1lBQ3hEcEIsUUFBUVEsT0FBTyxHQUFHO2dCQUNoQixHQUFHUixRQUFRUSxPQUFPO2dCQUNsQjRDLGVBQWUsR0FBZ0JsQyxPQUFiRyxXQUFVLEtBQVMsT0FBTkg7Z0JBQy9CLGdCQUFnQjtnQkFDaEJELFFBQVE7WUFDVjtRQUNGO1FBQ0EsSUFBSTRDLFFBQVE7WUFDVix3REFBd0Q7WUFDeEQsTUFBTSxFQUFFRyxRQUFRLEVBQUUsR0FBR0MsWUFBWSxHQUFHSjtZQUVwQyxJQUFJRyxVQUFVO2dCQUNaRixZQUFZSSxNQUFNLENBQUMsWUFBWUY7WUFDakM7WUFFQSxvQ0FBb0M7WUFDcENqRCxPQUFPb0QsT0FBTyxDQUFDRixZQUFZdkQsT0FBTyxDQUFDO29CQUFDLENBQUNFLEtBQUtELE1BQU07Z0JBQzlDLElBQUlBLFVBQVV5RCxhQUFhekQsVUFBVSxNQUFNO29CQUN6QyxJQUFJRSxNQUFNQyxPQUFPLENBQUNILFFBQVE7d0JBQ3hCbUQsWUFBWUksTUFBTSxDQUFDdEQsS0FBS0QsTUFBTTBELElBQUksQ0FBQztvQkFDckMsT0FBTyxJQUFJLE9BQU8xRCxVQUFVLFdBQVc7d0JBQ3JDbUQsWUFBWUksTUFBTSxDQUFDdEQsS0FBS0QsUUFBUSxNQUFNO29CQUN4QyxPQUFPO3dCQUNMbUQsWUFBWUksTUFBTSxDQUFDdEQsS0FBS0QsTUFBTTJELFFBQVE7b0JBQ3hDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU8sSUFBSSxDQUFDeEUsT0FBTyxDQUNqQiwwQkFBaUQsT0FBdkJnRSxZQUFZUSxRQUFRLEtBQzlDO1lBQ0VoRSxRQUFRO1FBQ1YsR0FDQSxNQUFNLHVCQUF1Qjs7SUFFakM7SUFFQSxNQUFNaUUsY0FBYy9CLElBQXVCLEVBQWtDO1FBQzNFLE9BQU8sSUFBSSxDQUFDMUMsT0FBTyxDQUNqQix5QkFDQTtZQUNFUSxRQUFRO1lBQ1JpQixNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCLEdBQ0EsT0FDQyxzQkFBc0I7SUFDM0I7SUFFQSxNQUFNZ0MsMEJBQ0pDLFFBQWtCLEVBQ2M7UUFDaEMsTUFBTXZELFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxNQUFNQyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1FBRXhELElBQUksQ0FBQ0YsT0FBTyxNQUFNLElBQUkxQixNQUFNO1FBRTVCLE1BQU1nQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUN0QixPQUFPLEVBQUMsMEJBQXdCO1lBQ25FRyxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1A0QyxlQUFlLEdBQWdCbEMsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1lBRWpDO1lBQ0FLLE1BQU1rRDtRQUNSO1FBRUEsSUFBSSxDQUFDakQsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1xQyxZQUFZLE1BQU1sRCxTQUFTNkIsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBRXRELGlDQUFpQztZQUNqQ2xELFFBQVFrQixLQUFLLENBQUMsYUFBNkIsT0FBaEJFLFNBQVNHLE1BQU0sRUFBQyxNQUFJO2dCQUM3Q3pCLEtBQUssR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztnQkFDckJHLFFBQVE7Z0JBQ1JvRTtZQUNGO1lBRUEsSUFBSWxELFNBQVNHLE1BQU0sS0FBSyxLQUFLO2dCQUMzQnZCLFFBQVFrQixLQUFLLENBQUMsc0JBQXNCb0QsVUFBVS9FLE1BQU0sSUFBSStFO2dCQUN4RCxNQUFNLElBQUluRixnQkFDUm1GLFVBQVVoRixPQUFPLElBQUkscUJBQ3JCZ0YsVUFBVS9FLE1BQU0sSUFBSStFO1lBRXhCO1lBRUEsTUFBTSxJQUFJbEYsTUFDUmtGLFVBQVVoRixPQUFPLElBQUksUUFBNEI4QixPQUFwQkEsU0FBU0csTUFBTSxFQUFDLE1BQXdCLE9BQXBCSCxTQUFTSSxVQUFVO1FBRXhFO1FBRUEsT0FBT0osU0FBUzZCLElBQUk7SUFDdEI7SUFFQSxNQUFNc0IsYUFBMkI7UUFDL0IsT0FBTyxJQUFJLENBQUM3RSxPQUFPLENBQ2pCLHlCQUNBO1lBQ0VRLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNc0UsZUFBZUMsSUFBVSxFQUFtQztRQUNoRSxNQUFNM0QsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLE1BQU1DLFlBQVlGLGFBQWFDLE9BQU8sQ0FBQyxpQkFBaUI7UUFFeEQsSUFBSSxDQUFDRixPQUFPLE1BQU0sSUFBSTFCLE1BQU07UUFFNUIsTUFBTWlGLFdBQVcsSUFBSUs7UUFDckJMLFNBQVNQLE1BQU0sQ0FBQyxZQUFZVztRQUU1QixNQUFNckQsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDdEIsT0FBTyxFQUFDLDRCQUEwQjtZQUNyRUcsUUFBUTtZQUNSRSxTQUFTO2dCQUNQNEMsZUFBZSxHQUFnQmxDLE9BQWJHLFdBQVUsS0FBUyxPQUFOSDtZQUNqQztZQUNBSyxNQUFNa0Q7WUFDTi9DLGFBQWE7UUFDZjtRQUVBLElBQUksQ0FBQ0YsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1xQyxZQUFZLE1BQU1sRCxTQUFTNkIsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBQ3REbEQsUUFBUWtCLEtBQUssQ0FBQywwQkFBMEJvRDtZQUN4QyxNQUFNLElBQUlsRixNQUFNa0YsVUFBVWhGLE9BQU8sSUFBSTtRQUN2QztRQUVBLE9BQU8sTUFBTThCLFNBQVM2QixJQUFJO0lBQzVCO0lBRUEsTUFBTTBCLG1CQUNKRixJQUFVLEVBQzRDO1FBQ3RELE1BQU1KLFdBQVcsSUFBSUs7UUFDckJMLFNBQVNQLE1BQU0sQ0FBQyxpQkFBaUJXO1FBRWpDLHdCQUF3QjtRQUN4QixNQUFNckUsVUFBVSxJQUFJQztRQUNwQixrRkFBa0Y7UUFFbEYscUJBQXFCO1FBQ3JCLE1BQU1TLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJRixPQUFPO1lBQ1RWLFFBQVEwRCxNQUFNLENBQUMsaUJBQWlCLFVBQWdCLE9BQU5oRDtRQUM1QztRQUVBLElBQUk7Z0JBK0JtQ2U7WUE5QnJDLE1BQU1ULFdBQVcsTUFBTUMsTUFDckIsR0FBZ0IsT0FBYixJQUFJLENBQUN0QixPQUFPLEVBQUMsZ0NBQ2hCO2dCQUNFRyxRQUFRO2dCQUNSRTtnQkFDQWUsTUFBTWtEO2dCQUNOL0MsYUFBYTtZQUNmO1lBR0YscUNBQXFDO1lBQ3JDLElBQUksQ0FBQ0YsU0FBU2EsRUFBRSxFQUFFO2dCQUNoQixNQUFNcUMsWUFBWSxNQUFNbEQsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJOUQsTUFBTWtGLFVBQVVoRixPQUFPLElBQUk7WUFDdkM7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSXVDO1lBQ0osSUFBSTtnQkFDRkEsZUFBZSxNQUFNVCxTQUFTNkIsSUFBSTtZQUNwQyxFQUFFLE9BQU9qQixHQUFHO2dCQUNWLGdFQUFnRTtnQkFDaEUsSUFBSVosU0FBU0csTUFBTSxLQUFLLEtBQUs7b0JBQzNCLE9BQU87d0JBQUVxRCxTQUFTO3dCQUFNeEMsTUFBTTs0QkFBRXRDLEtBQUs7d0JBQUc7b0JBQUUsR0FBRyxrQ0FBa0M7Z0JBQ2pGO2dCQUNBLE1BQU0sSUFBSVYsTUFBTTtZQUNsQjtZQUVBLDZDQUE2QztZQUM3QyxzRUFBc0U7WUFDdEUsTUFBTXlGLFdBQVdoRCxhQUFhL0IsR0FBRyxNQUFJK0IscUJBQUFBLGFBQWFPLElBQUksY0FBakJQLHlDQUFBQSxtQkFBbUIvQixHQUFHLEtBQUk7WUFFL0QsT0FBTztnQkFDTDhFLFNBQVM7Z0JBQ1R4QyxNQUFNO29CQUNKdEMsS0FBSytFO2dCQUNQO1lBQ0Y7UUFDRixFQUFFLE9BQU8zRCxPQUFnQjtZQUN2QmxCLFFBQVFrQixLQUFLLENBQUMsY0FBY0E7WUFFNUIsbUNBQW1DO1lBQ25DLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07Z0JBQy9DLG1DQUFtQztnQkFDbkMsSUFDRSxjQUFjQSxTQUNkQSxNQUFNRSxRQUFRLElBQ2QsT0FBT0YsTUFBTUUsUUFBUSxLQUFLLFlBQzFCRixNQUFNRSxRQUFRLEtBQUssTUFDbkI7b0JBQ0EsSUFBSTt3QkFDRiw4Q0FBOEM7d0JBQzlDLE1BQU1rRCxZQUFZLE1BQU1wRCxNQUFNRSxRQUFRLENBQUM2QixJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7d0JBQzVELE1BQU0sSUFBSTlELE1BQU1rRixVQUFVaEYsT0FBTyxJQUFJO29CQUN2QyxFQUFFLE9BQU8wQyxHQUFHO3dCQUNWLHVDQUF1Qzt3QkFDdkMsTUFBTSxJQUFJNUMsTUFBTTtvQkFDbEI7Z0JBQ0Y7Z0JBRUEsdUJBQXVCO2dCQUN2QixJQUFJOEIsaUJBQWlCOUIsT0FBTztvQkFDMUIsTUFBTSxJQUFJQSxNQUNSOEIsTUFBTTVCLE9BQU8sSUFBSTtnQkFFckI7WUFDRjtZQUVBLGdCQUFnQjtZQUNoQixNQUFNLElBQUlGLE1BQU07UUFDbEI7SUFDRjtJQUVBLHdCQUF3QjtJQUN4QjBGLGtCQUEyQjtRQUN6QixPQUFPLENBQUMsQ0FBQy9ELGFBQWFDLE9BQU8sQ0FBQztJQUNoQztJQUVBOzs7O0dBSUMsR0FDRCxNQUFNK0QsbUJBQW1CQyxFQUFtQixFQUE0QjtRQUN0RSxNQUFNNUUsVUFBVSxJQUFJQztRQUNwQixNQUFNUyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFFbkMsSUFBSUYsT0FBTztZQUNUVixRQUFRMEQsTUFBTSxDQUFDLGlCQUFpQixVQUFnQixPQUFOaEQ7WUFDMUNWLFFBQVEwRCxNQUFNLENBQUMsVUFBVTtRQUMzQjtRQUVBLElBQUk7WUFDRixNQUFNMUMsV0FBVyxNQUFNQyxNQUNyQixHQUFpQzJELE9BQTlCLElBQUksQ0FBQ2pGLE9BQU8sRUFBQyxtQkFBb0IsT0FBSGlGLElBQUcsY0FDcEM7Z0JBQ0U5RSxRQUFRO2dCQUNSRTtnQkFDQWtCLGFBQWE7WUFDZjtZQUdGLElBQUksQ0FBQ0YsU0FBU2EsRUFBRSxFQUFFO2dCQUNoQixNQUFNcUMsWUFBWSxNQUFNbEQsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJOUQsTUFDUmtGLFVBQVVoRixPQUFPLElBQUk7WUFFekI7WUFFQSxPQUFPLE1BQU04QixTQUFTNkIsSUFBSTtRQUM1QixFQUFFLE9BQU8vQixPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbEQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTStELG1CQUFtQkQsRUFBbUIsRUFBNEI7UUFDdEUsTUFBTTVFLFVBQVUsSUFBSUM7UUFDcEIsTUFBTVMsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBRW5DLElBQUlGLE9BQU87WUFDVFYsUUFBUTBELE1BQU0sQ0FBQyxpQkFBaUIsVUFBZ0IsT0FBTmhEO1lBQzFDVixRQUFRMEQsTUFBTSxDQUFDLFVBQVU7UUFDM0I7UUFFQSxJQUFJO1lBQ0YsTUFBTTFDLFdBQVcsTUFBTUMsTUFBTSxHQUFpQzJELE9BQTlCLElBQUksQ0FBQ2pGLE9BQU8sRUFBQyxtQkFBb0IsT0FBSGlGLEtBQU07Z0JBQ2xFOUUsUUFBUTtnQkFDUkU7Z0JBQ0FrQixhQUFhO1lBQ2Y7WUFFQSxJQUFJLENBQUNGLFNBQVNhLEVBQUUsRUFBRTtnQkFDaEIsTUFBTXFDLFlBQVksTUFBTWxELFNBQVM2QixJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSTlELE1BQ1JrRixVQUFVaEYsT0FBTyxJQUFJO1lBRXpCO1lBRUEsT0FBTyxNQUFNOEIsU0FBUzZCLElBQUk7UUFDNUIsRUFBRSxPQUFPL0IsT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1nRSxhQUNKQyxVQUFrQixFQUNsQkMsTUFBYyxFQUNkQyxPQUFlLEVBQ2U7UUFDOUIsTUFBTXZFLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJLENBQUNGLE9BQU87WUFDVixNQUFNLElBQUkxQixNQUFNO1FBQ2xCO1FBRUEsTUFBTWdDLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiLElBQUksQ0FBQ3RCLE9BQU8sRUFBQywwQkFBd0I7WUFDbkVHLFFBQVE7WUFDUkUsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCNEMsZUFBZSxVQUFnQixPQUFObEM7Z0JBQ3pCRCxRQUFRO1lBQ1Y7WUFDQU0sTUFBTVcsS0FBS08sU0FBUyxDQUFDO2dCQUNuQmlELG1CQUFtQkg7Z0JBQ25CSSxPQUFPSDtnQkFDUEMsU0FBU0E7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDakUsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1mLFFBQVEsTUFBTUUsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUNsRCxNQUFNLElBQUk5RCxNQUFNOEIsTUFBTTVCLE9BQU8sSUFBSTtRQUNuQztRQUVBLE9BQU84QixTQUFTNkIsSUFBSTtJQUN0QjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNdUMsV0FBbUM7UUFDdkMsT0FBTyxJQUFJLENBQUM5RixPQUFPLENBQWdCO0lBQ3JDO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU0rRixrQkFDSkMsTUFBdUIsRUFDYTtRQUNwQyxPQUFPLElBQUksQ0FBQ2hHLE9BQU8sQ0FDakIsNkJBQW9DLE9BQVBnRyxTQUM3QjtZQUNFeEYsUUFBUTtRQUNWO0lBRUo7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFNeUYsZUFDSkMsZUFBdUIsRUFDdkJDLFdBQW1CLEVBQ25CQyxlQUF1QixFQUNPO1FBQzlCLE9BQU8sSUFBSSxDQUFDcEcsT0FBTyxDQUNqQiw2QkFDQTtZQUNFUSxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1lBQ0FlLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQztnQkFDbkIwRCxrQkFBa0JIO2dCQUNsQkksVUFBVUg7Z0JBQ1ZJLHVCQUF1Qkg7WUFDekI7UUFDRixHQUNBLEtBQUssMEJBQTBCOztJQUVuQztJQUVBLDRCQUE0QjtJQUM1QixNQUFNSSxpQkFBK0I7UUFDbkMsT0FBTyxJQUFJLENBQUN4RyxPQUFPLENBQ2pCLDZCQUNBO1lBQ0VRLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNaUcsa0JBQWtCQyxXQUFnQixFQUFnQjtRQUN0RCxPQUFPLElBQUksQ0FBQzFHLE9BQU8sQ0FDakIsNkJBQ0E7WUFDRVEsUUFBUTtZQUNSRSxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtZQUNBZSxNQUFNVyxLQUFLTyxTQUFTLENBQUMrRDtRQUN2QixHQUNBO0lBRUo7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTUMsbUJBQW1CaEMsUUFBa0IsRUFBZ0I7UUFDekQsTUFBTXZELFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxNQUFNQyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1FBRXhELElBQUksQ0FBQ0YsT0FBTyxNQUFNLElBQUkxQixNQUFNO1FBRTVCLE1BQU1nQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUN0QixPQUFPLEVBQUMsaUNBQStCO1lBQzFFRyxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1A0QyxlQUFlLEdBQWdCbEMsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1lBRWpDO1lBQ0FLLE1BQU1rRDtRQUNSO1FBRUEsSUFBSSxDQUFDakQsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1xQyxZQUFZLE1BQU1sRCxTQUFTNkIsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBQ3RELE1BQU0sSUFBSTlELE1BQU1rRixVQUFVaEYsT0FBTyxJQUFJLFFBQTRCOEIsT0FBcEJBLFNBQVNHLE1BQU0sRUFBQyxNQUF3QixPQUFwQkgsU0FBU0ksVUFBVTtRQUN0RjtRQUVBLE9BQU9KLFNBQVM2QixJQUFJO0lBQ3RCO0lBRUEsTUFBTXFELG1CQUFtQkMsT0FBZSxFQUFnQjtRQUN0RCxNQUFNekYsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLE1BQU1DLFlBQVlGLGFBQWFDLE9BQU8sQ0FBQyxpQkFBaUI7UUFFeEQsSUFBSSxDQUFDRixPQUFPLE1BQU0sSUFBSTFCLE1BQU07UUFFNUIsTUFBTWdDLFdBQVcsTUFBTUMsTUFBTSxHQUErQ2tGLE9BQTVDLElBQUksQ0FBQ3hHLE9BQU8sRUFBQyxpQ0FBdUMsT0FBUndHLFVBQVc7WUFDckZyRyxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1A0QyxlQUFlLEdBQWdCbEMsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1lBQ2pDO1FBQ0Y7UUFFQSxJQUFJLENBQUNNLFNBQVNhLEVBQUUsRUFBRTtZQUNoQixNQUFNcUMsWUFBWSxNQUFNbEQsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUN0RCxNQUFNLElBQUk5RCxNQUFNa0YsVUFBVWhGLE9BQU8sSUFBSSxRQUE0QjhCLE9BQXBCQSxTQUFTRyxNQUFNLEVBQUMsTUFBd0IsT0FBcEJILFNBQVNJLFVBQVU7UUFDdEY7UUFFQSx1Q0FBdUM7UUFDdkMsT0FBTztZQUFFb0QsU0FBUztZQUFNdEYsU0FBUztRQUE2QjtJQUNoRTtJQUVBLE1BQU1rSCxnQkFBOEI7UUFDbEMsTUFBTTFGLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxNQUFNQyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1FBRXhELElBQUksQ0FBQ0YsT0FBTyxNQUFNLElBQUkxQixNQUFNO1FBRTVCLE1BQU1nQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUN0QixPQUFPLEVBQUMsMEJBQXdCO1lBQ25FRyxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1A0QyxlQUFlLEdBQWdCbEMsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1lBQ2pDO1FBQ0Y7UUFFQSxJQUFJLENBQUNNLFNBQVNhLEVBQUUsRUFBRTtZQUNoQixNQUFNcUMsWUFBWSxNQUFNbEQsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUN0RCxNQUFNLElBQUk5RCxNQUFNa0YsVUFBVWhGLE9BQU8sSUFBSSxRQUE0QjhCLE9BQXBCQSxTQUFTRyxNQUFNLEVBQUMsTUFBd0IsT0FBcEJILFNBQVNJLFVBQVU7UUFDdEY7UUFFQSx1Q0FBdUM7UUFDdkMsT0FBTztZQUFFb0QsU0FBUztZQUFNdEYsU0FBUztRQUErQjtJQUNsRTtJQUVBLDBCQUEwQjtJQUMxQixNQUFNbUgsZUFBaUQ7WUFBcENDLFFBQUFBLGlFQUFnQjtRQUNqQyxPQUFPLElBQUksQ0FBQ2hILE9BQU8sQ0FDakIsaUNBQXVDLE9BQU5nSCxRQUNqQztZQUNFeEcsUUFBUTtRQUNWLEdBQ0E7SUFFSjtJQXp2QkFiLGFBQWM7UUFDWixJQUFJLENBQUNVLE9BQU8sR0FBR2I7SUFDakI7QUF3dkJGO0FBK0NPLE1BQU15SCxhQUFhLElBQUlsSCxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2aWNlcy9hcGkudHNcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmV2aWV3IHtcbiAgaWQ6IG51bWJlcjtcbiAgcmF0aW5nOiBudW1iZXI7XG4gIGNvbW1lbnQ6IHN0cmluZztcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1c2VyOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGF2YXRhcj86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDZXJ0aWZpY2F0aW9uIHtcbiAgaWQ6IG51bWJlcjtcbiAgY2VydGlmaWNhdGlvbl9uYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjdCB7XG4gIGlkOiBudW1iZXI7XG4gIHByb2R1Y3RfbmFtZTogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlIHtcbiAgaWQ6IG51bWJlcjtcbiAgc2VydmljZV9uYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGhvbmUge1xuICBpZDogbnVtYmVyO1xuICB0eXBlOiBzdHJpbmc7XG4gIG51bWJlcjogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2luZ0hvdXIge1xuICBvcGVuOiBzdHJpbmc7XG4gIGNsb3NlOiBzdHJpbmc7XG4gIGNsb3NlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdXBwbGllclByb2ZpbGVEYXRhIHtcbiAgYnVzaW5lc3NfdHlwZTogc3RyaW5nO1xuICBjYXRlZ29yeTogc3RyaW5nO1xuICBidXNpbmVzc19pbWFnZTogc3RyaW5nO1xuICB3ZWJzaXRlOiBzdHJpbmc7XG4gIGNvbnRhY3RfZW1haWw6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGw7XG4gIHNlcnZpY2VfZGlzdGFuY2U6IHN0cmluZztcbiAgdGFyZ2V0X21hcmtldDogc3RyaW5nW107XG4gIG1haW5fcGhvbmU6IHN0cmluZztcbiAgYWRkaXRpb25hbF9waG9uZXM6IFBob25lW107XG4gIGJ1c2luZXNzX2FkZHJlc3M6IHN0cmluZztcbiAgbGF0aXR1ZGU6IHN0cmluZztcbiAgbG9uZ2l0dWRlOiBzdHJpbmc7XG4gIHdvcmtpbmdfaG91cnM6IFJlY29yZDxzdHJpbmcsIFdvcmtpbmdIb3VyPjtcbiAgc2VydmljZXNfb2ZmZXJlZDogc3RyaW5nW107XG4gIHByb2R1Y3RzPzogUHJvZHVjdFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1cHBsaWVyUHJvZmlsZSB7XG4gIGlkOiBudW1iZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIHByb2ZpbGU6IFN1cHBsaWVyUHJvZmlsZURhdGE7XG4gIHByb2ZpbGVfaW1hZ2U6IHN0cmluZztcbiAgcmF0aW5nczoge1xuICAgIGF2ZXJhZ2U6IG51bWJlciB8IG51bGw7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICByZXZpZXdzOiBSZXZpZXdbXTtcbiAgfTtcbiAgY2VydGlmaWNhdGlvbnM6IENlcnRpZmljYXRpb25bXTtcbiAgcHJvZHVjdF9pbWFnZXM6IEFycmF5PHtcbiAgICBpZDogbnVtYmVyO1xuICAgIGltYWdlX3VybDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfT47XG4gIHNlcnZpY2VzOiBTZXJ2aWNlW107XG59XG5cbi8vIEJ1c2luZXNzUHJvZmlsZSBleHRlbmRzIFN1cHBsaWVyUHJvZmlsZSB3aXRoIGV4cGxpY2l0IHByb2R1Y3RzIGluIHByb2ZpbGVcbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3NQcm9maWxlIGV4dGVuZHMgT21pdDxTdXBwbGllclByb2ZpbGUsIFwicHJvZmlsZVwiPiB7XG4gIHByb2ZpbGU6IFN1cHBsaWVyUHJvZmlsZURhdGEgJiB7XG4gICAgcHJvZHVjdHM6IFByb2R1Y3RbXTsgLy8gQ29tcGFueSBwcm9kdWN0cyBpbnNpZGUgcHJvZmlsZVxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZ2lzdHJhdGlvbkRhdGEge1xuICBidXNpbmVzc05hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcGFzc3dvcmRfY29uZmlybWF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cmF0aW9uUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN1cHBsaWVyOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZE90cFJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeU90cFJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xuICBvdHA6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3Jnb3RQYXNzd29yZFJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2V0UGFzc3dvcmRSZXF1ZXN0IHtcbiAgZW1haWw6IHN0cmluZztcbiAgb3RwOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIHBhc3N3b3JkX2NvbmZpcm1hdGlvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2luUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5SZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgdXNlclR5cGU6IHN0cmluZztcbiAgc3VwcGxpZXI6IHtcbiAgICBpZDogbnVtYmVyO1xuICAgIHNsdWc6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBwaG9uZTogc3RyaW5nO1xuICAgIHByb2ZpbGVJbWFnZTogc3RyaW5nO1xuICAgIGVtYWlsVmVyaWZpZWRBdDogc3RyaW5nO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIHBsYW46IHN0cmluZztcbiAgICBwcm9maWxlQ29tcGxldGlvbjogbnVtYmVyO1xuICAgIHByb2ZpbGU6IGFueTtcbiAgICBicmFuY2hlczogYW55W107XG4gIH07XG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gIHRva2VuVHlwZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE90cFJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBzdXBwbGllcj86IGFueTtcbiAgYWNjZXNzVG9rZW4/OiBzdHJpbmc7XG4gIHRva2VuVHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9maWxlVXBkYXRlRGF0YSB7XG4gIGJ1c2luZXNzTmFtZT86IHN0cmluZztcbiAgYnVzaW5lc3NUeXBlPzogc3RyaW5nO1xuICBjYXRlZ29yaWVzPzogc3RyaW5nW107XG4gIHByb2R1Y3RLZXl3b3Jkcz86IHN0cmluZ1tdO1xuICB3aG9Eb1lvdVNlcnZlPzogc3RyaW5nO1xuICBzZXJ2aWNlRGlzdGFuY2U/OiBzdHJpbmc7XG4gIHNlcnZpY2VzPzogc3RyaW5nW107XG4gIHdlYnNpdGU/OiBzdHJpbmc7XG4gIG1haW5QaG9uZT86IHN0cmluZztcbiAgYWRkaXRpb25hbFBob25lcz86IEFycmF5PHtcbiAgICBudW1iZXI6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xuICB9PjtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgbG9jYXRpb24/OiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9O1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgd29ya2luZ0hvdXJzPzoge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgIGNsb3NlZD86IGJvb2xlYW47XG4gICAgICBvcGVuPzogc3RyaW5nO1xuICAgICAgY2xvc2U/OiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgaGFzQnJhbmNoZXM/OiBib29sZWFuO1xuICBicmFuY2hlcz86IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcGhvbmU/OiBzdHJpbmc7XG4gICAgZW1haWw/OiBzdHJpbmc7XG4gICAgYWRkcmVzcz86IHN0cmluZztcbiAgICBtYW5hZ2VyPzogc3RyaW5nO1xuICAgIGxvY2F0aW9uPzogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfTtcbiAgICB3b3JraW5nSG91cnM/OiB7XG4gICAgICBba2V5OiBzdHJpbmddOiB7XG4gICAgICAgIGNsb3NlZD86IGJvb2xlYW47XG4gICAgICAgIG9wZW4/OiBzdHJpbmc7XG4gICAgICAgIGNsb3NlPzogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHNwZWNpYWxTZXJ2aWNlcz86IHN0cmluZ1tdO1xuICAgIGlzTWFpbkJyYW5jaD86IGJvb2xlYW47XG4gIH0+O1xuICBjb250YWN0RW1haWw/OiBzdHJpbmc7IC8vIEZyb20gdmVyaWZpY2F0aW9uL2xvZ2luXG4gIGNvbnRhY3RQaG9uZT86IHN0cmluZzsgLy8gRnJvbSB2ZXJpZmljYXRpb24vbG9naW5cbiAgY2F0ZWdvcnk/OiBzdHJpbmc7XG4gIGRvY3VtZW50PzogRmlsZTsgLy8gSW5jbHVkZSBkb2N1bWVudCBpbiBtYWluIHJlcXVlc3Rcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9maWxlVXBkYXRlUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN1cHBsaWVyOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRVcGxvYWRSZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZGF0YTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1c2luZXNzIHtcbiAgaWQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBidXNpbmVzc0ltYWdlOiBzdHJpbmc7XG4gIHNsdWc6IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgY2F0ZWdvcmllczogc3RyaW5nW107XG4gIHRhcmdldE1hcmtldDogc3RyaW5nW107XG4gIHNlcnZpY2VzOiBzdHJpbmdbXTtcbiAgYnVzaW5lc3NUeXBlOiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgc2VydmljZURpc3RhbmNlOiBudW1iZXI7XG4gIHJhdGluZz86IG51bWJlcjtcbiAgcmV2aWV3c0NvdW50OiBudW1iZXI7XG4gIHN0YXR1czogc3RyaW5nO1xuICBwbGFuOiBzdHJpbmc7XG4gIGxhdGl0dWRlOiBzdHJpbmc7XG4gIGxvbmdpdHVkZTogc3RyaW5nO1xuICBtYWluUGhvbmU6IHN0cmluZztcbiAgY29udGFjdEVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3NMaXN0UmVzcG9uc2Uge1xuICBkYXRhOiBCdXNpbmVzc1tdO1xuICBtZXRhOiB7XG4gICAgY3VycmVudF9wYWdlOiBudW1iZXI7XG4gICAgcGVyX3BhZ2U6IG51bWJlcjtcbiAgICB0b3RhbDogbnVtYmVyO1xuICAgIGxhc3RfcGFnZTogbnVtYmVyO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwaUVycm9yIHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nW107XG59XG5cbmV4cG9ydCBjbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyBlcnJvcnM6IEFwaUVycm9yO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZXJyb3JzOiBBcGlFcnJvcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiVmFsaWRhdGlvbkVycm9yXCI7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gIH1cbn1cblxuY2xhc3MgQXBpU2VydmljZSB7XG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmFzZVVSTCA9IEFQSV9CQVNFX1VSTDtcbiAgfVxuXG4gIC8vID09PT09PSBSRVFVRVNUIFdSQVBQRVIgPT09PT09XG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdDxUPihcbiAgICBlbmRwb2ludDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30sXG4gICAgcmVxdWlyZXNBdXRoOiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVVJMfSR7ZW5kcG9pbnR9YDtcbiAgICBjb25zb2xlLmxvZyhgW0FQSV0gUHJlcGFyaW5nIHJlcXVlc3QgdG86ICR7dXJsfWAsIHtcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIixcbiAgICB9KTtcblxuICAgIC8vIENvbnZlcnQgSGVhZGVyc0luaXQgdG8gUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIGNvbnN0IG9wdGlvbnNIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBvcHRpb25zSGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIG9wdGlvbnNIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnNIZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5vcHRpb25zSGVhZGVycyxcbiAgICB9O1xuXG4gICAgaWYgKHJlcXVpcmVzQXV0aCkge1xuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG4gICAgICBjb25zb2xlLmxvZyhcIltBUEldIEF1dGggY2hlY2sgLSBUb2tlbiBleGlzdHM6XCIsICEhdG9rZW4pO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW0FQSV0gTm8gYXV0aCB0b2tlbiBmb3VuZCBpbiBsb2NhbFN0b3JhZ2VcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiW0FQSV0gUmVxdWVzdCBoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltBUEldIFJlcXVlc3QgYm9keTpcIiwgb3B0aW9ucy5ib2R5KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJbQVBJXSBTZW5kaW5nIHJlcXVlc3QuLi5cIik7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBbQVBJXSBSZWNlaXZlZCByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuXG4gICAgICAvLyBDbG9uZSB0aGUgcmVzcG9uc2UgdG8gcmVhZCBpdCBhcyB0ZXh0IGZpcnN0IChmb3IgbG9nZ2luZylcbiAgICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgbGV0IHJlc3BvbnNlRGF0YTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIltBUEldIFJlc3BvbnNlIGRhdGE6XCIsIHJlc3BvbnNlRGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0FQSV0gTm9uLUpTT04gcmVzcG9uc2U6XCIsIHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHJlc3BvbnNlRGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtBUEldIFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfTpgLCB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIyKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICAgIFwiVmFsaWRhdGlvbiBmYWlsZWRcIixcbiAgICAgICAgICAgIHJlc3BvbnNlRGF0YS5lcnJvcnMgfHwgcmVzcG9uc2VEYXRhXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0FQSV0gVmFsaWRhdGlvbiBFcnJvcnM6XCIsIHZhbGlkYXRpb25FcnJvci5lcnJvcnMpO1xuICAgICAgICAgIHRocm93IHZhbGlkYXRpb25FcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICByZXNwb25zZURhdGEubWVzc2FnZSB8fCBgSFRUUCBlcnJvciAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZURhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQVBJXSBSZXF1ZXN0IGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09IFNVUFBMSUVSIElOUVVJUklFUyA9PT09PT1cbiAgYXN5bmMgc2VuZElucXVpcnkoZGF0YToge1xuICAgIHJlY2VpdmVyX3N1cHBsaWVyX2lkOiBudW1iZXI7XG4gICAgc2VuZGVyX25hbWU6IHN0cmluZztcbiAgICBjb21wYW55OiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBwaG9uZTogc3RyaW5nO1xuICAgIHN1YmplY3Q6IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPElucXVpcnlSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvc3VwcGxpZXItaW5xdWlyaWVzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgcmVwbHlUb0lucXVpcnkoXG4gICAgaW5xdWlyeUlkOiBudW1iZXIsXG4gICAgZGF0YTogeyBtZXNzYWdlOiBzdHJpbmcgfVxuICApOiBQcm9taXNlPElucXVpcnlSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBgL2FwaS9zdXBwbGllci9zdXBwbGllci1pbnF1aXJpZXMvJHtpbnF1aXJ5SWR9L3JlcGx5YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBhc3luYyBtYXJrSW5xdWlyeUFzUmVhZChpbnF1aXJ5SWQ6IG51bWJlcik6IFByb21pc2U8UmVhZFN0YXR1c1Jlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIGAvYXBpL3N1cHBsaWVyL3N1cHBsaWVyLWlucXVpcmllcy8ke2lucXVpcnlJZH0vcmVhZGAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRJbnF1aXJ5KGlucXVpcnlJZDogbnVtYmVyKTogUHJvbWlzZTx7IGRhdGE6IElucXVpcnlbXSB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIGAvYXBpL3N1cHBsaWVyL3N1cHBsaWVyLWlucXVpcmllcy8ke2lucXVpcnlJZH1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxJbnF1aXJpZXMoKTogUHJvbWlzZTxJbnF1aXJ5TGlzdFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9zdXBwbGllci1pbnF1aXJpZXNcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgLy8gPT09PT09IEFQSSBNRVRIT0RTID09PT09PVxuICBhc3luYyByZWdpc3RlclN1cHBsaWVyKFxuICAgIGRhdGE6IFJlZ2lzdHJhdGlvbkRhdGFcbiAgKTogUHJvbWlzZTxSZWdpc3RyYXRpb25SZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvYXBpL3N1cHBsaWVyL3JlZ2lzdGVyXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGxvZ2luKGRhdGE6IExvZ2luUmVxdWVzdCk6IFByb21pc2U8TG9naW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0PExvZ2luUmVzcG9uc2U+KFwiL2FwaS9hdXRoL2xvZ2luXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmIChyZXNwb25zZS5hY2Nlc3NUb2tlbikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiLCByZXNwb25zZS5hY2Nlc3NUb2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRva2VuX3R5cGVcIiwgcmVzcG9uc2UudG9rZW5UeXBlIHx8IFwiQmVhcmVyXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIGxvZ291dCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9hdXRoL2xvZ291dGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlXG4gICAgICAgIC5qc29uKClcbiAgICAgICAgLmNhdGNoKCgpID0+ICh7IG1lc3NhZ2U6IFwiTG9nb3V0IGZhaWxlZFwiIH0pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8IFwiTG9nb3V0IGZhaWxlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBsb2NhbFN0b3JhZ2UgYWZ0ZXIgc3VjY2Vzc2Z1bCBsb2dvdXRcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwidG9rZW5fdHlwZVwiKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInN1cHBsaWVyX3VzZXJcIik7XG4gIH1cblxuICBhc3luYyBmb3Jnb3RQYXNzd29yZChcbiAgICBkYXRhOiBGb3Jnb3RQYXNzd29yZFJlcXVlc3RcbiAgKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvYXV0aC9mb3Jnb3QtcGFzc3dvcmRcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVzZXRQYXNzd29yZChcbiAgICBkYXRhOiBSZXNldFBhc3N3b3JkUmVxdWVzdFxuICApOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9hdXRoL3Jlc2V0LXBhc3N3b3JkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRPdHAoZGF0YTogU2VuZE90cFJlcXVlc3QpOiBQcm9taXNlPE90cFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvYXV0aC9zZW5kLW90cFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlPdHAoZGF0YTogVmVyaWZ5T3RwUmVxdWVzdCk6IFByb21pc2U8T3RwUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdDxPdHBSZXNwb25zZT4oXCIvYXBpL2F1dGgvdmVyaWZ5LW90cFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAocmVzcG9uc2UuYWNjZXNzVG9rZW4pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIiwgcmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0b2tlbl90eXBlXCIsIHJlc3BvbnNlLnRva2VuVHlwZSB8fCBcIkJlYXJlclwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBhc3luYyBnZXRCdXNpbmVzc2VzKHBhcmFtcz86IHtcbiAgICBrZXl3b3JkPzogc3RyaW5nO1xuICAgIGNhdGVnb3JpZXM/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBsb2NhdGlvbj86IHN0cmluZztcbiAgICBidXNpbmVzc1R5cGU/OiBzdHJpbmc7XG4gICAgbWluUmF0aW5nPzogbnVtYmVyO1xuICAgIHNlcnZpY2VEaXN0YW5jZT86IG51bWJlcjtcbiAgICB0YXJnZXRDdXN0b21lcj86IHN0cmluZztcbiAgICBpc0FwcHJvdmVkPzogYm9vbGVhbjtcbiAgICBpc09wZW5Ob3c/OiBib29sZWFuO1xuICAgIHNvcnQ/OiBcInJhdGluZ1wiIHwgXCJkaXN0YW5jZVwiIHwgXCJyZXZpZXdzXCIgfCBcIm5hbWVcIjtcbiAgICBwZXJfcGFnZT86IG51bWJlcjtcbiAgICBwYWdlPzogbnVtYmVyO1xuICAgIGFkZHJlc3M/OiBzdHJpbmc7XG4gICAgY2F0ZWdvcnk/OiBzdHJpbmc7IC8vIEFkZCBjYXRlZ29yeSBhcyBhIHNlcGFyYXRlIHBhcmFtZXRlclxuICB9KTogUHJvbWlzZTxCdXNpbmVzc0xpc3RSZXNwb25zZT4ge1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7IG1ldGhvZDogXCJHRVRcIiB9O1xuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgLy8gSGFuZGxlIGNhdGVnb3J5IHNlcGFyYXRlbHkgdG8gcHJldmVudCBkb3VibGUgZW5jb2RpbmdcbiAgICAgIGNvbnN0IHsgY2F0ZWdvcnksIC4uLnJlc3RQYXJhbXMgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImNhdGVnb3J5XCIsIGNhdGVnb3J5KTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIHRoZSByZXN0IG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgICBPYmplY3QuZW50cmllcyhyZXN0UGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHZhbHVlID8gXCIxXCIgOiBcIjBcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxCdXNpbmVzc0xpc3RSZXNwb25zZT4oXG4gICAgICBgL2FwaS9wdWJsaWMvYnVzaW5lc3Nlcz8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfSxcbiAgICAgIGZhbHNlIC8vIGRvZXNuJ3QgcmVxdWlyZSBhdXRoXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2ZpbGUoZGF0YTogUHJvZmlsZVVwZGF0ZURhdGEpOiBQcm9taXNlPFByb2ZpbGVVcGRhdGVSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvcHJvZmlsZVwiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7IC8vIHJlcXVpcmVzQXV0aCA9IHRydWVcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVByb2ZpbGVXaXRoRm9ybURhdGEoXG4gICAgZm9ybURhdGE6IEZvcm1EYXRhXG4gICk6IFByb21pc2U8UHJvZmlsZVVwZGF0ZVJlc3BvbnNlPiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuXG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcHJvZmlsZWAsIHtcbiAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YCxcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IENvbnRlbnQtVHlwZSBmb3IgRm9ybURhdGEgLSBicm93c2VyIHNldHMgaXQgd2l0aCBib3VuZGFyeVxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuXG4gICAgICAvLyBFbmhhbmNlZCBsb2dnaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFQSSBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306YCwge1xuICAgICAgICB1cmw6IGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3Byb2ZpbGVgLFxuICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgZXJyb3JEYXRhLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyMikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVmFsaWRhdGlvbiBFcnJvcnM6XCIsIGVycm9yRGF0YS5lcnJvcnMgfHwgZXJyb3JEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCBcIlZhbGlkYXRpb24gZmFpbGVkXCIsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9ycyB8fCBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyBnZXRQcm9maWxlKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9wcm9maWxlXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHVwbG9hZERvY3VtZW50KGZpbGU6IEZpbGUpOiBQcm9taXNlPERvY3VtZW50VXBsb2FkUmVzcG9uc2U+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJkb2N1bWVudFwiLCBmaWxlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvZG9jdW1lbnRzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICB9LFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRG9jdW1lbnQgdXBsb2FkIGVycm9yOlwiLCBlcnJvckRhdGEpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHVwbG9hZCBkb2N1bWVudFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgYXN5bmMgdXBsb2FkUHJvZmlsZUltYWdlKFxuICAgIGZpbGU6IEZpbGVcbiAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGRhdGE6IHsgdXJsOiBzdHJpbmcgfSB9PiB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJwcm9maWxlX2ltYWdlXCIsIGZpbGUpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWRlcnMgb2JqZWN0XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgLy8gRG9uJ3Qgc2V0IENvbnRlbnQtVHlwZSBoZWFkZXIsIGxldCB0aGUgYnJvd3NlciBzZXQgaXQgd2l0aCB0aGUgY29ycmVjdCBib3VuZGFyeVxuXG4gICAgLy8gR2V0IHRoZSBhdXRoIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcHJvZmlsZS9pbWFnZWAsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIHJlc3BvbnNlIGlzIE9LXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHVwbG9hZCBpbWFnZVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSByZXNwb25zZSBhcyBKU09OXG4gICAgICBsZXQgcmVzcG9uc2VEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBwYXJzaW5nIGZhaWxzIGJ1dCB0aGUgc3RhdHVzIGlzIDIwMCwgY29uc2lkZXIgaXQgYSBzdWNjZXNzXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgdXJsOiBcIlwiIH0gfTsgLy8gUmV0dXJuIGRlZmF1bHQgc3VjY2VzcyByZXNwb25zZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzZXJ2ZXIgcmVzcG9uc2VcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgLy8gVGhlIGJhY2tlbmQgbWlnaHQgYmUgcmV0dXJuaW5nIHRoZSBVUkwgZGlyZWN0bHkgb3IgaW4gYSBkYXRhIG9iamVjdFxuICAgICAgY29uc3QgaW1hZ2VVcmwgPSByZXNwb25zZURhdGEudXJsIHx8IHJlc3BvbnNlRGF0YS5kYXRhPy51cmwgfHwgXCJcIjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVybDogaW1hZ2VVcmwsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQVBJIEVycm9yOlwiLCBlcnJvcik7XG5cbiAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgdHlwZXMgb2YgZXJyb3JzXG4gICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEhhbmRsZSBGZXRjaCBBUEkgUmVzcG9uc2UgZXJyb3JzXG4gICAgICAgIGlmIChcbiAgICAgICAgICBcInJlc3BvbnNlXCIgaW4gZXJyb3IgJiZcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSAmJlxuICAgICAgICAgIHR5cGVvZiBlcnJvci5yZXNwb25zZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgIGVycm9yLnJlc3BvbnNlICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gV2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSB0eXBlXG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCBlcnJvci5yZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgXCLZgdi02YQg2YHZiiDYsdmB2Lkg2KfZhNi12YjYsdipXCIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSBlcnJvciByZXNwb25zZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi2YHYtNmEINmB2Yog2YXYudin2YTYrNipINin2LPYqtis2KfYqNipINin2YTYrtin2K/ZhVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgRXJyb3Igb2JqZWN0c1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgfHwgXCLYrdiv2Ksg2K7Yt9ijINij2KvZhtin2KEg2LHZgdi5INin2YTYtdmI2LHYqS4g2YrYsdis2Ykg2KfZhNmF2K3Yp9mI2YTYqSDZhdix2Kkg2KPYrtix2YkuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgZXJyb3JcbiAgICAgIHRocm93IG5ldyBFcnJvcihcItit2K/YqyDYrti32KMg2LrZitixINmF2KrZiNmC2LkuINmK2LHYrNmJINin2YTZhdit2KfZiNmE2Kkg2YXYsdipINij2K7YsdmJLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT0gSEVMUEVSUyA9PT09PT1cbiAgaXNBdXRoZW50aWNhdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIWxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBidXNpbmVzcyBwcm9maWxlIGZvciBhIHNwZWNpZmljIHN1cHBsaWVyXG4gICAqIEBwYXJhbSBpZCBUaGUgc3VwcGxpZXIgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSBzdXBwbGllcidzIGJ1c2luZXNzIHByb2ZpbGUgaW5jbHVkaW5nIHByb2R1Y3RzXG4gICAqL1xuICBhc3luYyBnZXRCdXNpbmVzc1Byb2ZpbGUoaWQ6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8QnVzaW5lc3NQcm9maWxlPiB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke3Rva2VufWApO1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllcnMvJHtpZH0vYnVzaW5lc3NgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIGJ1c2luZXNzIHByb2ZpbGVcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgcHJvZmlsZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0U3VwcGxpZXJQcm9maWxlKGlkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPFN1cHBsaWVyUHJvZmlsZT4ge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllcnMvJHtpZH1gLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggc3VwcGxpZXIgcHJvZmlsZVwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBzdXBwbGllciBwcm9maWxlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdWJtaXRSZXZpZXcoXG4gICAgc3VwcGxpZXJJZDogbnVtYmVyLFxuICAgIHJhdGluZzogbnVtYmVyLFxuICAgIGNvbW1lbnQ6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gcmVxdWlyZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9yYXRpbmdzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcmF0ZWRfc3VwcGxpZXJfaWQ6IHN1cHBsaWVySWQsXG4gICAgICAgIHNjb3JlOiByYXRpbmcsXG4gICAgICAgIGNvbW1lbnQ6IGNvbW1lbnQsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gc3VibWl0IHJldmlld1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgLy8gR2V0IGJ1c2luZXNzIHN0YXRpc3RpY3NcbiAgYXN5bmMgZ2V0U3RhdHMoKTogUHJvbWlzZTxCdXNpbmVzc1N0YXRzPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxCdXNpbmVzc1N0YXRzPihcIi9hcGkvcHVibGljL3N0YXRzXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHByb2ZpbGUgcGljdHVyZSBVUkwgZm9yIGEgdXNlclxuICAgKiBAcGFyYW0gdXNlcklkIFRoZSBJRCBvZiB0aGUgdXNlclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHByb2ZpbGUgcGljdHVyZSBVUkxcbiAgICovXG4gIGFzeW5jIGdldFByb2ZpbGVQaWN0dXJlKFxuICAgIHVzZXJJZDogc3RyaW5nIHwgbnVtYmVyXG4gICk6IFByb21pc2U8eyBwcm9maWxlX2ltYWdlOiBzdHJpbmcgfT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8eyBwcm9maWxlX2ltYWdlOiBzdHJpbmcgfT4oXG4gICAgICBgL2FwaS9hdXRoL3Byb2ZpbGUvcGljdHVyZS8ke3VzZXJJZH1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICogQHBhcmFtIGN1cnJlbnRQYXNzd29yZCBUaGUgdXNlcidzIGN1cnJlbnQgcGFzc3dvcmRcbiAgICogQHBhcmFtIG5ld1Bhc3N3b3JkIFRoZSBuZXcgcGFzc3dvcmRcbiAgICogQHBhcmFtIGNvbmZpcm1QYXNzd29yZCBUaGUgbmV3IHBhc3N3b3JkIGNvbmZpcm1hdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggc3VjY2VzcyBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBjaGFuZ2VQYXNzd29yZChcbiAgICBjdXJyZW50UGFzc3dvcmQ6IHN0cmluZyxcbiAgICBuZXdQYXNzd29yZDogc3RyaW5nLFxuICAgIGNvbmZpcm1QYXNzd29yZDogc3RyaW5nXG4gICk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8eyBtZXNzYWdlOiBzdHJpbmcgfT4oXG4gICAgICBcIi9hcGkvYXV0aC9jaGFuZ2UtcGFzc3dvcmRcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgY3VycmVudF9wYXNzd29yZDogY3VycmVudFBhc3N3b3JkLFxuICAgICAgICAgIHBhc3N3b3JkOiBuZXdQYXNzd29yZCxcbiAgICAgICAgICBwYXNzd29yZF9jb25maXJtYXRpb246IGNvbmZpcm1QYXNzd29yZCxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAgdHJ1ZSAvLyByZXF1aXJlcyBhdXRoZW50aWNhdGlvblxuICAgICk7XG4gIH1cblxuICAvLyA9PT09PT0gUFJFRkVSRU5DRVMgPT09PT09XG4gIGFzeW5jIGdldFByZWZlcmVuY2VzKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9wcmVmZXJlbmNlc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVQcmVmZXJlbmNlcyhwcmVmZXJlbmNlczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgXCIvYXBpL3N1cHBsaWVyL3ByZWZlcmVuY2VzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcmVmZXJlbmNlcyksXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cblxuICAvLyA9PT09PT0gUFJPRFVDVCBJTUFHRVMgPT09PT09XG4gIGFzeW5jIHVwbG9hZFByb2R1Y3RJbWFnZShmb3JtRGF0YTogRm9ybURhdGEpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcblxuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3Byb2R1Y3QtaW1hZ2VzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgZm9yIEZvcm1EYXRhIC0gYnJvd3NlciBzZXRzIGl0IHdpdGggYm91bmRhcnlcbiAgICAgIH0sXG4gICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlUHJvZHVjdEltYWdlKGltYWdlSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuXG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcHJvZHVjdC1pbWFnZXMvJHtpbWFnZUlkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzdWNjZXNzIGZvciBERUxFVEUgb3BlcmF0aW9uc1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6IFwiSW1hZ2UgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIiB9O1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQWNjb3VudCgpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcblxuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL2FjY291bnRgLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gc3VjY2VzcyBmb3IgREVMRVRFIG9wZXJhdGlvbnNcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIkFjY291bnQgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIiB9O1xuICB9XG5cbiAgLy8gPT09PT09IERBU0hCT0FSRCA9PT09PT1cbiAgYXN5bmMgZ2V0RGFzaGJvYXJkKHJhbmdlOiBzdHJpbmcgPSBcIjMwXCIpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBgL2FwaS9zdXBwbGllci9kYXNoYm9hcmQ/cmFuZ2U9JHtyYW5nZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbn1cblxuLy8gU3VwcGxpZXIgSW5xdWlyeSBJbnRlcmZhY2VzXG5leHBvcnQgaW50ZXJmYWNlIElucXVpcnkge1xuICBpZDogbnVtYmVyO1xuICBzdWJqZWN0OiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgY29tcGFueTogc3RyaW5nIHwgbnVsbDtcbiAgc2VuZGVyOiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBuYW1lOiBzdHJpbmc7XG4gIH07XG4gIHJlY2VpdmVyOiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBuYW1lOiBzdHJpbmc7XG4gIH07XG4gIGlzX3JlYWQ6IGJvb2xlYW47XG4gIHR5cGU6IFwiaW5xdWlyeVwiIHwgXCJyZXBseVwiO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHRpbWVfYWdvOiBzdHJpbmc7XG4gIGlzX3JlcGx5OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucXVpcnlSZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZGF0YTogSW5xdWlyeTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnF1aXJ5TGlzdFJlc3BvbnNlIHtcbiAgZGF0YTogSW5xdWlyeVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRTdGF0dXNSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuLy8gSW50ZXJmYWNlIGZvciBidXNpbmVzcyBzdGF0aXN0aWNzXG5pbnRlcmZhY2UgQnVzaW5lc3NTdGF0cyB7XG4gIHRvdGFsX2J1c2luZXNzZXM6IG51bWJlcjtcbiAgdG90YWxfc3VwcGxpZXJzOiBudW1iZXI7XG4gIG9wZW5fbm93OiBudW1iZXI7XG4gIG5ld190aGlzX3dlZWs6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGFwaVNlcnZpY2UgPSBuZXcgQXBpU2VydmljZSgpO1xuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsIlZhbGlkYXRpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZXJyb3JzIiwibmFtZSIsIkFwaVNlcnZpY2UiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwicmVxdWlyZXNBdXRoIiwidXJsIiwiYmFzZVVSTCIsImNvbnNvbGUiLCJsb2ciLCJtZXRob2QiLCJvcHRpb25zSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0IiwiYXNzaWduIiwiQWNjZXB0IiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidG9rZW5UeXBlIiwiZXJyb3IiLCJib2R5IiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlQ2xvbmUiLCJjbG9uZSIsInJlc3BvbnNlVGV4dCIsInRleHQiLCJyZXNwb25zZURhdGEiLCJKU09OIiwicGFyc2UiLCJlIiwib2siLCJ2YWxpZGF0aW9uRXJyb3IiLCJzZW5kSW5xdWlyeSIsImRhdGEiLCJzdHJpbmdpZnkiLCJyZXBseVRvSW5xdWlyeSIsImlucXVpcnlJZCIsIm1hcmtJbnF1aXJ5QXNSZWFkIiwiZ2V0SW5xdWlyeSIsImdldEFsbElucXVpcmllcyIsInJlZ2lzdGVyU3VwcGxpZXIiLCJsb2dpbiIsImFjY2Vzc1Rva2VuIiwic2V0SXRlbSIsImxvZ291dCIsIkF1dGhvcml6YXRpb24iLCJqc29uIiwiY2F0Y2giLCJyZW1vdmVJdGVtIiwiZm9yZ290UGFzc3dvcmQiLCJyZXNldFBhc3N3b3JkIiwic2VuZE90cCIsInZlcmlmeU90cCIsImdldEJ1c2luZXNzZXMiLCJwYXJhbXMiLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImNhdGVnb3J5IiwicmVzdFBhcmFtcyIsImFwcGVuZCIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJqb2luIiwidG9TdHJpbmciLCJ1cGRhdGVQcm9maWxlIiwidXBkYXRlUHJvZmlsZVdpdGhGb3JtRGF0YSIsImZvcm1EYXRhIiwiZXJyb3JEYXRhIiwiZ2V0UHJvZmlsZSIsInVwbG9hZERvY3VtZW50IiwiZmlsZSIsIkZvcm1EYXRhIiwidXBsb2FkUHJvZmlsZUltYWdlIiwic3VjY2VzcyIsImltYWdlVXJsIiwiaXNBdXRoZW50aWNhdGVkIiwiZ2V0QnVzaW5lc3NQcm9maWxlIiwiaWQiLCJnZXRTdXBwbGllclByb2ZpbGUiLCJzdWJtaXRSZXZpZXciLCJzdXBwbGllcklkIiwicmF0aW5nIiwiY29tbWVudCIsInJhdGVkX3N1cHBsaWVyX2lkIiwic2NvcmUiLCJnZXRTdGF0cyIsImdldFByb2ZpbGVQaWN0dXJlIiwidXNlcklkIiwiY2hhbmdlUGFzc3dvcmQiLCJjdXJyZW50UGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsImNvbmZpcm1QYXNzd29yZCIsImN1cnJlbnRfcGFzc3dvcmQiLCJwYXNzd29yZCIsInBhc3N3b3JkX2NvbmZpcm1hdGlvbiIsImdldFByZWZlcmVuY2VzIiwidXBkYXRlUHJlZmVyZW5jZXMiLCJwcmVmZXJlbmNlcyIsInVwbG9hZFByb2R1Y3RJbWFnZSIsImRlbGV0ZVByb2R1Y3RJbWFnZSIsImltYWdlSWQiLCJkZWxldGVBY2NvdW50IiwiZ2V0RGFzaGJvYXJkIiwicmFuZ2UiLCJhcGlTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});