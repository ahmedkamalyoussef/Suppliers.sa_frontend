"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },\n/* harmony export */   apiService: function() { return /* binding */ apiService; }\n/* harmony export */ });\n// services/api.ts\nconst API_BASE_URL = \"http://localhost:8000\";\nclass ValidationError extends Error {\n    constructor(message, errors){\n        super(message);\n        this.name = \"ValidationError\";\n        this.errors = errors;\n    }\n}\nclass ApiService {\n    // ====== REQUEST WRAPPER ======\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, requiresAuth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        // Convert HeadersInit to Record<string, string>\n        const optionsHeaders = {};\n        if (options.headers) {\n            if (options.headers instanceof Headers) {\n                options.headers.forEach((value, key)=>{\n                    optionsHeaders[key] = value;\n                });\n            } else if (Array.isArray(options.headers)) {\n                options.headers.forEach((param)=>{\n                    let [key, value] = param;\n                    optionsHeaders[key] = value;\n                });\n            } else {\n                Object.assign(optionsHeaders, options.headers);\n            }\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n            ...optionsHeaders\n        };\n        if (requiresAuth) {\n            const token = localStorage.getItem(\"supplier_token\");\n            const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n            if (!token) throw new Error(\"No auth token found\");\n            headers[\"Authorization\"] = \"\".concat(tokenType, \" \").concat(token);\n        }\n        const response = await fetch(url, {\n            ...options,\n            credentials: \"include\",\n            headers\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            // Enhanced logging for debugging\n            console.error(\"API Error \".concat(response.status, \":\"), {\n                url,\n                method: options.method || \"GET\",\n                errorData,\n                headers\n            });\n            if (response.status === 422) {\n                const validationError = new ValidationError(\"Validation failed\", errorData.errors || errorData);\n                // Log detailed validation errors\n                console.error(\"Validation Errors:\", validationError.errors);\n                console.error(\"Error data:\", errorData);\n                // Log password validation specifically\n                if (errorData.password) {\n                    console.error(\"Password validation errors:\", errorData.password);\n                }\n                throw validationError;\n            }\n            throw new Error(errorData.message || \"HTTP error \".concat(response.status));\n        }\n        return await response.json();\n    }\n    // ====== API METHODS ======\n    async registerSupplier(data) {\n        return this.request(\"/api/supplier/register\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async login(data) {\n        const response = await this.request(\"/api/auth/login\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async logout() {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/logout\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({\n                    message: \"Logout failed\"\n                }));\n            throw new Error(error.message || \"Logout failed\");\n        }\n        // Clear localStorage after successful logout\n        localStorage.removeItem(\"supplier_token\");\n        localStorage.removeItem(\"token_type\");\n        localStorage.removeItem(\"supplier_user\");\n    }\n    async forgotPassword(data) {\n        return this.request(\"/api/auth/forgot-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async resetPassword(data) {\n        return this.request(\"/api/auth/reset-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async sendOtp(data) {\n        return this.request(\"/api/auth/send-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async verifyOtp(data) {\n        const response = await this.request(\"/api/auth/verify-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async getBusinesses(params) {\n        const queryParams = new URLSearchParams();\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined && value !== null) {\n                    if (Array.isArray(value)) {\n                        queryParams.append(key, value.join(\",\"));\n                    } else if (typeof value === \"boolean\") {\n                        queryParams.append(key, value ? \"1\" : \"0\");\n                    } else {\n                        queryParams.append(key, value.toString());\n                    }\n                }\n            });\n        }\n        return this.request(\"/api/public/businesses?\".concat(queryParams.toString()), {\n            method: \"GET\"\n        }, false // doesn't require auth\n        );\n    }\n    async updateProfile(data) {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"PATCH\",\n            body: JSON.stringify(data)\n        }, true); // requiresAuth = true\n    }\n    async updateProfileWithFormData(formData) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile\"), {\n            method: \"PATCH\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            // Enhanced logging for debugging\n            console.error(\"API Error \".concat(response.status, \":\"), {\n                url: \"\".concat(this.baseURL, \"/api/supplier/profile\"),\n                method: \"PATCH\",\n                errorData\n            });\n            if (response.status === 422) {\n                console.error(\"Validation Errors:\", errorData.errors || errorData);\n                throw new ValidationError(errorData.message || \"Validation failed\", errorData.errors || errorData);\n            }\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async getProfile() {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"GET\"\n        }, true);\n    }\n    async uploadDocument(file) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const formData = new FormData();\n        formData.append(\"document\", file);\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/documents\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData,\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            console.error(\"Document upload error:\", errorData);\n            throw new Error(errorData.message || \"Failed to upload document\");\n        }\n        return await response.json();\n    }\n    async uploadProfileImage(file) {\n        const formData = new FormData();\n        formData.append(\"profile_image\", file);\n        // Create headers object\n        const headers = new Headers();\n        // Don't set Content-Type header, let the browser set it with the correct boundary\n        // Get the auth token\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n        }\n        try {\n            var _responseData_data;\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile/image\"), {\n                method: \"POST\",\n                headers,\n                body: formData,\n                credentials: \"include\"\n            });\n            // First, check if the response is OK\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to upload image\");\n            }\n            // Try to parse the response as JSON\n            let responseData;\n            try {\n                responseData = await response.json();\n            } catch (e) {\n                // If parsing fails but the status is 200, consider it a success\n                if (response.status === 200) {\n                    return {\n                        success: true,\n                        data: {\n                            url: \"\"\n                        }\n                    }; // Return default success response\n                }\n                throw new Error(\"Failed to parse server response\");\n            }\n            // If we got here, the request was successful\n            // The backend might be returning the URL directly or in a data object\n            const imageUrl = responseData.url || ((_responseData_data = responseData.data) === null || _responseData_data === void 0 ? void 0 : _responseData_data.url) || \"\";\n            return {\n                success: true,\n                data: {\n                    url: imageUrl\n                }\n            };\n        } catch (error) {\n            console.error(\"API Error:\", error);\n            // Handle different types of errors\n            if (typeof error === \"object\" && error !== null) {\n                // Handle Fetch API Response errors\n                if (\"response\" in error && error.response && typeof error.response === \"object\" && error.response !== null) {\n                    try {\n                        // @ts-ignore - We've already checked the type\n                        const errorData = await error.response.json().catch(()=>({}));\n                        throw new Error(errorData.message || \"فشل في رفع الصورة\");\n                    } catch (e) {\n                        // If we can't parse the error response\n                        throw new Error(\"فشل في معالجة استجابة الخادم\");\n                    }\n                }\n                // Handle Error objects\n                if (error instanceof Error) {\n                    throw new Error(error.message || \"حدث خطأ أثناء رفع الصورة. يرجى المحاولة مرة أخرى.\");\n                }\n            }\n            // Default error\n            throw new Error(\"حدث خطأ غير متوقع. يرجى المحاولة مرة أخرى.\");\n        }\n    }\n    // ====== HELPERS ======\n    isAuthenticated() {\n        return !!localStorage.getItem(\"supplier_token\");\n    }\n    /**\n   * Fetches business profile for a specific supplier\n   * @param id The supplier ID\n   * @returns Promise with the supplier's business profile including products\n   */ async getBusinessProfile(id) {\n        console.log(\"Fetching business profile for ID:\", id);\n        const headers = new Headers();\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n            headers.append(\"Accept\", \"application/json\");\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/suppliers/\").concat(id, \"/business\"), {\n                method: \"GET\",\n                headers,\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to fetch business profile\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Error fetching business profile:\", error);\n            throw error;\n        }\n    }\n    async getSupplierProfile(id) {\n        console.log(\"Fetching supplier profile for ID:\", id);\n        const headers = new Headers();\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n            headers.append(\"Accept\", \"application/json\");\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/suppliers/\").concat(id), {\n                method: \"GET\",\n                headers,\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to fetch supplier profile\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Error fetching supplier profile:\", error);\n            throw error;\n        }\n    }\n    async submitReview(supplierId, rating, comment) {\n        const token = localStorage.getItem(\"supplier_token\");\n        if (!token) {\n            throw new Error(\"Authentication required\");\n        }\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/ratings\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": \"Bearer \".concat(token),\n                \"Accept\": \"application/json\"\n            },\n            body: JSON.stringify({\n                rated_supplier_id: supplierId,\n                score: rating,\n                comment: comment\n            })\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({}));\n            throw new Error(error.message || \"Failed to submit review\");\n        }\n        return response.json();\n    }\n    constructor(){\n        this.baseURL = API_BASE_URL;\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSWpDLE1BQ1IrQixVQUFVN0IsT0FBTyxJQUFJO1lBRXpCO1lBRUEsT0FBTyxNQUFNeUIsU0FBU0ssSUFBSTtRQUM1QixFQUFFLE9BQU9HLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbEQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTStDLGFBQWFDLFVBQWtCLEVBQUVDLE1BQWMsRUFBRUMsT0FBZSxFQUFnQztRQUNwRyxNQUFNOUQsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLElBQUksQ0FBQ0YsT0FBTztZQUNWLE1BQU0sSUFBSXZCLE1BQU07UUFDbEI7UUFFQSxNQUFNMkIsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDakIsT0FBTyxFQUFDLDBCQUF3QjtZQUNuRTBCLFFBQVE7WUFDUnhCLFNBQVM7Z0JBQ1AsZ0JBQWdCO2dCQUNoQixpQkFBaUIsVUFBZ0IsT0FBTlU7Z0JBQzNCLFVBQVU7WUFDWjtZQUNBbUIsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUNuQjBDLG1CQUFtQkg7Z0JBQ25CSSxPQUFPSDtnQkFDUEMsU0FBU0E7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDMUQsU0FBU0csRUFBRSxFQUFFO1lBQ2hCLE1BQU1LLFFBQVEsTUFBTVIsU0FBU0ssSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBQ2xELE1BQU0sSUFBSWpDLE1BQU1tQyxNQUFNakMsT0FBTyxJQUFJO1FBQ25DO1FBRUEsT0FBT3lCLFNBQVNLLElBQUk7SUFDdEI7SUExZUEvQixhQUFjO1FBQ1osSUFBSSxDQUFDVSxPQUFPLEdBQUdiO0lBQ2pCO0FBeWVGO0FBRU8sTUFBTTBGLGFBQWEsSUFBSW5GLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS50cz82OGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlcnZpY2VzL2FwaS50c1xuY29uc3QgQVBJX0JBU0VfVVJMID0gXCJodHRwOi8vbG9jYWxob3N0OjgwMDBcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSZXZpZXcge1xuICBpZDogbnVtYmVyO1xuICByYXRpbmc6IG51bWJlcjtcbiAgY29tbWVudDogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVzZXI6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgYXZhdGFyPzogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENlcnRpZmljYXRpb24ge1xuICBpZDogbnVtYmVyO1xuICBjZXJ0aWZpY2F0aW9uX25hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9kdWN0IHtcbiAgaWQ6IG51bWJlcjtcbiAgcHJvZHVjdF9uYW1lOiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2Uge1xuICBpZDogbnVtYmVyO1xuICBzZXJ2aWNlX25hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaG9uZSB7XG4gIGlkOiBudW1iZXI7XG4gIHR5cGU6IHN0cmluZztcbiAgbnVtYmVyOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JraW5nSG91ciB7XG4gIG9wZW46IHN0cmluZztcbiAgY2xvc2U6IHN0cmluZztcbiAgY2xvc2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1cHBsaWVyUHJvZmlsZURhdGEge1xuICBidXNpbmVzc190eXBlOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGJ1c2luZXNzX2ltYWdlOiBzdHJpbmc7XG4gIHdlYnNpdGU6IHN0cmluZztcbiAgY29udGFjdF9lbWFpbDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgc2VydmljZV9kaXN0YW5jZTogc3RyaW5nO1xuICB0YXJnZXRfbWFya2V0OiBzdHJpbmdbXTtcbiAgbWFpbl9waG9uZTogc3RyaW5nO1xuICBhZGRpdGlvbmFsX3Bob25lczogUGhvbmVbXTtcbiAgYnVzaW5lc3NfYWRkcmVzczogc3RyaW5nO1xuICBsYXRpdHVkZTogc3RyaW5nO1xuICBsb25naXR1ZGU6IHN0cmluZztcbiAgd29ya2luZ19ob3VyczogUmVjb3JkPHN0cmluZywgV29ya2luZ0hvdXI+O1xuICBzZXJ2aWNlc19vZmZlcmVkOiBzdHJpbmdbXTtcbiAgcHJvZHVjdHM/OiBQcm9kdWN0W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VwcGxpZXJQcm9maWxlIHtcbiAgaWQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcHJvZmlsZTogU3VwcGxpZXJQcm9maWxlRGF0YTtcbiAgcHJvZmlsZV9pbWFnZTogc3RyaW5nO1xuICByYXRpbmdzOiB7XG4gICAgYXZlcmFnZTogbnVtYmVyIHwgbnVsbDtcbiAgICBjb3VudDogbnVtYmVyO1xuICAgIHJldmlld3M6IFJldmlld1tdO1xuICB9O1xuICBjZXJ0aWZpY2F0aW9uczogQ2VydGlmaWNhdGlvbltdO1xuICBwcm9kdWN0X2ltYWdlczogQXJyYXk8e1xuICAgIGlkOiBudW1iZXI7XG4gICAgaW1hZ2VfdXJsOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICB9PjtcbiAgc2VydmljZXM6IFNlcnZpY2VbXTtcbn1cblxuLy8gQnVzaW5lc3NQcm9maWxlIGV4dGVuZHMgU3VwcGxpZXJQcm9maWxlIHdpdGggZXhwbGljaXQgcHJvZHVjdHMgaW4gcHJvZmlsZVxuZXhwb3J0IGludGVyZmFjZSBCdXNpbmVzc1Byb2ZpbGUgZXh0ZW5kcyBPbWl0PFN1cHBsaWVyUHJvZmlsZSwgXCJwcm9maWxlXCI+IHtcbiAgcHJvZmlsZTogU3VwcGxpZXJQcm9maWxlRGF0YSAmIHtcbiAgICBwcm9kdWN0czogUHJvZHVjdFtdOyAvLyBDb21wYW55IHByb2R1Y3RzIGluc2lkZSBwcm9maWxlXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cmF0aW9uRGF0YSB7XG4gIGJ1c2luZXNzTmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBwYXNzd29yZF9jb25maXJtYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RyYXRpb25SZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgc3VwcGxpZXI6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kT3RwUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5T3RwUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG90cDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcmdvdFBhc3N3b3JkUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzZXRQYXNzd29yZFJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xuICBvdHA6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcGFzc3dvcmRfY29uZmlybWF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5SZXF1ZXN0IHtcbiAgZW1haWw6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpblJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB1c2VyVHlwZTogc3RyaW5nO1xuICBzdXBwbGllcjoge1xuICAgIGlkOiBudW1iZXI7XG4gICAgc2x1Zzogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBob25lOiBzdHJpbmc7XG4gICAgcHJvZmlsZUltYWdlOiBzdHJpbmc7XG4gICAgZW1haWxWZXJpZmllZEF0OiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgcGxhbjogc3RyaW5nO1xuICAgIHByb2ZpbGVDb21wbGV0aW9uOiBudW1iZXI7XG4gICAgcHJvZmlsZTogYW55O1xuICAgIGJyYW5jaGVzOiBhbnlbXTtcbiAgfTtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgdG9rZW5UeXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3RwUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIHN1cHBsaWVyPzogYW55O1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgdG9rZW5UeXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGVVcGRhdGVEYXRhIHtcbiAgYnVzaW5lc3NOYW1lPzogc3RyaW5nO1xuICBidXNpbmVzc1R5cGU/OiBzdHJpbmc7XG4gIGNhdGVnb3JpZXM/OiBzdHJpbmdbXTtcbiAgcHJvZHVjdEtleXdvcmRzPzogc3RyaW5nW107XG4gIHdob0RvWW91U2VydmU/OiBzdHJpbmc7XG4gIHNlcnZpY2VEaXN0YW5jZT86IG51bWJlcjtcbiAgc2VydmljZXM/OiBzdHJpbmdbXTtcbiAgd2Vic2l0ZT86IHN0cmluZztcbiAgbWFpblBob25lPzogc3RyaW5nO1xuICBhZGRpdGlvbmFsUGhvbmVzPzogQXJyYXk8e1xuICAgIG51bWJlcjogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG4gIH0+O1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBsb2NhdGlvbj86IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH07XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB3b3JraW5nSG91cnM/OiB7XG4gICAgW2tleTogc3RyaW5nXToge1xuICAgICAgY2xvc2VkPzogYm9vbGVhbjtcbiAgICAgIG9wZW4/OiBzdHJpbmc7XG4gICAgICBjbG9zZT86IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBoYXNCcmFuY2hlcz86IGJvb2xlYW47XG4gIGJyYW5jaGVzPzogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBwaG9uZT86IHN0cmluZztcbiAgICBlbWFpbD86IHN0cmluZztcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIG1hbmFnZXI/OiBzdHJpbmc7XG4gICAgbG9jYXRpb24/OiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9O1xuICAgIHdvcmtpbmdIb3Vycz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgICAgY2xvc2VkPzogYm9vbGVhbjtcbiAgICAgICAgb3Blbj86IHN0cmluZztcbiAgICAgICAgY2xvc2U/OiBzdHJpbmc7XG4gICAgICB9O1xuICAgIH07XG4gICAgc3BlY2lhbFNlcnZpY2VzPzogc3RyaW5nW107XG4gICAgaXNNYWluQnJhbmNoPzogYm9vbGVhbjtcbiAgfT47XG4gIGNvbnRhY3RFbWFpbD86IHN0cmluZzsgLy8gRnJvbSB2ZXJpZmljYXRpb24vbG9naW5cbiAgY29udGFjdFBob25lPzogc3RyaW5nOyAvLyBGcm9tIHZlcmlmaWNhdGlvbi9sb2dpblxuICBjYXRlZ29yeT86IHN0cmluZztcbiAgZG9jdW1lbnQ/OiBGaWxlOyAvLyBJbmNsdWRlIGRvY3VtZW50IGluIG1haW4gcmVxdWVzdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGVVcGRhdGVSZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgc3VwcGxpZXI6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFVwbG9hZFJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3Mge1xuICBpZDogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIHByb2ZpbGVJbWFnZTogc3RyaW5nO1xuICBzbHVnOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGNhdGVnb3JpZXM6IHN0cmluZ1tdO1xuICBidXNpbmVzc1R5cGU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICBzZXJ2aWNlRGlzdGFuY2U6IG51bWJlcjtcbiAgcmF0aW5nPzogbnVtYmVyO1xuICByZXZpZXdzQ291bnQ6IG51bWJlcjtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIHBsYW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdXNpbmVzc0xpc3RSZXNwb25zZSB7XG4gIGRhdGE6IEJ1c2luZXNzW107XG4gIG1ldGE6IHtcbiAgICBjdXJyZW50X3BhZ2U6IG51bWJlcjtcbiAgICBwZXJfcGFnZTogbnVtYmVyO1xuICAgIHRvdGFsOiBudW1iZXI7XG4gICAgbGFzdF9wYWdlOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBpRXJyb3Ige1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIGVycm9yczogQXBpRXJyb3I7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBlcnJvcnM6IEFwaUVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgfVxufVxuXG5jbGFzcyBBcGlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYXNlVVJMID0gQVBJX0JBU0VfVVJMO1xuICB9XG5cbiAgLy8gPT09PT09IFJFUVVFU1QgV1JBUFBFUiA9PT09PT1cbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0PFQ+KFxuICAgIGVuZHBvaW50OiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSxcbiAgICByZXF1aXJlc0F1dGg6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gO1xuXG4gICAgLy8gQ29udmVydCBIZWFkZXJzSW5pdCB0byBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgY29uc3Qgb3B0aW9uc0hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICBpZiAob3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIG9wdGlvbnNIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgb3B0aW9uc0hlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc0hlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLm9wdGlvbnNIZWFkZXJzLFxuICAgIH07XG5cbiAgICBpZiAocmVxdWlyZXNBdXRoKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcbiAgICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcblxuICAgICAgLy8gRW5oYW5jZWQgbG9nZ2luZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmVycm9yKGBBUEkgRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OmAsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgIGVycm9yRGF0YSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcihcbiAgICAgICAgICBcIlZhbGlkYXRpb24gZmFpbGVkXCIsXG4gICAgICAgICAgZXJyb3JEYXRhLmVycm9ycyB8fCBlcnJvckRhdGFcbiAgICAgICAgKTtcbiAgICAgICAgLy8gTG9nIGRldGFpbGVkIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWYWxpZGF0aW9uIEVycm9yczpcIiwgdmFsaWRhdGlvbkVycm9yLmVycm9ycyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkYXRhOlwiLCBlcnJvckRhdGEpO1xuICAgICAgICAvLyBMb2cgcGFzc3dvcmQgdmFsaWRhdGlvbiBzcGVjaWZpY2FsbHlcbiAgICAgICAgaWYgKGVycm9yRGF0YS5wYXNzd29yZCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQYXNzd29yZCB2YWxpZGF0aW9uIGVycm9yczpcIiwgZXJyb3JEYXRhLnBhc3N3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB2YWxpZGF0aW9uRXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgSFRUUCBlcnJvciAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgLy8gPT09PT09IEFQSSBNRVRIT0RTID09PT09PVxuICBhc3luYyByZWdpc3RlclN1cHBsaWVyKFxuICAgIGRhdGE6IFJlZ2lzdHJhdGlvbkRhdGFcbiAgKTogUHJvbWlzZTxSZWdpc3RyYXRpb25SZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvYXBpL3N1cHBsaWVyL3JlZ2lzdGVyXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGxvZ2luKGRhdGE6IExvZ2luUmVxdWVzdCk6IFByb21pc2U8TG9naW5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0PExvZ2luUmVzcG9uc2U+KFwiL2FwaS9hdXRoL2xvZ2luXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmIChyZXNwb25zZS5hY2Nlc3NUb2tlbikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiLCByZXNwb25zZS5hY2Nlc3NUb2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRva2VuX3R5cGVcIiwgcmVzcG9uc2UudG9rZW5UeXBlIHx8IFwiQmVhcmVyXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIGxvZ291dCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9hdXRoL2xvZ291dGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlXG4gICAgICAgIC5qc29uKClcbiAgICAgICAgLmNhdGNoKCgpID0+ICh7IG1lc3NhZ2U6IFwiTG9nb3V0IGZhaWxlZFwiIH0pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8IFwiTG9nb3V0IGZhaWxlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBsb2NhbFN0b3JhZ2UgYWZ0ZXIgc3VjY2Vzc2Z1bCBsb2dvdXRcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwidG9rZW5fdHlwZVwiKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInN1cHBsaWVyX3VzZXJcIik7XG4gIH1cblxuICBhc3luYyBmb3Jnb3RQYXNzd29yZChcbiAgICBkYXRhOiBGb3Jnb3RQYXNzd29yZFJlcXVlc3RcbiAgKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvYXV0aC9mb3Jnb3QtcGFzc3dvcmRcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVzZXRQYXNzd29yZChcbiAgICBkYXRhOiBSZXNldFBhc3N3b3JkUmVxdWVzdFxuICApOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9hdXRoL3Jlc2V0LXBhc3N3b3JkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRPdHAoZGF0YTogU2VuZE90cFJlcXVlc3QpOiBQcm9taXNlPE90cFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvYXV0aC9zZW5kLW90cFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlPdHAoZGF0YTogVmVyaWZ5T3RwUmVxdWVzdCk6IFByb21pc2U8T3RwUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdDxPdHBSZXNwb25zZT4oXCIvYXBpL2F1dGgvdmVyaWZ5LW90cFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAocmVzcG9uc2UuYWNjZXNzVG9rZW4pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIiwgcmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0b2tlbl90eXBlXCIsIHJlc3BvbnNlLnRva2VuVHlwZSB8fCBcIkJlYXJlclwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBhc3luYyBnZXRCdXNpbmVzc2VzKHBhcmFtcz86IHtcbiAgICBrZXl3b3JkPzogc3RyaW5nO1xuICAgIGNhdGVnb3JpZXM/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBsb2NhdGlvbj86IHN0cmluZztcbiAgICBidXNpbmVzc1R5cGU/OiBzdHJpbmc7XG4gICAgbWluUmF0aW5nPzogbnVtYmVyO1xuICAgIHNlcnZpY2VEaXN0YW5jZT86IG51bWJlcjtcbiAgICB0YXJnZXRDdXN0b21lcj86IHN0cmluZztcbiAgICBpc0FwcHJvdmVkPzogYm9vbGVhbjtcbiAgICBpc09wZW5Ob3c/OiBib29sZWFuO1xuICAgIHNvcnQ/OiAncmF0aW5nJyB8ICdkaXN0YW5jZScgfCAncmV2aWV3cycgfCAnbmFtZSc7XG4gICAgcGVyX3BhZ2U/OiBudW1iZXI7XG4gICAgcGFnZT86IG51bWJlcjtcbiAgfSk6IFByb21pc2U8QnVzaW5lc3NMaXN0UmVzcG9uc2U+IHtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUuam9pbignLCcpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSA/ICcxJyA6ICcwJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxCdXNpbmVzc0xpc3RSZXNwb25zZT4oXG4gICAgICBgL2FwaS9wdWJsaWMvYnVzaW5lc3Nlcz8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9LFxuICAgICAgZmFsc2UgLy8gZG9lc24ndCByZXF1aXJlIGF1dGhcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvZmlsZShkYXRhOiBQcm9maWxlVXBkYXRlRGF0YSk6IFByb21pc2U8UHJvZmlsZVVwZGF0ZVJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9wcm9maWxlXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTsgLy8gcmVxdWlyZXNBdXRoID0gdHJ1ZVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvZmlsZVdpdGhGb3JtRGF0YShcbiAgICBmb3JtRGF0YTogRm9ybURhdGFcbiAgKTogUHJvbWlzZTxQcm9maWxlVXBkYXRlUmVzcG9uc2U+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9wcm9maWxlYCwge1xuICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gLFxuICAgICAgICAvLyBEb24ndCBzZXQgQ29udGVudC1UeXBlIGZvciBGb3JtRGF0YSAtIGJyb3dzZXIgc2V0cyBpdCB3aXRoIGJvdW5kYXJ5XG4gICAgICB9LFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG5cbiAgICAgIC8vIEVuaGFuY2VkIGxvZ2dpbmcgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc29sZS5lcnJvcihgQVBJIEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTpgLCB7XG4gICAgICAgIHVybDogYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcHJvZmlsZWAsXG4gICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICBlcnJvckRhdGEsXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJWYWxpZGF0aW9uIEVycm9yczpcIiwgZXJyb3JEYXRhLmVycm9ycyB8fCBlcnJvckRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiVmFsaWRhdGlvbiBmYWlsZWRcIixcbiAgICAgICAgICBlcnJvckRhdGEuZXJyb3JzIHx8IGVycm9yRGF0YVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIGFzeW5jIGdldFByb2ZpbGUoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgXCIvYXBpL3N1cHBsaWVyL3Byb2ZpbGVcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgdXBsb2FkRG9jdW1lbnQoZmlsZTogRmlsZSk6IFByb21pc2U8RG9jdW1lbnRVcGxvYWRSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcblxuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG5cbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcImRvY3VtZW50XCIsIGZpbGUpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9kb2N1bWVudHNgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJEb2N1bWVudCB1cGxvYWQgZXJyb3I6XCIsIGVycm9yRGF0YSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBsb2FkIGRvY3VtZW50XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICBhc3luYyB1cGxvYWRQcm9maWxlSW1hZ2UoXG4gICAgZmlsZTogRmlsZVxuICApOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZGF0YTogeyB1cmw6IHN0cmluZyB9IH0+IHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcInByb2ZpbGVfaW1hZ2VcIiwgZmlsZSk7XG5cbiAgICAvLyBDcmVhdGUgaGVhZGVycyBvYmplY3RcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBEb24ndCBzZXQgQ29udGVudC1UeXBlIGhlYWRlciwgbGV0IHRoZSBicm93c2VyIHNldCBpdCB3aXRoIHRoZSBjb3JyZWN0IGJvdW5kYXJ5XG5cbiAgICAvLyBHZXQgdGhlIGF1dGggdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke3Rva2VufWApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9wcm9maWxlL2ltYWdlYCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgcmVzcG9uc2UgaXMgT0tcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBsb2FkIGltYWdlXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIHJlc3BvbnNlIGFzIEpTT05cbiAgICAgIGxldCByZXNwb25zZURhdGE7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMgYnV0IHRoZSBzdGF0dXMgaXMgMjAwLCBjb25zaWRlciBpdCBhIHN1Y2Nlc3NcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyB1cmw6IFwiXCIgfSB9OyAvLyBSZXR1cm4gZGVmYXVsdCBzdWNjZXNzIHJlc3BvbnNlXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHNlcnZlciByZXNwb25zZVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgICAvLyBUaGUgYmFja2VuZCBtaWdodCBiZSByZXR1cm5pbmcgdGhlIFVSTCBkaXJlY3RseSBvciBpbiBhIGRhdGEgb2JqZWN0XG4gICAgICBjb25zdCBpbWFnZVVybCA9IHJlc3BvbnNlRGF0YS51cmwgfHwgcmVzcG9uc2VEYXRhLmRhdGE/LnVybCB8fCBcIlwiO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdXJsOiBpbWFnZVVybCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgRXJyb3I6XCIsIGVycm9yKTtcblxuICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCB0eXBlcyBvZiBlcnJvcnNcbiAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSGFuZGxlIEZldGNoIEFQSSBSZXNwb25zZSBlcnJvcnNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwicmVzcG9uc2VcIiBpbiBlcnJvciAmJlxuICAgICAgICAgIGVycm9yLnJlc3BvbnNlICYmXG4gICAgICAgICAgdHlwZW9mIGVycm9yLnJlc3BvbnNlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBXZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlIHR5cGVcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IGVycm9yLnJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBcItmB2LTZhCDZgdmKINix2YHYuSDYp9mE2LXZiNix2KlcIik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcGFyc2UgdGhlIGVycm9yIHJlc3BvbnNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCLZgdi02YQg2YHZiiDZhdi52KfZhNis2Kkg2KfYs9iq2KzYp9io2Kkg2KfZhNiu2KfYr9mFXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBFcnJvciBvYmplY3RzXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSB8fCBcItit2K/YqyDYrti32KMg2KPYq9mG2KfYoSDYsdmB2Lkg2KfZhNi12YjYsdipLiDZitix2KzZiSDYp9mE2YXYrdin2YjZhNipINmF2LHYqSDYo9iu2LHZiS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBlcnJvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwi2K3Yr9irINiu2LfYoyDYutmK2LEg2YXYqtmI2YLYuS4g2YrYsdis2Ykg2KfZhNmF2K3Yp9mI2YTYqSDZhdix2Kkg2KPYrtix2YkuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PSBIRUxQRVJTID09PT09PVxuICBpc0F1dGhlbnRpY2F0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGJ1c2luZXNzIHByb2ZpbGUgZm9yIGEgc3BlY2lmaWMgc3VwcGxpZXJcbiAgICogQHBhcmFtIGlkIFRoZSBzdXBwbGllciBJRFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHN1cHBsaWVyJ3MgYnVzaW5lc3MgcHJvZmlsZSBpbmNsdWRpbmcgcHJvZHVjdHNcbiAgICovXG4gIGFzeW5jIGdldEJ1c2luZXNzUHJvZmlsZShpZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxCdXNpbmVzc1Byb2ZpbGU+IHtcbiAgICBjb25zb2xlLmxvZyhcIkZldGNoaW5nIGJ1c2luZXNzIHByb2ZpbGUgZm9yIElEOlwiLCBpZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke3Rva2VufWApO1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllcnMvJHtpZH0vYnVzaW5lc3NgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIGJ1c2luZXNzIHByb2ZpbGVcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3MgcHJvZmlsZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0U3VwcGxpZXJQcm9maWxlKGlkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPFN1cHBsaWVyUHJvZmlsZT4ge1xuICAgIGNvbnNvbGUubG9nKFwiRmV0Y2hpbmcgc3VwcGxpZXIgcHJvZmlsZSBmb3IgSUQ6XCIsIGlkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7dG9rZW59YCk7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXJzLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIHN1cHBsaWVyIHByb2ZpbGVcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc3VwcGxpZXIgcHJvZmlsZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3VibWl0UmV2aWV3KHN1cHBsaWVySWQ6IG51bWJlciwgcmF0aW5nOiBudW1iZXIsIGNvbW1lbnQ6IHN0cmluZyk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRoZW50aWNhdGlvbiByZXF1aXJlZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3JhdGluZ3NgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICBcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcmF0ZWRfc3VwcGxpZXJfaWQ6IHN1cHBsaWVySWQsXG4gICAgICAgIHNjb3JlOiByYXRpbmcsXG4gICAgICAgIGNvbW1lbnQ6IGNvbW1lbnRcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc3VibWl0IHJldmlldycpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGFwaVNlcnZpY2UgPSBuZXcgQXBpU2VydmljZSgpO1xuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsIlZhbGlkYXRpb25FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZXJyb3JzIiwibmFtZSIsIkFwaVNlcnZpY2UiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwicmVxdWlyZXNBdXRoIiwidXJsIiwiYmFzZVVSTCIsIm9wdGlvbnNIZWFkZXJzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJhc3NpZ24iLCJBY2NlcHQiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ0b2tlblR5cGUiLCJyZXNwb25zZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsImNvbnNvbGUiLCJlcnJvciIsInN0YXR1cyIsIm1ldGhvZCIsInZhbGlkYXRpb25FcnJvciIsInBhc3N3b3JkIiwicmVnaXN0ZXJTdXBwbGllciIsImRhdGEiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZ2luIiwiYWNjZXNzVG9rZW4iLCJzZXRJdGVtIiwibG9nb3V0IiwiQXV0aG9yaXphdGlvbiIsInJlbW92ZUl0ZW0iLCJmb3Jnb3RQYXNzd29yZCIsInJlc2V0UGFzc3dvcmQiLCJzZW5kT3RwIiwidmVyaWZ5T3RwIiwiZ2V0QnVzaW5lc3NlcyIsInBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiZW50cmllcyIsInVuZGVmaW5lZCIsImFwcGVuZCIsImpvaW4iLCJ0b1N0cmluZyIsInVwZGF0ZVByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlV2l0aEZvcm1EYXRhIiwiZm9ybURhdGEiLCJzdGF0dXNUZXh0IiwiZ2V0UHJvZmlsZSIsInVwbG9hZERvY3VtZW50IiwiZmlsZSIsIkZvcm1EYXRhIiwidXBsb2FkUHJvZmlsZUltYWdlIiwicmVzcG9uc2VEYXRhIiwiZSIsInN1Y2Nlc3MiLCJpbWFnZVVybCIsImlzQXV0aGVudGljYXRlZCIsImdldEJ1c2luZXNzUHJvZmlsZSIsImlkIiwibG9nIiwiZ2V0U3VwcGxpZXJQcm9maWxlIiwic3VibWl0UmV2aWV3Iiwic3VwcGxpZXJJZCIsInJhdGluZyIsImNvbW1lbnQiLCJyYXRlZF9zdXBwbGllcl9pZCIsInNjb3JlIiwiYXBpU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});