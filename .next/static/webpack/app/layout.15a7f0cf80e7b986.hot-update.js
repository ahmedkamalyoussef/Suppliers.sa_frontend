"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"f5228929c93f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzg1ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmNTIyODkyOWM5M2ZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },\n/* harmony export */   apiService: function() { return /* binding */ apiService; }\n/* harmony export */ });\n// services/api.ts\nconst API_BASE_URL = \"http://localhost:8000\";\nclass ValidationError extends Error {\n    constructor(message, errors){\n        super(message);\n        this.name = \"ValidationError\";\n        this.errors = errors;\n    }\n}\nclass ApiService {\n    // ====== REQUEST WRAPPER ======\n    async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, requiresAuth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const url = \"\".concat(this.baseURL).concat(endpoint);\n        console.log(\"[API] Preparing request to: \".concat(url), {\n            method: options.method || \"GET\"\n        });\n        // Convert HeadersInit to Record<string, string>\n        const optionsHeaders = {};\n        if (options.headers) {\n            if (options.headers instanceof Headers) {\n                options.headers.forEach((value, key)=>{\n                    optionsHeaders[key] = value;\n                });\n            } else if (Array.isArray(options.headers)) {\n                options.headers.forEach((param)=>{\n                    let [key, value] = param;\n                    optionsHeaders[key] = value;\n                });\n            } else {\n                Object.assign(optionsHeaders, options.headers);\n            }\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n            ...optionsHeaders\n        };\n        if (requiresAuth) {\n            const token = localStorage.getItem(\"supplier_token\");\n            const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n            console.log(\"[API] Auth check - Token exists:\", !!token);\n            if (!token) {\n                console.error(\"[API] No auth token found in localStorage\");\n                throw new Error(\"No auth token found\");\n            }\n            headers[\"Authorization\"] = \"\".concat(tokenType, \" \").concat(token);\n        }\n        console.log(\"[API] Request headers:\", headers);\n        if (options.body) {\n            console.log(\"[API] Request body:\", options.body);\n        }\n        try {\n            console.log(\"[API] Sending request...\");\n            const response = await fetch(url, {\n                ...options,\n                credentials: \"include\",\n                headers\n            });\n            console.log(\"[API] Received response: \".concat(response.status, \" \").concat(response.statusText));\n            // Clone the response to read it as text first (for logging)\n            const responseClone = response.clone();\n            const responseText = await response.text();\n            let responseData;\n            try {\n                responseData = JSON.parse(responseText);\n                console.log(\"[API] Response data:\", responseData);\n            } catch (e) {\n                console.log(\"[API] Non-JSON response:\", responseText);\n                responseData = {};\n            }\n            if (!response.ok) {\n                console.error(\"[API] Request failed with status \".concat(response.status, \":\"), {\n                    url,\n                    status: response.status,\n                    statusText: response.statusText,\n                    response: responseData\n                });\n                if (response.status === 422) {\n                    const validationError = new ValidationError(\"Validation failed\", responseData.errors || responseData);\n                    console.error(\"[API] Validation Error:\", validationError.errors);\n                    throw validationError;\n                }\n                throw new Error(responseData.message || \"HTTP error \".concat(response.status));\n            }\n            return responseData;\n        } catch (error) {\n            console.error(\"[API] Request failed:\", error);\n            throw error;\n        }\n    }\n    // ====== SUPPLIER INQUIRIES ======\n    async sendInquiry(data) {\n        return this.request(\"/api/supplier/supplier-inquiries\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        }, true);\n    }\n    async replyToInquiry(inquiryId, data) {\n        return this.request(\"/api/supplier/supplier-inquiries/\".concat(inquiryId, \"/reply\"), {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        }, true);\n    }\n    async markInquiryAsRead(inquiryId) {\n        return this.request(\"/api/supplier/supplier-inquiries/\".concat(inquiryId, \"/read\"), {\n            method: \"POST\"\n        }, true);\n    }\n    async getInquiry(inquiryId) {\n        return this.request(\"/api/supplier/supplier-inquiries/\".concat(inquiryId), {\n            method: \"GET\"\n        }, true);\n    }\n    async getAllInquiries() {\n        return this.request(\"/api/supplier/supplier-inquiries\", {\n            method: \"GET\"\n        }, true);\n    }\n    // ====== API METHODS ======\n    async registerSupplier(data) {\n        return this.request(\"/api/supplier/register\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async login(data) {\n        const response = await this.request(\"/api/auth/login\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async logout() {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/auth/logout\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({\n                    message: \"Logout failed\"\n                }));\n            throw new Error(error.message || \"Logout failed\");\n        }\n        // Clear localStorage after successful logout\n        localStorage.removeItem(\"supplier_token\");\n        localStorage.removeItem(\"token_type\");\n        localStorage.removeItem(\"supplier_user\");\n    }\n    async forgotPassword(data) {\n        return this.request(\"/api/auth/forgot-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async resetPassword(data) {\n        return this.request(\"/api/auth/reset-password\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async sendOtp(data) {\n        return this.request(\"/api/auth/send-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n    }\n    async verifyOtp(data) {\n        const response = await this.request(\"/api/auth/verify-otp\", {\n            method: \"POST\",\n            body: JSON.stringify(data)\n        });\n        if (response.accessToken) {\n            localStorage.setItem(\"supplier_token\", response.accessToken);\n            localStorage.setItem(\"token_type\", response.tokenType || \"Bearer\");\n        }\n        return response;\n    }\n    async getBusinesses(params) {\n        const queryParams = new URLSearchParams();\n        const options = {\n            method: \"GET\"\n        };\n        // Check if user is authenticated\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n            options.headers = {\n                ...options.headers,\n                Authorization: \"\".concat(tokenType, \" \").concat(token),\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\"\n            };\n        }\n        if (params) {\n            // Handle category separately to prevent double encoding\n            const { category, ...restParams } = params;\n            if (category) {\n                queryParams.append(\"category\", category);\n            }\n            // Handle the rest of the parameters\n            Object.entries(restParams).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined && value !== null) {\n                    if (Array.isArray(value)) {\n                        queryParams.append(key, value.join(\",\"));\n                    } else if (typeof value === \"boolean\") {\n                        queryParams.append(key, value ? \"1\" : \"0\");\n                    } else {\n                        queryParams.append(key, value.toString());\n                    }\n                }\n            });\n        }\n        return this.request(\"/api/public/businesses?\".concat(queryParams.toString()), {\n            method: \"GET\"\n        }, false // doesn't require auth\n        );\n    }\n    async updateProfile(data) {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"PATCH\",\n            body: JSON.stringify(data)\n        }, true); // requiresAuth = true\n    }\n    async updateProfileWithFormData(formData) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile\"), {\n            method: \"PATCH\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            // Enhanced logging for debugging\n            console.error(\"API Error \".concat(response.status, \":\"), {\n                url: \"\".concat(this.baseURL, \"/api/supplier/profile\"),\n                method: \"PATCH\",\n                errorData\n            });\n            if (response.status === 422) {\n                console.error(\"Validation Errors:\", errorData.errors || errorData);\n                throw new ValidationError(errorData.message || \"Validation failed\", errorData.errors || errorData);\n            }\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async getProfile() {\n        return this.request(\"/api/supplier/profile\", {\n            method: \"GET\"\n        }, true);\n    }\n    async uploadDocument(file) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const formData = new FormData();\n        formData.append(\"document\", file);\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/documents\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData,\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            console.error(\"Document upload error:\", errorData);\n            throw new Error(errorData.message || \"Failed to upload document\");\n        }\n        return await response.json();\n    }\n    async uploadProfileImage(file) {\n        const formData = new FormData();\n        formData.append(\"profile_image\", file);\n        // Create headers object\n        const headers = new Headers();\n        // Don't set Content-Type header, let the browser set it with the correct boundary\n        // Get the auth token\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n        }\n        try {\n            var _responseData_data;\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/profile/image\"), {\n                method: \"POST\",\n                headers,\n                body: formData,\n                credentials: \"include\"\n            });\n            // First, check if the response is OK\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to upload image\");\n            }\n            // Try to parse the response as JSON\n            let responseData;\n            try {\n                responseData = await response.json();\n            } catch (e) {\n                // If parsing fails but the status is 200, consider it a success\n                if (response.status === 200) {\n                    return {\n                        success: true,\n                        data: {\n                            url: \"\"\n                        }\n                    }; // Return default success response\n                }\n                throw new Error(\"Failed to parse server response\");\n            }\n            // If we got here, the request was successful\n            // The backend might be returning the URL directly or in a data object\n            const imageUrl = responseData.url || ((_responseData_data = responseData.data) === null || _responseData_data === void 0 ? void 0 : _responseData_data.url) || \"\";\n            return {\n                success: true,\n                data: {\n                    url: imageUrl\n                }\n            };\n        } catch (error) {\n            console.error(\"API Error:\", error);\n            // Handle different types of errors\n            if (typeof error === \"object\" && error !== null) {\n                // Handle Fetch API Response errors\n                if (\"response\" in error && error.response && typeof error.response === \"object\" && error.response !== null) {\n                    try {\n                        // @ts-ignore - We've already checked the type\n                        const errorData = await error.response.json().catch(()=>({}));\n                        throw new Error(errorData.message || \"فشل في رفع الصورة\");\n                    } catch (e) {\n                        // If we can't parse the error response\n                        throw new Error(\"فشل في معالجة استجابة الخادم\");\n                    }\n                }\n                // Handle Error objects\n                if (error instanceof Error) {\n                    throw new Error(error.message || \"حدث خطأ أثناء رفع الصورة. يرجى المحاولة مرة أخرى.\");\n                }\n            }\n            // Default error\n            throw new Error(\"حدث خطأ غير متوقع. يرجى المحاولة مرة أخرى.\");\n        }\n    }\n    // ====== HELPERS ======\n    isAuthenticated() {\n        return !!localStorage.getItem(\"supplier_token\");\n    }\n    /**\n   * Fetches business profile for a specific supplier\n   * @param id The supplier ID\n   * @returns Promise with the supplier's business profile including products\n   */ async getBusinessProfile(id) {\n        const headers = new Headers();\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n            headers.append(\"Accept\", \"application/json\");\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/suppliers/\").concat(id, \"/business\"), {\n                method: \"GET\",\n                headers,\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to fetch business profile\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Error fetching business profile:\", error);\n            throw error;\n        }\n    }\n    async getSupplierProfile(id) {\n        const headers = new Headers();\n        const token = localStorage.getItem(\"supplier_token\");\n        if (token) {\n            headers.append(\"Authorization\", \"Bearer \".concat(token));\n            headers.append(\"Accept\", \"application/json\");\n        }\n        try {\n            const response = await fetch(\"\".concat(this.baseURL, \"/api/suppliers/\").concat(id), {\n                method: \"GET\",\n                headers,\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.message || \"Failed to fetch supplier profile\");\n            }\n            return await response.json();\n        } catch (error) {\n            console.error(\"Error fetching supplier profile:\", error);\n            throw error;\n        }\n    }\n    async submitReview(supplierId, rating, comment) {\n        const token = localStorage.getItem(\"supplier_token\");\n        if (!token) {\n            throw new Error(\"Authentication required\");\n        }\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/ratings\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: \"Bearer \".concat(token),\n                Accept: \"application/json\"\n            },\n            body: JSON.stringify({\n                rated_supplier_id: supplierId,\n                score: rating,\n                comment: comment\n            })\n        });\n        if (!response.ok) {\n            const error = await response.json().catch(()=>({}));\n            throw new Error(error.message || \"Failed to submit review\");\n        }\n        return response.json();\n    }\n    // Get business statistics\n    async getStats() {\n        return this.request(\"/api/public/stats\");\n    }\n    /**\n   * Fetches the profile picture URL for a user\n   * @param userId The ID of the user\n   * @returns Promise with the profile picture URL\n   */ async getProfilePicture(userId) {\n        return this.request(\"/api/auth/profile/picture/\".concat(userId), {\n            method: \"GET\"\n        });\n    }\n    /**\n   * Changes the user's password\n   * @param currentPassword The user's current password\n   * @param newPassword The new password\n   * @param confirmPassword The new password confirmation\n   * @returns Promise with success message\n   */ async changePassword(currentPassword, newPassword, confirmPassword) {\n        return this.request(\"/api/auth/change-password\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                current_password: currentPassword,\n                password: newPassword,\n                password_confirmation: confirmPassword\n            })\n        }, true // requires authentication\n        );\n    }\n    // ====== PREFERENCES ======\n    async getPreferences() {\n        return this.request(\"/api/supplier/preferences\", {\n            method: \"GET\"\n        }, true);\n    }\n    async updatePreferences(preferences) {\n        return this.request(\"/api/supplier/preferences\", {\n            method: \"PUT\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(preferences)\n        }, true);\n    }\n    // ====== PRODUCT IMAGES ======\n    async uploadProductImage(formData) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/product-images\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        return response.json();\n    }\n    async deleteProductImage(imageId) {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/product-images/\").concat(imageId), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Return success for DELETE operations\n        return {\n            success: true,\n            message: \"Image deleted successfully\"\n        };\n    }\n    async deleteAccount() {\n        const token = localStorage.getItem(\"supplier_token\");\n        const tokenType = localStorage.getItem(\"token_type\") || \"Bearer\";\n        if (!token) throw new Error(\"No auth token found\");\n        const response = await fetch(\"\".concat(this.baseURL, \"/api/supplier/account\"), {\n            method: \"DELETE\",\n            headers: {\n                Authorization: \"\".concat(tokenType, \" \").concat(token)\n            }\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.message || \"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Return success for DELETE operations\n        return {\n            success: true,\n            message: \"Account deleted successfully\"\n        };\n    }\n    // ====== DASHBOARD ======\n    async getDashboard() {\n        let range = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"30\";\n        return this.request(\"/api/supplier/dashboard?range=\".concat(range), {\n            method: \"GET\"\n        }, true // requiresAuth = true to send token\n        );\n    }\n    // ====== ANALYTICS ======\n    async trackView(data) {\n        return this.request(\"/api/supplier/analytics/track-view\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        }, true);\n    }\n    async trackSearch(data) {\n        return this.request(\"/api/supplier/analytics/track-search\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        }, true);\n    }\n    // Performance Metrics\n    async getPerformanceMetrics() {\n        return this.request(\"/api/supplier/analytics/performance\", {}, true);\n    }\n    // Charts Data\n    async getChartsData(range, type) {\n        return this.request(\"/api/supplier/analytics/charts?range=\".concat(range, \"&type=\").concat(type), {}, true);\n    }\n    // Keywords Analytics\n    async getKeywordsAnalytics() {\n        return this.request(\"/api/supplier/analytics/keywords\", {}, true);\n    }\n    // Customer Insights\n    async getCustomerInsights() {\n        return this.request(\"/api/supplier/analytics/insights\", {}, true);\n    }\n    // Recommendations\n    async getRecommendations() {\n        return this.request(\"/api/supplier/analytics/recommendations\", {}, true);\n    }\n    // Export Analytics\n    async exportAnalytics() {\n        let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"csv\";\n        return this.request(\"/api/supplier/analytics/export?format=\".concat(format), {}, true);\n    }\n    constructor(){\n        this.baseURL = API_BASE_URL;\n    }\n}\nconst apiService = new ApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrQkFBa0I7QUFHbEIsTUFBTUEsZUFBZTtBQTJQZCxNQUFNQyx3QkFBd0JDO0lBR25DQyxZQUFZQyxPQUFlLEVBQUVDLE1BQWdCLENBQUU7UUFDN0MsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxNQUFNLEdBQUdBO0lBQ2hCO0FBQ0Y7QUFFQSxNQUFNRTtJQU9KLGdDQUFnQztJQUNoQyxNQUFjQyxRQUNaQyxRQUFnQixFQUdKO1lBRlpDLFVBQUFBLGlFQUF1QixDQUFDLEdBQ3hCQyxlQUFBQSxpRUFBd0I7UUFFeEIsTUFBTUMsTUFBTSxHQUFrQkgsT0FBZixJQUFJLENBQUNJLE9BQU8sRUFBWSxPQUFUSjtRQUM5QkssUUFBUUMsR0FBRyxDQUFDLCtCQUFtQyxPQUFKSCxNQUFPO1lBQ2hESSxRQUFRTixRQUFRTSxNQUFNLElBQUk7UUFDNUI7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTUMsaUJBQXlDLENBQUM7UUFDaEQsSUFBSVAsUUFBUVEsT0FBTyxFQUFFO1lBQ25CLElBQUlSLFFBQVFRLE9BQU8sWUFBWUMsU0FBUztnQkFDdENULFFBQVFRLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDLENBQUNDLE9BQU9DO29CQUM5QkwsY0FBYyxDQUFDSyxJQUFJLEdBQUdEO2dCQUN4QjtZQUNGLE9BQU8sSUFBSUUsTUFBTUMsT0FBTyxDQUFDZCxRQUFRUSxPQUFPLEdBQUc7Z0JBQ3pDUixRQUFRUSxPQUFPLENBQUNFLE9BQU8sQ0FBQzt3QkFBQyxDQUFDRSxLQUFLRCxNQUFNO29CQUNuQ0osY0FBYyxDQUFDSyxJQUFJLEdBQUdEO2dCQUN4QjtZQUNGLE9BQU87Z0JBQ0xJLE9BQU9DLE1BQU0sQ0FBQ1QsZ0JBQWdCUCxRQUFRUSxPQUFPO1lBQy9DO1FBQ0Y7UUFFQSxNQUFNQSxVQUFrQztZQUN0QyxnQkFBZ0I7WUFDaEJTLFFBQVE7WUFDUixHQUFHVixjQUFjO1FBQ25CO1FBRUEsSUFBSU4sY0FBYztZQUNoQixNQUFNaUIsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1lBQ25DLE1BQU1DLFlBQVlGLGFBQWFDLE9BQU8sQ0FBQyxpQkFBaUI7WUFDeERoQixRQUFRQyxHQUFHLENBQUMsb0NBQW9DLENBQUMsQ0FBQ2E7WUFDbEQsSUFBSSxDQUFDQSxPQUFPO2dCQUNWZCxRQUFRa0IsS0FBSyxDQUFDO2dCQUNkLE1BQU0sSUFBSTlCLE1BQU07WUFDbEI7WUFDQWdCLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxHQUFnQlUsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1FBQzdDO1FBRUFkLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJHO1FBQ3RDLElBQUlSLFFBQVF1QixJQUFJLEVBQUU7WUFDaEJuQixRQUFRQyxHQUFHLENBQUMsdUJBQXVCTCxRQUFRdUIsSUFBSTtRQUNqRDtRQUVBLElBQUk7WUFDRm5CLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1tQixXQUFXLE1BQU1DLE1BQU12QixLQUFLO2dCQUNoQyxHQUFHRixPQUFPO2dCQUNWMEIsYUFBYTtnQkFDYmxCO1lBQ0Y7WUFFQUosUUFBUUMsR0FBRyxDQUNULDRCQUErQ21CLE9BQW5CQSxTQUFTRyxNQUFNLEVBQUMsS0FBdUIsT0FBcEJILFNBQVNJLFVBQVU7WUFHcEUsNERBQTREO1lBQzVELE1BQU1DLGdCQUFnQkwsU0FBU00sS0FBSztZQUNwQyxNQUFNQyxlQUFlLE1BQU1QLFNBQVNRLElBQUk7WUFDeEMsSUFBSUM7WUFFSixJQUFJO2dCQUNGQSxlQUFlQyxLQUFLQyxLQUFLLENBQUNKO2dCQUMxQjNCLFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0I0QjtZQUN0QyxFQUFFLE9BQU9HLEdBQUc7Z0JBQ1ZoQyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCMEI7Z0JBQ3hDRSxlQUFlLENBQUM7WUFDbEI7WUFFQSxJQUFJLENBQUNULFNBQVNhLEVBQUUsRUFBRTtnQkFDaEJqQyxRQUFRa0IsS0FBSyxDQUFDLG9DQUFvRCxPQUFoQkUsU0FBU0csTUFBTSxFQUFDLE1BQUk7b0JBQ3BFekI7b0JBQ0F5QixRQUFRSCxTQUFTRyxNQUFNO29CQUN2QkMsWUFBWUosU0FBU0ksVUFBVTtvQkFDL0JKLFVBQVVTO2dCQUNaO2dCQUVBLElBQUlULFNBQVNHLE1BQU0sS0FBSyxLQUFLO29CQUMzQixNQUFNVyxrQkFBa0IsSUFBSS9DLGdCQUMxQixxQkFDQTBDLGFBQWF0QyxNQUFNLElBQUlzQztvQkFFekI3QixRQUFRa0IsS0FBSyxDQUFDLDJCQUEyQmdCLGdCQUFnQjNDLE1BQU07b0JBQy9ELE1BQU0yQztnQkFDUjtnQkFFQSxNQUFNLElBQUk5QyxNQUNSeUMsYUFBYXZDLE9BQU8sSUFBSSxjQUE4QixPQUFoQjhCLFNBQVNHLE1BQU07WUFFekQ7WUFFQSxPQUFPTTtRQUNULEVBQUUsT0FBT1gsT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNaUIsWUFBWUMsSUFRakIsRUFBNEI7UUFDM0IsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQ2pCLG9DQUNBO1lBQ0VRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkIsR0FDQTtJQUVKO0lBRUEsTUFBTUUsZUFDSkMsU0FBaUIsRUFDakJILElBQXlCLEVBQ0M7UUFDMUIsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQ2pCLG9DQUE4QyxPQUFWNkMsV0FBVSxXQUM5QztZQUNFckMsUUFBUTtZQUNSaUIsTUFBTVcsS0FBS08sU0FBUyxDQUFDRDtRQUN2QixHQUNBO0lBRUo7SUFFQSxNQUFNSSxrQkFBa0JELFNBQWlCLEVBQStCO1FBQ3RFLE9BQU8sSUFBSSxDQUFDN0MsT0FBTyxDQUNqQixvQ0FBOEMsT0FBVjZDLFdBQVUsVUFDOUM7WUFDRXJDLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNdUMsV0FBV0YsU0FBaUIsRUFBZ0M7UUFDaEUsT0FBTyxJQUFJLENBQUM3QyxPQUFPLENBQ2pCLG9DQUE4QyxPQUFWNkMsWUFDcEM7WUFDRXJDLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNd0Msa0JBQWdEO1FBQ3BELE9BQU8sSUFBSSxDQUFDaEQsT0FBTyxDQUNqQixvQ0FDQTtZQUNFUSxRQUFRO1FBQ1YsR0FDQTtJQUVKO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU15QyxpQkFDSlAsSUFBc0IsRUFDUztRQUMvQixPQUFPLElBQUksQ0FBQzFDLE9BQU8sQ0FBQywwQkFBMEI7WUFDNUNRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkI7SUFDRjtJQUVBLE1BQU1RLE1BQU1SLElBQWtCLEVBQTBCO1FBQ3RELE1BQU1oQixXQUFXLE1BQU0sSUFBSSxDQUFDMUIsT0FBTyxDQUFnQixtQkFBbUI7WUFDcEVRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkI7UUFFQSxJQUFJaEIsU0FBU3lCLFdBQVcsRUFBRTtZQUN4QjlCLGFBQWErQixPQUFPLENBQUMsa0JBQWtCMUIsU0FBU3lCLFdBQVc7WUFDM0Q5QixhQUFhK0IsT0FBTyxDQUFDLGNBQWMxQixTQUFTSCxTQUFTLElBQUk7UUFDM0Q7UUFFQSxPQUFPRztJQUNUO0lBRUEsTUFBTTJCLFNBQXdCO1FBQzVCLE1BQU1qQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFDbkMsTUFBTUMsWUFBWUYsYUFBYUMsT0FBTyxDQUFDLGlCQUFpQjtRQUV4RCxJQUFJLENBQUNGLE9BQU8sTUFBTSxJQUFJMUIsTUFBTTtRQUU1QixNQUFNZ0MsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJuQyxjQUFhLHFCQUFtQjtZQUM5RGdCLFFBQVE7WUFDUkUsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCNEMsZUFBZSxHQUFnQmxDLE9BQWJHLFdBQVUsS0FBUyxPQUFOSDtZQUNqQztRQUNGO1FBRUEsSUFBSSxDQUFDTSxTQUFTYSxFQUFFLEVBQUU7WUFDaEIsTUFBTWYsUUFBUSxNQUFNRSxTQUNqQjZCLElBQUksR0FDSkMsS0FBSyxDQUFDLElBQU87b0JBQUU1RCxTQUFTO2dCQUFnQjtZQUMzQyxNQUFNLElBQUlGLE1BQU04QixNQUFNNUIsT0FBTyxJQUFJO1FBQ25DO1FBRUEsNkNBQTZDO1FBQzdDeUIsYUFBYW9DLFVBQVUsQ0FBQztRQUN4QnBDLGFBQWFvQyxVQUFVLENBQUM7UUFDeEJwQyxhQUFhb0MsVUFBVSxDQUFDO0lBQzFCO0lBRUEsTUFBTUMsZUFDSmhCLElBQTJCLEVBQ0c7UUFDOUIsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQUMsNkJBQTZCO1lBQy9DUSxRQUFRO1lBQ1JpQixNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNaUIsY0FDSmpCLElBQTBCLEVBQ0k7UUFDOUIsT0FBTyxJQUFJLENBQUMxQyxPQUFPLENBQUMsNEJBQTRCO1lBQzlDUSxRQUFRO1lBQ1JpQixNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNa0IsUUFBUWxCLElBQW9CLEVBQXdCO1FBQ3hELE9BQU8sSUFBSSxDQUFDMUMsT0FBTyxDQUFDLHNCQUFzQjtZQUN4Q1EsUUFBUTtZQUNSaUIsTUFBTVcsS0FBS08sU0FBUyxDQUFDRDtRQUN2QjtJQUNGO0lBRUEsTUFBTW1CLFVBQVVuQixJQUFzQixFQUF3QjtRQUM1RCxNQUFNaEIsV0FBVyxNQUFNLElBQUksQ0FBQzFCLE9BQU8sQ0FBYyx3QkFBd0I7WUFDdkVRLFFBQVE7WUFDUmlCLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQ0Q7UUFDdkI7UUFFQSxJQUFJaEIsU0FBU3lCLFdBQVcsRUFBRTtZQUN4QjlCLGFBQWErQixPQUFPLENBQUMsa0JBQWtCMUIsU0FBU3lCLFdBQVc7WUFDM0Q5QixhQUFhK0IsT0FBTyxDQUFDLGNBQWMxQixTQUFTSCxTQUFTLElBQUk7UUFDM0Q7UUFFQSxPQUFPRztJQUNUO0lBRUEsTUFBTW9DLGNBQWNDLE1BZW5CLEVBQWlDO1FBQ2hDLE1BQU1DLGNBQWMsSUFBSUM7UUFFeEIsTUFBTS9ELFVBQXVCO1lBQUVNLFFBQVE7UUFBTTtRQUU3QyxpQ0FBaUM7UUFDakMsTUFBTVksUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLElBQUlGLE9BQU87WUFDVCxNQUFNRyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1lBQ3hEcEIsUUFBUVEsT0FBTyxHQUFHO2dCQUNoQixHQUFHUixRQUFRUSxPQUFPO2dCQUNsQjRDLGVBQWUsR0FBZ0JsQyxPQUFiRyxXQUFVLEtBQVMsT0FBTkg7Z0JBQy9CLGdCQUFnQjtnQkFDaEJELFFBQVE7WUFDVjtRQUNGO1FBQ0EsSUFBSTRDLFFBQVE7WUFDVix3REFBd0Q7WUFDeEQsTUFBTSxFQUFFRyxRQUFRLEVBQUUsR0FBR0MsWUFBWSxHQUFHSjtZQUVwQyxJQUFJRyxVQUFVO2dCQUNaRixZQUFZSSxNQUFNLENBQUMsWUFBWUY7WUFDakM7WUFFQSxvQ0FBb0M7WUFDcENqRCxPQUFPb0QsT0FBTyxDQUFDRixZQUFZdkQsT0FBTyxDQUFDO29CQUFDLENBQUNFLEtBQUtELE1BQU07Z0JBQzlDLElBQUlBLFVBQVV5RCxhQUFhekQsVUFBVSxNQUFNO29CQUN6QyxJQUFJRSxNQUFNQyxPQUFPLENBQUNILFFBQVE7d0JBQ3hCbUQsWUFBWUksTUFBTSxDQUFDdEQsS0FBS0QsTUFBTTBELElBQUksQ0FBQztvQkFDckMsT0FBTyxJQUFJLE9BQU8xRCxVQUFVLFdBQVc7d0JBQ3JDbUQsWUFBWUksTUFBTSxDQUFDdEQsS0FBS0QsUUFBUSxNQUFNO29CQUN4QyxPQUFPO3dCQUNMbUQsWUFBWUksTUFBTSxDQUFDdEQsS0FBS0QsTUFBTTJELFFBQVE7b0JBQ3hDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU8sSUFBSSxDQUFDeEUsT0FBTyxDQUNqQiwwQkFBaUQsT0FBdkJnRSxZQUFZUSxRQUFRLEtBQzlDO1lBQ0VoRSxRQUFRO1FBQ1YsR0FDQSxNQUFNLHVCQUF1Qjs7SUFFakM7SUFFQSxNQUFNaUUsY0FBYy9CLElBQXVCLEVBQWtDO1FBQzNFLE9BQU8sSUFBSSxDQUFDMUMsT0FBTyxDQUNqQix5QkFDQTtZQUNFUSxRQUFRO1lBQ1JpQixNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCLEdBQ0EsT0FDQyxzQkFBc0I7SUFDM0I7SUFFQSxNQUFNZ0MsMEJBQ0pDLFFBQWtCLEVBQ2M7UUFDaEMsTUFBTXZELFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxNQUFNQyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1FBRXhELElBQUksQ0FBQ0YsT0FBTyxNQUFNLElBQUkxQixNQUFNO1FBRTVCLE1BQU1nQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUN0QixPQUFPLEVBQUMsMEJBQXdCO1lBQ25FRyxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1A0QyxlQUFlLEdBQWdCbEMsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1lBRWpDO1lBQ0FLLE1BQU1rRDtRQUNSO1FBRUEsSUFBSSxDQUFDakQsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1xQyxZQUFZLE1BQU1sRCxTQUFTNkIsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBRXRELGlDQUFpQztZQUNqQ2xELFFBQVFrQixLQUFLLENBQUMsYUFBNkIsT0FBaEJFLFNBQVNHLE1BQU0sRUFBQyxNQUFJO2dCQUM3Q3pCLEtBQUssR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztnQkFDckJHLFFBQVE7Z0JBQ1JvRTtZQUNGO1lBRUEsSUFBSWxELFNBQVNHLE1BQU0sS0FBSyxLQUFLO2dCQUMzQnZCLFFBQVFrQixLQUFLLENBQUMsc0JBQXNCb0QsVUFBVS9FLE1BQU0sSUFBSStFO2dCQUN4RCxNQUFNLElBQUluRixnQkFDUm1GLFVBQVVoRixPQUFPLElBQUkscUJBQ3JCZ0YsVUFBVS9FLE1BQU0sSUFBSStFO1lBRXhCO1lBRUEsTUFBTSxJQUFJbEYsTUFDUmtGLFVBQVVoRixPQUFPLElBQUksUUFBNEI4QixPQUFwQkEsU0FBU0csTUFBTSxFQUFDLE1BQXdCLE9BQXBCSCxTQUFTSSxVQUFVO1FBRXhFO1FBRUEsT0FBT0osU0FBUzZCLElBQUk7SUFDdEI7SUFFQSxNQUFNc0IsYUFBMkI7UUFDL0IsT0FBTyxJQUFJLENBQUM3RSxPQUFPLENBQ2pCLHlCQUNBO1lBQ0VRLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNc0UsZUFBZUMsSUFBVSxFQUFtQztRQUNoRSxNQUFNM0QsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLE1BQU1DLFlBQVlGLGFBQWFDLE9BQU8sQ0FBQyxpQkFBaUI7UUFFeEQsSUFBSSxDQUFDRixPQUFPLE1BQU0sSUFBSTFCLE1BQU07UUFFNUIsTUFBTWlGLFdBQVcsSUFBSUs7UUFDckJMLFNBQVNQLE1BQU0sQ0FBQyxZQUFZVztRQUU1QixNQUFNckQsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDdEIsT0FBTyxFQUFDLDRCQUEwQjtZQUNyRUcsUUFBUTtZQUNSRSxTQUFTO2dCQUNQNEMsZUFBZSxHQUFnQmxDLE9BQWJHLFdBQVUsS0FBUyxPQUFOSDtZQUNqQztZQUNBSyxNQUFNa0Q7WUFDTi9DLGFBQWE7UUFDZjtRQUVBLElBQUksQ0FBQ0YsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1xQyxZQUFZLE1BQU1sRCxTQUFTNkIsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBQ3REbEQsUUFBUWtCLEtBQUssQ0FBQywwQkFBMEJvRDtZQUN4QyxNQUFNLElBQUlsRixNQUFNa0YsVUFBVWhGLE9BQU8sSUFBSTtRQUN2QztRQUVBLE9BQU8sTUFBTThCLFNBQVM2QixJQUFJO0lBQzVCO0lBRUEsTUFBTTBCLG1CQUNKRixJQUFVLEVBQzRDO1FBQ3RELE1BQU1KLFdBQVcsSUFBSUs7UUFDckJMLFNBQVNQLE1BQU0sQ0FBQyxpQkFBaUJXO1FBRWpDLHdCQUF3QjtRQUN4QixNQUFNckUsVUFBVSxJQUFJQztRQUNwQixrRkFBa0Y7UUFFbEYscUJBQXFCO1FBQ3JCLE1BQU1TLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJRixPQUFPO1lBQ1RWLFFBQVEwRCxNQUFNLENBQUMsaUJBQWlCLFVBQWdCLE9BQU5oRDtRQUM1QztRQUVBLElBQUk7Z0JBK0JtQ2U7WUE5QnJDLE1BQU1ULFdBQVcsTUFBTUMsTUFDckIsR0FBZ0IsT0FBYixJQUFJLENBQUN0QixPQUFPLEVBQUMsZ0NBQ2hCO2dCQUNFRyxRQUFRO2dCQUNSRTtnQkFDQWUsTUFBTWtEO2dCQUNOL0MsYUFBYTtZQUNmO1lBR0YscUNBQXFDO1lBQ3JDLElBQUksQ0FBQ0YsU0FBU2EsRUFBRSxFQUFFO2dCQUNoQixNQUFNcUMsWUFBWSxNQUFNbEQsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJOUQsTUFBTWtGLFVBQVVoRixPQUFPLElBQUk7WUFDdkM7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSXVDO1lBQ0osSUFBSTtnQkFDRkEsZUFBZSxNQUFNVCxTQUFTNkIsSUFBSTtZQUNwQyxFQUFFLE9BQU9qQixHQUFHO2dCQUNWLGdFQUFnRTtnQkFDaEUsSUFBSVosU0FBU0csTUFBTSxLQUFLLEtBQUs7b0JBQzNCLE9BQU87d0JBQUVxRCxTQUFTO3dCQUFNeEMsTUFBTTs0QkFBRXRDLEtBQUs7d0JBQUc7b0JBQUUsR0FBRyxrQ0FBa0M7Z0JBQ2pGO2dCQUNBLE1BQU0sSUFBSVYsTUFBTTtZQUNsQjtZQUVBLDZDQUE2QztZQUM3QyxzRUFBc0U7WUFDdEUsTUFBTXlGLFdBQVdoRCxhQUFhL0IsR0FBRyxNQUFJK0IscUJBQUFBLGFBQWFPLElBQUksY0FBakJQLHlDQUFBQSxtQkFBbUIvQixHQUFHLEtBQUk7WUFFL0QsT0FBTztnQkFDTDhFLFNBQVM7Z0JBQ1R4QyxNQUFNO29CQUNKdEMsS0FBSytFO2dCQUNQO1lBQ0Y7UUFDRixFQUFFLE9BQU8zRCxPQUFnQjtZQUN2QmxCLFFBQVFrQixLQUFLLENBQUMsY0FBY0E7WUFFNUIsbUNBQW1DO1lBQ25DLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07Z0JBQy9DLG1DQUFtQztnQkFDbkMsSUFDRSxjQUFjQSxTQUNkQSxNQUFNRSxRQUFRLElBQ2QsT0FBT0YsTUFBTUUsUUFBUSxLQUFLLFlBQzFCRixNQUFNRSxRQUFRLEtBQUssTUFDbkI7b0JBQ0EsSUFBSTt3QkFDRiw4Q0FBOEM7d0JBQzlDLE1BQU1rRCxZQUFZLE1BQU1wRCxNQUFNRSxRQUFRLENBQUM2QixJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7d0JBQzVELE1BQU0sSUFBSTlELE1BQU1rRixVQUFVaEYsT0FBTyxJQUFJO29CQUN2QyxFQUFFLE9BQU8wQyxHQUFHO3dCQUNWLHVDQUF1Qzt3QkFDdkMsTUFBTSxJQUFJNUMsTUFBTTtvQkFDbEI7Z0JBQ0Y7Z0JBRUEsdUJBQXVCO2dCQUN2QixJQUFJOEIsaUJBQWlCOUIsT0FBTztvQkFDMUIsTUFBTSxJQUFJQSxNQUNSOEIsTUFBTTVCLE9BQU8sSUFBSTtnQkFFckI7WUFDRjtZQUVBLGdCQUFnQjtZQUNoQixNQUFNLElBQUlGLE1BQU07UUFDbEI7SUFDRjtJQUVBLHdCQUF3QjtJQUN4QjBGLGtCQUEyQjtRQUN6QixPQUFPLENBQUMsQ0FBQy9ELGFBQWFDLE9BQU8sQ0FBQztJQUNoQztJQUVBOzs7O0dBSUMsR0FDRCxNQUFNK0QsbUJBQW1CQyxFQUFtQixFQUE0QjtRQUN0RSxNQUFNNUUsVUFBVSxJQUFJQztRQUNwQixNQUFNUyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFFbkMsSUFBSUYsT0FBTztZQUNUVixRQUFRMEQsTUFBTSxDQUFDLGlCQUFpQixVQUFnQixPQUFOaEQ7WUFDMUNWLFFBQVEwRCxNQUFNLENBQUMsVUFBVTtRQUMzQjtRQUVBLElBQUk7WUFDRixNQUFNMUMsV0FBVyxNQUFNQyxNQUNyQixHQUFpQzJELE9BQTlCLElBQUksQ0FBQ2pGLE9BQU8sRUFBQyxtQkFBb0IsT0FBSGlGLElBQUcsY0FDcEM7Z0JBQ0U5RSxRQUFRO2dCQUNSRTtnQkFDQWtCLGFBQWE7WUFDZjtZQUdGLElBQUksQ0FBQ0YsU0FBU2EsRUFBRSxFQUFFO2dCQUNoQixNQUFNcUMsWUFBWSxNQUFNbEQsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJOUQsTUFDUmtGLFVBQVVoRixPQUFPLElBQUk7WUFFekI7WUFFQSxPQUFPLE1BQU04QixTQUFTNkIsSUFBSTtRQUM1QixFQUFFLE9BQU8vQixPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLG9DQUFvQ0E7WUFDbEQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTStELG1CQUFtQkQsRUFBbUIsRUFBNEI7UUFDdEUsTUFBTTVFLFVBQVUsSUFBSUM7UUFDcEIsTUFBTVMsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBRW5DLElBQUlGLE9BQU87WUFDVFYsUUFBUTBELE1BQU0sQ0FBQyxpQkFBaUIsVUFBZ0IsT0FBTmhEO1lBQzFDVixRQUFRMEQsTUFBTSxDQUFDLFVBQVU7UUFDM0I7UUFFQSxJQUFJO1lBQ0YsTUFBTTFDLFdBQVcsTUFBTUMsTUFBTSxHQUFpQzJELE9BQTlCLElBQUksQ0FBQ2pGLE9BQU8sRUFBQyxtQkFBb0IsT0FBSGlGLEtBQU07Z0JBQ2xFOUUsUUFBUTtnQkFDUkU7Z0JBQ0FrQixhQUFhO1lBQ2Y7WUFFQSxJQUFJLENBQUNGLFNBQVNhLEVBQUUsRUFBRTtnQkFDaEIsTUFBTXFDLFlBQVksTUFBTWxELFNBQVM2QixJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSTlELE1BQ1JrRixVQUFVaEYsT0FBTyxJQUFJO1lBRXpCO1lBRUEsT0FBTyxNQUFNOEIsU0FBUzZCLElBQUk7UUFDNUIsRUFBRSxPQUFPL0IsT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1nRSxhQUNKQyxVQUFrQixFQUNsQkMsTUFBYyxFQUNkQyxPQUFlLEVBQ2U7UUFDOUIsTUFBTXZFLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxJQUFJLENBQUNGLE9BQU87WUFDVixNQUFNLElBQUkxQixNQUFNO1FBQ2xCO1FBRUEsTUFBTWdDLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiLElBQUksQ0FBQ3RCLE9BQU8sRUFBQywwQkFBd0I7WUFDbkVHLFFBQVE7WUFDUkUsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCNEMsZUFBZSxVQUFnQixPQUFObEM7Z0JBQ3pCRCxRQUFRO1lBQ1Y7WUFDQU0sTUFBTVcsS0FBS08sU0FBUyxDQUFDO2dCQUNuQmlELG1CQUFtQkg7Z0JBQ25CSSxPQUFPSDtnQkFDUEMsU0FBU0E7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDakUsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1mLFFBQVEsTUFBTUUsU0FBUzZCLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztZQUNsRCxNQUFNLElBQUk5RCxNQUFNOEIsTUFBTTVCLE9BQU8sSUFBSTtRQUNuQztRQUVBLE9BQU84QixTQUFTNkIsSUFBSTtJQUN0QjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNdUMsV0FBbUM7UUFDdkMsT0FBTyxJQUFJLENBQUM5RixPQUFPLENBQWdCO0lBQ3JDO0lBRUE7Ozs7R0FJQyxHQUNELE1BQU0rRixrQkFDSkMsTUFBdUIsRUFDYTtRQUNwQyxPQUFPLElBQUksQ0FBQ2hHLE9BQU8sQ0FDakIsNkJBQW9DLE9BQVBnRyxTQUM3QjtZQUNFeEYsUUFBUTtRQUNWO0lBRUo7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFNeUYsZUFDSkMsZUFBdUIsRUFDdkJDLFdBQW1CLEVBQ25CQyxlQUF1QixFQUNPO1FBQzlCLE9BQU8sSUFBSSxDQUFDcEcsT0FBTyxDQUNqQiw2QkFDQTtZQUNFUSxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1lBQ0FlLE1BQU1XLEtBQUtPLFNBQVMsQ0FBQztnQkFDbkIwRCxrQkFBa0JIO2dCQUNsQkksVUFBVUg7Z0JBQ1ZJLHVCQUF1Qkg7WUFDekI7UUFDRixHQUNBLEtBQUssMEJBQTBCOztJQUVuQztJQUVBLDRCQUE0QjtJQUM1QixNQUFNSSxpQkFBK0I7UUFDbkMsT0FBTyxJQUFJLENBQUN4RyxPQUFPLENBQ2pCLDZCQUNBO1lBQ0VRLFFBQVE7UUFDVixHQUNBO0lBRUo7SUFFQSxNQUFNaUcsa0JBQWtCQyxXQUFnQixFQUFnQjtRQUN0RCxPQUFPLElBQUksQ0FBQzFHLE9BQU8sQ0FDakIsNkJBQ0E7WUFDRVEsUUFBUTtZQUNSRSxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtZQUNBZSxNQUFNVyxLQUFLTyxTQUFTLENBQUMrRDtRQUN2QixHQUNBO0lBRUo7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTUMsbUJBQW1CaEMsUUFBa0IsRUFBZ0I7UUFDekQsTUFBTXZELFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztRQUNuQyxNQUFNQyxZQUFZRixhQUFhQyxPQUFPLENBQUMsaUJBQWlCO1FBRXhELElBQUksQ0FBQ0YsT0FBTyxNQUFNLElBQUkxQixNQUFNO1FBRTVCLE1BQU1nQyxXQUFXLE1BQU1DLE1BQ3JCLEdBQWdCLE9BQWIsSUFBSSxDQUFDdEIsT0FBTyxFQUFDLGlDQUNoQjtZQUNFRyxRQUFRO1lBQ1JFLFNBQVM7Z0JBQ1A0QyxlQUFlLEdBQWdCbEMsT0FBYkcsV0FBVSxLQUFTLE9BQU5IO1lBRWpDO1lBQ0FLLE1BQU1rRDtRQUNSO1FBR0YsSUFBSSxDQUFDakQsU0FBU2EsRUFBRSxFQUFFO1lBQ2hCLE1BQU1xQyxZQUFZLE1BQU1sRCxTQUFTNkIsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO1lBQ3RELE1BQU0sSUFBSTlELE1BQ1JrRixVQUFVaEYsT0FBTyxJQUFJLFFBQTRCOEIsT0FBcEJBLFNBQVNHLE1BQU0sRUFBQyxNQUF3QixPQUFwQkgsU0FBU0ksVUFBVTtRQUV4RTtRQUVBLE9BQU9KLFNBQVM2QixJQUFJO0lBQ3RCO0lBRUEsTUFBTXFELG1CQUFtQkMsT0FBZSxFQUFnQjtRQUN0RCxNQUFNekYsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLE1BQU1DLFlBQVlGLGFBQWFDLE9BQU8sQ0FBQyxpQkFBaUI7UUFFeEQsSUFBSSxDQUFDRixPQUFPLE1BQU0sSUFBSTFCLE1BQU07UUFFNUIsTUFBTWdDLFdBQVcsTUFBTUMsTUFDckIsR0FBK0NrRixPQUE1QyxJQUFJLENBQUN4RyxPQUFPLEVBQUMsaUNBQXVDLE9BQVJ3RyxVQUMvQztZQUNFckcsUUFBUTtZQUNSRSxTQUFTO2dCQUNQNEMsZUFBZSxHQUFnQmxDLE9BQWJHLFdBQVUsS0FBUyxPQUFOSDtZQUNqQztRQUNGO1FBR0YsSUFBSSxDQUFDTSxTQUFTYSxFQUFFLEVBQUU7WUFDaEIsTUFBTXFDLFlBQVksTUFBTWxELFNBQVM2QixJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7WUFDdEQsTUFBTSxJQUFJOUQsTUFDUmtGLFVBQVVoRixPQUFPLElBQUksUUFBNEI4QixPQUFwQkEsU0FBU0csTUFBTSxFQUFDLE1BQXdCLE9BQXBCSCxTQUFTSSxVQUFVO1FBRXhFO1FBRUEsdUNBQXVDO1FBQ3ZDLE9BQU87WUFBRW9ELFNBQVM7WUFBTXRGLFNBQVM7UUFBNkI7SUFDaEU7SUFFQSxNQUFNa0gsZ0JBQThCO1FBQ2xDLE1BQU0xRixRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFDbkMsTUFBTUMsWUFBWUYsYUFBYUMsT0FBTyxDQUFDLGlCQUFpQjtRQUV4RCxJQUFJLENBQUNGLE9BQU8sTUFBTSxJQUFJMUIsTUFBTTtRQUU1QixNQUFNZ0MsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDdEIsT0FBTyxFQUFDLDBCQUF3QjtZQUNuRUcsUUFBUTtZQUNSRSxTQUFTO2dCQUNQNEMsZUFBZSxHQUFnQmxDLE9BQWJHLFdBQVUsS0FBUyxPQUFOSDtZQUNqQztRQUNGO1FBRUEsSUFBSSxDQUFDTSxTQUFTYSxFQUFFLEVBQUU7WUFDaEIsTUFBTXFDLFlBQVksTUFBTWxELFNBQVM2QixJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7WUFDdEQsTUFBTSxJQUFJOUQsTUFDUmtGLFVBQVVoRixPQUFPLElBQUksUUFBNEI4QixPQUFwQkEsU0FBU0csTUFBTSxFQUFDLE1BQXdCLE9BQXBCSCxTQUFTSSxVQUFVO1FBRXhFO1FBRUEsdUNBQXVDO1FBQ3ZDLE9BQU87WUFBRW9ELFNBQVM7WUFBTXRGLFNBQVM7UUFBK0I7SUFDbEU7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTW1ILGVBQStEO1lBQWxEQyxRQUFBQSxpRUFBZ0I7UUFDakMsT0FBTyxJQUFJLENBQUNoSCxPQUFPLENBQ2pCLGlDQUF1QyxPQUFOZ0gsUUFDakM7WUFDRXhHLFFBQVE7UUFDVixHQUNBLEtBQUssb0NBQW9DOztJQUU3QztJQUVBLDBCQUEwQjtJQUMxQixNQUFNeUcsVUFBVXZFLElBTWYsRUFBZ0I7UUFDZixPQUFPLElBQUksQ0FBQzFDLE9BQU8sQ0FDakIsc0NBQ0E7WUFDRVEsUUFBUTtZQUNSRSxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtZQUNBZSxNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCLEdBQ0E7SUFFSjtJQUVBLE1BQU13RSxZQUFZeEUsSUFJakIsRUFBZ0I7UUFDZixPQUFPLElBQUksQ0FBQzFDLE9BQU8sQ0FDakIsd0NBQ0E7WUFDRVEsUUFBUTtZQUNSRSxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtZQUNBZSxNQUFNVyxLQUFLTyxTQUFTLENBQUNEO1FBQ3ZCLEdBQ0E7SUFFSjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNeUUsd0JBVUg7UUFDRCxPQUFPLElBQUksQ0FBQ25ILE9BQU8sQ0FBQyx1Q0FBdUMsQ0FBQyxHQUFHO0lBQ2pFO0lBRUEsY0FBYztJQUNkLE1BQU1vSCxjQUFjSixLQUFhLEVBQUVLLElBQXdDLEVBS3hFO1FBQ0QsT0FBTyxJQUFJLENBQUNySCxPQUFPLENBQUMsd0NBQXNEcUgsT0FBZEwsT0FBTSxVQUFhLE9BQUxLLE9BQVEsQ0FBQyxHQUFHO0lBQ3hGO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU1DLHVCQVdIO1FBQ0QsT0FBTyxJQUFJLENBQUN0SCxPQUFPLENBQUMsb0NBQW9DLENBQUMsR0FBRztJQUM5RDtJQUVBLG9CQUFvQjtJQUNwQixNQUFNdUgsc0JBY0g7UUFDRCxPQUFPLElBQUksQ0FBQ3ZILE9BQU8sQ0FBQyxvQ0FBb0MsQ0FBQyxHQUFHO0lBQzlEO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU13SCxxQkFJSDtRQUNELE9BQU8sSUFBSSxDQUFDeEgsT0FBTyxDQUFDLDJDQUEyQyxDQUFDLEdBQUc7SUFDckU7SUFFQSxtQkFBbUI7SUFDbkIsTUFBTXlILGtCQVFIO1lBUm1CQyxTQUFBQSxpRUFBeUI7UUFTN0MsT0FBTyxJQUFJLENBQUMxSCxPQUFPLENBQUMseUNBQWdELE9BQVAwSCxTQUFVLENBQUMsR0FBRztJQUM3RTtJQTkzQkEvSCxhQUFjO1FBQ1osSUFBSSxDQUFDVSxPQUFPLEdBQUdiO0lBQ2pCO0FBNjNCRjtBQStDTyxNQUFNbUksYUFBYSxJQUFJNUgsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2VydmljZXMvYXBpLnRzXG5pbXBvcnQgeyBEYXNoYm9hcmRSZXNwb25zZSB9IGZyb20gXCIuLi90eXBlcy9kYXNoYm9hcmRcIjtcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gXCJodHRwOi8vbG9jYWxob3N0OjgwMDBcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSZXZpZXcge1xuICBpZDogbnVtYmVyO1xuICByYXRpbmc6IG51bWJlcjtcbiAgY29tbWVudDogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVzZXI6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgYXZhdGFyPzogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENlcnRpZmljYXRpb24ge1xuICBpZDogbnVtYmVyO1xuICBjZXJ0aWZpY2F0aW9uX25hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9kdWN0IHtcbiAgaWQ6IG51bWJlcjtcbiAgcHJvZHVjdF9uYW1lOiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2Uge1xuICBpZDogbnVtYmVyO1xuICBzZXJ2aWNlX25hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaG9uZSB7XG4gIGlkOiBudW1iZXI7XG4gIHR5cGU6IHN0cmluZztcbiAgbnVtYmVyOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JraW5nSG91ciB7XG4gIG9wZW46IHN0cmluZztcbiAgY2xvc2U6IHN0cmluZztcbiAgY2xvc2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1cHBsaWVyUHJvZmlsZURhdGEge1xuICBidXNpbmVzc190eXBlOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGJ1c2luZXNzX2ltYWdlOiBzdHJpbmc7XG4gIHdlYnNpdGU6IHN0cmluZztcbiAgY29udGFjdF9lbWFpbDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgc2VydmljZV9kaXN0YW5jZTogc3RyaW5nO1xuICB0YXJnZXRfbWFya2V0OiBzdHJpbmdbXTtcbiAgbWFpbl9waG9uZTogc3RyaW5nO1xuICBhZGRpdGlvbmFsX3Bob25lczogUGhvbmVbXTtcbiAgYnVzaW5lc3NfYWRkcmVzczogc3RyaW5nO1xuICBsYXRpdHVkZTogc3RyaW5nO1xuICBsb25naXR1ZGU6IHN0cmluZztcbiAgd29ya2luZ19ob3VyczogUmVjb3JkPHN0cmluZywgV29ya2luZ0hvdXI+O1xuICBzZXJ2aWNlc19vZmZlcmVkOiBzdHJpbmdbXTtcbiAgcHJvZHVjdHM/OiBQcm9kdWN0W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VwcGxpZXJQcm9maWxlIHtcbiAgaWQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcHJvZmlsZTogU3VwcGxpZXJQcm9maWxlRGF0YTtcbiAgcHJvZmlsZV9pbWFnZTogc3RyaW5nO1xuICByYXRpbmdzOiB7XG4gICAgYXZlcmFnZTogbnVtYmVyIHwgbnVsbDtcbiAgICBjb3VudDogbnVtYmVyO1xuICAgIHJldmlld3M6IFJldmlld1tdO1xuICB9O1xuICBjZXJ0aWZpY2F0aW9uczogQ2VydGlmaWNhdGlvbltdO1xuICBwcm9kdWN0X2ltYWdlczogQXJyYXk8e1xuICAgIGlkOiBudW1iZXI7XG4gICAgaW1hZ2VfdXJsOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICB9PjtcbiAgc2VydmljZXM6IFNlcnZpY2VbXTtcbn1cblxuLy8gQnVzaW5lc3NQcm9maWxlIGV4dGVuZHMgU3VwcGxpZXJQcm9maWxlIHdpdGggZXhwbGljaXQgcHJvZHVjdHMgaW4gcHJvZmlsZVxuZXhwb3J0IGludGVyZmFjZSBCdXNpbmVzc1Byb2ZpbGUgZXh0ZW5kcyBPbWl0PFN1cHBsaWVyUHJvZmlsZSwgXCJwcm9maWxlXCI+IHtcbiAgcHJvZmlsZTogU3VwcGxpZXJQcm9maWxlRGF0YSAmIHtcbiAgICBwcm9kdWN0czogUHJvZHVjdFtdOyAvLyBDb21wYW55IHByb2R1Y3RzIGluc2lkZSBwcm9maWxlXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0cmF0aW9uRGF0YSB7XG4gIGJ1c2luZXNzTmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBwYXNzd29yZF9jb25maXJtYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RyYXRpb25SZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgc3VwcGxpZXI6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kT3RwUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5T3RwUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG90cDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcmdvdFBhc3N3b3JkUmVxdWVzdCB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzZXRQYXNzd29yZFJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xuICBvdHA6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcGFzc3dvcmRfY29uZmlybWF0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5SZXF1ZXN0IHtcbiAgZW1haWw6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpblJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB1c2VyVHlwZTogc3RyaW5nO1xuICBzdXBwbGllcjoge1xuICAgIGlkOiBudW1iZXI7XG4gICAgc2x1Zzogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBob25lOiBzdHJpbmc7XG4gICAgcHJvZmlsZUltYWdlOiBzdHJpbmc7XG4gICAgZW1haWxWZXJpZmllZEF0OiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgcGxhbjogc3RyaW5nO1xuICAgIHByb2ZpbGVDb21wbGV0aW9uOiBudW1iZXI7XG4gICAgcHJvZmlsZTogYW55O1xuICAgIGJyYW5jaGVzOiBhbnlbXTtcbiAgfTtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgdG9rZW5UeXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3RwUmVzcG9uc2Uge1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIHN1cHBsaWVyPzogYW55O1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgdG9rZW5UeXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGVVcGRhdGVEYXRhIHtcbiAgYnVzaW5lc3NOYW1lPzogc3RyaW5nO1xuICBidXNpbmVzc1R5cGU/OiBzdHJpbmc7XG4gIGNhdGVnb3JpZXM/OiBzdHJpbmdbXTtcbiAgcHJvZHVjdEtleXdvcmRzPzogc3RyaW5nW107XG4gIHdob0RvWW91U2VydmU/OiBzdHJpbmc7XG4gIHNlcnZpY2VEaXN0YW5jZT86IHN0cmluZztcbiAgc2VydmljZXM/OiBzdHJpbmdbXTtcbiAgd2Vic2l0ZT86IHN0cmluZztcbiAgbWFpblBob25lPzogc3RyaW5nO1xuICBhZGRpdGlvbmFsUGhvbmVzPzogQXJyYXk8e1xuICAgIG51bWJlcjogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG4gIH0+O1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBsb2NhdGlvbj86IHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyIH07XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB3b3JraW5nSG91cnM/OiB7XG4gICAgW2tleTogc3RyaW5nXToge1xuICAgICAgY2xvc2VkPzogYm9vbGVhbjtcbiAgICAgIG9wZW4/OiBzdHJpbmc7XG4gICAgICBjbG9zZT86IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBoYXNCcmFuY2hlcz86IGJvb2xlYW47XG4gIGJyYW5jaGVzPzogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBwaG9uZT86IHN0cmluZztcbiAgICBlbWFpbD86IHN0cmluZztcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIG1hbmFnZXI/OiBzdHJpbmc7XG4gICAgbG9jYXRpb24/OiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9O1xuICAgIHdvcmtpbmdIb3Vycz86IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgICAgY2xvc2VkPzogYm9vbGVhbjtcbiAgICAgICAgb3Blbj86IHN0cmluZztcbiAgICAgICAgY2xvc2U/OiBzdHJpbmc7XG4gICAgICB9O1xuICAgIH07XG4gICAgc3BlY2lhbFNlcnZpY2VzPzogc3RyaW5nW107XG4gICAgaXNNYWluQnJhbmNoPzogYm9vbGVhbjtcbiAgfT47XG4gIGNvbnRhY3RFbWFpbD86IHN0cmluZzsgLy8gRnJvbSB2ZXJpZmljYXRpb24vbG9naW5cbiAgY29udGFjdFBob25lPzogc3RyaW5nOyAvLyBGcm9tIHZlcmlmaWNhdGlvbi9sb2dpblxuICBjYXRlZ29yeT86IHN0cmluZztcbiAgZG9jdW1lbnQ/OiBGaWxlOyAvLyBJbmNsdWRlIGRvY3VtZW50IGluIG1haW4gcmVxdWVzdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGVVcGRhdGVSZXNwb25zZSB7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgc3VwcGxpZXI6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFVwbG9hZFJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3Mge1xuICBpZDogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIGJ1c2luZXNzSW1hZ2U6IHN0cmluZztcbiAgc2x1Zzogc3RyaW5nO1xuICBjYXRlZ29yeTogc3RyaW5nO1xuICBjYXRlZ29yaWVzOiBzdHJpbmdbXTtcbiAgdGFyZ2V0TWFya2V0OiBzdHJpbmdbXTtcbiAgc2VydmljZXM6IHN0cmluZ1tdO1xuICBidXNpbmVzc1R5cGU6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICBzZXJ2aWNlRGlzdGFuY2U6IG51bWJlcjtcbiAgcmF0aW5nPzogbnVtYmVyO1xuICByZXZpZXdzQ291bnQ6IG51bWJlcjtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIHBsYW46IHN0cmluZztcbiAgbGF0aXR1ZGU6IHN0cmluZztcbiAgbG9uZ2l0dWRlOiBzdHJpbmc7XG4gIG1haW5QaG9uZTogc3RyaW5nO1xuICBjb250YWN0RW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdXNpbmVzc0xpc3RSZXNwb25zZSB7XG4gIGRhdGE6IEJ1c2luZXNzW107XG4gIG1ldGE6IHtcbiAgICBjdXJyZW50X3BhZ2U6IG51bWJlcjtcbiAgICBwZXJfcGFnZTogbnVtYmVyO1xuICAgIHRvdGFsOiBudW1iZXI7XG4gICAgbGFzdF9wYWdlOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBpRXJyb3Ige1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIGVycm9yczogQXBpRXJyb3I7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBlcnJvcnM6IEFwaUVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgfVxufVxuXG5jbGFzcyBBcGlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBiYXNlVVJMOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYXNlVVJMID0gQVBJX0JBU0VfVVJMO1xuICB9XG5cbiAgLy8gPT09PT09IFJFUVVFU1QgV1JBUFBFUiA9PT09PT1cbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0PFQ+KFxuICAgIGVuZHBvaW50OiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSxcbiAgICByZXF1aXJlc0F1dGg6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVUkx9JHtlbmRwb2ludH1gO1xuICAgIGNvbnNvbGUubG9nKGBbQVBJXSBQcmVwYXJpbmcgcmVxdWVzdCB0bzogJHt1cmx9YCwge1xuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiLFxuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCBIZWFkZXJzSW5pdCB0byBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgY29uc3Qgb3B0aW9uc0hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICBpZiAob3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIG9wdGlvbnNIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgb3B0aW9uc0hlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc0hlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLm9wdGlvbnNIZWFkZXJzLFxuICAgIH07XG5cbiAgICBpZiAocmVxdWlyZXNBdXRoKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcbiAgICAgIGNvbnNvbGUubG9nKFwiW0FQSV0gQXV0aCBjaGVjayAtIFRva2VuIGV4aXN0czpcIiwgISF0b2tlbik7XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQVBJXSBObyBhdXRoIHRva2VuIGZvdW5kIGluIGxvY2FsU3RvcmFnZVwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYCR7dG9rZW5UeXBlfSAke3Rva2VufWA7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJbQVBJXSBSZXF1ZXN0IGhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW0FQSV0gUmVxdWVzdCBib2R5OlwiLCBvcHRpb25zLmJvZHkpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltBUEldIFNlbmRpbmcgcmVxdWVzdC4uLlwiKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgaGVhZGVycyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYFtBUEldIFJlY2VpdmVkIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG5cbiAgICAgIC8vIENsb25lIHRoZSByZXNwb25zZSB0byByZWFkIGl0IGFzIHRleHQgZmlyc3QgKGZvciBsb2dnaW5nKVxuICAgICAgY29uc3QgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBsZXQgcmVzcG9uc2VEYXRhO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0FQSV0gUmVzcG9uc2UgZGF0YTpcIiwgcmVzcG9uc2VEYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbQVBJXSBOb24tSlNPTiByZXNwb25zZTpcIiwgcmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmVzcG9uc2VEYXRhID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0FQSV0gUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9OmAsIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VEYXRhLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJWYWxpZGF0aW9uIGZhaWxlZFwiLFxuICAgICAgICAgICAgcmVzcG9uc2VEYXRhLmVycm9ycyB8fCByZXNwb25zZURhdGFcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQVBJXSBWYWxpZGF0aW9uIEVycm9yOlwiLCB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgICAgICAgICB0aHJvdyB2YWxpZGF0aW9uRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgcmVzcG9uc2VEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgZXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0FQSV0gUmVxdWVzdCBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PSBTVVBQTElFUiBJTlFVSVJJRVMgPT09PT09XG4gIGFzeW5jIHNlbmRJbnF1aXJ5KGRhdGE6IHtcbiAgICByZWNlaXZlcl9zdXBwbGllcl9pZDogbnVtYmVyO1xuICAgIHNlbmRlcl9uYW1lOiBzdHJpbmc7XG4gICAgY29tcGFueTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcGhvbmU6IHN0cmluZztcbiAgICBzdWJqZWN0OiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxJbnF1aXJ5UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgXCIvYXBpL3N1cHBsaWVyL3N1cHBsaWVyLWlucXVpcmllc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHJlcGx5VG9JbnF1aXJ5KFxuICAgIGlucXVpcnlJZDogbnVtYmVyLFxuICAgIGRhdGE6IHsgbWVzc2FnZTogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxJbnF1aXJ5UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgYC9hcGkvc3VwcGxpZXIvc3VwcGxpZXItaW5xdWlyaWVzLyR7aW5xdWlyeUlkfS9yZXBseWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgbWFya0lucXVpcnlBc1JlYWQoaW5xdWlyeUlkOiBudW1iZXIpOiBQcm9taXNlPFJlYWRTdGF0dXNSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBgL2FwaS9zdXBwbGllci9zdXBwbGllci1pbnF1aXJpZXMvJHtpbnF1aXJ5SWR9L3JlYWRgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZ2V0SW5xdWlyeShpbnF1aXJ5SWQ6IG51bWJlcik6IFByb21pc2U8eyBkYXRhOiBJbnF1aXJ5W10gfT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBgL2FwaS9zdXBwbGllci9zdXBwbGllci1pbnF1aXJpZXMvJHtpbnF1aXJ5SWR9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsSW5xdWlyaWVzKCk6IFByb21pc2U8SW5xdWlyeUxpc3RSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvc3VwcGxpZXItaW5xdWlyaWVzXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIC8vID09PT09PSBBUEkgTUVUSE9EUyA9PT09PT1cbiAgYXN5bmMgcmVnaXN0ZXJTdXBwbGllcihcbiAgICBkYXRhOiBSZWdpc3RyYXRpb25EYXRhXG4gICk6IFByb21pc2U8UmVnaXN0cmF0aW9uUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9zdXBwbGllci9yZWdpc3RlclwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBsb2dpbihkYXRhOiBMb2dpblJlcXVlc3QpOiBQcm9taXNlPExvZ2luUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdDxMb2dpblJlc3BvbnNlPihcIi9hcGkvYXV0aC9sb2dpblwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAocmVzcG9uc2UuYWNjZXNzVG9rZW4pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIiwgcmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0b2tlbl90eXBlXCIsIHJlc3BvbnNlLnRva2VuVHlwZSB8fCBcIkJlYXJlclwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuXG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvYXV0aC9sb2dvdXRgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZVxuICAgICAgICAuanNvbigpXG4gICAgICAgIC5jYXRjaCgoKSA9PiAoeyBtZXNzYWdlOiBcIkxvZ291dCBmYWlsZWRcIiB9KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkxvZ291dCBmYWlsZWRcIik7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgbG9jYWxTdG9yYWdlIGFmdGVyIHN1Y2Nlc3NmdWwgbG9nb3V0XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInRva2VuX3R5cGVcIik7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJzdXBwbGllcl91c2VyXCIpO1xuICB9XG5cbiAgYXN5bmMgZm9yZ290UGFzc3dvcmQoXG4gICAgZGF0YTogRm9yZ290UGFzc3dvcmRSZXF1ZXN0XG4gICk6IFByb21pc2U8eyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvYXBpL2F1dGgvZm9yZ290LXBhc3N3b3JkXCIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlc2V0UGFzc3dvcmQoXG4gICAgZGF0YTogUmVzZXRQYXNzd29yZFJlcXVlc3RcbiAgKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvYXV0aC9yZXNldC1wYXNzd29yZFwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzZW5kT3RwKGRhdGE6IFNlbmRPdHBSZXF1ZXN0KTogUHJvbWlzZTxPdHBSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvYXBpL2F1dGgvc2VuZC1vdHBcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5T3RwKGRhdGE6IFZlcmlmeU90cFJlcXVlc3QpOiBQcm9taXNlPE90cFJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3Q8T3RwUmVzcG9uc2U+KFwiL2FwaS9hdXRoL3ZlcmlmeS1vdHBcIiwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLmFjY2Vzc1Rva2VuKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIsIHJlc3BvbnNlLmFjY2Vzc1Rva2VuKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidG9rZW5fdHlwZVwiLCByZXNwb25zZS50b2tlblR5cGUgfHwgXCJCZWFyZXJcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgYXN5bmMgZ2V0QnVzaW5lc3NlcyhwYXJhbXM/OiB7XG4gICAga2V5d29yZD86IHN0cmluZztcbiAgICBjYXRlZ29yaWVzPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgbG9jYXRpb24/OiBzdHJpbmc7XG4gICAgYnVzaW5lc3NUeXBlPzogc3RyaW5nO1xuICAgIG1pblJhdGluZz86IG51bWJlcjtcbiAgICBzZXJ2aWNlRGlzdGFuY2U/OiBudW1iZXI7XG4gICAgdGFyZ2V0Q3VzdG9tZXI/OiBzdHJpbmc7XG4gICAgaXNBcHByb3ZlZD86IGJvb2xlYW47XG4gICAgaXNPcGVuTm93PzogYm9vbGVhbjtcbiAgICBzb3J0PzogXCJyYXRpbmdcIiB8IFwiZGlzdGFuY2VcIiB8IFwicmV2aWV3c1wiIHwgXCJuYW1lXCI7XG4gICAgcGVyX3BhZ2U/OiBudW1iZXI7XG4gICAgcGFnZT86IG51bWJlcjtcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIGNhdGVnb3J5Pzogc3RyaW5nOyAvLyBBZGQgY2F0ZWdvcnkgYXMgYSBzZXBhcmF0ZSBwYXJhbWV0ZXJcbiAgfSk6IFByb21pc2U8QnVzaW5lc3NMaXN0UmVzcG9uc2U+IHtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICAgIGNvbnN0IG9wdGlvbnM6IFJlcXVlc3RJbml0ID0geyBtZXRob2Q6IFwiR0VUXCIgfTtcblxuICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gLFxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIC8vIEhhbmRsZSBjYXRlZ29yeSBzZXBhcmF0ZWx5IHRvIHByZXZlbnQgZG91YmxlIGVuY29kaW5nXG4gICAgICBjb25zdCB7IGNhdGVnb3J5LCAuLi5yZXN0UGFyYW1zIH0gPSBwYXJhbXM7XG5cbiAgICAgIGlmIChjYXRlZ29yeSkge1xuICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJjYXRlZ29yeVwiLCBjYXRlZ29yeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgcmVzdCBvZiB0aGUgcGFyYW1ldGVyc1xuICAgICAgT2JqZWN0LmVudHJpZXMocmVzdFBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSA/IFwiMVwiIDogXCIwXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8QnVzaW5lc3NMaXN0UmVzcG9uc2U+KFxuICAgICAgYC9hcGkvcHVibGljL2J1c2luZXNzZXM/JHtxdWVyeVBhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIH0sXG4gICAgICBmYWxzZSAvLyBkb2Vzbid0IHJlcXVpcmUgYXV0aFxuICAgICk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVQcm9maWxlKGRhdGE6IFByb2ZpbGVVcGRhdGVEYXRhKTogUHJvbWlzZTxQcm9maWxlVXBkYXRlUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFxuICAgICAgXCIvYXBpL3N1cHBsaWVyL3Byb2ZpbGVcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApOyAvLyByZXF1aXJlc0F1dGggPSB0cnVlXG4gIH1cblxuICBhc3luYyB1cGRhdGVQcm9maWxlV2l0aEZvcm1EYXRhKFxuICAgIGZvcm1EYXRhOiBGb3JtRGF0YVxuICApOiBQcm9taXNlPFByb2ZpbGVVcGRhdGVSZXNwb25zZT4ge1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VuX3R5cGVcIikgfHwgXCJCZWFyZXJcIjtcblxuICAgIGlmICghdG9rZW4pIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGggdG9rZW4gZm91bmRcIik7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3Byb2ZpbGVgLCB7XG4gICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgZm9yIEZvcm1EYXRhIC0gYnJvd3NlciBzZXRzIGl0IHdpdGggYm91bmRhcnlcbiAgICAgIH0sXG4gICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcblxuICAgICAgLy8gRW5oYW5jZWQgbG9nZ2luZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmVycm9yKGBBUEkgRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OmAsIHtcbiAgICAgICAgdXJsOiBgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9wcm9maWxlYCxcbiAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgIGVycm9yRGF0YSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlZhbGlkYXRpb24gRXJyb3JzOlwiLCBlcnJvckRhdGEuZXJyb3JzIHx8IGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoXG4gICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgXCJWYWxpZGF0aW9uIGZhaWxlZFwiLFxuICAgICAgICAgIGVycm9yRGF0YS5lcnJvcnMgfHwgZXJyb3JEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHJvZmlsZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvcHJvZmlsZVwiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBhc3luYyB1cGxvYWREb2N1bWVudChmaWxlOiBGaWxlKTogUHJvbWlzZTxEb2N1bWVudFVwbG9hZFJlc3BvbnNlPiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuXG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcblxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZG9jdW1lbnRcIiwgZmlsZSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL2RvY3VtZW50c2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkRvY3VtZW50IHVwbG9hZCBlcnJvcjpcIiwgZXJyb3JEYXRhKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBcIkZhaWxlZCB0byB1cGxvYWQgZG9jdW1lbnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIGFzeW5jIHVwbG9hZFByb2ZpbGVJbWFnZShcbiAgICBmaWxlOiBGaWxlXG4gICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBkYXRhOiB7IHVybDogc3RyaW5nIH0gfT4ge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwicHJvZmlsZV9pbWFnZVwiLCBmaWxlKTtcblxuICAgIC8vIENyZWF0ZSBoZWFkZXJzIG9iamVjdFxuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgaGVhZGVyLCBsZXQgdGhlIGJyb3dzZXIgc2V0IGl0IHdpdGggdGhlIGNvcnJlY3QgYm91bmRhcnlcblxuICAgIC8vIEdldCB0aGUgYXV0aCB0b2tlblxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7dG9rZW59YCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3Byb2ZpbGUvaW1hZ2VgLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSByZXNwb25zZSBpcyBPS1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBcIkZhaWxlZCB0byB1cGxvYWQgaW1hZ2VcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYXMgSlNPTlxuICAgICAgbGV0IHJlc3BvbnNlRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgcGFyc2luZyBmYWlscyBidXQgdGhlIHN0YXR1cyBpcyAyMDAsIGNvbnNpZGVyIGl0IGEgc3VjY2Vzc1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IHVybDogXCJcIiB9IH07IC8vIFJldHVybiBkZWZhdWx0IHN1Y2Nlc3MgcmVzcG9uc2VcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc2VydmVyIHJlc3BvbnNlXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgIC8vIFRoZSBiYWNrZW5kIG1pZ2h0IGJlIHJldHVybmluZyB0aGUgVVJMIGRpcmVjdGx5IG9yIGluIGEgZGF0YSBvYmplY3RcbiAgICAgIGNvbnN0IGltYWdlVXJsID0gcmVzcG9uc2VEYXRhLnVybCB8fCByZXNwb25zZURhdGEuZGF0YT8udXJsIHx8IFwiXCI7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB1cmw6IGltYWdlVXJsLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFQSSBFcnJvcjpcIiwgZXJyb3IpO1xuXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHR5cGVzIG9mIGVycm9yc1xuICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBIYW5kbGUgRmV0Y2ggQVBJIFJlc3BvbnNlIGVycm9yc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJyZXNwb25zZVwiIGluIGVycm9yICYmXG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgJiZcbiAgICAgICAgICB0eXBlb2YgZXJyb3IucmVzcG9uc2UgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgdHlwZVxuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3IucmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8IFwi2YHYtNmEINmB2Yog2LHZgdi5INin2YTYtdmI2LHYqVwiKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSB0aGUgZXJyb3IgcmVzcG9uc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcItmB2LTZhCDZgdmKINmF2LnYp9mE2KzYqSDYp9iz2KrYrNin2KjYqSDYp9mE2K7Yp9iv2YVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIEVycm9yIG9iamVjdHNcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlIHx8IFwi2K3Yr9irINiu2LfYoyDYo9ir2YbYp9ihINix2YHYuSDYp9mE2LXZiNix2KkuINmK2LHYrNmJINin2YTZhdit2KfZiNmE2Kkg2YXYsdipINij2K7YsdmJLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGVycm9yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCLYrdiv2Ksg2K7Yt9ijINi62YrYsSDZhdiq2YjZgti5LiDZitix2KzZiSDYp9mE2YXYrdin2YjZhNipINmF2LHYqSDYo9iu2LHZiS5cIik7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09IEhFTFBFUlMgPT09PT09XG4gIGlzQXV0aGVudGljYXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYnVzaW5lc3MgcHJvZmlsZSBmb3IgYSBzcGVjaWZpYyBzdXBwbGllclxuICAgKiBAcGFyYW0gaWQgVGhlIHN1cHBsaWVyIElEXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgc3VwcGxpZXIncyBidXNpbmVzcyBwcm9maWxlIGluY2x1ZGluZyBwcm9kdWN0c1xuICAgKi9cbiAgYXN5bmMgZ2V0QnVzaW5lc3NQcm9maWxlKGlkOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPEJ1c2luZXNzUHJvZmlsZT4ge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdXBwbGllcl90b2tlblwiKTtcblxuICAgIGlmICh0b2tlbikge1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXJzLyR7aWR9L2J1c2luZXNzYCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBidXNpbmVzcyBwcm9maWxlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGJ1c2luZXNzIHByb2ZpbGU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN1cHBsaWVyUHJvZmlsZShpZDogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTxTdXBwbGllclByb2ZpbGU+IHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7dG9rZW59YCk7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXJzLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIHN1cHBsaWVyIHByb2ZpbGVcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc3VwcGxpZXIgcHJvZmlsZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3VibWl0UmV2aWV3KFxuICAgIHN1cHBsaWVySWQ6IG51bWJlcixcbiAgICByYXRpbmc6IG51bWJlcixcbiAgICBjb21tZW50OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvc3VwcGxpZXIvcmF0aW5nc2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHJhdGVkX3N1cHBsaWVyX2lkOiBzdXBwbGllcklkLFxuICAgICAgICBzY29yZTogcmF0aW5nLFxuICAgICAgICBjb21tZW50OiBjb21tZW50LFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHN1Ym1pdCByZXZpZXdcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIC8vIEdldCBidXNpbmVzcyBzdGF0aXN0aWNzXG4gIGFzeW5jIGdldFN0YXRzKCk6IFByb21pc2U8QnVzaW5lc3NTdGF0cz4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8QnVzaW5lc3NTdGF0cz4oXCIvYXBpL3B1YmxpYy9zdGF0c1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBwcm9maWxlIHBpY3R1cmUgVVJMIGZvciBhIHVzZXJcbiAgICogQHBhcmFtIHVzZXJJZCBUaGUgSUQgb2YgdGhlIHVzZXJcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSBwcm9maWxlIHBpY3R1cmUgVVJMXG4gICAqL1xuICBhc3luYyBnZXRQcm9maWxlUGljdHVyZShcbiAgICB1c2VySWQ6IHN0cmluZyB8IG51bWJlclxuICApOiBQcm9taXNlPHsgcHJvZmlsZV9pbWFnZTogc3RyaW5nIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PHsgcHJvZmlsZV9pbWFnZTogc3RyaW5nIH0+KFxuICAgICAgYC9hcGkvYXV0aC9wcm9maWxlL3BpY3R1cmUvJHt1c2VySWR9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgdXNlcidzIHBhc3N3b3JkXG4gICAqIEBwYXJhbSBjdXJyZW50UGFzc3dvcmQgVGhlIHVzZXIncyBjdXJyZW50IHBhc3N3b3JkXG4gICAqIEBwYXJhbSBuZXdQYXNzd29yZCBUaGUgbmV3IHBhc3N3b3JkXG4gICAqIEBwYXJhbSBjb25maXJtUGFzc3dvcmQgVGhlIG5ldyBwYXNzd29yZCBjb25maXJtYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHN1Y2Nlc3MgbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoXG4gICAgY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsXG4gICAgbmV3UGFzc3dvcmQ6IHN0cmluZyxcbiAgICBjb25maXJtUGFzc3dvcmQ6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PHsgbWVzc2FnZTogc3RyaW5nIH0+KFxuICAgICAgXCIvYXBpL2F1dGgvY2hhbmdlLXBhc3N3b3JkXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGN1cnJlbnRfcGFzc3dvcmQ6IGN1cnJlbnRQYXNzd29yZCxcbiAgICAgICAgICBwYXNzd29yZDogbmV3UGFzc3dvcmQsXG4gICAgICAgICAgcGFzc3dvcmRfY29uZmlybWF0aW9uOiBjb25maXJtUGFzc3dvcmQsXG4gICAgICAgIH0pLFxuICAgICAgfSxcbiAgICAgIHRydWUgLy8gcmVxdWlyZXMgYXV0aGVudGljYXRpb25cbiAgICApO1xuICB9XG5cbiAgLy8gPT09PT09IFBSRUZFUkVOQ0VTID09PT09PVxuICBhc3luYyBnZXRQcmVmZXJlbmNlcygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvcHJlZmVyZW5jZXNcIixcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJlZmVyZW5jZXMocHJlZmVyZW5jZXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9wcmVmZXJlbmNlc1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJlZmVyZW5jZXMpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgLy8gPT09PT09IFBST0RVQ1QgSU1BR0VTID09PT09PVxuICBhc3luYyB1cGxvYWRQcm9kdWN0SW1hZ2UoZm9ybURhdGE6IEZvcm1EYXRhKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke3RoaXMuYmFzZVVSTH0vYXBpL3N1cHBsaWVyL3Byb2R1Y3QtaW1hZ2VzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gLFxuICAgICAgICAgIC8vIERvbid0IHNldCBDb250ZW50LVR5cGUgZm9yIEZvcm1EYXRhIC0gYnJvd3NlciBzZXRzIGl0IHdpdGggYm91bmRhcnlcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlUHJvZHVjdEltYWdlKGltYWdlSWQ6IG51bWJlcik6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInN1cHBsaWVyX3Rva2VuXCIpO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5fdHlwZVwiKSB8fCBcIkJlYXJlclwiO1xuXG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCB0b2tlbiBmb3VuZFwiKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9wcm9kdWN0LWltYWdlcy8ke2ltYWdlSWR9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW5UeXBlfSAke3Rva2VufWAsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gc3VjY2VzcyBmb3IgREVMRVRFIG9wZXJhdGlvbnNcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIkltYWdlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIgfTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZUFjY291bnQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic3VwcGxpZXJfdG9rZW5cIik7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0b2tlbl90eXBlXCIpIHx8IFwiQmVhcmVyXCI7XG5cbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoIHRva2VuIGZvdW5kXCIpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS9zdXBwbGllci9hY2NvdW50YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlblR5cGV9ICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGVycm9yRGF0YS5tZXNzYWdlIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHN1Y2Nlc3MgZm9yIERFTEVURSBvcGVyYXRpb25zXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogXCJBY2NvdW50IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIgfTtcbiAgfVxuXG4gIC8vID09PT09PSBEQVNIQk9BUkQgPT09PT09XG4gIGFzeW5jIGdldERhc2hib2FyZChyYW5nZTogc3RyaW5nID0gXCIzMFwiKTogUHJvbWlzZTxEYXNoYm9hcmRSZXNwb25zZT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8RGFzaGJvYXJkUmVzcG9uc2U+KFxuICAgICAgYC9hcGkvc3VwcGxpZXIvZGFzaGJvYXJkP3JhbmdlPSR7cmFuZ2V9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgfSxcbiAgICAgIHRydWUgLy8gcmVxdWlyZXNBdXRoID0gdHJ1ZSB0byBzZW5kIHRva2VuXG4gICAgKTtcbiAgfVxuXG4gIC8vID09PT09PSBBTkFMWVRJQ1MgPT09PT09XG4gIGFzeW5jIHRyYWNrVmlldyhkYXRhOiB7XG4gICAgc3VwcGxpZXJfaWQ6IG51bWJlcjtcbiAgICBsb2NhdGlvbjogc3RyaW5nO1xuICAgIGN1c3RvbWVyX3R5cGU6IHN0cmluZztcbiAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIHNlc3Npb25faWQ6IHN0cmluZztcbiAgfSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcbiAgICAgIFwiL2FwaS9zdXBwbGllci9hbmFseXRpY3MvdHJhY2stdmlld1wiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgdHJhY2tTZWFyY2goZGF0YToge1xuICAgIGtleXdvcmQ6IHN0cmluZztcbiAgICBzZWFyY2hfdHlwZTogc3RyaW5nO1xuICAgIGxvY2F0aW9uOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXG4gICAgICBcIi9hcGkvc3VwcGxpZXIvYW5hbHl0aWNzL3RyYWNrLXNlYXJjaFwiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgLy8gUGVyZm9ybWFuY2UgTWV0cmljc1xuICBhc3luYyBnZXRQZXJmb3JtYW5jZU1ldHJpY3MoKTogUHJvbWlzZTx7XG4gICAgbWV0cmljczogQXJyYXk8e1xuICAgICAgbWV0cmljOiBzdHJpbmc7XG4gICAgICB2YWx1ZTogbnVtYmVyO1xuICAgICAgdGFyZ2V0OiBudW1iZXI7XG4gICAgICBjb2xvcjogc3RyaW5nO1xuICAgICAgdW5pdDogc3RyaW5nO1xuICAgICAgaXNSYXRpbmc/OiBib29sZWFuO1xuICAgIH0+O1xuICAgIG92ZXJhbGxTY29yZTogbnVtYmVyO1xuICB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvc3VwcGxpZXIvYW5hbHl0aWNzL3BlcmZvcm1hbmNlXCIsIHt9LCB0cnVlKTtcbiAgfVxuXG4gIC8vIENoYXJ0cyBEYXRhXG4gIGFzeW5jIGdldENoYXJ0c0RhdGEocmFuZ2U6IG51bWJlciwgdHlwZTogXCJ2aWV3c1wiIHwgXCJjb250YWN0c1wiIHwgXCJpbnF1aXJpZXNcIik6IFByb21pc2U8e1xuICAgIHR5cGU6IHN0cmluZztcbiAgICByYW5nZTogbnVtYmVyO1xuICAgIGRhdGE6IG51bWJlcltdO1xuICAgIGxhYmVsczogc3RyaW5nW107XG4gIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3N1cHBsaWVyL2FuYWx5dGljcy9jaGFydHM/cmFuZ2U9JHtyYW5nZX0mdHlwZT0ke3R5cGV9YCwge30sIHRydWUpO1xuICB9XG5cbiAgLy8gS2V5d29yZHMgQW5hbHl0aWNzXG4gIGFzeW5jIGdldEtleXdvcmRzQW5hbHl0aWNzKCk6IFByb21pc2U8e1xuICAgIGtleXdvcmRzOiBBcnJheTx7XG4gICAgICBrZXl3b3JkOiBzdHJpbmc7XG4gICAgICBzZWFyY2hlczogbnVtYmVyO1xuICAgICAgY2hhbmdlOiBudW1iZXI7XG4gICAgICBjb250YWN0czogbnVtYmVyO1xuICAgICAgbGFzdF9zZWFyY2hlZDogc3RyaW5nO1xuICAgIH0+O1xuICAgIHRvdGFsU2VhcmNoZXM6IG51bWJlcjtcbiAgICBhdmVyYWdlQ2hhbmdlOiBudW1iZXI7XG4gICAgcGVyaW9kOiBzdHJpbmc7XG4gIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9zdXBwbGllci9hbmFseXRpY3Mva2V5d29yZHNcIiwge30sIHRydWUpO1xuICB9XG5cbiAgLy8gQ3VzdG9tZXIgSW5zaWdodHNcbiAgYXN5bmMgZ2V0Q3VzdG9tZXJJbnNpZ2h0cygpOiBQcm9taXNlPHtcbiAgICBkZW1vZ3JhcGhpY3M6IEFycmF5PHtcbiAgICAgIHR5cGU6IHN0cmluZztcbiAgICAgIHBlcmNlbnRhZ2U6IG51bWJlcjtcbiAgICAgIGNvdW50OiBudW1iZXI7XG4gICAgfT47XG4gICAgdG9wTG9jYXRpb25zOiBBcnJheTx7XG4gICAgICBjaXR5OiBzdHJpbmc7XG4gICAgICB2aXNpdG9yczogbnVtYmVyO1xuICAgICAgcGVyY2VudGFnZTogbnVtYmVyO1xuICAgIH0+O1xuICAgIHRvdGFsVmlzaXRvcnM6IG51bWJlcjtcbiAgICB0b3RhbEN1c3RvbWVyczogbnVtYmVyO1xuICAgIHBlcmlvZDogc3RyaW5nO1xuICB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvc3VwcGxpZXIvYW5hbHl0aWNzL2luc2lnaHRzXCIsIHt9LCB0cnVlKTtcbiAgfVxuXG4gIC8vIFJlY29tbWVuZGF0aW9uc1xuICBhc3luYyBnZXRSZWNvbW1lbmRhdGlvbnMoKTogUHJvbWlzZTx7XG4gICAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbiAgICBwcmlvcml0eTogc3RyaW5nO1xuICAgIGdlbmVyYXRlZF9hdDogc3RyaW5nO1xuICB9PiB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvc3VwcGxpZXIvYW5hbHl0aWNzL3JlY29tbWVuZGF0aW9uc1wiLCB7fSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBFeHBvcnQgQW5hbHl0aWNzXG4gIGFzeW5jIGV4cG9ydEFuYWx5dGljcyhmb3JtYXQ6IFwiY3N2XCIgfCBcImpzb25cIiA9IFwiY3N2XCIpOiBQcm9taXNlPHtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgZG93bmxvYWRfdXJsOiBzdHJpbmc7XG4gICAgZmlsZW5hbWU6IHN0cmluZztcbiAgICBleHBpcmVzX2F0OiBzdHJpbmc7XG4gICAgZmlsZV9zaXplOiBzdHJpbmc7XG4gICAgcmVjb3Jkc19jb3VudDogbnVtYmVyO1xuICAgIGV4cG9ydF90eXBlOiBzdHJpbmc7XG4gIH0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3N1cHBsaWVyL2FuYWx5dGljcy9leHBvcnQ/Zm9ybWF0PSR7Zm9ybWF0fWAsIHt9LCB0cnVlKTtcbiAgfVxufVxuXG4vLyBTdXBwbGllciBJbnF1aXJ5IEludGVyZmFjZXNcbmV4cG9ydCBpbnRlcmZhY2UgSW5xdWlyeSB7XG4gIGlkOiBudW1iZXI7XG4gIHN1YmplY3Q6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZTogc3RyaW5nO1xuICBjb21wYW55OiBzdHJpbmcgfCBudWxsO1xuICBzZW5kZXI6IHtcbiAgICBpZDogbnVtYmVyO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfTtcbiAgcmVjZWl2ZXI6IHtcbiAgICBpZDogbnVtYmVyO1xuICAgIG5hbWU6IHN0cmluZztcbiAgfTtcbiAgaXNfcmVhZDogYm9vbGVhbjtcbiAgdHlwZTogXCJpbnF1aXJ5XCIgfCBcInJlcGx5XCI7XG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcbiAgdGltZV9hZ286IHN0cmluZztcbiAgaXNfcmVwbHk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5xdWlyeVJlc3BvbnNlIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkYXRhOiBJbnF1aXJ5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElucXVpcnlMaXN0UmVzcG9uc2Uge1xuICBkYXRhOiBJbnF1aXJ5W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZFN0YXR1c1Jlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG4vLyBJbnRlcmZhY2UgZm9yIGJ1c2luZXNzIHN0YXRpc3RpY3NcbmludGVyZmFjZSBCdXNpbmVzc1N0YXRzIHtcbiAgdG90YWxfYnVzaW5lc3NlczogbnVtYmVyO1xuICB0b3RhbF9zdXBwbGllcnM6IG51bWJlcjtcbiAgb3Blbl9ub3c6IG51bWJlcjtcbiAgbmV3X3RoaXNfd2VlazogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgYXBpU2VydmljZSA9IG5ldyBBcGlTZXJ2aWNlKCk7XG4iXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwiVmFsaWRhdGlvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJlcnJvcnMiLCJuYW1lIiwiQXBpU2VydmljZSIsInJlcXVlc3QiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJyZXF1aXJlc0F1dGgiLCJ1cmwiLCJiYXNlVVJMIiwiY29uc29sZSIsImxvZyIsIm1ldGhvZCIsIm9wdGlvbnNIZWFkZXJzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJhc3NpZ24iLCJBY2NlcHQiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ0b2tlblR5cGUiLCJlcnJvciIsImJvZHkiLCJyZXNwb25zZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2VDbG9uZSIsImNsb25lIiwicmVzcG9uc2VUZXh0IiwidGV4dCIsInJlc3BvbnNlRGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJvayIsInZhbGlkYXRpb25FcnJvciIsInNlbmRJbnF1aXJ5IiwiZGF0YSIsInN0cmluZ2lmeSIsInJlcGx5VG9JbnF1aXJ5IiwiaW5xdWlyeUlkIiwibWFya0lucXVpcnlBc1JlYWQiLCJnZXRJbnF1aXJ5IiwiZ2V0QWxsSW5xdWlyaWVzIiwicmVnaXN0ZXJTdXBwbGllciIsImxvZ2luIiwiYWNjZXNzVG9rZW4iLCJzZXRJdGVtIiwibG9nb3V0IiwiQXV0aG9yaXphdGlvbiIsImpzb24iLCJjYXRjaCIsInJlbW92ZUl0ZW0iLCJmb3Jnb3RQYXNzd29yZCIsInJlc2V0UGFzc3dvcmQiLCJzZW5kT3RwIiwidmVyaWZ5T3RwIiwiZ2V0QnVzaW5lc3NlcyIsInBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiY2F0ZWdvcnkiLCJyZXN0UGFyYW1zIiwiYXBwZW5kIiwiZW50cmllcyIsInVuZGVmaW5lZCIsImpvaW4iLCJ0b1N0cmluZyIsInVwZGF0ZVByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlV2l0aEZvcm1EYXRhIiwiZm9ybURhdGEiLCJlcnJvckRhdGEiLCJnZXRQcm9maWxlIiwidXBsb2FkRG9jdW1lbnQiLCJmaWxlIiwiRm9ybURhdGEiLCJ1cGxvYWRQcm9maWxlSW1hZ2UiLCJzdWNjZXNzIiwiaW1hZ2VVcmwiLCJpc0F1dGhlbnRpY2F0ZWQiLCJnZXRCdXNpbmVzc1Byb2ZpbGUiLCJpZCIsImdldFN1cHBsaWVyUHJvZmlsZSIsInN1Ym1pdFJldmlldyIsInN1cHBsaWVySWQiLCJyYXRpbmciLCJjb21tZW50IiwicmF0ZWRfc3VwcGxpZXJfaWQiLCJzY29yZSIsImdldFN0YXRzIiwiZ2V0UHJvZmlsZVBpY3R1cmUiLCJ1c2VySWQiLCJjaGFuZ2VQYXNzd29yZCIsImN1cnJlbnRQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwiY29uZmlybVBhc3N3b3JkIiwiY3VycmVudF9wYXNzd29yZCIsInBhc3N3b3JkIiwicGFzc3dvcmRfY29uZmlybWF0aW9uIiwiZ2V0UHJlZmVyZW5jZXMiLCJ1cGRhdGVQcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzIiwidXBsb2FkUHJvZHVjdEltYWdlIiwiZGVsZXRlUHJvZHVjdEltYWdlIiwiaW1hZ2VJZCIsImRlbGV0ZUFjY291bnQiLCJnZXREYXNoYm9hcmQiLCJyYW5nZSIsInRyYWNrVmlldyIsInRyYWNrU2VhcmNoIiwiZ2V0UGVyZm9ybWFuY2VNZXRyaWNzIiwiZ2V0Q2hhcnRzRGF0YSIsInR5cGUiLCJnZXRLZXl3b3Jkc0FuYWx5dGljcyIsImdldEN1c3RvbWVySW5zaWdodHMiLCJnZXRSZWNvbW1lbmRhdGlvbnMiLCJleHBvcnRBbmFseXRpY3MiLCJmb3JtYXQiLCJhcGlTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});